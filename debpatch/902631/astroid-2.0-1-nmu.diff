diff -Nru astroid-1.6.5/astroid/arguments.py astroid-2.0/astroid/arguments.py
--- astroid-1.6.5/astroid/arguments.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/arguments.py	2018-07-15 09:19:21.000000000 +0200
@@ -1,12 +1,13 @@
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
-# Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016, 2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
+# Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>
+# Copyright (c) 2018 Anthony Sottile <asottile@umich.edu>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
 
 
-import six
-
 from astroid import bases
 from astroid import context as contextmod
 from astroid import exceptions
@@ -14,8 +15,7 @@
 from astroid import util
 
 
-
-class CallSite(object):
+class CallSite:
     """Class for understanding arguments passed into a call site
 
     It needs a call context, which contains the arguments and the
@@ -25,7 +25,10 @@
     and the argument name.
     """
 
-    def __init__(self, callcontext):
+    def __init__(self, callcontext, argument_context_map=None):
+        if argument_context_map is None:
+            argument_context_map = {}
+        self.argument_context_map = argument_context_map
         args = callcontext.args
         keywords = callcontext.keywords
         self.duplicated_keywords = set()
@@ -71,6 +74,7 @@
     def _unpack_keywords(self, keywords):
         values = {}
         context = contextmod.InferenceContext()
+        context.extra_context = self.argument_context_map
         for name, value in keywords:
             if name is None:
                 # Then it's an unpacking operation (**)
@@ -94,7 +98,7 @@
                     if not isinstance(dict_key, nodes.Const):
                         values[name] = util.Uninferable
                         continue
-                    if not isinstance(dict_key.value, six.string_types):
+                    if not isinstance(dict_key.value, str):
                         values[name] = util.Uninferable
                         continue
                     if dict_key.value in values:
@@ -107,10 +111,10 @@
                 values[name] = value
         return values
 
-    @staticmethod
-    def _unpack_args(args):
+    def _unpack_args(self, args):
         values = []
         context = contextmod.InferenceContext()
+        context.extra_context = self.argument_context_map
         for arg in args:
             if isinstance(arg, nodes.Starred):
                 try:
@@ -136,7 +140,7 @@
         Arguments:
             funcnode: The function being called.
             name: The name of the argument whose value is being inferred.
-            context: TODO
+            context: Inference context object
         """
         if name in self.duplicated_keywords:
             raise exceptions.InferenceError('The arguments passed to {func!r} '
@@ -162,7 +166,7 @@
         positional = self.positional_arguments[:len(funcnode.args.args)]
         vararg = self.positional_arguments[len(funcnode.args.args):]
         argindex = funcnode.args.find_argname(name)[0]
-        kwonlyargs = set(arg.name for arg in funcnode.args.kwonlyargs)
+        kwonlyargs = {arg.name for arg in funcnode.args.kwonlyargs}
         kwargs = {
             key: value for key, value in self.keyword_arguments.items()
             if key not in kwonlyargs
@@ -230,7 +234,7 @@
             kwarg.postinit([(nodes.const_factory(key), value)
                             for key, value in kwargs.items()])
             return iter((kwarg, ))
-        elif funcnode.args.vararg == name:
+        if funcnode.args.vararg == name:
             # It wants all the args that were passed into
             # the call site.
             if self.has_invalid_arguments():
diff -Nru astroid-1.6.5/astroid/as_string.py astroid-2.0/astroid/as_string.py
--- astroid-1.6.5/astroid/as_string.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/as_string.py	2018-07-15 09:19:22.000000000 +0200
@@ -1,7 +1,15 @@
+# -*- coding: utf-8 -*-
 # Copyright (c) 2009-2011, 2013-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
-# Copyright (c) 2013-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2010 Daniel Harding <dharding@gmail.com>
+# Copyright (c) 2013-2016, 2018 Claudiu Popa <pcmanticore@gmail.com>
 # Copyright (c) 2013-2014 Google, Inc.
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2016 Jared Garst <jgarst@users.noreply.github.com>
+# Copyright (c) 2016 Jakub Wilk <jwilk@jwilk.net>
+# Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
+# Copyright (c) 2017 rr- <rr-@sakuya.pl>
+# Copyright (c) 2018 brendanator <brendan.maginnis@gmail.com>
+# Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -15,13 +23,13 @@
 """
 import sys
 
-import six
-
 
 # pylint: disable=unused-argument
 
+DOC_NEWLINE = '\0'
+
 
-class AsStringVisitor(object):
+class AsStringVisitor:
     """Visitor to render an Astroid node as a valid python code string"""
 
     def __init__(self, indent):
@@ -29,12 +37,47 @@
 
     def __call__(self, node):
         """Makes this visitor behave as a simple function"""
-        return node.accept(self)
+        return node.accept(self).replace(DOC_NEWLINE, '\n')
 
-    def _stmt_list(self, stmts):
+    def _docs_dedent(self, doc):
+        """Stop newlines in docs being indented by self._stmt_list"""
+        return '\n%s"""%s"""' % (self.indent, doc.replace('\n', DOC_NEWLINE))
+
+    def _stmt_list(self, stmts, indent=True):
         """return a list of nodes to string"""
-        stmts = '\n'.join([nstr for nstr in [n.accept(self) for n in stmts] if nstr])
-        return self.indent + stmts.replace('\n', '\n'+self.indent)
+        stmts = '\n'.join(
+            [nstr for nstr in [n.accept(self) for n in stmts] if nstr])
+        if indent:
+            return self.indent + stmts.replace('\n', '\n' + self.indent)
+
+        return stmts
+
+    def _precedence_parens(self, node, child, is_left=True):
+        """Wrap child in parens only if required to keep same semantics"""
+        if self._should_wrap(node, child, is_left):
+            return '(%s)' % child.accept(self)
+
+        return child.accept(self)
+
+    def _should_wrap(self, node, child, is_left):
+        """Wrap child if:
+            - it has lower precedence
+            - same precedence with position opposite to associativity direction
+        """
+        node_precedence = node.op_precedence()
+        child_precedence = child.op_precedence()
+
+        if node_precedence > child_precedence:
+            # 3 * (4 + 5)
+            return True
+
+        if (node_precedence == child_precedence and
+                is_left != node.op_left_associative()):
+            # 3 - (4 - 5)
+            # (2**3)**4
+            return True
+
+        return False
 
 
     ## visit_<node> methods ###########################################
@@ -82,12 +125,17 @@
 
     def visit_binop(self, node):
         """return an astroid.BinOp node as string"""
-        return '(%s) %s (%s)' % (node.left.accept(self), node.op, node.right.accept(self))
+        left = self._precedence_parens(node, node.left)
+        right = self._precedence_parens(node, node.right, is_left=False)
+        if node.op == '**':
+            return '%s%s%s' % (left, node.op, right)
+
+        return '%s %s %s' % (left, node.op, right)
 
     def visit_boolop(self, node):
         """return an astroid.BoolOp node as string"""
-        return (' %s ' % node.op).join(['(%s)' % n.accept(self)
-                                        for n in node.values])
+        values = ['%s' % self._precedence_parens(node, n) for n in node.values]
+        return (' %s ' % node.op).join(values)
 
     def visit_break(self, node):
         """return an astroid.Break node as string"""
@@ -95,7 +143,7 @@
 
     def visit_call(self, node):
         """return an astroid.Call node as string"""
-        expr_str = node.func.accept(self)
+        expr_str = self._precedence_parens(node, node.func)
         args = [arg.accept(self) for arg in node.args]
         if node.keywords:
             keywords = [kwarg.accept(self) for kwarg in node.keywords]
@@ -120,15 +168,17 @@
                     bases = '(metaclass=%s)' % metaclass.name
             else:
                 bases = '(%s)' % bases if bases else ''
-        docs = '\n%s"""%s"""' % (self.indent, node.doc) if node.doc else ''
+        docs = self._docs_dedent(node.doc) if node.doc else ''
         return '\n\n%sclass %s%s:%s\n%s\n' % (decorate, node.name, bases, docs,
                                               self._stmt_list(node.body))
 
     def visit_compare(self, node):
         """return an astroid.Compare node as string"""
-        rhs_str = ' '.join(['%s %s' % (op, expr.accept(self))
-                            for op, expr in node.ops])
-        return '%s %s' % (node.left.accept(self), rhs_str)
+        rhs_str = ' '.join([
+            '%s %s' % (op, self._precedence_parens(node, expr, is_left=False))
+            for op, expr in node.ops
+        ])
+        return '%s %s' % (self._precedence_parens(node, node.left), rhs_str)
 
     def visit_comprehension(self, node):
         """return an astroid.Comprehension node as string"""
@@ -242,13 +292,11 @@
     def visit_functiondef(self, node):
         """return an astroid.Function node as string"""
         decorate = node.decorators.accept(self) if node.decorators else ''
-        docs = '\n%s"""%s"""' % (self.indent, node.doc) if node.doc else ''
-        return_annotation = ''
-        if six.PY3 and node.returns:
+        docs = self._docs_dedent(node.doc) if node.doc else ''
+        trailer = ':'
+        if node.returns:
             return_annotation = '->' + node.returns.as_string()
             trailer = return_annotation + ":"
-        else:
-            trailer = ":"
         def_format = "\n%sdef %s(%s)%s%s\n%s"
         return def_format % (decorate, node.name,
                              node.args.accept(self),
@@ -262,7 +310,7 @@
 
     def visit_attribute(self, node):
         """return an astroid.Getattr node as string"""
-        return '%s.%s' % (node.expr.accept(self), node.attrname)
+        return '%s.%s' % (self._precedence_parens(node, node.expr), node.attrname)
 
     def visit_global(self, node):
         """return an astroid.Global node as string"""
@@ -271,15 +319,18 @@
     def visit_if(self, node):
         """return an astroid.If node as string"""
         ifs = ['if %s:\n%s' % (node.test.accept(self), self._stmt_list(node.body))]
-        if node.orelse:# XXX use elif ???
+        if node.has_elif_block():
+            ifs.append('el%s' % self._stmt_list(node.orelse, indent=False))
+        elif node.orelse:
             ifs.append('else:\n%s' % self._stmt_list(node.orelse))
         return '\n'.join(ifs)
 
     def visit_ifexp(self, node):
         """return an astroid.IfExp node as string"""
-        return '%s if %s else %s' % (node.body.accept(self),
-                                     node.test.accept(self),
-                                     node.orelse.accept(self))
+        return '%s if %s else %s' % (
+            self._precedence_parens(node, node.body, is_left=True),
+            self._precedence_parens(node, node.test, is_left=True),
+            self._precedence_parens(node, node.orelse, is_left=False))
 
     def visit_import(self, node):
         """return an astroid.Import node as string"""
@@ -293,8 +344,12 @@
 
     def visit_lambda(self, node):
         """return an astroid.Lambda node as string"""
-        return 'lambda %s: %s' % (node.args.accept(self),
-                                  node.body.accept(self))
+        args = node.args.accept(self)
+        body = node.body.accept(self)
+        if args:
+            return 'lambda %s: %s' % (args, body)
+
+        return 'lambda: %s' % body
 
     def visit_list(self, node):
         """return an astroid.List node as string"""
@@ -342,6 +397,10 @@
 
     def visit_return(self, node):
         """return an astroid.Return node as string"""
+        if node.is_tuple_return() and len(node.value.elts) > 1:
+            elts = [child.accept(self) for child in node.value.elts]
+            return 'return %s' % ', '.join(elts)
+
         if node.value:
             return 'return %s' % node.value.accept(self)
 
@@ -363,15 +422,16 @@
     def visit_slice(self, node):
         """return a astroid.Slice node as string"""
         lower = node.lower.accept(self) if node.lower else ''
-        upper = node.upper.accept(self) if node.upper else''
+        upper = node.upper.accept(self) if node.upper else ''
         step = node.step.accept(self) if node.step else ''
         if step:
             return '%s:%s:%s' % (lower, upper, step)
-        return  '%s:%s' % (lower, upper)
+        return '%s:%s' % (lower, upper)
 
     def visit_subscript(self, node):
         """return an astroid.Subscript node as string"""
-        return '%s[%s]' % (node.value.accept(self), node.slice.accept(self))
+        return '%s[%s]' % (self._precedence_parens(node, node.value),
+                           node.slice.accept(self))
 
     def visit_tryexcept(self, node):
         """return an astroid.TryExcept node as string"""
@@ -399,7 +459,7 @@
             operator = 'not '
         else:
             operator = node.op
-        return '%s%s' % (operator, node.operand.accept(self))
+        return '%s%s' % (operator, self._precedence_parens(node, node.operand))
 
     def visit_while(self, node):
         """return an astroid.While node as string"""
@@ -411,8 +471,8 @@
 
     def visit_with(self, node): # 'with' without 'as' is possible
         """return an astroid.With node as string"""
-        items = ', '.join(('(%s)' % expr.accept(self)) +
-                          (vars and ' as (%s)' % (vars.accept(self)) or '')
+        items = ', '.join(('%s' % expr.accept(self)) +
+                          (vars and ' as %s' % (vars.accept(self)) or '')
                           for expr, vars in node.items)
         return 'with %s:\n%s' % (items, self._stmt_list(node.body))
 
diff -Nru astroid-1.6.5/astroid/astpeephole.py astroid-2.0/astroid/astpeephole.py
--- astroid-1.6.5/astroid/astpeephole.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/astpeephole.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,74 +0,0 @@
-# Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
-
-# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
-
-"""Small AST optimizations."""
-
-import _ast
-
-from astroid import nodes
-
-
-__all__ = ('ASTPeepholeOptimizer', )
-
-
-try:
-    _TYPES = (_ast.Str, _ast.Bytes)
-except AttributeError:
-    _TYPES = (_ast.Str, )
-
-
-class ASTPeepholeOptimizer(object):
-    """Class for applying small optimizations to generate new AST."""
-
-    def optimize_binop(self, node, parent=None):
-        """Optimize BinOps with string Const nodes on the lhs.
-
-        This fixes an infinite recursion crash, where multiple
-        strings are joined using the addition operator. With a
-        sufficient number of such strings, astroid will fail
-        with a maximum recursion limit exceeded. The
-        function will return a Const node with all the strings
-        already joined.
-        Return ``None`` if no AST node can be obtained
-        through optimization.
-        """
-        ast_nodes = []
-        current = node
-        while isinstance(current, _ast.BinOp):
-            # lhs must be a BinOp with the addition operand.
-            if not isinstance(current.left, _ast.BinOp):
-                return None
-            if (not isinstance(current.left.op, _ast.Add)
-                    or not isinstance(current.op, _ast.Add)):
-                return None
-
-            # rhs must a str / bytes.
-            if not isinstance(current.right, _TYPES):
-                return None
-
-            ast_nodes.append(current.right.s)
-            current = current.left
-
-            if (isinstance(current, _ast.BinOp)
-                    and isinstance(current.left, _TYPES)
-                    and isinstance(current.right, _TYPES)):
-                # Stop early if we are at the last BinOp in
-                # the operation
-                ast_nodes.append(current.right.s)
-                ast_nodes.append(current.left.s)
-                break
-
-        if not ast_nodes:
-            return None
-
-        # If we have inconsistent types, bail out.
-        known = type(ast_nodes[0])
-        if any(not isinstance(element, known)
-               for element in ast_nodes[1:]):
-            return None
-
-        value = known().join(reversed(ast_nodes))
-        newnode = nodes.Const(value, node.lineno, node.col_offset, parent)
-        return newnode
diff -Nru astroid-1.6.5/astroid/_ast.py astroid-2.0/astroid/_ast.py
--- astroid-1.6.5/astroid/_ast.py	1970-01-01 01:00:00.000000000 +0100
+++ astroid-2.0/astroid/_ast.py	2018-07-15 09:19:21.000000000 +0200
@@ -0,0 +1,43 @@
+import ast
+import sys
+from collections import namedtuple
+from typing import Optional
+
+_ast_py2 = _ast_py3 = None
+try:
+    import typed_ast.ast3 as _ast_py3
+    import typed_ast.ast27 as _ast_py2
+except ImportError:
+    pass
+
+
+FunctionType = namedtuple('FunctionType', ['argtypes', 'returns'])
+
+
+def _get_parser_module(parse_python_two: bool = False):
+    if parse_python_two:
+        parser_module = _ast_py2
+    elif sys.version_info[:2] >= (3, 7):
+        # The typed_ast module doesn't support the full 3.7 syntax yet.
+        # Remove once typed_ast is updated.
+        parser_module = ast
+    else:
+        parser_module = _ast_py3
+    return parser_module or ast
+
+
+def _parse(string: str,
+           parse_python_two: bool = False):
+    return _get_parser_module(parse_python_two=parse_python_two).parse(string)
+
+
+def parse_function_type_comment(type_comment: str) -> Optional[FunctionType]:
+    """Given a correct type comment, obtain a FunctionType object"""
+    if _ast_py3 is None:
+        return None
+
+    func_type = _ast_py3.parse(type_comment, "<type_comment>", "func_type")
+    return FunctionType(
+        argtypes=func_type.argtypes,
+        returns=func_type.returns,
+    )
diff -Nru astroid-1.6.5/astroid/bases.py astroid-2.0/astroid/bases.py
--- astroid-1.6.5/astroid/bases.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/bases.py	2018-07-15 09:19:23.000000000 +0200
@@ -1,7 +1,15 @@
 # Copyright (c) 2009-2011, 2013-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
-# Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2012 FELD Boris <lothiraldan@gmail.com>
+# Copyright (c) 2014-2018 Claudiu Popa <pcmanticore@gmail.com>
 # Copyright (c) 2014 Google, Inc.
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2014 Eevee (Alex Munroe) <amunroe@yelp.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>
+# Copyright (c) 2016-2017 Derek Gustafson <degustaf@gmail.com>
+# Copyright (c) 2017 Calen Pennington <calen.pennington@gmail.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
+# Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>
+# Copyright (c) 2018 Daniel Colascione <dancol@dancol.org>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -10,21 +18,22 @@
 inference utils.
 """
 
+import builtins
 import collections
 import sys
 
-import six
-
 from astroid import context as contextmod
 from astroid import exceptions
 from astroid import util
 
 objectmodel = util.lazy_import('interpreter.objectmodel')
-BUILTINS = six.moves.builtins.__name__
+helpers = util.lazy_import('helpers')
+BUILTINS = builtins.__name__
 manager = util.lazy_import('manager')
 MANAGER = manager.AstroidManager()
 
 if sys.version_info >= (3, 0):
+    # TODO: check if needs special treatment
     BUILTINS = 'builtins'
     BOOL_SPECIAL_METHOD = '__bool__'
 else:
@@ -39,11 +48,10 @@
 # Also, these aren't qualified, because each project can
 # define them, we shouldn't expect to know every possible
 # property-like decorator!
-# TODO(cpopa): just implement descriptors already.
 POSSIBLE_PROPERTIES = {"cached_property", "cachedproperty",
                        "lazyproperty", "lazy_property", "reify",
                        "lazyattribute", "lazy_attribute",
-                       "LazyProperty", "lazy"}
+                       "LazyProperty", "lazy", "cache_readonly"}
 
 
 def _is_property(meth):
@@ -51,11 +59,33 @@
         return True
     stripped = {name.split(".")[-1] for name in meth.decoratornames()
                 if name is not util.Uninferable}
-    return any(name in stripped for name in POSSIBLE_PROPERTIES)
+    if any(name in stripped for name in POSSIBLE_PROPERTIES):
+        return True
+
+    # Lookup for subclasses of *property*
+    if not meth.decorators:
+        return False
+    for decorator in meth.decorators.nodes or ():
+        inferred = helpers.safe_infer(decorator)
+        if inferred is None or inferred is util.Uninferable:
+            continue
+        if inferred.__class__.__name__ == 'ClassDef':
+            for base_class in inferred.bases:
+                module, _ = base_class.lookup(base_class.name)
+                if module.name == BUILTINS and base_class.name == 'property':
+                    return True
 
+    return False
 
-class Proxy(object):
-    """a simple proxy object"""
+
+class Proxy:
+    """a simple proxy object
+
+    Note:
+
+    Subclasses of this object will need a custom __getattr__
+    if new instance attributes are created. See the Const class
+    """
 
     _proxied = None # proxied object may be set by class or by instance
 
@@ -133,7 +163,7 @@
     def getattr(self, name, context=None, lookupclass=True):
         try:
             values = self._proxied.instance_attr(name, context)
-        except exceptions.AttributeInferenceError:
+        except exceptions.AttributeInferenceError as exc:
             if self.special_attributes and name in self.special_attributes:
                 return [self.special_attributes.lookup(name)]
 
@@ -143,9 +173,11 @@
                 return self._proxied.getattr(name, context,
                                              class_context=False)
 
-            util.reraise(exceptions.AttributeInferenceError(target=self,
-                                                            attribute=name,
-                                                            context=context))
+            raise exceptions.AttributeInferenceError(
+                target=self,
+                attribute=name,
+                context=context,
+            ) from exc
         # since we've no context information, return matching class members as
         # well
         if lookupclass:
@@ -167,29 +199,25 @@
 
             # XXX frame should be self._proxied, or not ?
             get_attr = self.getattr(name, context, lookupclass=False)
-            for stmt in _infer_stmts(self._wrap_attr(get_attr, context),
-                                     context, frame=self):
-                yield stmt
+            yield from _infer_stmts(self._wrap_attr(get_attr, context), context, frame=self)
         except exceptions.AttributeInferenceError as error:
             try:
                 # fallback to class.igetattr since it has some logic to handle
                 # descriptors
                 # But only if the _proxied is the Class.
                 if self._proxied.__class__.__name__ != 'ClassDef':
-                    util.reraise(exceptions.InferenceError(**vars(error)))
+                    raise exceptions.InferenceError(**vars(error)) from error
                 attrs = self._proxied.igetattr(name, context, class_context=False)
-                for stmt in self._wrap_attr(attrs, context):
-                    yield stmt
+                yield from self._wrap_attr(attrs, context)
             except exceptions.AttributeInferenceError as error:
-                util.reraise(exceptions.InferenceError(**vars(error)))
+                raise exceptions.InferenceError(**vars(error)) from error
 
     def _wrap_attr(self, attrs, context=None):
         """wrap bound methods of attrs in a InstanceMethod proxies"""
         for attr in attrs:
             if isinstance(attr, UnboundMethod):
                 if _is_property(attr):
-                    for inferred in attr.infer_call_result(self, context):
-                        yield inferred
+                    yield from attr.infer_call_result(self, context)
                 else:
                     yield BoundMethod(attr, self)
             elif hasattr(attr, 'name') and attr.name == '<lambda>':
@@ -208,6 +236,7 @@
 
     def infer_call_result(self, caller, context=None):
         """infer what a class instance is returning when called"""
+        context = contextmod.bind_context_to_node(context, self)
         inferred = False
         for node in self._proxied.igetattr('__call__', context):
             if node is util.Uninferable or not node.callable():
@@ -274,8 +303,7 @@
                 return True
         return result
 
-    # TODO(cpopa): this is set in inference.py
-    # The circular dependency hell goes deeper and deeper.
+    # This is set in inference.py.
     def getitem(self, index, context=None):
         pass
 
@@ -292,6 +320,9 @@
                                          self._proxied.name,
                                          frame.qname(), id(self))
 
+    def implicit_parameters(self):
+        return 0
+
     def is_bound(self):
         return False
 
@@ -306,11 +337,25 @@
         return self._proxied.igetattr(name, context)
 
     def infer_call_result(self, caller, context):
+        """
+        The boundnode of the regular context with a function called
+        on ``object.__new__`` will be of type ``object``,
+        which is incorrect for the argument in general.
+        If no context is given the ``object.__new__`` call argument will
+        correctly inferred except when inside a call that requires
+        the additonal context (such as a classmethod) of the boundnode
+        to determine which class the method was called from
+        """
+
         # If we're unbound method __new__ of builtin object, the result is an
         # instance of the class given as first argument.
         if (self._proxied.name == '__new__' and
                 self._proxied.parent.frame().qname() == '%s.object' % BUILTINS):
-            infer = caller.args[0].infer() if caller.args else []
+            if caller.args:
+                node_context = context.extra_context.get(caller.args[0])
+                infer = caller.args[0].infer(context=node_context)
+            else:
+                infer = []
             return (Instance(x) if x is not util.Uninferable else x for x in infer)
         return self._proxied.infer_call_result(caller, context)
 
@@ -328,6 +373,9 @@
         UnboundMethod.__init__(self, proxy)
         self.bound = bound
 
+    def implicit_parameters(self):
+        return 1
+
     def is_bound(self):
         return True
 
@@ -336,8 +384,7 @@
 
         In order for such call to be valid, the metaclass needs to be
         a subtype of ``type``, the name needs to be a string, the bases
-        needs to be a tuple of classes and the attributes a dictionary
-        of strings to values.
+        needs to be a tuple of classes
         """
         from astroid import node_classes
         # Verify the metaclass
@@ -379,13 +426,10 @@
         for key, value in attrs.items:
             key = next(key.infer(context=context))
             value = next(value.infer(context=context))
-            if key.__class__.__name__ != 'Const':
-                # Something invalid as an attribute.
-                return None
-            if not isinstance(key.value, str):
-                # Not a proper attribute.
-                return None
-            cls_locals[key.value].append(value)
+            # Ignore non string keys
+            if (key.__class__.__name__ == 'Const' and
+                    isinstance(key.value, str)):
+                cls_locals[key.value].append(value)
 
         # Build the class from now.
         cls = mcs.__class__(name=name.value, lineno=caller.lineno,
@@ -398,18 +442,11 @@
         return cls
 
     def infer_call_result(self, caller, context=None):
-        if context is None:
-            context = contextmod.InferenceContext()
-        context = context.clone()
-        context.boundnode = self.bound
-
+        context = contextmod.bind_context_to_node(context, self.bound)
         if (self.bound.__class__.__name__ == 'ClassDef'
                 and self.bound.name == 'type'
                 and self.name == '__new__'
-                and len(caller.args) == 4
-                # TODO(cpopa): this check shouldn't be needed.
-                and self._proxied.parent.frame().qname() == '%s.object' % BUILTINS):
-
+                and len(caller.args) == 4):
             # Check if we have an ``type.__new__(mcs, name, bases, attrs)`` call.
             new_cls = self._infer_type_new_call(caller, context)
             if new_cls:
diff -Nru astroid-1.6.5/astroid/brain/brain_attrs.py astroid-2.0/astroid/brain/brain_attrs.py
--- astroid-1.6.5/astroid/brain/brain_attrs.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/brain/brain_attrs.py	2018-07-15 09:19:25.000000000 +0200
@@ -21,6 +21,8 @@
     if not node.decorators:
         return False
     for decorator_attribute in node.decorators.nodes:
+        if isinstance(decorator_attribute, astroid.Call):  # decorator with arguments
+            decorator_attribute = decorator_attribute.func
         if decorator_attribute.as_string() in decorator_names:
             return True
     return False
@@ -32,7 +34,7 @@
     """
     # Astroid can't infer this attribute properly
     # Prevents https://github.com/PyCQA/pylint/issues/1884
-    node.locals["__attrs_attrs__"] = [astroid.Unknown(parent=node.body)]
+    node.locals["__attrs_attrs__"] = [astroid.Unknown(parent=node)]
 
     for cdefbodynode in node.body:
         if not isinstance(cdefbodynode, astroid.Assign):
@@ -53,6 +55,6 @@
 
 
 MANAGER.register_transform(
-    astroid.Class,
+    astroid.ClassDef,
     attr_attributes_transform,
     is_decorated_with_attrs)
diff -Nru astroid-1.6.5/astroid/brain/brain_builtin_inference.py astroid-2.0/astroid/brain/brain_builtin_inference.py
--- astroid-1.6.5/astroid/brain/brain_builtin_inference.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/brain/brain_builtin_inference.py	2018-07-15 09:19:27.000000000 +0200
@@ -1,5 +1,8 @@
-# Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2014-2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2014-2015 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2015 Rene Zhang <rz99@cornell.edu>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -11,8 +14,17 @@
 from textwrap import dedent
 
 import six
-from astroid import (MANAGER, UseInferenceDefault, AttributeInferenceError,
-                     inference_tip, InferenceError, NameInferenceError)
+from astroid import (
+    MANAGER,
+    Instance,
+    UseInferenceDefault,
+    AttributeInferenceError,
+    inference_tip,
+    InferenceError,
+    NameInferenceError,
+    AstroidTypeError,
+    MroError,
+)
 from astroid import arguments
 from astroid.builder import AstroidBuilder
 from astroid import helpers
@@ -27,9 +39,6 @@
 
 def _extend_str(class_node, rvalue):
     """function to extend builtin str/unicode class"""
-    # TODO(cpopa): this approach will make astroid to believe
-    # that some arguments can be passed by keyword, but
-    # unfortunately, strings and bytes don't accept keyword arguments.
     code = dedent('''
     class whatever(object):
         def join(self, iterable):
@@ -74,6 +83,11 @@
     code = code.format(rvalue=rvalue)
     fake = AstroidBuilder(MANAGER).string_build(code)['whatever']
     for method in fake.mymethods():
+        method.parent = class_node
+        method.lineno = None
+        method.col_offset = None
+        if '__class__' in method.locals:
+            method.locals['__class__'] = [class_node]
         class_node.locals[method.name] = [method]
         method.parent = class_node
 
@@ -93,6 +107,16 @@
                      'unicode': partial(_extend_str, rvalue="u''")})
 
 
+def _builtin_filter_predicate(node, builtin_name):
+    if isinstance(node.func, nodes.Name) and node.func.name == builtin_name:
+        return True
+    if isinstance(node.func, nodes.Attribute):
+        return (node.func.attrname == 'fromkeys'
+                and isinstance(node.func.expr, nodes.Name)
+                and node.func.expr.name == 'dict')
+    return False
+
+
 def register_builtin_transform(transform, builtin_name):
     """Register a new transform function for the given *builtin_name*.
 
@@ -108,14 +132,17 @@
                 # we set it to be the node we transformed from.
                 result.parent = node
 
-            result.lineno = node.lineno
-            result.col_offset = node.col_offset
+            if result.lineno is None:
+                result.lineno = node.lineno
+            if result.col_offset is None:
+                result.col_offset = node.col_offset
         return iter([result])
 
-    MANAGER.register_transform(nodes.Call,
-                               inference_tip(_transform_wrapper),
-                               lambda n: (isinstance(n.func, nodes.Name) and
-                                          n.func.name == builtin_name))
+    MANAGER.register_transform(
+        nodes.Call,
+        inference_tip(_transform_wrapper),
+        partial(_builtin_filter_predicate, builtin_name=builtin_name),
+    )
 
 
 def _generic_inference(node, context, node_type, transform):
@@ -144,10 +171,7 @@
     if isinstance(arg, klass):
         return arg
     elif isinstance(arg, iterables):
-        if not all(isinstance(elt, nodes.Const)
-                   for elt in arg.elts):
-            # TODO(cpopa): Don't support heterogenous elements.
-            # Not yet, though.
+        if not all(isinstance(elt, nodes.Const) for elt in arg.elts):
             raise UseInferenceDefault()
         elts = [elt.value for elt in arg.elts]
     elif isinstance(arg, nodes.Dict):
@@ -313,7 +337,6 @@
         else:
             mro_type = cls.instantiate_class()
     else:
-        # TODO(cpopa): support flow control (multiple inference values).
         try:
             mro_pointer = next(node.args[0].infer(context=context))
         except InferenceError:
@@ -341,7 +364,6 @@
         raise UseInferenceDefault
 
     try:
-        # TODO(cpopa): follow all the values of the first argument?
         obj = next(node.args[0].infer(context=context))
         attr = next(node.args[1].infer(context=context))
     except InferenceError:
@@ -508,6 +530,250 @@
     return False
 
 
+def infer_issubclass(callnode, context=None):
+    """Infer issubclass() calls
+
+    :param nodes.Call callnode: a `issubclass` call
+    :param InferenceContext: the context for the inference
+    :rtype nodes.Const: Boolean Const value of the `issubclass` call
+    :raises UseInferenceDefault: If the node cannot be inferred
+    """
+    call = arguments.CallSite.from_call(callnode)
+    if call.keyword_arguments:
+        # issubclass doesn't support keyword arguments
+        raise UseInferenceDefault("TypeError: issubclass() takes no keyword arguments")
+    if len(call.positional_arguments) != 2:
+        raise UseInferenceDefault(
+            "Expected two arguments, got {count}"
+            .format(count=len(call.positional_arguments)))
+    # The left hand argument is the obj to be checked
+    obj_node, class_or_tuple_node = call.positional_arguments
+
+    try:
+        obj_type = next(obj_node.infer(context=context))
+    except InferenceError as exc:
+        raise UseInferenceDefault from exc
+    if not isinstance(obj_type, nodes.ClassDef):
+        raise UseInferenceDefault("TypeError: arg 1 must be class")
+
+    # The right hand argument is the class(es) that the given
+    # object is to be checked against.
+    try:
+        class_container = _class_or_tuple_to_container(
+            class_or_tuple_node, context=context)
+    except InferenceError as exc:
+        raise UseInferenceDefault from exc
+    try:
+        issubclass_bool = helpers.object_issubclass(obj_type, class_container, context)
+    except AstroidTypeError as exc:
+        raise UseInferenceDefault("TypeError: " + str(exc)) from exc
+    except MroError as exc:
+        raise UseInferenceDefault from exc
+    return nodes.Const(issubclass_bool)
+
+
+def infer_isinstance(callnode, context=None):
+    """Infer isinstance calls
+
+    :param nodes.Call callnode: an isinstance call
+    :param InferenceContext: context for call
+        (currently unused but is a common interface for inference)
+    :rtype nodes.Const: Boolean Const value of isinstance call
+
+    :raises UseInferenceDefault: If the node cannot be inferred
+    """
+    call = arguments.CallSite.from_call(callnode)
+    if call.keyword_arguments:
+        # isinstance doesn't support keyword arguments
+        raise UseInferenceDefault("TypeError: isinstance() takes no keyword arguments")
+    if len(call.positional_arguments) != 2:
+        raise UseInferenceDefault(
+            "Expected two arguments, got {count}"
+            .format(count=len(call.positional_arguments)))
+    # The left hand argument is the obj to be checked
+    obj_node, class_or_tuple_node = call.positional_arguments
+    # The right hand argument is the class(es) that the given
+    # obj is to be check is an instance of
+    try:
+        class_container = _class_or_tuple_to_container(
+            class_or_tuple_node, context=context)
+    except InferenceError:
+        raise UseInferenceDefault
+    try:
+        isinstance_bool = helpers.object_isinstance(
+            obj_node, class_container, context)
+    except AstroidTypeError as exc:
+        raise UseInferenceDefault("TypeError: " + str(exc))
+    except MroError as exc:
+        raise UseInferenceDefault from exc
+    if isinstance_bool is util.Uninferable:
+        raise UseInferenceDefault
+    return nodes.Const(isinstance_bool)
+
+
+def _class_or_tuple_to_container(node, context=None):
+    # Move inferences results into container
+    # to simplify later logic
+    # raises InferenceError if any of the inferences fall through
+    node_infer = next(node.infer(context=context))
+    # arg2 MUST be a type or a TUPLE of types
+    # for isinstance
+    if isinstance(node_infer, nodes.Tuple):
+        class_container = [
+            next(node.infer(context=context))
+            for node in node_infer.elts
+        ]
+        class_container = [
+            klass_node for klass_node
+            in class_container if klass_node is not None
+        ]
+    else:
+        class_container = [node_infer]
+    return class_container
+
+
+def infer_len(node, context=None):
+    """Infer length calls
+
+    :param nodes.Call node: len call to infer
+    :param context.InferenceContext: node context
+    :rtype nodes.Const: a Const node with the inferred length, if possible
+    """
+    call = arguments.CallSite.from_call(node)
+    if call.keyword_arguments:
+        raise UseInferenceDefault(
+            "TypeError: len() must take no keyword arguments"
+        )
+    if len(call.positional_arguments) != 1:
+        raise UseInferenceDefault(
+            "TypeError: len() must take exactly one argument "
+            "({len}) given".format(len=len(call.positional_arguments))
+        )
+    [argument_node] = call.positional_arguments
+    try:
+        return nodes.Const(helpers.object_len(argument_node))
+    except (AstroidTypeError, InferenceError) as exc:
+        raise UseInferenceDefault(str(exc)) from exc
+
+
+def infer_str(node, context=None):
+    """Infer str() calls
+
+    :param nodes.Call node: str() call to infer
+    :param context.InferenceContext: node context
+    :rtype nodes.Const: a Const containing an empty string
+    """
+    call = arguments.CallSite.from_call(node)
+    if call.keyword_arguments:
+        raise UseInferenceDefault(
+            "TypeError: str() must take no keyword arguments")
+    try:
+        return nodes.Const('')
+    except (AstroidTypeError, InferenceError) as exc:
+        raise UseInferenceDefault(str(exc)) from exc
+
+
+def infer_int(node, context=None):
+    """Infer int() calls
+
+    :param nodes.Call node: int() call to infer
+    :param context.InferenceContext: node context
+    :rtype nodes.Const: a Const containing the integer value of the int() call
+    """
+    call = arguments.CallSite.from_call(node)
+    if call.keyword_arguments:
+        raise UseInferenceDefault(
+            "TypeError: int() must take no keyword arguments"
+        )
+
+    if call.positional_arguments:
+        try:
+            first_value = next(call.positional_arguments[0].infer(context=context))
+        except InferenceError as exc:
+            raise UseInferenceDefault(str(exc)) from exc
+
+        if first_value is util.Uninferable:
+            raise UseInferenceDefault
+
+        if isinstance(first_value, nodes.Const) and isinstance(first_value.value, (int, str)):
+            try:
+                actual_value = int(first_value.value)
+            except ValueError:
+                return nodes.Const(0)
+            return nodes.Const(actual_value)
+
+    return nodes.Const(0)
+
+
+def infer_dict_fromkeys(node, context=None):
+    """Infer dict.fromkeys
+
+    :param nodes.Call node: dict.fromkeys() call to infer
+    :param context.InferenceContext: node context
+    :rtype nodes.Dict:
+        a Dictionary containing the values that astroid was able to infer.
+        In case the inference failed for any reason, an empty dictionary
+        will be inferred instead.
+    """
+
+    def _build_dict_with_elements(elements):
+        new_node = nodes.Dict(col_offset=node.col_offset,
+                              lineno=node.lineno,
+                              parent=node.parent)
+        new_node.postinit(elements)
+        return new_node
+
+    call = arguments.CallSite.from_call(node)
+    if call.keyword_arguments:
+        raise UseInferenceDefault(
+            "TypeError: int() must take no keyword arguments"
+        )
+    if len(call.positional_arguments) not in {1, 2}:
+        raise UseInferenceDefault("TypeError: Needs between 1 and 2 positional arguments")
+
+    default = nodes.Const(None)
+    values = call.positional_arguments[0]
+    try:
+        inferred_values = next(values.infer(context=context))
+    except InferenceError:
+        return _build_dict_with_elements([])
+    if inferred_values is util.Uninferable:
+        return _build_dict_with_elements([])
+
+    # Limit to a couple of potential values, as this can become pretty complicated
+    accepted_iterable_elements = (
+        nodes.Const,
+    )
+    if isinstance(inferred_values, (nodes.List, nodes.Set, nodes.Tuple)):
+        elements = inferred_values.elts
+        for element in elements:
+            if not isinstance(element, accepted_iterable_elements):
+                # Fallback to an empty dict
+                return _build_dict_with_elements([])
+
+        elements_with_value = [(element, default) for element in elements]
+        return _build_dict_with_elements(elements_with_value)
+
+    elif (isinstance(inferred_values, nodes.Const)
+              and isinstance(inferred_values.value, (str, bytes))):
+        elements = [
+            (nodes.Const(element), default) for element in inferred_values.value
+        ]
+        return _build_dict_with_elements(elements)
+    elif isinstance(inferred_values, nodes.Dict):
+        keys = inferred_values.itered()
+        for key in keys:
+            if not isinstance(key, accepted_iterable_elements):
+                # Fallback to an empty dict
+                return _build_dict_with_elements([])
+
+        elements_with_value = [(element, default) for element in keys]
+        return _build_dict_with_elements(elements_with_value)
+
+    # Fallback to an empty dictionary
+    return _build_dict_with_elements([])
+
+
 # Builtins inference
 register_builtin_transform(infer_bool, 'bool')
 register_builtin_transform(infer_super, 'super')
@@ -521,6 +787,13 @@
 register_builtin_transform(infer_frozenset, 'frozenset')
 register_builtin_transform(infer_type, 'type')
 register_builtin_transform(infer_slice, 'slice')
+register_builtin_transform(infer_isinstance, 'isinstance')
+register_builtin_transform(infer_issubclass, 'issubclass')
+register_builtin_transform(infer_len, 'len')
+register_builtin_transform(infer_str, 'str')
+register_builtin_transform(infer_int, 'int')
+register_builtin_transform(infer_dict_fromkeys, 'dict.fromkeys')
+
 
 # Infer object.__new__ calls
 MANAGER.register_transform(
diff -Nru astroid-1.6.5/astroid/brain/brain_collections.py astroid-2.0/astroid/brain/brain_collections.py
--- astroid-1.6.5/astroid/brain/brain_collections.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/brain/brain_collections.py	2018-07-15 09:19:26.000000000 +0200
@@ -1,4 +1,8 @@
-# Copyright (c) 2016 Claudiu Popa <pcmanticore@gmail.com>
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, 2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016-2017 Łukasz Rogalski <rogalski.91@gmail.com>
+# Copyright (c) 2017 Derek Gustafson <degustaf@gmail.com>
+# Copyright (c) 2018 Ioana Tagirta <ioana.tagirta@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -6,6 +10,7 @@
 
 import astroid
 
+PY34 = sys.version_info >= (3, 4)
 PY35 = sys.version_info >= (3, 5)
 
 
@@ -16,11 +21,7 @@
         def __missing__(self, key): pass
         def __getitem__(self, key): return default_factory
 
-    ''' + _deque_mock() + '''
-
-    class OrderedDict(dict):
-        def __reversed__(self): return self[::-1]
-    ''')
+    ''' + _deque_mock() + _ordered_dict_mock())
 
 
 def _deque_mock():
@@ -28,21 +29,21 @@
     class deque(object):
         maxlen = 0
         def __init__(self, iterable=None, maxlen=None):
-            self.iterable = iterable
+            self.iterable = iterable or []
         def append(self, x): pass
         def appendleft(self, x): pass
         def clear(self): pass
         def count(self, x): return 0
         def extend(self, iterable): pass
         def extendleft(self, iterable): pass
-        def pop(self): pass
-        def popleft(self): pass
+        def pop(self): return self.iterable[0]
+        def popleft(self): return self.iterable[0]
         def remove(self, value): pass
-        def reverse(self): pass
-        def rotate(self, n=1): pass
+        def reverse(self): return reversed(self.iterable)
+        def rotate(self, n=1): return self
         def __iter__(self): return self
         def __reversed__(self): return self.iterable[::-1]
-        def __getitem__(self, index): pass
+        def __getitem__(self, index): return self.iterable[index]
         def __setitem__(self, index, value): pass
         def __delitem__(self, index): pass
         def __bool__(self): return bool(self.iterable)
@@ -62,5 +63,16 @@
         def __rmul__(self, other): pass'''
     return base_deque_class
 
+
+def _ordered_dict_mock():
+    base_ordered_dict_class = '''
+    class OrderedDict(dict):
+        def __reversed__(self): return self[::-1]
+    '''
+    if PY34:
+        base_ordered_dict_class += '''
+        def move_to_end(self, key, last=False): pass'''
+    return base_ordered_dict_class
+
 astroid.register_module_extender(astroid.MANAGER, 'collections', _collections_transform)
 
diff -Nru astroid-1.6.5/astroid/brain/brain_dateutil.py astroid-2.0/astroid/brain/brain_dateutil.py
--- astroid-1.6.5/astroid/brain/brain_dateutil.py	2018-01-07 11:53:49.000000000 +0100
+++ astroid-2.0/astroid/brain/brain_dateutil.py	2018-07-15 09:19:26.000000000 +0200
@@ -1,5 +1,6 @@
 # Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
-# Copyright (c) 2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2015 raylu <lurayl@gmail.com>
+# Copyright (c) 2016 Ceridwen <ceridwenv@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
diff -Nru astroid-1.6.5/astroid/brain/brain_functools.py astroid-2.0/astroid/brain/brain_functools.py
--- astroid-1.6.5/astroid/brain/brain_functools.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/brain/brain_functools.py	2018-07-15 09:19:26.000000000 +0200
@@ -1,8 +1,11 @@
-# Copyright (c) 2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016, 2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
 
 """Astroid hooks for understanding functools library module."""
+from itertools import chain
 
 import astroid
+from astroid import arguments
 from astroid import BoundMethod
 from astroid import extract_node
 from astroid import helpers
@@ -53,6 +56,84 @@
     return
 
 
+def _functools_partial_inference(node, context=None):
+    call = arguments.CallSite.from_call(node)
+    number_of_positional = len(call.positional_arguments)
+    if number_of_positional < 1:
+        raise astroid.UseInferenceDefault('functools.partial takes at least one argument')
+    if number_of_positional == 1 and not call.keyword_arguments:
+        raise astroid.UseInferenceDefault(
+            'functools.partial needs at least to have some filled arguments'
+        )
+
+    partial_function = call.positional_arguments[0]
+    try:
+        inferred_wrapped_function = next(partial_function.infer(context=context))
+    except astroid.InferenceError as exc:
+        raise astroid.UseInferenceDefault from exc
+    if inferred_wrapped_function is astroid.Uninferable:
+        raise astroid.UseInferenceDefault('Cannot infer the wrapped function')
+    if not isinstance(inferred_wrapped_function, astroid.FunctionDef):
+        raise astroid.UseInferenceDefault('The wrapped function is not a function')
+
+    # Determine if the passed keywords into the callsite are supported
+    # by the wrapped function.
+    function_parameters = chain(
+        inferred_wrapped_function.args.args or (),
+        inferred_wrapped_function.args.kwonlyargs or ()
+    )
+    parameter_names = set(
+        param.name for param in function_parameters
+        if isinstance(param, astroid.AssignName)
+    )
+    if set(call.keyword_arguments) - parameter_names:
+        raise astroid.UseInferenceDefault('wrapped function received unknown parameters')
+
+    # Return a wrapped() object that can be used further for inference
+    class PartialFunction(astroid.FunctionDef):
+
+        filled_positionals = len(call.positional_arguments[1:])
+        filled_keywords = list(call.keyword_arguments)
+
+        def infer_call_result(self, caller=None, context=None):
+            nonlocal call
+            filled_args = call.positional_arguments[1:]
+            filled_keywords = call.keyword_arguments
+
+            if context:
+                current_passed_keywords = {
+                    keyword for (keyword, _) in context.callcontext.keywords
+                }
+                for keyword, value in filled_keywords.items():
+                    if keyword not in current_passed_keywords:
+                        context.callcontext.keywords.append((keyword, value))
+
+                call_context_args = context.callcontext.args or []
+                context.callcontext.args = filled_args + call_context_args
+
+            return super().infer_call_result(
+                caller=caller,
+                context=context,
+            )
+
+    partial_function = PartialFunction(
+        name=inferred_wrapped_function.name,
+        doc=inferred_wrapped_function.doc,
+        lineno=inferred_wrapped_function.lineno,
+        col_offset=inferred_wrapped_function.col_offset,
+        parent=inferred_wrapped_function.parent,
+    )
+    partial_function.postinit(
+        args=inferred_wrapped_function.args,
+        body=inferred_wrapped_function.body,
+        decorators=inferred_wrapped_function.decorators,
+        returns=inferred_wrapped_function.returns,
+        type_comment_returns=inferred_wrapped_function.type_comment_returns,
+        type_comment_args=inferred_wrapped_function.type_comment_args,
+    )
+    return iter((partial_function,))
+
+
 def _looks_like_lru_cache(node):
     """Check if the given function node is decorated with lru_cache."""
     if not node.decorators:
@@ -71,5 +152,25 @@
     return False
 
 
-MANAGER.register_transform(astroid.FunctionDef, _transform_lru_cache,
-                           _looks_like_lru_cache)
+def _looks_like_functools_partial(node):
+    """Check if the given Call node is a functools.partial call"""
+    if isinstance(node.func, astroid.Name):
+        return node.func.name == 'partial'
+    elif isinstance(node.func, astroid.Attribute):
+        return (node.func.attrname == 'partial'
+                and isinstance(node.func.expr, astroid.Name)
+                and node.func.expr.name == 'functools')
+
+
+MANAGER.register_transform(
+    astroid.FunctionDef,
+    _transform_lru_cache,
+    _looks_like_lru_cache,
+)
+
+
+MANAGER.register_transform(
+    astroid.Call,
+    astroid.inference_tip(_functools_partial_inference),
+    _looks_like_functools_partial,
+)
diff -Nru astroid-1.6.5/astroid/brain/brain_gi.py astroid-2.0/astroid/brain/brain_gi.py
--- astroid-1.6.5/astroid/brain/brain_gi.py	2018-06-03 13:32:37.000000000 +0200
+++ astroid-2.0/astroid/brain/brain_gi.py	2018-07-15 09:19:26.000000000 +0200
@@ -1,4 +1,11 @@
+# Copyright (c) 2013-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
+# Copyright (c) 2014 Google, Inc.
+# Copyright (c) 2014 Cole Robinson <crobinso@redhat.com>
 # Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2015 David Shea <dshea@redhat.com>
+# Copyright (c) 2016 Jakub Wilk <jwilk@jwilk.net>
+# Copyright (c) 2016 Giuseppe Scrivano <gscrivan@redhat.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
diff -Nru astroid-1.6.5/astroid/brain/brain_hashlib.py astroid-2.0/astroid/brain/brain_hashlib.py
--- astroid-1.6.5/astroid/brain/brain_hashlib.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/brain/brain_hashlib.py	2018-07-15 09:19:26.000000000 +0200
@@ -1,12 +1,15 @@
-# Copyright (c) 2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016, 2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2018 Ioana Tagirta <ioana.tagirta@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
+import sys
 
 import six
 
 import astroid
 
+PY36 = sys.version_info >= (3, 6)
 
 def _hashlib_transform():
     template = '''
@@ -29,7 +32,12 @@
       def digest_size(self):
         return 1
     '''
-    algorithms = ('md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512')
+    algorithms = ['md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512']
+    if PY36:
+        algorithms += [
+            'sha3_224', 'sha3_256', 'sha3_384', 'sha3_512', 'shake_128', 'shake_256',
+            'blake2b',
+        ]
     classes = "".join(
         template % {'name': hashfunc, 'digest': 'b""' if six.PY3 else '""'}
         for hashfunc in algorithms)
@@ -37,4 +45,3 @@
 
 
 astroid.register_module_extender(astroid.MANAGER, 'hashlib', _hashlib_transform)
-
diff -Nru astroid-1.6.5/astroid/brain/brain_mechanize.py astroid-2.0/astroid/brain/brain_mechanize.py
--- astroid-1.6.5/astroid/brain/brain_mechanize.py	2018-01-07 11:53:49.000000000 +0100
+++ astroid-2.0/astroid/brain/brain_mechanize.py	2018-07-15 09:19:27.000000000 +0200
@@ -1,4 +1,7 @@
+# Copyright (c) 2012-2013 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
+# Copyright (c) 2014 Google, Inc.
 # Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016 Ceridwen <ceridwenv@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
diff -Nru astroid-1.6.5/astroid/brain/brain_namedtuple_enum.py astroid-2.0/astroid/brain/brain_namedtuple_enum.py
--- astroid-1.6.5/astroid/brain/brain_namedtuple_enum.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/brain/brain_namedtuple_enum.py	2018-07-15 09:19:28.000000000 +0200
@@ -1,5 +1,16 @@
+# -*- coding: utf-8 -*-
 # Copyright (c) 2012-2015 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
-# Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2013-2014 Google, Inc.
+# Copyright (c) 2014-2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2014 Eevee (Alex Munroe) <amunroe@yelp.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2015 Dmitry Pribysh <dmand@yandex.ru>
+# Copyright (c) 2015 David Shea <dshea@redhat.com>
+# Copyright (c) 2015 Philip Lorenz <philip@bithub.de>
+# Copyright (c) 2016 Jakub Wilk <jwilk@jwilk.net>
+# Copyright (c) 2016 Mateusz Bysiek <mb@mbdev.pl>
+# Copyright (c) 2017 Hugo <hugovk@users.noreply.github.com>
+# Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -7,7 +18,6 @@
 """Astroid hooks for the Python standard library."""
 
 import functools
-import sys
 import keyword
 from textwrap import dedent
 
@@ -21,6 +31,13 @@
 from astroid import util
 
 
+TYPING_NAMEDTUPLE_BASENAMES = {
+    'NamedTuple',
+    'typing.NamedTuple'
+}
+ENUM_BASE_NAMES = {'Enum', 'IntEnum', 'enum.Enum', 'enum.IntEnum'}
+
+
 def _infer_first(node, context):
     if node is util.Uninferable:
         raise UseInferenceDefault
@@ -81,7 +98,6 @@
             else:
                 # Enums supports either iterator of (name, value) pairs
                 # or mappings.
-                # TODO: support only list, tuples and mappings.
                 if hasattr(names, 'items') and isinstance(names.items, list):
                     attributes = [_infer_first(const[0], context).value
                                   for const in names.items
@@ -122,6 +138,15 @@
     return class_node, name, attributes
 
 
+def _has_namedtuple_base(node):
+    """Predicate for class inference tip
+
+    :type node: ClassDef
+    :rtype: bool
+    """
+    return set(node.basenames) & TYPING_NAMEDTUPLE_BASENAMES
+
+
 def _looks_like(node, name):
     func = node.func
     if isinstance(func, nodes.Attribute):
@@ -130,14 +155,20 @@
         return func.name == name
     return False
 
+
 _looks_like_namedtuple = functools.partial(_looks_like, name='namedtuple')
 _looks_like_enum = functools.partial(_looks_like, name='Enum')
+_looks_like_typing_namedtuple = functools.partial(_looks_like, name='NamedTuple')
 
 
 def infer_named_tuple(node, context=None):
     """Specific inference function for namedtuple Call node"""
-    class_node, name, attributes = infer_func_form(node, nodes.Tuple._proxied,
-                                                   context=context)
+    tuple_base_name = nodes.Name(name='tuple', parent=node.root())
+    class_node, name, attributes = infer_func_form(
+        node,
+        tuple_base_name,
+        context=context,
+    )
     call_site = arguments.CallSite.from_call(node)
     func = next(extract_node('import collections; collections.namedtuple').infer())
     try:
@@ -232,11 +263,10 @@
 
 def infer_enum_class(node):
     """ Specific inference for enums. """
-    names = set(('Enum', 'IntEnum', 'enum.Enum', 'enum.IntEnum'))
     for basename in node.basenames:
         # TODO: doesn't handle subclasses yet. This implementation
         # is a hack to support enums.
-        if basename not in names:
+        if basename not in ENUM_BASE_NAMES:
             continue
         if node.root().name == 'enum':
             # Skip if the class is directly from enum module.
@@ -246,6 +276,7 @@
                    for value in values):
                 continue
 
+            targets = []
             stmt = values[0].statement()
             if isinstance(stmt, nodes.Assign):
                 if isinstance(stmt.targets[0], nodes.Tuple):
@@ -255,19 +286,29 @@
             elif isinstance(stmt, nodes.AnnAssign):
                 targets = [stmt.target]
 
+            inferred_return_value = None
+            if isinstance(stmt.value, nodes.Const):
+                if isinstance(stmt.value.value, str):
+                    inferred_return_value = '"{}"'.format(stmt.value.value)
+                else:
+                    inferred_return_value = stmt.value.value
+
             new_targets = []
             for target in targets:
                 # Replace all the assignments with our mocked class.
                 classdef = dedent('''
-                class %(name)s(%(types)s):
+                class {name}({types}):
                     @property
                     def value(self):
-                        # Not the best return.
-                        return None
+                        return {return_value}
                     @property
                     def name(self):
-                        return %(name)r
-                ''' % {'name': target.name, 'types': ', '.join(node.basenames)})
+                        return {name}
+                '''.format(
+                    name=target.name,
+                    types=', '.join(node.basenames),
+                    return_value=inferred_return_value,
+                ))
                 fake = AstroidBuilder(MANAGER).string_build(classdef)[target.name]
                 fake.parent = target.parent
                 for method in node.mymethods():
@@ -278,8 +319,79 @@
     return node
 
 
-MANAGER.register_transform(nodes.Call, inference_tip(infer_named_tuple),
-                           _looks_like_namedtuple)
-MANAGER.register_transform(nodes.Call, inference_tip(infer_enum),
-                           _looks_like_enum)
-MANAGER.register_transform(nodes.ClassDef, infer_enum_class)
+def infer_typing_namedtuple_class(class_node, context=None):
+    """Infer a subclass of typing.NamedTuple"""
+    # Check if it has the corresponding bases
+    annassigns_fields = [
+        annassign.target.name for annassign in class_node.body
+        if isinstance(annassign, nodes.AnnAssign)
+    ]
+    code = dedent('''
+    from collections import namedtuple
+    namedtuple({typename!r}, {fields!r})
+    ''').format(
+        typename=class_node.name,
+        fields=",".join(annassigns_fields)
+    )
+    node = extract_node(code)
+    generated_class_node = next(infer_named_tuple(node, context))
+    for method in class_node.mymethods():
+        generated_class_node.locals[method.name] = [method]
+    return iter((generated_class_node, ))
+
+
+def infer_typing_namedtuple(node, context=None):
+    """Infer a typing.NamedTuple(...) call."""
+    # This is essentially a namedtuple with different arguments
+    # so we extract the args and infer a named tuple.
+    try:
+        func = next(node.func.infer())
+    except InferenceError:
+        raise UseInferenceDefault
+
+    if func.qname() != 'typing.NamedTuple':
+        raise UseInferenceDefault
+
+    if len(node.args) != 2:
+        raise UseInferenceDefault
+
+    if not isinstance(node.args[1], (nodes.List, nodes.Tuple)):
+        raise UseInferenceDefault
+
+    names = []
+    for elt in node.args[1].elts:
+        if not isinstance(elt, (nodes.List, nodes.Tuple)):
+            raise UseInferenceDefault
+        if len(elt.elts) != 2:
+            raise UseInferenceDefault
+        names.append(elt.elts[0].as_string())
+
+    typename = node.args[0].as_string()
+    node = extract_node('namedtuple(%(typename)s, (%(fields)s,)) ' %
+        {'typename': typename, 'fields': ",".join(names)})
+    return infer_named_tuple(node, context)
+
+
+MANAGER.register_transform(
+    nodes.Call, inference_tip(infer_named_tuple),
+    _looks_like_namedtuple,
+)
+MANAGER.register_transform(
+    nodes.Call, inference_tip(infer_enum),
+    _looks_like_enum,
+)
+MANAGER.register_transform(
+    nodes.ClassDef, infer_enum_class,
+    predicate=lambda cls: any(basename for basename in cls.basenames
+                              if basename in ENUM_BASE_NAMES)
+)
+MANAGER.register_transform(
+    nodes.ClassDef,
+    inference_tip(infer_typing_namedtuple_class),
+    _has_namedtuple_base,
+)
+MANAGER.register_transform(
+    nodes.Call,
+    inference_tip(infer_typing_namedtuple),
+    _looks_like_typing_namedtuple,
+)
diff -Nru astroid-1.6.5/astroid/brain/brain_nose.py astroid-2.0/astroid/brain/brain_nose.py
--- astroid-1.6.5/astroid/brain/brain_nose.py	2018-05-13 12:38:38.000000000 +0200
+++ astroid-2.0/astroid/brain/brain_nose.py	2018-07-15 09:19:27.000000000 +0200
@@ -1,4 +1,5 @@
 # Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016 Ceridwen <ceridwenv@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
diff -Nru astroid-1.6.5/astroid/brain/brain_numpy.py astroid-2.0/astroid/brain/brain_numpy.py
--- astroid-1.6.5/astroid/brain/brain_numpy.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/brain/brain_numpy.py	2018-07-15 09:19:27.000000000 +0200
@@ -1,4 +1,6 @@
-# Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016, 2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2017-2018 hippo91 <guillaume.peillex@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -150,30 +152,307 @@
 def numpy_core_numerictypes_transform():
     return astroid.parse('''
     # different types defined in numerictypes.py
-    uint16 = type('uint16') 
-    uint32 = type('uint32')
-    uint64 = type('uint64')
-    int128 = type('int128')
-    uint128 = type('uint128')
-    float16 = type('float16')
-    float32 = type('float32')
-    float64 = type('float64')
-    float80 = type('float80')
-    float96 = type('float96')
-    float128 = type('float128')
-    float256 = type('float256')
-    complex32 = type('complex32')
-    complex64 = type('complex64')
-    complex128 = type('complex128')
-    complex160 = type('complex160')
-    complex192 = type('complex192')
-    complex256 = type('complex256')
-    complex512 = type('complex512')
-    timedelta64 = type('timedelta64')
-    datetime64 = type('datetime64')
-    unicode_ = type('unicode_')
-    string_ = type('string_')
-    object_ = type('object_')
+    class generic(object):
+        def __init__(self, value):
+            self.T = None
+            self.base = None
+            self.data = None
+            self.dtype = None
+            self.flags = None
+            self.flat = None
+            self.imag = None
+            self.itemsize = None
+            self.nbytes = None
+            self.ndim = None
+            self.real = None
+            self.size = None
+            self.strides = None
+
+        def all(self): pass
+        def any(self): pass
+        def argmax(self): pass
+        def argmin(self): pass
+        def argsort(self): pass
+        def astype(self): pass
+        def base(self): pass
+        def byteswap(self): pass
+        def choose(self): pass
+        def clip(self): pass
+        def compress(self): pass
+        def conj(self): pass
+        def conjugate(self): pass
+        def copy(self): pass
+        def cumprod(self): pass
+        def cumsum(self): pass
+        def data(self): pass
+        def diagonal(self): pass
+        def dtype(self): pass
+        def dump(self): pass
+        def dumps(self): pass
+        def fill(self): pass
+        def flags(self): pass
+        def flat(self): pass
+        def flatten(self): pass
+        def getfield(self): pass
+        def imag(self): pass
+        def item(self): pass
+        def itemset(self): pass
+        def itemsize(self): pass
+        def max(self): pass
+        def mean(self): pass
+        def min(self): pass
+        def nbytes(self): pass
+        def ndim(self): pass
+        def newbyteorder(self): pass
+        def nonzero(self): pass
+        def prod(self): pass
+        def ptp(self): pass
+        def put(self): pass
+        def ravel(self): pass
+        def real(self): pass
+        def repeat(self): pass
+        def reshape(self): pass
+        def resize(self): pass
+        def round(self): pass
+        def searchsorted(self): pass
+        def setfield(self): pass
+        def setflags(self): pass
+        def shape(self): pass
+        def size(self): pass
+        def sort(self): pass
+        def squeeze(self): pass
+        def std(self): pass
+        def strides(self): pass
+        def sum(self): pass
+        def swapaxes(self): pass
+        def take(self): pass
+        def tobytes(self): pass
+        def tofile(self): pass
+        def tolist(self): pass
+        def tostring(self): pass
+        def trace(self): pass
+        def transpose(self): pass
+        def var(self): pass
+        def view(self): pass
+
+
+    class dtype(object):
+        def __init__(self, obj, align=False, copy=False):
+            self.alignment = None
+            self.base = None
+            self.byteorder = None
+            self.char = None
+            self.descr = None
+            self.fields = None
+            self.flags = None
+            self.hasobject = None
+            self.isalignedstruct = None
+            self.isbuiltin = None
+            self.isnative = None
+            self.itemsize = None
+            self.kind = None
+            self.metadata = None
+            self.name = None
+            self.names = None
+            self.num = None
+            self.shape = None
+            self.str = None
+            self.subdtype = None
+            self.type = None
+
+        def newbyteorder(self, new_order='S'): pass
+
+
+    class ndarray(object):
+        def __init__(self, shape, dtype=float, buffer=None, offset=0,
+                     strides=None, order=None):
+            self.T = None
+            self.base = None
+            self.ctypes = None
+            self.data = None
+            self.dtype = None
+            self.flags = None
+            self.flat = None
+            self.imag = None
+            self.itemsize = None
+            self.nbytes = None
+            self.ndim = None
+            self.real = None
+            self.shape = None
+            self.size = None
+            self.strides = None
+
+        def all(self): pass
+        def any(self): pass
+        def argmax(self): pass
+        def argmin(self): pass
+        def argpartition(self): pass
+        def argsort(self): pass
+        def astype(self): pass
+        def byteswap(self): pass
+        def choose(self): pass
+        def clip(self): pass
+        def compress(self): pass
+        def conj(self): pass
+        def conjugate(self): pass
+        def copy(self): pass
+        def cumprod(self): pass
+        def cumsum(self): pass
+        def diagonal(self): pass
+        def dot(self): pass
+        def dump(self): pass
+        def dumps(self): pass
+        def fill(self): pass
+        def flatten(self): pass
+        def getfield(self): pass
+        def item(self): pass
+        def itemset(self): pass
+        def max(self): pass
+        def mean(self): pass
+        def min(self): pass
+        def newbyteorder(self): pass
+        def nonzero(self): pass
+        def partition(self): pass
+        def prod(self): pass
+        def ptp(self): pass
+        def put(self): pass
+        def ravel(self): pass
+        def repeat(self): pass
+        def reshape(self): pass
+        def resize(self): pass
+        def round(self): pass
+        def searchsorted(self): pass
+        def setfield(self): pass
+        def setflags(self): pass
+        def sort(self): pass
+        def squeeze(self): pass
+        def std(self): pass
+        def sum(self): pass
+        def swapaxes(self): pass
+        def take(self): pass
+        def tobytes(self): pass
+        def tofile(self): pass
+        def tolist(self): pass
+        def tostring(self): pass
+        def trace(self): pass
+        def transpose(self): pass
+        def var(self): pass
+        def view(self): pass
+
+
+    class busdaycalendar(object):
+        def __init__(self, weekmask='1111100', holidays=None):
+            self.holidays = None
+            self.weekmask = None
+
+    class flexible(generic): pass
+    class bool_(generic): pass
+    class number(generic): pass
+    class datetime64(generic): pass
+   
+
+    class void(flexible):
+        def __init__(self, *args, **kwargs):
+            self.base = None
+            self.dtype = None
+            self.flags = None
+        def getfield(self): pass
+        def setfield(self): pass
+
+
+    class character(flexible): pass
+
+
+    class integer(number):
+        def __init__(self, value):
+           self.denominator = None
+           self.numerator = None
+
+
+    class inexact(number): pass
+
+
+    class str_(str, character):
+        def maketrans(self, x, y=None, z=None): pass
+
+    
+    class bytes_(bytes, character):
+        def fromhex(self, string): pass
+        def maketrans(self, frm, to): pass
+
+
+    class signedinteger(integer): pass
+
+
+    class unsignedinteger(integer): pass
+
+
+    class complexfloating(inexact): pass
+
+
+    class floating(inexact): pass
+
+
+    class float64(floating, float):
+        def fromhex(self, string): pass 
+
+        
+    class uint64(unsignedinteger): pass
+    class complex64(complexfloating): pass
+    class int16(signedinteger): pass
+    class float96(floating): pass
+    class int8(signedinteger): pass
+    class uint32(unsignedinteger): pass
+    class uint8(unsignedinteger): pass
+    class _typedict(dict): pass
+    class complex192(complexfloating): pass
+    class timedelta64(signedinteger): pass
+    class int32(signedinteger): pass
+    class uint16(unsignedinteger): pass
+    class float32(floating): pass
+    class complex128(complexfloating, complex): pass
+    class float16(floating): pass
+    class int64(signedinteger): pass
+
+    buffer_type = memoryview
+    bool8 = bool_
+    byte = int8
+    bytes0 = bytes_
+    cdouble = complex128
+    cfloat = complex128
+    clongdouble = complex192
+    clongfloat = complex192
+    complex_ = complex128
+    csingle = complex64
+    double = float64
+    float_ = float64
+    half = float16
+    int0 = int32
+    int_ = int32
+    intc = int32
+    intp = int32
+    long = int32
+    longcomplex = complex192
+    longdouble = float96
+    longfloat = float96
+    longlong = int64
+    object0 = object_
+    object_ = object_
+    short = int16
+    single = float32
+    singlecomplex = complex64
+    str0 = str_
+    string_ = bytes_
+    ubyte = uint8
+    uint = uint32
+    uint0 = uint32
+    uintc = uint32
+    uintp = uint32
+    ulonglong = uint64
+    unicode = str_
+    unicode_ = str_
+    ushort = uint16
+    void0 = void
     ''')
 
 
diff -Nru astroid-1.6.5/astroid/brain/brain_pkg_resources.py astroid-2.0/astroid/brain/brain_pkg_resources.py
--- astroid-1.6.5/astroid/brain/brain_pkg_resources.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/brain/brain_pkg_resources.py	2018-07-15 09:19:27.000000000 +0200
@@ -1,4 +1,5 @@
-# Copyright (c) 2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016, 2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016 Ceridwen <ceridwenv@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -65,6 +66,7 @@
 def get_distribution(dist):
     return Distribution(dist)
 
+_namespace_packages = {}
 ''')
 
 register_module_extender(MANAGER, 'pkg_resources', pkg_resources_transform)
diff -Nru astroid-1.6.5/astroid/brain/brain_pytest.py astroid-2.0/astroid/brain/brain_pytest.py
--- astroid-1.6.5/astroid/brain/brain_pytest.py	2018-05-13 12:38:38.000000000 +0200
+++ astroid-2.0/astroid/brain/brain_pytest.py	2018-07-15 09:19:27.000000000 +0200
@@ -1,5 +1,8 @@
 # Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
-# Copyright (c) 2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2014 Jeff Quast <contact@jeffquast.com>
+# Copyright (c) 2014 Google, Inc.
+# Copyright (c) 2016 Florian Bruhin <me@the-compiler.org>
+# Copyright (c) 2016 Ceridwen <ceridwenv@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
diff -Nru astroid-1.6.5/astroid/brain/brain_qt.py astroid-2.0/astroid/brain/brain_qt.py
--- astroid-1.6.5/astroid/brain/brain_qt.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/brain/brain_qt.py	2018-07-15 09:19:27.000000000 +0200
@@ -1,4 +1,7 @@
 # Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2017 Roy Wright <roy@wright.org>
+# Copyright (c) 2018 Ashley Whetter <ashley@awhetter.co.uk>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -22,7 +25,7 @@
     return False
 
 
-def transform_pyqt_signal(node):    
+def transform_pyqt_signal(node):
     module = parse('''
     class pyqtSignal(object):
         def connect(self, slot, type=None, no_receiver_check=False):
@@ -38,6 +41,22 @@
     node.instance_attrs['connect'] = signal_cls['connect']
 
 
+def transform_pyside_signal(node):
+    module = parse('''
+    class NotPySideSignal(object):
+        def connect(self, receiver, type=None):
+            pass
+        def disconnect(self, receiver):
+            pass
+        def emit(self, *args):
+            pass
+    ''')
+    signal_cls = module['NotPySideSignal']
+    node.instance_attrs['connect'] = signal_cls['connect']
+    node.instance_attrs['disconnect'] = signal_cls['disconnect']
+    node.instance_attrs['emit'] = signal_cls['emit']
+
+
 def pyqt4_qtcore_transform():
     return AstroidBuilder(MANAGER).string_build('''
 
@@ -50,4 +69,6 @@
 
 register_module_extender(MANAGER, 'PyQt4.QtCore', pyqt4_qtcore_transform)
 MANAGER.register_transform(nodes.FunctionDef, transform_pyqt_signal,
-                           _looks_like_signal)
\ Pas de fin de ligne à la fin du fichier
+                           _looks_like_signal)
+MANAGER.register_transform(nodes.ClassDef, transform_pyside_signal,
+                           lambda node: node.qname() == 'PySide.QtCore.Signal')
diff -Nru astroid-1.6.5/astroid/brain/brain_random.py astroid-2.0/astroid/brain/brain_random.py
--- astroid-1.6.5/astroid/brain/brain_random.py	1970-01-01 01:00:00.000000000 +0100
+++ astroid-2.0/astroid/brain/brain_random.py	2018-07-15 09:19:27.000000000 +0200
@@ -0,0 +1,97 @@
+# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
+# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
+import random
+
+import astroid
+from astroid import helpers
+from astroid import MANAGER
+
+
+ACCEPTED_ITERABLES_FOR_SAMPLE = (
+    astroid.List,
+    astroid.Set,
+    astroid.Tuple,
+)
+
+
+def _clone_node_with_lineno(node, parent, lineno):
+    cls = node.__class__
+    other_fields = node._other_fields
+    _astroid_fields = node._astroid_fields
+    init_params = {
+        'lineno': lineno,
+        'col_offset': node.col_offset,
+        'parent': parent
+    }
+    postinit_params = {
+        param: getattr(node, param)
+        for param in _astroid_fields
+    }
+    if other_fields:
+        init_params.update({
+            param: getattr(node, param)
+            for param in other_fields
+        })
+    new_node = cls(**init_params)
+    if hasattr(node, 'postinit') and _astroid_fields:
+        new_node.postinit(**postinit_params)
+    return new_node
+
+
+def infer_random_sample(node, context=None):
+    if len(node.args) != 2:
+        raise astroid.UseInferenceDefault
+
+    length = node.args[1]
+    if not isinstance(length, astroid.Const):
+        raise astroid.UseInferenceDefault
+    if not isinstance(length.value, int):
+        raise astroid.UseInferenceDefault
+
+    inferred_sequence = helpers.safe_infer(node.args[0], context=context)
+    if inferred_sequence in (None, astroid.Uninferable):
+        raise astroid.UseInferenceDefault
+
+    if not isinstance(inferred_sequence, ACCEPTED_ITERABLES_FOR_SAMPLE):
+        raise astroid.UseInferenceDefault
+
+    if length.value > len(inferred_sequence.elts):
+        # In this case, this will raise a ValueError
+        raise astroid.UseInferenceDefault
+
+    try:
+        elts = random.sample(inferred_sequence.elts, length.value)
+    except ValueError:
+        raise astroid.UseInferenceDefault
+
+    new_node = astroid.List(
+        lineno=node.lineno,
+        col_offset=node.col_offset,
+        parent=node.scope(),
+    )
+    new_elts = [
+        _clone_node_with_lineno(
+            elt,
+            parent=new_node,
+            lineno=new_node.lineno
+        )
+        for elt in elts
+    ]
+    new_node.postinit(new_elts)
+    return iter((new_node, ))
+
+
+def _looks_like_random_sample(node):
+    func = node.func
+    if isinstance(func, astroid.Attribute):
+        return func.attrname == 'sample'
+    if isinstance(func, astroid.Name):
+        return func.name == 'sample'
+    return False
+
+
+MANAGER.register_transform(
+    astroid.Call,
+    astroid.inference_tip(infer_random_sample),
+    _looks_like_random_sample,
+)
diff -Nru astroid-1.6.5/astroid/brain/brain_six.py astroid-2.0/astroid/brain/brain_six.py
--- astroid-1.6.5/astroid/brain/brain_six.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/brain/brain_six.py	2018-07-15 09:19:27.000000000 +0200
@@ -1,4 +1,6 @@
-# Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2014-2016, 2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -6,7 +8,6 @@
 
 """Astroid hooks for six module."""
 
-import sys
 from textwrap import dedent
 
 from astroid import MANAGER, register_module_extender
@@ -35,202 +36,69 @@
     return ''.join(prefixed_lines())
 
 
-if sys.version_info[0] == 2:
-    _IMPORTS_2 = """
-    import BaseHTTPServer
-    import CGIHTTPServer
-    import SimpleHTTPServer
-
-    from StringIO import StringIO
-    from cStringIO import StringIO as cStringIO
-    from UserDict import UserDict
-    from UserList import UserList
-    from UserString import UserString
-
-    import __builtin__ as builtins
-    import thread as _thread
-    import dummy_thread as _dummy_thread
-    import ConfigParser as configparser
-    import copy_reg as copyreg
-    from itertools import (imap as map,
-                           ifilter as filter,
-                           ifilterfalse as filterfalse,
-                           izip_longest as zip_longest,
-                           izip as zip)
-    import htmlentitydefs as html_entities
-    import HTMLParser as html_parser
-    import httplib as http_client
-    import cookielib as http_cookiejar
-    import Cookie as http_cookies
-    import Queue as queue
-    import repr as reprlib
-    from pipes import quote as shlex_quote
-    import SocketServer as socketserver
-    import SimpleXMLRPCServer as xmlrpc_server
-    import xmlrpclib as xmlrpc_client
-    import _winreg as winreg
-    import robotparser as urllib_robotparser
-    import Tkinter as tkinter
-    import tkFileDialog as tkinter_tkfiledialog
-
-    input = raw_input
-    intern = intern
-    range = xrange
-    xrange = xrange
-    reduce = reduce
-    reload_module = reload
-
-    class UrllibParse(object):
-        def __init__(self):
-            import urlparse as _urlparse
-            import urllib as _urllib
-
-            self.ParseResult = _urlparse.ParseResult
-            self.SplitResult = _urlparse.SplitResult
-            self.parse_qs = _urlparse.parse_qs
-            self.parse_qsl = _urlparse.parse_qsl
-            self.urldefrag = _urlparse.urldefrag
-            self.urljoin = _urlparse.urljoin
-            self.urlparse = _urlparse.urlparse
-            self.urlsplit = _urlparse.urlsplit
-            self.urlunparse = _urlparse.urlunparse
-            self.urlunsplit = _urlparse.urlunsplit
-            self.quote = _urllib.quote
-            self.quote_plus = _urllib.quote_plus
-            self.unquote = _urllib.unquote
-            self.unquote_plus = _urllib.unquote_plus
-            self.urlencode = _urllib.urlencode
-            self.splitquery = _urllib.splitquery
-            self.splittag = _urllib.splittag
-            self.splituser = _urllib.splituser
-            self.uses_fragment = _urlparse.uses_fragment
-            self.uses_netloc = _urlparse.uses_netloc
-            self.uses_params = _urlparse.uses_params
-            self.uses_query = _urlparse.uses_query
-            self.uses_relative = _urlparse.uses_relative
-
-    class UrllibError(object):
-        import urllib2 as _urllib2
-        import urllib as _urllib
-        URLError = _urllib2.URLError
-        HTTPError = _urllib2.HTTPError
-        ContentTooShortError = _urllib.ContentTooShortError
-
-    class DummyModule(object):
-        pass
-
-    class UrllibRequest(object):
-        def __init__(self):
-            import urlparse as _urlparse
-            import urllib2 as _urllib2
-            import urllib as _urllib
-            self.urlopen = _urllib2.urlopen
-            self.install_opener = _urllib2.install_opener
-            self.build_opener = _urllib2.build_opener
-            self.pathname2url = _urllib.pathname2url
-            self.url2pathname = _urllib.url2pathname
-            self.getproxies = _urllib.getproxies
-            self.Request = _urllib2.Request
-            self.OpenerDirector = _urllib2.OpenerDirector
-            self.HTTPDefaultErrorHandler = _urllib2.HTTPDefaultErrorHandler
-            self.HTTPRedirectHandler = _urllib2.HTTPRedirectHandler
-            self.HTTPCookieProcessor = _urllib2.HTTPCookieProcessor
-            self.ProxyHandler = _urllib2.ProxyHandler
-            self.BaseHandler = _urllib2.BaseHandler
-            self.HTTPPasswordMgr = _urllib2.HTTPPasswordMgr
-            self.HTTPPasswordMgrWithDefaultRealm = _urllib2.HTTPPasswordMgrWithDefaultRealm
-            self.AbstractBasicAuthHandler = _urllib2.AbstractBasicAuthHandler
-            self.HTTPBasicAuthHandler = _urllib2.HTTPBasicAuthHandler
-            self.ProxyBasicAuthHandler = _urllib2.ProxyBasicAuthHandler
-            self.AbstractDigestAuthHandler = _urllib2.AbstractDigestAuthHandler
-            self.HTTPDigestAuthHandler = _urllib2.HTTPDigestAuthHandler
-            self.ProxyDigestAuthHandler = _urllib2.ProxyDigestAuthHandler
-            self.HTTPHandler = _urllib2.HTTPHandler
-            self.HTTPSHandler = _urllib2.HTTPSHandler
-            self.FileHandler = _urllib2.FileHandler
-            self.FTPHandler = _urllib2.FTPHandler
-            self.CacheFTPHandler = _urllib2.CacheFTPHandler
-            self.UnknownHandler = _urllib2.UnknownHandler
-            self.HTTPErrorProcessor = _urllib2.HTTPErrorProcessor
-            self.urlretrieve = _urllib.urlretrieve
-            self.urlcleanup = _urllib.urlcleanup
-            self.proxy_bypass = _urllib.proxy_bypass
-
-    urllib_parse = UrllibParse()
-    urllib_error = UrllibError()
-    urllib = DummyModule()
-    urllib.request = UrllibRequest()
-    urllib.parse = UrllibParse()
-    urllib.error = UrllibError()
-    """
-else:
-    _IMPORTS_3 = """
-    import _io
-    cStringIO = _io.StringIO
-    filter = filter
-    from itertools import filterfalse
-    input = input
-    from sys import intern
-    map = map
-    range = range
-    from imp import reload as reload_module
-    from functools import reduce
-    from shlex import quote as shlex_quote
-    from io import StringIO
-    from collections import UserDict, UserList, UserString
-    xrange = range
-    zip = zip
-    from itertools import zip_longest
-    import builtins
-    import configparser
-    import copyreg
-    import _dummy_thread
-    import http.cookiejar as http_cookiejar
-    import http.cookies as http_cookies
-    import html.entities as html_entities
-    import html.parser as html_parser
-    import http.client as http_client
-    import http.server as http_server
-    BaseHTTPServer = CGIHTTPServer = SimpleHTTPServer = http.server
-    import pickle as cPickle
-    import queue
-    import reprlib
-    import socketserver
-    import _thread
-    import winreg
-    import xmlrpc.server as xmlrpc_server
-    import xmlrpc.client as xmlrpc_client
-    import urllib.robotparser as urllib_robotparser
-    import email.mime.multipart as email_mime_multipart
-    import email.mime.nonmultipart as email_mime_nonmultipart
-    import email.mime.text as email_mime_text
-    import email.mime.base as email_mime_base
-    import urllib.parse as urllib_parse
-    import urllib.error as urllib_error
-    import tkinter
-    import tkinter.dialog as tkinter_dialog
-    import tkinter.filedialog as tkinter_filedialog
-    import tkinter.scrolledtext as tkinter_scrolledtext
-    import tkinter.simpledialog as tkinder_simpledialog
-    import tkinter.tix as tkinter_tix
-    import tkinter.ttk as tkinter_ttk
-    import tkinter.constants as tkinter_constants
-    import tkinter.dnd as tkinter_dnd
-    import tkinter.colorchooser as tkinter_colorchooser
-    import tkinter.commondialog as tkinter_commondialog
-    import tkinter.filedialog as tkinter_tkfiledialog
-    import tkinter.font as tkinter_font
-    import tkinter.messagebox as tkinter_messagebox
-    import urllib
-    import urllib.request as urllib_request
-    import urllib.robotparser as urllib_robotparser
-    import urllib.parse as urllib_parse
-    import urllib.error as urllib_error
-    """
-if sys.version_info[0] == 2:
-    _IMPORTS = dedent(_IMPORTS_2)
-else:
-    _IMPORTS = dedent(_IMPORTS_3)
+_IMPORTS = """
+import _io
+cStringIO = _io.StringIO
+filter = filter
+from itertools import filterfalse
+input = input
+from sys import intern
+map = map
+range = range
+from imp import reload as reload_module
+from functools import reduce
+from shlex import quote as shlex_quote
+from io import StringIO
+from collections import UserDict, UserList, UserString
+xrange = range
+zip = zip
+from itertools import zip_longest
+import builtins
+import configparser
+import copyreg
+import _dummy_thread
+import http.cookiejar as http_cookiejar
+import http.cookies as http_cookies
+import html.entities as html_entities
+import html.parser as html_parser
+import http.client as http_client
+import http.server as http_server
+BaseHTTPServer = CGIHTTPServer = SimpleHTTPServer = http.server
+import pickle as cPickle
+import queue
+import reprlib
+import socketserver
+import _thread
+import winreg
+import xmlrpc.server as xmlrpc_server
+import xmlrpc.client as xmlrpc_client
+import urllib.robotparser as urllib_robotparser
+import email.mime.multipart as email_mime_multipart
+import email.mime.nonmultipart as email_mime_nonmultipart
+import email.mime.text as email_mime_text
+import email.mime.base as email_mime_base
+import urllib.parse as urllib_parse
+import urllib.error as urllib_error
+import tkinter
+import tkinter.dialog as tkinter_dialog
+import tkinter.filedialog as tkinter_filedialog
+import tkinter.scrolledtext as tkinter_scrolledtext
+import tkinter.simpledialog as tkinder_simpledialog
+import tkinter.tix as tkinter_tix
+import tkinter.ttk as tkinter_ttk
+import tkinter.constants as tkinter_constants
+import tkinter.dnd as tkinter_dnd
+import tkinter.colorchooser as tkinter_colorchooser
+import tkinter.commondialog as tkinter_commondialog
+import tkinter.filedialog as tkinter_tkfiledialog
+import tkinter.font as tkinter_font
+import tkinter.messagebox as tkinter_messagebox
+import urllib
+import urllib.request as urllib_request
+import urllib.robotparser as urllib_robotparser
+import urllib.parse as urllib_parse
+import urllib.error as urllib_error
+"""
 
 
 def six_moves_transform():
@@ -248,7 +116,7 @@
     """Fix six.moves imports due to the dynamic nature of this
     class.
 
-    Construct a psuedo-module which contains all the nessecary imports
+    Construct a pseudo-module which contains all the necessary imports
     for six
 
     :param modname: Name of failed module
@@ -279,6 +147,19 @@
     # This will cause an Uninferable result, which is okay
     return module
 
+
+def _looks_like_decorated_with_six_add_metaclass(node):
+    if not node.decorators:
+        return False
+
+    for decorator in node.decorators.nodes:
+        if not isinstance(decorator, nodes.Call):
+            continue
+        if decorator.func.as_string() == SIX_ADD_METACLASS:
+            return True
+    return False
+
+
 def transform_six_add_metaclass(node):
     """Check if the given class node is decorated with *six.add_metaclass*
 
@@ -305,4 +186,8 @@
 register_module_extender(MANAGER, 'requests.packages.urllib3.packages.six',
                          six_moves_transform)
 MANAGER.register_failed_import_hook(_six_fail_hook)
-MANAGER.register_transform(nodes.ClassDef, transform_six_add_metaclass)
+MANAGER.register_transform(
+    nodes.ClassDef,
+    transform_six_add_metaclass,
+    _looks_like_decorated_with_six_add_metaclass,
+)
diff -Nru astroid-1.6.5/astroid/brain/brain_ssl.py astroid-2.0/astroid/brain/brain_ssl.py
--- astroid-1.6.5/astroid/brain/brain_ssl.py	2018-01-07 11:53:49.000000000 +0100
+++ astroid-2.0/astroid/brain/brain_ssl.py	2018-07-15 09:19:27.000000000 +0200
@@ -1,4 +1,5 @@
 # Copyright (c) 2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016 Ceridwen <ceridwenv@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
diff -Nru astroid-1.6.5/astroid/brain/brain_subprocess.py astroid-2.0/astroid/brain/brain_subprocess.py
--- astroid-1.6.5/astroid/brain/brain_subprocess.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/brain/brain_subprocess.py	2018-07-15 09:19:27.000000000 +0200
@@ -1,4 +1,6 @@
-# Copyright (c) 2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016-2017 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2017 Hugo <hugovk@users.noreply.github.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -13,6 +15,7 @@
 
 PY34 = sys.version_info >= (3, 4)
 PY36 = sys.version_info >= (3, 6)
+PY33 = sys.version_info >= (3, 3)
 
 
 def _subprocess_transform():
@@ -62,10 +65,14 @@
         '''
     else:
         ctx_manager = ''
+    py3_args = ""
+    if PY33:
+        py3_args = "args = []"
     code = textwrap.dedent('''
     class Popen(object):
         returncode = pid = 0
         stdin = stdout = stderr = file()
+        %(py3_args)s
 
         %(communicate_signature)s:
             return %(communicate)r
@@ -83,7 +90,9 @@
        ''' % {'communicate': communicate,
               'communicate_signature': communicate_signature,
               'wait_signature': wait_signature,
-              'ctx_manager': ctx_manager})
+              'ctx_manager': ctx_manager,
+              'py3_args': py3_args,
+              })
 
     init_lines = textwrap.dedent(init).splitlines()
     indented_init = '\n'.join([' ' * 4 + line for line in init_lines])
diff -Nru astroid-1.6.5/astroid/brain/brain_threading.py astroid-2.0/astroid/brain/brain_threading.py
--- astroid-1.6.5/astroid/brain/brain_threading.py	2018-05-13 12:38:38.000000000 +0200
+++ astroid-2.0/astroid/brain/brain_threading.py	2018-07-15 09:19:27.000000000 +0200
@@ -1,4 +1,6 @@
+# -*- coding: utf-8 -*-
 # Copyright (c) 2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
diff -Nru astroid-1.6.5/astroid/brain/brain_typing.py astroid-2.0/astroid/brain/brain_typing.py
--- astroid-1.6.5/astroid/brain/brain_typing.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/brain/brain_typing.py	2018-07-15 09:19:28.000000000 +0200
@@ -1,97 +1,97 @@
-# Copyright (c) 2016 David Euresti <david@dropbox.com>
+# -*- coding: utf-8 -*-
+# Copyright (c) 2017-2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
+# Copyright (c) 2017 David Euresti <github@euresti.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
 
 """Astroid hooks for typing.py support."""
-import textwrap
+import typing
 
 from astroid import (
-    MANAGER, UseInferenceDefault, extract_node, inference_tip,
-    nodes, InferenceError)
-from astroid.nodes import List, Tuple
+    MANAGER,
+    UseInferenceDefault,
+    extract_node,
+    inference_tip,
+    nodes,
+    InferenceError,
+)
 
 
 TYPING_NAMEDTUPLE_BASENAMES = {
     'NamedTuple',
     'typing.NamedTuple'
 }
+TYPING_TYPEVARS = {'TypeVar', 'NewType'}
+TYPING_TYPEVARS_QUALIFIED = {'typing.TypeVar', 'typing.NewType'}
+TYPING_TYPE_TEMPLATE = """
+class Meta(type):
+    def __getitem__(self, item):
+        return self
+
+class {0}(metaclass=Meta):
+    pass
+"""
+TYPING_MEMBERS = set(typing.__all__)
 
 
-def infer_typing_namedtuple(node, context=None):
-    """Infer a typing.NamedTuple(...) call."""
-    # This is essentially a namedtuple with different arguments
-    # so we extract the args and infer a named tuple.
-    try:
-        func = next(node.func.infer())
-    except InferenceError:
-        raise UseInferenceDefault
+def looks_like_typing_typevar_or_newtype(node):
+    func = node.func
+    if isinstance(func, nodes.Attribute):
+        return func.attrname in TYPING_TYPEVARS
+    if isinstance(func, nodes.Name):
+        return func.name in TYPING_TYPEVARS
+    return False
 
-    if func.qname() != 'typing.NamedTuple':
-        raise UseInferenceDefault
 
-    if len(node.args) != 2:
-        raise UseInferenceDefault
+def infer_typing_typevar_or_newtype(node, context=None):
+    """Infer a typing.TypeVar(...) or typing.NewType(...) call"""
+    try:
+        func = next(node.func.infer(context=context))
+    except InferenceError as exc:
+        raise UseInferenceDefault from exc
 
-    if not isinstance(node.args[1], (List, Tuple)):
+    if func.qname() not in TYPING_TYPEVARS_QUALIFIED:
+        raise UseInferenceDefault
+    if not node.args:
         raise UseInferenceDefault
 
-    names = []
-    for elt in node.args[1].elts:
-        if not isinstance(elt, (List, Tuple)):
-            raise UseInferenceDefault
-        if len(elt.elts) != 2:
-            raise UseInferenceDefault
-        names.append(elt.elts[0].as_string())
-
-    typename = node.args[0].as_string()
-    node = extract_node('namedtuple(%(typename)s, (%(fields)s,)) ' %
-        {'typename': typename, 'fields': ",".join(names)})
+    typename = node.args[0].as_string().strip("'")
+    node = extract_node(TYPING_TYPE_TEMPLATE.format(typename))
     return node.infer(context=context)
 
 
-def infer_typing_namedtuple_class(node, context=None):
-    """Infer a subclass of typing.NamedTuple"""
-
-    # Check if it has the corresponding bases
-    annassigns_fields = [
-        annassign.target.name for annassign in node.body
-        if isinstance(annassign, nodes.AnnAssign)
-    ]
-    code = textwrap.dedent('''
-    from collections import namedtuple
-    namedtuple({typename!r}, {fields!r})
-    ''').format(
-        typename=node.name,
-        fields=",".join(annassigns_fields)
-    )
-    node = extract_node(code)
-    return node.infer(context=context)
-
+def _looks_like_typing_subscript(node):
+    """Try to figure out if a Subscript node *might* be a typing-related subscript"""
+    if isinstance(node, nodes.Name):
+        return node.name in TYPING_MEMBERS
+    elif isinstance(node, nodes.Attribute):
+        return node.attrname in TYPING_MEMBERS
+    elif isinstance(node, nodes.Subscript):
+        return _looks_like_typing_subscript(node.value)
+    return False
 
-def has_namedtuple_base(node):
-    """Predicate for class inference tip
 
-    :type node: ClassDef
-    :rtype: bool
-    """
-    return set(node.basenames) & TYPING_NAMEDTUPLE_BASENAMES
+def infer_typing_attr(node, context=None):
+    """Infer a typing.X[...] subscript"""
+    try:
+        value = next(node.value.infer())
+    except InferenceError as exc:
+        raise UseInferenceDefault from exc
 
+    if not value.qname().startswith('typing.'):
+        raise UseInferenceDefault
 
-def looks_like_typing_namedtuple(node):
-    func = node.func
-    if isinstance(func, nodes.Attribute):
-        return func.attrname == 'NamedTuple'
-    if isinstance(func, nodes.Name):
-        return func.name == 'NamedTuple'
-    return False
+    node = extract_node(TYPING_TYPE_TEMPLATE.format(value.qname().split('.')[-1]))
+    return node.infer(context=context)
 
 
 MANAGER.register_transform(
     nodes.Call,
-    inference_tip(infer_typing_namedtuple),
-    looks_like_typing_namedtuple
+    inference_tip(infer_typing_typevar_or_newtype),
+    looks_like_typing_typevar_or_newtype
 )
-
 MANAGER.register_transform(
-    nodes.ClassDef,
-    inference_tip(infer_typing_namedtuple_class),
-    has_namedtuple_base
+    nodes.Subscript,
+    inference_tip(infer_typing_attr),
+    _looks_like_typing_subscript,
 )
diff -Nru astroid-1.6.5/astroid/builder.py astroid-2.0/astroid/builder.py
--- astroid-1.6.5/astroid/builder.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/builder.py	2018-07-15 09:19:23.000000000 +0200
@@ -1,7 +1,13 @@
+# -*- coding: utf-8 -*-
 # Copyright (c) 2006-2011, 2013-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
+# Copyright (c) 2013 Phil Schaf <flying-sheep@web.de>
+# Copyright (c) 2014-2018 Claudiu Popa <pcmanticore@gmail.com>
 # Copyright (c) 2014-2015 Google, Inc.
-# Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2014 Alexander Presnyakov <flagist0@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2016 Derek Gustafson <degustaf@gmail.com>
+# Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
+# Copyright (c) 2018 Anthony Sottile <asottile@umich.edu>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -12,12 +18,11 @@
 at the same time.
 """
 
-import re
 import os
-import sys
 import textwrap
-import _ast
+from tokenize import detect_encoding
 
+from astroid._ast import _parse
 from astroid import bases
 from astroid import exceptions
 from astroid import manager
@@ -36,45 +41,15 @@
 # when calling extract_node.
 _STATEMENT_SELECTOR = '#@'
 
-
-def _parse(string):
-    return compile(string, "<string>", 'exec', _ast.PyCF_ONLY_AST)
-
-
-if sys.version_info >= (3, 0):
-    from tokenize import detect_encoding
-
-    def open_source_file(filename):
-        with open(filename, 'rb') as byte_stream:
-            encoding = detect_encoding(byte_stream.readline)[0]
-        stream = open(filename, 'r', newline=None, encoding=encoding)
-        data = stream.read()
-        return stream, encoding, data
-
-else:
-    _ENCODING_RGX = re.compile(r"\s*#+.*coding[:=]\s*([-\w.]+)")
-
-    def _guess_encoding(string):
-        """get encoding from a python file as string or return None if not found"""
-        # check for UTF-8 byte-order mark
-        if string.startswith('\xef\xbb\xbf'):
-            return 'UTF-8'
-        for line in string.split('\n', 2)[:2]:
-            # check for encoding declaration
-            match = _ENCODING_RGX.match(line)
-            if match is not None:
-                return match.group(1)
-        return None
-
-    def open_source_file(filename):
-        """get data for parsing a file"""
-        stream = open(filename, 'U')
-        data = stream.read()
-        encoding = _guess_encoding(data)
-        return stream, encoding, data
+MANAGER = manager.AstroidManager()
 
 
-MANAGER = manager.AstroidManager()
+def open_source_file(filename):
+    with open(filename, 'rb') as byte_stream:
+        encoding = detect_encoding(byte_stream.readline)[0]
+    stream = open(filename, 'r', newline=None, encoding=encoding)
+    data = stream.read()
+    return stream, encoding, data
 
 
 def _can_assign_attr(node, attrname):
@@ -83,7 +58,7 @@
     except NotImplementedError:
         pass
     else:
-        if slots and attrname not in set(slot.value for slot in slots):
+        if slots and attrname not in {slot.value for slot in slots}:
             return False
     return True
 
@@ -129,18 +104,18 @@
         try:
             stream, encoding, data = open_source_file(path)
         except IOError as exc:
-            util.reraise(exceptions.AstroidBuildingError(
+            raise exceptions.AstroidBuildingError(
                 'Unable to load file {path}:\n{error}',
-                modname=modname, path=path, error=exc))
+                modname=modname, path=path, error=exc) from exc
         except (SyntaxError, LookupError) as exc:
-            util.reraise(exceptions.AstroidSyntaxError(
+            raise exceptions.AstroidSyntaxError(
                 'Python 3 encoding specification error or unknown encoding:\n'
-                '{error}', modname=modname, path=path, error=exc))
-        except UnicodeError:  # wrong encoding
+                '{error}', modname=modname, path=path, error=exc) from exc
+        except UnicodeError as exc:  # wrong encoding
             # detect_encoding returns utf-8 if no encoding specified
-            util.reraise(exceptions.AstroidBuildingError(
+            raise exceptions.AstroidBuildingError(
                 'Wrong or no encoding specified for {filename}.',
-                filename=path))
+                filename=path) from exc
         with stream:
             # get module name if necessary
             if modname is None:
@@ -182,9 +157,9 @@
         try:
             node = _parse(data + '\n')
         except (TypeError, ValueError, SyntaxError) as exc:
-            util.reraise(exceptions.AstroidSyntaxError(
+            raise exceptions.AstroidSyntaxError(
                 'Parsing Python code failed:\n{error}',
-                source=data, modname=modname, path=path, error=exc))
+                source=data, modname=modname, path=path, error=exc) from exc
         if path is not None:
             node_file = os.path.abspath(path)
         else:
@@ -316,8 +291,7 @@
         yield real_expr
     else:
         for child in node.get_children():
-            for result in _extract_expressions(child):
-                yield result
+            yield from _extract_expressions(child)
 
 
 def _find_statement_by_line(node, line):
@@ -421,10 +395,12 @@
             requested_lines.append(idx + 1)
 
     tree = parse(code, module_name=module_name)
+    if not tree.body:
+        raise ValueError('Empty tree, cannot extract from it')
+
     extracted = []
     if requested_lines:
-        for line in requested_lines:
-            extracted.append(_find_statement_by_line(tree, line))
+        extracted = [_find_statement_by_line(tree, line) for line in requested_lines]
 
     # Modifies the tree.
     extracted.extend(_extract_expressions(tree))
diff -Nru astroid-1.6.5/astroid/context.py astroid-2.0/astroid/context.py
--- astroid-1.6.5/astroid/context.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/context.py	2018-07-15 09:19:22.000000000 +0200
@@ -1,5 +1,7 @@
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
-# Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016, 2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
+# Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -11,30 +13,63 @@
 import pprint
 
 
-class InferenceContext(object):
+class InferenceContext:
     """Provide context for inference
 
     Store already inferred nodes to save time
     Account for already visited nodes to infinite stop infinite recursion
     """
 
-    __slots__ = ('path', 'lookupname', 'callcontext', 'boundnode', 'inferred')
+    __slots__ = ('path', 'lookupname', 'callcontext', 'boundnode', 'inferred', 'extra_context')
 
     def __init__(self, path=None, inferred=None):
         self.path = path or set()
-        """Path of visited nodes and their lookupname
-        :type: set(tuple(NodeNG, optional(str)))"""
+        """
+        :type: set(tuple(NodeNG, optional(str)))
+
+        Path of visited nodes and their lookupname
+
+        Currently this key is ``(node, context.lookupname)``
+        """
         self.lookupname = None
+        """
+        :type: optional[str]
+
+        The original name of the node
+
+        e.g.
+        foo = 1
+        The inference of 'foo' is nodes.Const(1) but the lookup name is 'foo'
+        """
         self.callcontext = None
+        """
+        :type: optional[CallContext]
+
+        The call arguments and keywords for the given context
+        """
         self.boundnode = None
+        """
+        :type: optional[NodeNG]
+
+        The bound node of the given context
+
+        e.g. the bound node of object.__new__(cls) is the object node
+        """
         self.inferred = inferred or {}
         """
         :type: dict(seq, seq)
 
         Inferred node contexts to their mapped results
-        Currently the key is (node, lookupname, callcontext, boundnode)
+        Currently the key is ``(node, lookupname, callcontext, boundnode)``
         and the value is tuple of the inferred results
         """
+        self.extra_context = {}
+        """
+        :type: dict(NodeNG, Context)
+
+        Context that needs to be passed down through call stacks
+        for call arguments
+        """
 
     def push(self, node):
         """Push node into inference path
@@ -61,6 +96,7 @@
         clone = InferenceContext(copy.copy(self.path), inferred=self.inferred)
         clone.callcontext = self.callcontext
         clone.boundnode = self.boundnode
+        clone.extra_context = self.extra_context
         return clone
 
     def cache_generator(self, key, generator):
@@ -87,12 +123,16 @@
         return '%s(%s)' % (type(self).__name__, ',\n    '.join(state))
 
 
-class CallContext(object):
+class CallContext:
     """Holds information for a call site."""
 
     __slots__ = ('args', 'keywords')
 
     def __init__(self, args, keywords=None):
+        """
+        :param List[NodeNG] args: Call positional arguments
+        :param Union[List[nodes.Keyword], None] keywords: Call keywords
+        """
         self.args = args
         if keywords:
             keywords = [(arg.arg, arg.value) for arg in keywords]
@@ -106,3 +146,28 @@
         return context.clone()
 
     return InferenceContext()
+
+
+def bind_context_to_node(context, node):
+    """Give a context a boundnode
+    to retrieve the correct function name or attribute value
+    with from further inference.
+
+    Do not use an existing context since the boundnode could then
+    be incorrectly propagated higher up in the call stack.
+
+    :param context: Context to use
+    :type context: Optional(context)
+
+    :param node: Node to do name lookups from
+    :type node NodeNG:
+
+    :returns: A new context
+    :rtype: InferenceContext
+    """
+    if context is not None:
+        context = context.clone()
+    else:
+        context = InferenceContext()
+    context.boundnode = node
+    return context
diff -Nru astroid-1.6.5/astroid/decorators.py astroid-2.0/astroid/decorators.py
--- astroid-1.6.5/astroid/decorators.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/decorators.py	2018-07-15 09:19:22.000000000 +0200
@@ -1,6 +1,11 @@
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2015-2016, 2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
 # Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>
-# Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016 Derek Gustafson <degustaf@gmail.com>
+# Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>
+# Copyright (c) 2018 Ashley Whetter <ashley@awhetter.co.uk>
+# Copyright (c) 2018 HoverHell <hoverhell@gmail.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -29,7 +34,7 @@
         return result
 
 
-class cachedproperty(object):
+class cachedproperty:
     """ Provides a cached property equivalent to the stacking of
     @cached and @property, but more efficient.
 
@@ -48,9 +53,8 @@
     def __init__(self, wrapped):
         try:
             wrapped.__name__
-        except AttributeError:
-            util.reraise(TypeError('%s must have a __name__ attribute'
-                                   % wrapped))
+        except AttributeError as exc:
+            raise TypeError('%s must have a __name__ attribute' % wrapped) from exc
         self.wrapped = wrapped
 
     @property
@@ -73,14 +77,13 @@
     Used to stop inference if the node has already been looked
     at for a given `InferenceContext` to prevent infinite recursion
     """
-    # TODO: switch this to wrapt after the monkey-patching is fixed (ceridwen)
     @functools.wraps(func)
     def wrapped(node, context=None, _func=func, **kwargs):
         """wrapper function handling context"""
         if context is None:
             context = contextmod.InferenceContext()
         if context.push(node):
-            return
+            return None
 
         yielded = set()
         generator = _func(node, context, **kwargs)
@@ -99,9 +102,8 @@
             # Explicit StopIteration to return error information, see
             # comment in raise_if_nothing_inferred.
             if error.args:
-                raise StopIteration(error.args[0])
-            else:
-                raise StopIteration
+                return error.args[0]
+            return None
 
     return wrapped
 
@@ -118,23 +120,10 @@
 
 @wrapt.decorator
 def raise_if_nothing_inferred(func, instance, args, kwargs):
-    '''All generators wrapped with raise_if_nothing_inferred *must*
+    """All generators wrapped with raise_if_nothing_inferred *must*
     explicitly raise StopIteration with information to create an
     appropriate structured InferenceError.
-
-    '''
-    # TODO: Explicitly raising StopIteration in a generator will cause
-    # a RuntimeError in Python >=3.7, as per
-    # http://legacy.python.org/dev/peps/pep-0479/ .  Before 3.7 is
-    # released, this code will need to use one of four possible
-    # solutions: a decorator that restores the current behavior as
-    # described in
-    # http://legacy.python.org/dev/peps/pep-0479/#sub-proposal-decorator-to-explicitly-request-current-behaviour
-    # , dynamic imports or exec to generate different code for
-    # different versions, drop support for all Python versions <3.3,
-    # or refactoring to change how these decorators work.  In any
-    # event, after dropping support for Python <3.3 this code should
-    # be refactored to use `yield from`.
+    """
     inferred = False
     try:
         generator = func(*args, **kwargs)
diff -Nru astroid-1.6.5/astroid/exceptions.py astroid-2.0/astroid/exceptions.py
--- astroid-1.6.5/astroid/exceptions.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/exceptions.py	2018-07-15 09:19:22.000000000 +0200
@@ -1,7 +1,9 @@
 # Copyright (c) 2007, 2009-2010, 2013 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
 # Copyright (c) 2014 Google, Inc.
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
-# Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2016 Derek Gustafson <degustaf@gmail.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -121,11 +123,10 @@
 
 
 class SuperError(ResolveError):
-
-    """Error raised when there is a problem with a super call.
+    """Error raised when there is a problem with a *super* call.
 
     Standard attributes:
-        super_: The Super instance that raised the exception.
+        *super_*: The Super instance that raised the exception.
         context: InferenceContext object.
     """
     super_ = None
diff -Nru astroid-1.6.5/astroid/helpers.py astroid-2.0/astroid/helpers.py
--- astroid-1.6.5/astroid/helpers.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/helpers.py	2018-07-15 09:19:22.000000000 +0200
@@ -1,5 +1,6 @@
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
-# Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -9,7 +10,7 @@
 Various helper utilities.
 """
 
-import six
+import builtins as builtins_mod
 
 from astroid import bases
 from astroid import context as contextmod
@@ -21,7 +22,7 @@
 from astroid import util
 
 
-BUILTINS = six.moves.builtins.__name__
+BUILTINS = builtins_mod.__name__
 
 
 def _build_proxy_class(cls_name, builtins):
@@ -37,15 +38,9 @@
         else:
             cls_name = 'function'
     elif isinstance(function, bases.BoundMethod):
-        if six.PY2:
-            cls_name = 'instancemethod'
-        else:
-            cls_name = 'method'
+        cls_name = 'method'
     elif isinstance(function, bases.UnboundMethod):
-        if six.PY2:
-            cls_name = 'instancemethod'
-        else:
-            cls_name = 'function'
+        cls_name = 'function'
     return _build_proxy_class(cls_name, builtins)
 
 
@@ -89,6 +84,62 @@
     return list(types)[0]
 
 
+def _object_type_is_subclass(obj_type, class_or_seq, context=None):
+    if not isinstance(class_or_seq, (tuple, list)):
+        class_seq = (class_or_seq,)
+    else:
+        class_seq = class_or_seq
+
+    if obj_type is util.Uninferable:
+        return util.Uninferable
+
+    # Instances are not types
+    class_seq = [item if not isinstance(item, bases.Instance)
+                 else util.Uninferable for item in class_seq]
+    # strict compatibility with issubclass
+    # issubclass(type, (object, 1)) evaluates to true
+    # issubclass(object, (1, type)) raises TypeError
+    for klass in class_seq:
+        if klass is util.Uninferable:
+            raise exceptions.AstroidTypeError("arg 2 must be a type or tuple of types")
+
+        for obj_subclass in obj_type.mro():
+            if obj_subclass == klass:
+                return True
+    return False
+
+
+def object_isinstance(node, class_or_seq, context=None):
+    """Check if a node 'isinstance' any node in class_or_seq
+
+    :param node: A given node
+    :param class_or_seq: Union[nodes.NodeNG, Sequence[nodes.NodeNG]]
+    :rtype: bool
+
+    :raises AstroidTypeError: if the given ``classes_or_seq`` are not types
+    """
+    obj_type = object_type(node, context)
+    if obj_type is util.Uninferable:
+        return util.Uninferable
+    return _object_type_is_subclass(obj_type, class_or_seq, context=context)
+
+
+def object_issubclass(node, class_or_seq, context=None):
+    """Check if a type is a subclass of any node in class_or_seq
+
+    :param node: A given node
+    :param class_or_seq: Union[Nodes.NodeNG, Sequence[nodes.NodeNG]]
+    :rtype: bool
+
+    :raises AstroidTypeError: if the given ``classes_or_seq`` are not types
+    :raises AstroidError: if the type of the given node cannot be inferred
+        or its type's mro doesn't work
+    """
+    if not isinstance(node, nodes.ClassDef):
+        raise TypeError("{node} needs to be a ClassDef node".format(node=node))
+    return _object_type_is_subclass(node, class_or_seq, context=context)
+
+
 def safe_infer(node, context=None):
     """Return the inferred value for the given node.
 
@@ -172,3 +223,46 @@
     except exceptions.InferenceError:
         pass
     return None
+
+
+def object_len(node, context=None):
+    """Infer length of given node object
+
+    :param Union[nodes.ClassDef, nodes.Instance] node:
+    :param node: Node to infer length of
+
+    :raises AstroidTypeError: If an invalid node is returned
+        from __len__ method or no __len__ method exists
+    :raises InferenceError: If the given node cannot be inferred
+        or if multiple nodes are inferred
+    :rtype int: Integer length of node
+    """
+    from astroid.objects import FrozenSet
+    inferred_node = safe_infer(node, context=context)
+    if inferred_node is None or inferred_node is util.Uninferable:
+        raise exceptions.InferenceError(node=node)
+    if (isinstance(inferred_node, nodes.Const) and
+            isinstance(inferred_node.value, (bytes, str))):
+        return len(inferred_node.value)
+    if isinstance(inferred_node, (nodes.List, nodes.Set, nodes.Tuple, FrozenSet)):
+        return len(inferred_node.elts)
+    if isinstance(inferred_node, nodes.Dict):
+        return len(inferred_node.items)
+    try:
+        node_type = object_type(inferred_node, context=context)
+        len_call = next(node_type.igetattr("__len__", context=context))
+    except exceptions.AttributeInferenceError:
+        raise exceptions.AstroidTypeError(
+            "object of type '{}' has no len()"
+            .format(len_call.pytype()))
+
+    try:
+        result_of_len = next(len_call.infer_call_result(node, context))
+        # Remove StopIteration catch when #507 is fixed
+    except StopIteration:
+        raise exceptions.InferenceError(node=node)
+    if isinstance(result_of_len, nodes.Const) and result_of_len.pytype() == "builtins.int":
+        return result_of_len.value
+    raise exceptions.AstroidTypeError(
+        "'{}' object cannot be interpreted as an integer"
+        .format(result_of_len))
diff -Nru astroid-1.6.5/astroid/inference.py astroid-2.0/astroid/inference.py
--- astroid-1.6.5/astroid/inference.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/inference.py	2018-07-15 09:19:25.000000000 +0200
@@ -1,7 +1,19 @@
+# -*- coding: utf-8 -*-
 # Copyright (c) 2006-2011, 2013-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
+# Copyright (c) 2012 FELD Boris <lothiraldan@gmail.com>
 # Copyright (c) 2013-2014 Google, Inc.
-# Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2014-2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2014 Eevee (Alex Munroe) <amunroe@yelp.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2015 Dmitry Pribysh <dmand@yandex.ru>
+# Copyright (c) 2016 Jakub Wilk <jwilk@jwilk.net>
+# Copyright (c) 2017 Michał Masłowski <m.maslowski@clearcode.cc>
+# Copyright (c) 2017 Calen Pennington <cale@edx.org>
+# Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
+# Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>
+# Copyright (c) 2018 Ashley Whetter <ashley@awhetter.co.uk>
+# Copyright (c) 2018 HoverHell <hoverhell@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -89,6 +101,29 @@
         yield new_seq
 
 
+def _update_with_replacement(lhs_dict, rhs_dict):
+    """Delete nodes that equate to duplicate keys
+
+    Since an astroid node doesn't 'equal' another node with the same value,
+    this function uses the as_string method to make sure duplicate keys
+    don't get through
+
+    Note that both the key and the value are astroid nodes
+
+    Fixes issue with DictUnpack causing duplicte keys
+    in inferred Dict items
+
+    :param dict(nodes.NodeNG, nodes.NodeNG) lhs_dict: Dictionary to 'merge' nodes into
+    :param dict(nodes.NodeNG, nodes.NodeNG) rhs_dict: Dictionary with nodes to pull from
+    :return dict(nodes.NodeNG, nodes.NodeNG): merged dictionary of nodes
+    """
+    combined_dict = itertools.chain(lhs_dict.items(), rhs_dict.items())
+    # Overwrite keys which have the same string values
+    string_map = {key.as_string(): (key, value) for key, value in combined_dict}
+    # Return to dictionary
+    return dict(string_map.values())
+
+
 def _infer_map(node, context):
     """Infer all values based on Dict.items"""
     values = {}
@@ -100,14 +135,15 @@
             if not isinstance(double_starred, nodes.Dict):
                 raise exceptions.InferenceError(node=node,
                                                 context=context)
-            values.update(_infer_map(double_starred, context))
+            unpack_items = _infer_map(double_starred, context)
+            values = _update_with_replacement(values, unpack_items)
         else:
             key = helpers.safe_infer(name, context=context)
             value = helpers.safe_infer(value, context=context)
             if any(elem in (None, util.Uninferable) for elem in (key, value)):
                 raise exceptions.InferenceError(node=node,
                                                 context=context)
-            values[key] = value
+            values = _update_with_replacement(values, {key: value})
     return values
 
 
@@ -139,7 +175,6 @@
     if not stmts:
         # Try to see if the name is enclosed in a nested function
         # and use the higher (first function) scope for searching.
-        # TODO: should this be promoted to other nodes as well?
         parent_function = _higher_function_scope(self.scope())
         if parent_function:
             _, stmts = parent_function.lookup(self.name)
@@ -163,20 +198,26 @@
     callcontext.callcontext = contextmod.CallContext(args=self.args,
                                                      keywords=self.keywords)
     callcontext.boundnode = None
+    extra_context = {}
+    if context is not None:
+        extra_context = _populate_context_lookup(self, context.clone())
+        callcontext.extra_context = extra_context
     for callee in self.func.infer(context):
         if callee is util.Uninferable:
             yield callee
             continue
         try:
             if hasattr(callee, 'infer_call_result'):
-                for inferred in callee.infer_call_result(self, callcontext):
-                    yield inferred
+                yield from callee.infer_call_result(
+                    caller=self,
+                    context=callcontext,
+                )
         except exceptions.InferenceError:
             ## XXX log error ?
             continue
     # Explicit StopIteration to return error information, see comment
     # in raise_if_nothing_inferred.
-    raise StopIteration(dict(node=self, context=context))
+    return dict(node=self, context=context)
 nodes.Call._infer = infer_call
 
 
@@ -193,8 +234,11 @@
         else:
             yield self.do_import_module(name)
     except exceptions.AstroidBuildingError as exc:
-        util.reraise(exceptions.InferenceError(node=self, error=exc,
-                                               context=context))
+        raise exceptions.InferenceError(
+            node=self,
+            context=context,
+        ) from exc
+
 
 nodes.Import._infer = infer_import
 
@@ -218,8 +262,10 @@
     try:
         module = self.do_import_module()
     except exceptions.AstroidBuildingError as exc:
-        util.reraise(exceptions.InferenceError(node=self, error=exc,
-                                               context=context))
+        raise exceptions.InferenceError(
+            node=self,
+            context=context,
+        ) from exc
 
     try:
         context = contextmod.copy_context(context)
@@ -227,8 +273,12 @@
         stmts = module.getattr(name, ignore_locals=module is self.root())
         return bases._infer_stmts(stmts, context)
     except exceptions.AttributeInferenceError as error:
-        util.reraise(exceptions.InferenceError(
-            error.message, target=self, attribute=name, context=context))
+        raise exceptions.InferenceError(
+            error.message,
+            target=self,
+            attribute=name,
+            context=context,
+        ) from error
 nodes.ImportFrom._infer = infer_import_from
 
 
@@ -256,8 +306,7 @@
 
         try:
             context.boundnode = owner
-            for obj in owner.igetattr(self.attrname, context):
-                yield obj
+            yield from owner.igetattr(self.attrname, context)
             context.boundnode = None
         except (exceptions.AttributeInferenceError, exceptions.InferenceError):
             context.boundnode = None
@@ -266,7 +315,7 @@
             context.boundnode = None
     # Explicit StopIteration to return error information, see comment
     # in raise_if_nothing_inferred.
-    raise StopIteration(dict(node=self, context=context))
+    return dict(node=self, context=context)
 nodes.Attribute._infer = decorators.path_wrapper(infer_attribute)
 nodes.AssignAttr.infer_lhs = infer_attribute # # won't work with a path wrapper
 
@@ -279,9 +328,12 @@
         return bases._infer_stmts(self.root().getattr(context.lookupname),
                                   context)
     except exceptions.AttributeInferenceError as error:
-        util.reraise(exceptions.InferenceError(
-            error.message, target=self, attribute=context.lookupname,
-            context=context))
+        raise exceptions.InferenceError(
+            error.message,
+            target=self,
+            attribute=context.lookupname,
+            context=context,
+        ) from error
 nodes.Global._infer = infer_global
 
 
@@ -298,15 +350,21 @@
     handle each supported index type accordingly.
     """
 
-    value = next(self.value.infer(context))
+    try:
+        value = next(self.value.infer(context))
+    except StopIteration:
+        return None
     if value is util.Uninferable:
         yield util.Uninferable
-        return
+        return None
 
-    index = next(self.slice.infer(context))
+    try:
+        index = next(self.slice.infer(context))
+    except StopIteration:
+        return None
     if index is util.Uninferable:
         yield util.Uninferable
-        return
+        return None
 
     # Try to deduce the index value.
     index_value = _SUBSCRIPT_SENTINEL
@@ -328,20 +386,18 @@
             exceptions.AstroidIndexError,
             exceptions.AttributeInferenceError,
             AttributeError) as exc:
-        util.reraise(exceptions.InferenceError(node=self, error=exc,
-                                               context=context))
+        raise exceptions.InferenceError(node=self, context=context) from exc
 
     # Prevent inferring if the inferred subscript
     # is the same as the original subscripted object.
     if self is assigned or assigned is util.Uninferable:
         yield util.Uninferable
-        return
-    for inferred in assigned.infer(context):
-        yield inferred
+        return None
+    yield from assigned.infer(context)
 
     # Explicit StopIteration to return error information, see comment
     # in raise_if_nothing_inferred.
-    raise StopIteration(dict(node=self, context=context))
+    return dict(node=self, context=context)
 
 nodes.Subscript._infer = decorators.path_wrapper(infer_subscript)
 nodes.Subscript.infer_lhs = infer_subscript
@@ -366,7 +422,7 @@
         values = [value.infer(context=context) for value in values]
     except exceptions.InferenceError:
         yield util.Uninferable
-        return
+        return None
 
     for pair in itertools.product(*values):
         if any(item is util.Uninferable for item in pair):
@@ -399,7 +455,7 @@
 
     # Explicit StopIteration to return error information, see comment
     # in raise_if_nothing_inferred.
-    raise StopIteration(dict(node=self, context=context))
+    return dict(node=self, context=context)
 
 nodes.BoolOp._infer = _infer_boolop
 
@@ -475,12 +531,11 @@
 @decorators.path_wrapper
 def infer_unaryop(self, context=None):
     """Infer what an UnaryOp should return when evaluated."""
-    for inferred in _filter_operation_errors(self, _infer_unaryop, context,
-                                             util.BadUnaryOperationMessage):
-        yield inferred
+    yield from _filter_operation_errors(self, _infer_unaryop, context,
+                                        util.BadUnaryOperationMessage)
     # Explicit StopIteration to return error information, see comment
     # in raise_if_nothing_inferred.
-    raise StopIteration(dict(node=self, context=context))
+    return dict(node=self, context=context)
 
 nodes.UnaryOp._infer_unaryop = _infer_unaryop
 nodes.UnaryOp._infer = infer_unaryop
@@ -494,6 +549,7 @@
 def _invoke_binop_inference(instance, opnode, op, other, context, method_name):
     """Invoke binary operation inference on the given instance."""
     methods = dunder_lookup.lookup(instance, method_name)
+    context = contextmod.bind_context_to_node(context, instance)
     method = methods[0]
     inferred = next(method.infer(context=context))
     if inferred is util.Uninferable:
@@ -641,23 +697,19 @@
                 yield util.Uninferable
                 return
 
-            # TODO(cpopa): since the inference engine might return
-            # more values than are actually possible, we decide
-            # to return util.Uninferable if we have union types.
             if all(map(_is_not_implemented, results)):
                 continue
             not_implemented = sum(1 for result in results
                                   if _is_not_implemented(result))
             if not_implemented and not_implemented != len(results):
-                # Can't decide yet what this is, not yet though.
+                # Can't infer yet what this is.
                 yield util.Uninferable
                 return
 
             for result in results:
                 yield result
             return
-    # TODO(cpopa): yield a BadBinaryOperationMessage here,
-    # since the operation is not supported
+    # The operation doesn't seem to be supported so let the caller know about it
     yield util.BadBinaryOperationMessage(left_type, binary_opnode.op, right_type)
 
 
@@ -687,9 +739,8 @@
                 return
 
             try:
-                for result in _infer_binary_operation(lhs, rhs, self,
-                                                      context, _get_binop_flow):
-                    yield result
+                yield from _infer_binary_operation(
+                    lhs, rhs, self, context, _get_binop_flow)
             except exceptions._NonDeducibleTypeHierarchy:
                 yield util.Uninferable
 
@@ -723,8 +774,7 @@
                 return
 
             try:
-                for result in _infer_binary_operation(lhs, rhs, self, context, _get_aug_flow):
-                    yield result
+                yield from _infer_binary_operation(lhs, rhs, self, context, _get_aug_flow)
             except exceptions._NonDeducibleTypeHierarchy:
                 yield util.Uninferable
 
@@ -771,9 +821,7 @@
         yield util.Uninferable
     else:
         try:
-            for inferred in MANAGER.infer_ast_from_something(self.object,
-                                                             context=context):
-                yield inferred
+            yield from MANAGER.infer_ast_from_something(self.object, context=context)
         except exceptions.AstroidError:
             yield util.Uninferable
 nodes.EmptyNode._infer = infer_empty_node
@@ -787,16 +835,14 @@
 # will be solved.
 def instance_getitem(self, index, context=None):
     # Rewrap index to Const for this case
-    if context:
-        new_context = context.clone()
-    else:
-        context = new_context = contextmod.InferenceContext()
+    new_context = contextmod.bind_context_to_node(context, self)
+    if not context:
+        context = new_context
 
     # Create a new callcontext for providing index as an argument.
     new_context.callcontext = contextmod.CallContext(args=[index])
-    new_context.boundnode = self
 
-    method = next(self.igetattr('__getitem__', context=context))
+    method = next(self.igetattr('__getitem__', context=context), None)
     if not isinstance(method, bases.BoundMethod):
         raise exceptions.InferenceError(
             'Could not find __getitem__ for {node!r}.',
@@ -804,9 +850,28 @@
 
     try:
         return next(method.infer_call_result(self, new_context))
-    except StopIteration:
-        util.reraise(exceptions.InferenceError(
+    except StopIteration as exc:
+        raise exceptions.InferenceError(
             message='Inference for {node!r}[{index!s}] failed.',
-            node=self, index=index, context=context))
+            node=self,
+            index=index,
+            context=context) from exc
 
 bases.Instance.getitem = instance_getitem
+
+
+def _populate_context_lookup(call, context):
+    # Allows context to be saved for later
+    # for inference inside a function
+    context_lookup = {}
+    if context is None:
+        return context_lookup
+    for arg in call.args:
+        if isinstance(arg, nodes.Starred):
+            context_lookup[arg.value] = context
+        else:
+            context_lookup[arg] = context
+    keywords = call.keywords if call.keywords is not None else []
+    for keyword in keywords:
+        context_lookup[keyword.value] = context
+    return context_lookup
diff -Nru astroid-1.6.5/astroid/__init__.py astroid-2.0/astroid/__init__.py
--- astroid-1.6.5/astroid/__init__.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/__init__.py	2018-07-15 09:19:22.000000000 +0200
@@ -1,6 +1,11 @@
 # Copyright (c) 2006-2013, 2015 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
 # Copyright (c) 2014 Google, Inc.
-# Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2014 Eevee (Alex Munroe) <amunroe@yelp.com>
+# Copyright (c) 2015-2016, 2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2016 Derek Gustafson <degustaf@gmail.com>
+# Copyright (c) 2016 Moises Lopez <moylop260@vauxoo.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -30,12 +35,12 @@
 * builder contains the class responsible to build astroid trees
 """
 
+import enum
+import itertools
 import os
 import sys
-import re
-from operator import attrgetter
 
-import enum
+import wrapt
 
 
 _Context = enum.Enum('Context', 'Load Store Del')
@@ -74,28 +79,22 @@
 
 # transform utilities (filters and decorator)
 
-class AsStringRegexpPredicate(object):
-    """ClassDef to be used as predicate that may be given to `register_transform`
 
-    First argument is a regular expression that will be searched against the `as_string`
-    representation of the node onto which it's applied.
+# pylint: disable=dangerous-default-value
+@wrapt.decorator
+def _inference_tip_cached(func, instance, args, kwargs, _cache={}):
+    """Cache decorator used for inference tips"""
+    node = args[0]
+    try:
+        return iter(_cache[func, node])
+    except KeyError:
+        result = func(*args, **kwargs)
+        # Need to keep an iterator around
+        original, copy = itertools.tee(result)
+        _cache[func, node] = list(copy)
+        return original
+# pylint: enable=dangerous-default-value
 
-    If specified, the second argument is an `attrgetter` expression that will be
-    applied on the node first to get the actual node on which `as_string` should
-    be called.
-
-    WARNING: This can be fairly slow, as it has to convert every AST node back
-    to Python code; you should consider examining the AST directly instead.
-    """
-    def __init__(self, regexp, expression=None):
-        self.regexp = re.compile(regexp)
-        self.expression = expression
-
-    def __call__(self, node):
-        if self.expression is not None:
-            node = attrgetter(self.expression)(node)
-        # pylint: disable=no-member; github.com/pycqa/astroid/126
-        return self.regexp.search(node.as_string())
 
 def inference_tip(infer_function, raise_on_overwrite=False):
     """Given an instance specific inference function, return a function to be
@@ -128,7 +127,8 @@
                 .format(existing_inference=infer_function,
                         new_inference=node._explicit_inference,
                         node=node))
-        node._explicit_inference = infer_function
+        # pylint: disable=no-value-for-parameter
+        node._explicit_inference = _inference_tip_cached(infer_function)
         return node
     return transform
 
diff -Nru astroid-1.6.5/astroid/interpreter/dunder_lookup.py astroid-2.0/astroid/interpreter/dunder_lookup.py
--- astroid-1.6.5/astroid/interpreter/dunder_lookup.py	2018-05-13 12:38:38.000000000 +0200
+++ astroid-2.0/astroid/interpreter/dunder_lookup.py	2018-07-15 09:19:27.000000000 +0200
@@ -1,4 +1,4 @@
-# Copyright (c) 2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016-2018 Claudiu Popa <pcmanticore@gmail.com>
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
 
@@ -48,9 +48,9 @@
                          astroid.Dict,
                          astroid.Set)):
         return _builtin_lookup(node, name)
-    elif isinstance(node, astroid.Instance):
+    if isinstance(node, astroid.Instance):
         return _lookup_in_mro(node, name)
-    elif isinstance(node, astroid.ClassDef):
+    if isinstance(node, astroid.ClassDef):
         return _class_lookup(node, name)
 
     raise exceptions.AttributeInferenceError(
diff -Nru astroid-1.6.5/astroid/interpreter/_import/spec.py astroid-2.0/astroid/interpreter/_import/spec.py
--- astroid-1.6.5/astroid/interpreter/_import/spec.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/interpreter/_import/spec.py	2018-07-15 09:19:28.000000000 +0200
@@ -1,4 +1,10 @@
-# Copyright (c) 2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016-2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016 Derek Gustafson <degustaf@gmail.com>
+# Copyright (c) 2017 Chris Philip <chrisp533@gmail.com>
+# Copyright (c) 2017 Hugo <hugovk@users.noreply.github.com>
+# Copyright (c) 2017 ioanatia <ioanatia@users.noreply.github.com>
+# Copyright (c) 2017 Calen Pennington <cale@edx.org>
+# Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>
 
 import abc
 import collections
@@ -55,7 +61,7 @@
                                    submodule_search_locations=submodule_search_locations)
 
 
-class Finder(object):
+class Finder:
     """A finder is a class which knows how to find a particular module."""
 
     def __init__(self, path=None):
@@ -160,8 +166,12 @@
     def find_module(self, modname, module_parts, processed, submodule_path):
         spec = importlib.machinery.PathFinder.find_spec(modname, path=submodule_path)
         if spec:
-            location = spec.origin if spec.origin != 'namespace' else None
-            module_type = ModuleType.PY_NAMESPACE if spec.origin == 'namespace' else None
+            # origin can be either a string on older Python versions
+            # or None in case it is a namespace package:
+            # https://github.com/python/cpython/pull/5481
+            is_namespace_pkg = spec.origin in ('namespace', None)
+            location = spec.origin if not is_namespace_pkg else None
+            module_type = ModuleType.PY_NAMESPACE if is_namespace_pkg else None
             spec = ModuleSpec(name=spec.name, location=location,
                               origin=spec.origin, module_type=module_type,
                               submodule_search_locations=list(spec.submodule_search_locations
diff -Nru astroid-1.6.5/astroid/interpreter/_import/util.py astroid-2.0/astroid/interpreter/_import/util.py
--- astroid-1.6.5/astroid/interpreter/_import/util.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/interpreter/_import/util.py	2018-07-15 09:19:28.000000000 +0200
@@ -1,4 +1,4 @@
-# Copyright (c) 2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016, 2018 Claudiu Popa <pcmanticore@gmail.com>
 
 try:
     import pkg_resources
@@ -7,6 +7,5 @@
 
 
 def is_namespace(modname):
-    # pylint: disable=no-member; astroid issue #290, modifying globals at runtime.
     return (pkg_resources is not None
             and modname in pkg_resources._namespace_packages)
diff -Nru astroid-1.6.5/astroid/interpreter/objectmodel.py astroid-2.0/astroid/interpreter/objectmodel.py
--- astroid-1.6.5/astroid/interpreter/objectmodel.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/interpreter/objectmodel.py	2018-07-15 09:19:28.000000000 +0200
@@ -1,4 +1,9 @@
-# Copyright (c) 2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016-2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016 Derek Gustafson <degustaf@gmail.com>
+# Copyright (c) 2017-2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
+# Copyright (c) 2017 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2017 Calen Pennington <cale@edx.org>
+# Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
 """
@@ -20,17 +25,12 @@
 mechanism.
 """
 
-try:
-    from functools import lru_cache
-except ImportError:
-    from backports.functools_lru_cache import lru_cache
-
+import builtins
 import itertools
 import pprint
 import os
 import types
-
-import six
+from functools import lru_cache
 
 import astroid
 from astroid import context as contextmod
@@ -54,7 +54,7 @@
     return obj
 
 
-class ObjectModel(object):
+class ObjectModel:
 
     def __init__(self):
         self._instance = None
@@ -114,18 +114,12 @@
 class ModuleModel(ObjectModel):
 
     def _builtins(self):
-        builtins = astroid.MANAGER.astroid_cache[six.moves.builtins.__name__]
-        return builtins.special_attributes.lookup('__dict__')
+        builtins_ast_module = astroid.MANAGER.astroid_cache[builtins.__name__]
+        return builtins_ast_module.special_attributes.lookup('__dict__')
 
-    if six.PY3:
-        @property
-        def pybuiltins(self):
-            return self._builtins()
-
-    else:
-        @property
-        def py__builtin__(self):
-            return self._builtins()
+    @property
+    def pybuiltins(self):
+        return self._builtins()
 
     # __path__ is a standard attribute on *packages* not
     # non-package modules.  The only mention of it in the
@@ -138,14 +132,13 @@
             raise exceptions.AttributeInferenceError(target=self._instance,
                                                      attribute='__path__')
 
-        if isinstance(self._instance.path, list):
-            path_objs = [
-                node_classes.Const(value=path, parent=self._instance)
-                for path in self._instance.path
-            ]
-        else:
-            path = os.path.dirname(self._instance.path)
-            path_objs = [node_classes.Const(value=path, parent=self._instance)]
+        path_objs = [
+            node_classes.Const(
+                value=path if not path.endswith('__init__.py') else os.path.dirname(path),
+                parent=self._instance
+            )
+            for path in self._instance.path
+        ]
 
         container = node_classes.List(parent=self._instance)
         container.postinit(path_objs)
@@ -240,8 +233,8 @@
 
         args = self._instance.args
         pair_annotations = itertools.chain(
-            six.moves.zip(args.args or [], args.annotations),
-            six.moves.zip(args.kwonlyargs, args.kwonlyargs_annotations)
+            zip(args.args or [], args.annotations),
+            zip(args.kwonlyargs, args.kwonlyargs_annotations)
         )
 
         annotations = {
@@ -300,6 +293,12 @@
 
         class DescriptorBoundMethod(bases.BoundMethod):
             """Bound method which knows how to understand calling descriptor binding."""
+
+            def implicit_parameters(self):
+                # Different than BoundMethod since the signature
+                # is different.
+                return 0
+
             def infer_call_result(self, caller, context=None):
                 if len(caller.args) != 2:
                     raise exceptions.InferenceError(
@@ -309,6 +308,17 @@
                 context = contextmod.copy_context(context)
                 cls = next(caller.args[0].infer(context=context))
 
+                if cls is astroid.Uninferable:
+                    raise exceptions.InferenceError(
+                        "Invalid class inferred",
+                        target=self, context=context)
+
+                # For some reason func is a Node that the below
+                # code is not expecting
+                if isinstance(func, bases.BoundMethod):
+                    yield func
+                    return
+
                 # Rebuild the original value, but with the parent set as the
                 # class where it will be bound.
                 new_func = func.__class__(name=func.name, doc=func.doc,
@@ -322,6 +332,31 @@
                 proxy = bases.UnboundMethod(new_func)
                 yield bases.BoundMethod(proxy=proxy, bound=cls)
 
+            @property
+            def args(self):
+                """Overwrite the underlying args to match those of the underlying func
+
+                Usually the underlying *func* is a function/method, as in:
+
+                    def test(self):
+                        pass
+
+                This has only the *self* parameter but when we access test.__get__
+                we get a new object which has two parameters, *self* and *type*.
+                """
+                nonlocal func
+                params = func.args.args.copy()
+                params.append(astroid.AssignName(name='type'))
+                arguments = astroid.Arguments(parent=func.args.parent,)
+                arguments.postinit(
+                    args=params,
+                    defaults=[],
+                    kwonlyargs=[],
+                    kw_defaults=[],
+                    annotations=[],
+                )
+                return arguments
+
         return DescriptorBoundMethod(proxy=self._instance, bound=self._instance)
 
     # These are here just for completion.
@@ -351,15 +386,6 @@
     py__closure__ = py__ne__
     py__code__ = py__ne__
 
-    if six.PY2:
-        pyfunc_name = py__name__
-        pyfunc_doc = py__doc__
-        pyfunc_globals = py__globals__
-        pyfunc_dict = py__dict__
-        pyfunc_defaults = py__defaults__
-        pyfunc_code = py__code__
-        pyfunc_closure = py__closure__
-
 
 class ClassModel(ObjectModel):
 
@@ -514,7 +540,7 @@
     def __new__(cls, *args, **kwargs):
         # Append the values from the GeneratorType unto this object.
         ret = super(GeneratorModel, cls).__new__(cls, *args, **kwargs)
-        generator = astroid.MANAGER.astroid_cache[six.moves.builtins.__name__]['generator']
+        generator = astroid.MANAGER.astroid_cache[builtins.__name__]['generator']
         for name, values in generator.locals.items():
             method = values[0]
             patched = lambda cls, meth=method: meth
@@ -562,21 +588,11 @@
         args.postinit((message, ))
         return args
 
-    if six.PY3:
-        # It's available only on Python 3.
-
-        @property
-        def py__traceback__(self):
-            builtins = astroid.MANAGER.astroid_cache[six.moves.builtins.__name__]
-            traceback_type = builtins[types.TracebackType.__name__]
-            return traceback_type.instantiate_class()
-
-    if six.PY2:
-        # It's available only on Python 2.
-
-        @property
-        def pymessage(self):
-            return node_classes.Const('')
+    @property
+    def py__traceback__(self):
+        builtins_ast_module = astroid.MANAGER.astroid_cache[builtins.__name__]
+        traceback_type = builtins_ast_module[types.TracebackType.__name__]
+        return traceback_type.instantiate_class()
 
 
 class DictModel(ObjectModel):
@@ -605,9 +621,8 @@
             elems.append(elem)
         obj.postinit(elts=elems)
 
-        if six.PY3:
-            from astroid import objects
-            obj = objects.DictItems(obj)
+        from astroid import objects
+        obj = objects.DictItems(obj)
 
         return self._generic_dict_attribute(obj, 'items')
 
@@ -617,9 +632,8 @@
         obj = node_classes.List(parent=self._instance)
         obj.postinit(elts=keys)
 
-        if six.PY3:
-            from astroid import objects
-            obj = objects.DictKeys(obj)
+        from astroid import objects
+        obj = objects.DictKeys(obj)
 
         return self._generic_dict_attribute(obj, 'keys')
 
@@ -630,8 +644,7 @@
         obj = node_classes.List(parent=self._instance)
         obj.postinit(values)
 
-        if six.PY3:
-            from astroid import objects
-            obj = objects.DictValues(obj)
+        from astroid import objects
+        obj = objects.DictValues(obj)
 
         return self._generic_dict_attribute(obj, 'values')
diff -Nru astroid-1.6.5/astroid/manager.py astroid-2.0/astroid/manager.py
--- astroid-1.6.5/astroid/manager.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/manager.py	2018-07-15 09:19:24.000000000 +0200
@@ -1,7 +1,13 @@
 # Copyright (c) 2006-2011, 2013-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
-# Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2014-2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2014 BioGeek <jeroen.vangoey@gmail.com>
 # Copyright (c) 2014 Google, Inc.
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2014 Eevee (Alex Munroe) <amunroe@yelp.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2016 Derek Gustafson <degustaf@gmail.com>
+# Copyright (c) 2017 Iva Miholic <ivamiho@gmail.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
+# Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -12,16 +18,12 @@
 """
 
 import os
-import sys
 import zipimport
 
-import six
-
 from astroid import exceptions
 from astroid.interpreter._import import spec
 from astroid import modutils
 from astroid import transforms
-from astroid import util
 
 
 def safe_repr(obj):
@@ -31,7 +33,7 @@
         return '???'
 
 
-class AstroidManager(object):
+class AstroidManager:
     """the astroid manager, responsible to build astroid from files
      or modules.
 
@@ -56,6 +58,7 @@
             # Export these APIs for convenience
             self.register_transform = self._transform.register_transform
             self.unregister_transform = self._transform.unregister_transform
+            self.max_inferable_values = 100
 
     def visit_transforms(self, node):
         """Visit the transforms and apply them to the given *node*."""
@@ -78,7 +81,7 @@
         if source:
             from astroid.builder import AstroidBuilder
             return AstroidBuilder(self).file_build(filepath, modname)
-        elif fallback and modname:
+        if fallback and modname:
             return self.ast_from_module_name(modname)
         raise exceptions.AstroidBuildingError(
             'Unable to build an AST for {path}.', path=filepath)
@@ -112,45 +115,38 @@
             os.chdir(os.path.dirname(context_file))
         try:
             found_spec = self.file_from_module_name(modname, context_file)
-            # pylint: disable=no-member
             if found_spec.type == spec.ModuleType.PY_ZIPMODULE:
-                # pylint: disable=no-member
                 module = self.zip_import_data(found_spec.location)
                 if module is not None:
                     return module
 
             elif found_spec.type in (spec.ModuleType.C_BUILTIN,
                                      spec.ModuleType.C_EXTENSION):
-                # pylint: disable=no-member
                 if (found_spec.type == spec.ModuleType.C_EXTENSION
                         and not self._can_load_extension(modname)):
                     return self._build_stub_module(modname)
                 try:
                     module = modutils.load_module_from_name(modname)
-                except Exception as ex: # pylint: disable=broad-except
-                    util.reraise(exceptions.AstroidImportError(
+                except Exception as ex:
+                    raise exceptions.AstroidImportError(
                         'Loading {modname} failed with:\n{error}',
-                        modname=modname, path=found_spec.location, error=ex))
+                        modname=modname, path=found_spec.location) from ex
                 return self.ast_from_module(module, modname)
 
             elif found_spec.type == spec.ModuleType.PY_COMPILED:
                 raise exceptions.AstroidImportError(
                     "Unable to load compiled module {modname}.",
-                    # pylint: disable=no-member
                     modname=modname, path=found_spec.location)
 
             elif found_spec.type == spec.ModuleType.PY_NAMESPACE:
                 return self._build_namespace_module(modname,
-                                                    # pylint: disable=no-member
                                                     found_spec.submodule_search_locations)
 
-            # pylint: disable=no-member
             if found_spec.location is None:
                 raise exceptions.AstroidImportError(
                     "Can't find a file for module {modname}.",
                     modname=modname)
 
-            # pylint: disable=no-member
             return self.ast_from_file(found_spec.location, modname, fallback=False)
         except exceptions.AstroidBuildingError as e:
             for hook in self._failed_import_hooks:
@@ -187,21 +183,17 @@
     def file_from_module_name(self, modname, contextfile):
         try:
             value = self._mod_file_cache[(modname, contextfile)]
-            traceback = sys.exc_info()[2]
         except KeyError:
             try:
                 value = modutils.file_info_from_modpath(
                     modname.split('.'), context_file=contextfile)
-                traceback = sys.exc_info()[2]
             except ImportError as ex:
                 value = exceptions.AstroidImportError(
                     'Failed to import module {modname} with error:\n{error}.',
                     modname=modname, error=ex)
-                traceback = sys.exc_info()[2]
             self._mod_file_cache[(modname, contextfile)] = value
         if isinstance(value, exceptions.AstroidBuildingError):
-            six.reraise(exceptions.AstroidBuildingError,
-                        value, traceback)
+            raise value
         return value
 
     def ast_from_module(self, module, modname=None):
@@ -224,10 +216,10 @@
         if modname is None:
             try:
                 modname = klass.__module__
-            except AttributeError:
-                util.reraise(exceptions.AstroidBuildingError(
+            except AttributeError as exc:
+                raise exceptions.AstroidBuildingError(
                     'Unable to get module for class {class_name}.',
-                    cls=klass, class_repr=safe_repr(klass), modname=modname))
+                    cls=klass, class_repr=safe_repr(klass), modname=modname) from exc
         modastroid = self.ast_from_module_name(modname)
         return modastroid.getattr(klass.__name__)[0] # XXX
 
@@ -239,24 +231,24 @@
             klass = obj
         try:
             modname = klass.__module__
-        except AttributeError:
-            util.reraise(exceptions.AstroidBuildingError(
+        except AttributeError as exc:
+            raise exceptions.AstroidBuildingError(
                 'Unable to get module for {class_repr}.',
-                cls=klass, class_repr=safe_repr(klass)))
-        except Exception as ex: # pylint: disable=broad-except
-            util.reraise(exceptions.AstroidImportError(
+                cls=klass, class_repr=safe_repr(klass)) from exc
+        except Exception as exc:
+            raise exceptions.AstroidImportError(
                 'Unexpected error while retrieving module for {class_repr}:\n'
-                '{error}', cls=klass, class_repr=safe_repr(klass), error=ex))
+                '{error}', cls=klass, class_repr=safe_repr(klass)) from exc
         try:
             name = klass.__name__
-        except AttributeError:
-            util.reraise(exceptions.AstroidBuildingError(
+        except AttributeError as exc:
+            raise exceptions.AstroidBuildingError(
                 'Unable to get name for {class_repr}:\n',
-                cls=klass, class_repr=safe_repr(klass)))
-        except Exception as ex: # pylint: disable=broad-except
-            util.reraise(exceptions.AstroidImportError(
+                cls=klass, class_repr=safe_repr(klass)) from exc
+        except Exception as exc:
+            raise exceptions.AstroidImportError(
                 'Unexpected error while retrieving name for {class_repr}:\n'
-                '{error}', cls=klass, class_repr=safe_repr(klass), error=ex))
+                '{error}', cls=klass, class_repr=safe_repr(klass)) from exc
         # take care, on living object __module__ is regularly wrong :(
         modastroid = self.ast_from_module_name(modname)
         if klass is obj:
diff -Nru astroid-1.6.5/astroid/mixins.py astroid-2.0/astroid/mixins.py
--- astroid-1.6.5/astroid/mixins.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/mixins.py	2018-07-15 09:19:23.000000000 +0200
@@ -1,6 +1,11 @@
 # Copyright (c) 2010-2011, 2013-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
+# Copyright (c) 2014-2016, 2018 Claudiu Popa <pcmanticore@gmail.com>
 # Copyright (c) 2014 Google, Inc.
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2014 Eevee (Alex Munroe) <amunroe@yelp.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>
+# Copyright (c) 2016 Jakub Wilk <jwilk@jwilk.net>
+# Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -8,13 +13,11 @@
 """This module contains some mixins for the different nodes.
 """
 
-import warnings
-
 from astroid import decorators
 from astroid import exceptions
 
 
-class BlockRangeMixIn(object):
+class BlockRangeMixIn:
     """override block range """
 
     @decorators.cachedproperty
@@ -34,7 +37,7 @@
         return lineno, last or self.tolineno
 
 
-class FilterStmtsMixin(object):
+class FilterStmtsMixin:
     """Mixin for statement filtering and assignment type"""
 
     def _get_filtered_stmts(self, _, node, _stmts, mystmt):
@@ -48,26 +51,12 @@
     def assign_type(self):
         return self
 
-    def ass_type(self):
-        warnings.warn('%s.ass_type() is deprecated and slated for removal '
-                      'in astroid 2.0, use %s.assign_type() instead.'
-                      % (type(self).__name__, type(self).__name__),
-                      PendingDeprecationWarning, stacklevel=2)
-        return self.assign_type()
-
 
-class AssignTypeMixin(object):
+class AssignTypeMixin:
 
     def assign_type(self):
         return self
 
-    def ass_type(self):
-        warnings.warn('%s.ass_type() is deprecated and slated for removal '
-                      'in astroid 2.0, use %s.assign_type() instead.'
-                      % (type(self).__name__, type(self).__name__),
-                      PendingDeprecationWarning, stacklevel=2)
-        return self.assign_type()
-
     def _get_filtered_stmts(self, lookup_node, node, _stmts, mystmt):
         """method used in filter_stmts"""
         if self is mystmt:
@@ -84,13 +73,6 @@
     def assign_type(self):
         return self.parent.assign_type()
 
-    def ass_type(self):
-        warnings.warn('%s.ass_type() is deprecated and slated for removal '
-                      'in astroid 2.0, use %s.assign_type() instead.'
-                      % (type(self).__name__, type(self).__name__),
-                      PendingDeprecationWarning, stacklevel=2)
-        return self.assign_type()
-
 
 class ImportFromMixin(FilterStmtsMixin):
     """MixIn for From and Import Nodes"""
@@ -131,3 +113,44 @@
         raise exceptions.AttributeInferenceError(
             'Could not find original name for {attribute} in {target!r}',
             target=self, attribute=asname)
+
+
+class MultiLineBlockMixin:
+    """Mixin for nodes with multi-line blocks, e.g. For and FunctionDef.
+    Note that this does not apply to every node with a `body` field.
+    For instance, an If node has a multi-line body, but the body of an
+    IfExpr is not multi-line, and hence cannot contain Return nodes,
+    Assign nodes, etc.
+    """
+
+    @decorators.cachedproperty
+    def _multi_line_blocks(self):
+        return tuple(
+            getattr(self, field)
+            for field in self._multi_line_block_fields
+        )
+
+    def _get_return_nodes_skip_functions(self):
+        for block in self._multi_line_blocks:
+            for child_node in block:
+                if child_node.is_function:
+                    continue
+                yield from child_node._get_return_nodes_skip_functions()
+
+    def _get_yield_nodes_skip_lambdas(self):
+        for block in self._multi_line_blocks:
+            for child_node in block:
+                if child_node.is_lambda:
+                    continue
+                yield from child_node._get_yield_nodes_skip_lambdas()
+
+    def _get_assign_nodes(self):
+        for block in self._multi_line_blocks:
+            for child_node in block:
+                yield from child_node._get_assign_nodes()
+
+
+class NoChildrenMixin:
+    """Mixin for nodes with no children, e.g. Pass."""
+    def get_children(self):
+        yield from ()
diff -Nru astroid-1.6.5/astroid/modutils.py astroid-2.0/astroid/modutils.py
--- astroid-1.6.5/astroid/modutils.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/modutils.py	2018-07-15 09:19:24.000000000 +0200
@@ -1,9 +1,17 @@
 # -*- coding: utf-8 -*-
-# Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2014-2018 Claudiu Popa <pcmanticore@gmail.com>
 # Copyright (c) 2014 Google, Inc.
+# Copyright (c) 2014 Denis Laxalde <denis.laxalde@logilab.fr>
+# Copyright (c) 2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
+# Copyright (c) 2014 Eevee (Alex Munroe) <amunroe@yelp.com>
 # Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>
 # Copyright (c) 2015 Radosław Ganczarek <radoslaw@ganczarek.in>
+# Copyright (c) 2016 Derek Gustafson <degustaf@gmail.com>
 # Copyright (c) 2016 Jakub Wilk <jwilk@jwilk.net>
+# Copyright (c) 2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2018 Mario Corchero <mcorcherojim@bloomberg.net>
+# Copyright (c) 2018 Mario Corchero <mariocj89@gmail.com>
+# Copyright (c) 2018 Anthony Sottile <asottile@umich.edu>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -23,6 +31,7 @@
 import os
 import platform
 import sys
+import itertools
 from distutils.sysconfig import get_python_lib # pylint: disable=import-error
 # pylint: disable=import-error, no-name-in-module
 from distutils.errors import DistutilsPlatformError
@@ -30,8 +39,6 @@
 # weird path manipulations in order to get to the
 # real distutils module.
 
-import six
-
 from .interpreter._import import spec
 from .interpreter._import import util
 
@@ -49,11 +56,11 @@
     # with the prefix from which the virtualenv was created. This throws
     # off the detection logic for standard library modules, thus the
     # workaround.
-    STD_LIB_DIRS = set([
+    STD_LIB_DIRS = {
         get_python_lib(standard_lib=True, prefix=sys.prefix),
         # Take care of installations where exec_prefix != prefix.
         get_python_lib(standard_lib=True, prefix=sys.exec_prefix),
-        get_python_lib(standard_lib=True)])
+        get_python_lib(standard_lib=True)}
 # get_python_lib(standard_lib=1) is not available on pypy, set STD_LIB_DIR to
 # non-valid path, see https://bugs.pypy.org/issue1164
 except DistutilsPlatformError:
@@ -128,10 +135,9 @@
     if not is_jython:
         if sys.version_info > (3, 0):
             return filename
-        else:
-            if filename.endswith(".pyc"):
-                return filename[:-1]
-            return filename
+        if filename.endswith(".pyc"):
+            return filename[:-1]
+        return filename
     head, has_pyclass, _ = filename.partition("$py.class")
     if has_pyclass:
         return head + ".py"
@@ -285,26 +291,64 @@
     return True
 
 
+def _get_relative_base_path(filename, path_to_check):
+    """Extracts the relative mod path of the file to import from
+
+    Check if a file is within the passed in path and if so, returns the
+    relative mod path from the one passed in.
+
+    If the filename is no in path_to_check, returns None
+
+    Note this function will look for both abs and realpath of the file,
+    this allows to find the relative base path even if the file is a
+    symlink of a file in the passed in path
+
+    Examples:
+        _get_relative_base_path("/a/b/c/d.py", "/a/b") ->  ["c","d"]
+        _get_relative_base_path("/a/b/c/d.py", "/dev") ->  None
+    """
+    importable_path = None
+    path_to_check = os.path.normcase(path_to_check)
+    abs_filename = os.path.abspath(filename)
+    if os.path.normcase(abs_filename).startswith(path_to_check):
+        importable_path = abs_filename
+
+    real_filename = os.path.realpath(filename)
+    if os.path.normcase(real_filename).startswith(path_to_check):
+        importable_path = real_filename
+
+    if importable_path:
+        base_path = os.path.splitext(importable_path)[0]
+        relative_base_path = base_path[len(path_to_check):]
+        return [pkg for pkg in relative_base_path.split(os.sep) if pkg]
+
+    return None
+
+
 def modpath_from_file_with_callback(filename, extrapath=None, is_package_cb=None):
-    filename = _path_from_filename(filename)
-    filename = os.path.realpath(os.path.expanduser(filename))
-    base = os.path.splitext(filename)[0]
+    filename = os.path.expanduser(_path_from_filename(filename))
 
     if extrapath is not None:
-        for path_ in six.moves.map(_canonicalize_path, extrapath):
+        for path_ in itertools.chain(map(_canonicalize_path, extrapath),
+                                     extrapath):
             path = os.path.abspath(path_)
-            if path and os.path.normcase(base[:len(path)]) == os.path.normcase(path):
-                submodpath = [pkg for pkg in base[len(path):].split(os.sep)
-                              if pkg]
-                if is_package_cb(path, submodpath[:-1]):
-                    return extrapath[path_].split('.') + submodpath
+            if not path:
+                continue
+            submodpath = _get_relative_base_path(filename, path)
+            if not submodpath:
+                continue
+            if is_package_cb(path, submodpath[:-1]):
+                return extrapath[path_].split('.') + submodpath
 
-    for path in six.moves.map(_canonicalize_path, sys.path):
+    for path in itertools.chain(map(_canonicalize_path, sys.path), sys.path):
         path = _cache_normalize_path(path)
-        if path and os.path.normcase(base).startswith(path):
-            modpath = [pkg for pkg in base[len(path):].split(os.sep) if pkg]
-            if is_package_cb(path, modpath[:-1]):
-                return modpath
+        if not path:
+            continue
+        modpath = _get_relative_base_path(filename, path)
+        if not modpath:
+            continue
+        if is_package_cb(path, modpath[:-1]):
+            return modpath
 
     raise ImportError('Unable to find module for %s in %s' % (
         filename, ', \n'.join(sys.path)))
diff -Nru astroid-1.6.5/astroid/node_classes.py astroid-2.0/astroid/node_classes.py
--- astroid-1.6.5/astroid/node_classes.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/node_classes.py	2018-07-15 09:19:26.000000000 +0200
@@ -1,9 +1,24 @@
+# -*- coding: utf-8 -*-
 # pylint: disable=too-many-lines; https://github.com/PyCQA/astroid/issues/465
 # Copyright (c) 2009-2011, 2013-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
-# Copyright (c) 2013-2014, 2016 Google, Inc.
-# Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2010 Daniel Harding <dharding@gmail.com>
+# Copyright (c) 2012 FELD Boris <lothiraldan@gmail.com>
+# Copyright (c) 2013-2014 Google, Inc.
+# Copyright (c) 2014-2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2014 Eevee (Alex Munroe) <amunroe@yelp.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>
+# Copyright (c) 2016-2017 Derek Gustafson <degustaf@gmail.com>
+# Copyright (c) 2016 Jared Garst <jgarst@users.noreply.github.com>
 # Copyright (c) 2016 Jakub Wilk <jwilk@jwilk.net>
+# Copyright (c) 2016 Dave Baum <dbaum@google.com>
+# Copyright (c) 2017-2018 Ashley Whetter <ashley@awhetter.co.uk>
+# Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
+# Copyright (c) 2017 rr- <rr-@sakuya.pl>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
+# Copyright (c) 2018 brendanator <brendan.maginnis@gmail.com>
+# Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>
+# Copyright (c) 2018 HoverHell <hoverhell@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -12,14 +27,11 @@
 """
 
 import abc
+import builtins as builtins_mod
+import itertools
 import pprint
-import warnings
-try:
-    from functools import singledispatch as _singledispatch
-except ImportError:
-    from singledispatch import singledispatch as _singledispatch
-
-import six
+from functools import lru_cache
+from functools import singledispatch as _singledispatch
 
 from astroid import as_string
 from astroid import bases
@@ -31,7 +43,7 @@
 from astroid import util
 
 
-BUILTINS = six.moves.builtins.__name__
+BUILTINS = builtins_mod.__name__
 MANAGER = manager.AstroidManager()
 
 
@@ -45,26 +57,25 @@
             if elt is util.Uninferable:
                 yield elt
                 continue
-            for inferred_elt in unpack_infer(elt, context):
-                yield inferred_elt
+            yield from unpack_infer(elt, context)
         # Explicit StopIteration to return error information, see comment
         # in raise_if_nothing_inferred.
-        raise StopIteration(dict(node=stmt, context=context))
+        return dict(node=stmt, context=context)
     # if inferred is a final node, return it and stop
     inferred = next(stmt.infer(context))
     if inferred is stmt:
         yield inferred
         # Explicit StopIteration to return error information, see comment
         # in raise_if_nothing_inferred.
-        raise StopIteration(dict(node=stmt, context=context))
+        return dict(node=stmt, context=context)
     # else, infer recursively, except Uninferable object that should be returned as is
     for inferred in stmt.infer(context):
         if inferred is util.Uninferable:
             yield inferred
         else:
-            for inf_inf in unpack_infer(inferred, context):
-                yield inf_inf
-    raise StopIteration(dict(node=stmt, context=context))
+            yield from unpack_infer(inferred, context)
+
+    return dict(node=stmt, context=context)
 
 
 def are_exclusive(stmt1, stmt2, exceptions=None): # pylint: disable=redefined-outer-name
@@ -183,23 +194,43 @@
             new_cls.elts = elts[index_slice]
             new_cls.parent = instance.parent
             return new_cls
-        elif isinstance(index, Const):
+        if isinstance(index, Const):
             return elts[index.value]
-    except IndexError:
-        util.reraise(exceptions.AstroidIndexError(
+    except IndexError as exc:
+        raise exceptions.AstroidIndexError(
             message='Index {index!s} out of range',
-            node=instance, index=index, context=context))
+            node=instance, index=index, context=context) from exc
     except TypeError as exc:
-        util.reraise(exceptions.AstroidTypeError(
-            message='Type error {error!r}', error=exc,
-            node=instance, index=index, context=context))
+        raise exceptions.AstroidTypeError(
+            message='Type error {error!r}',
+            node=instance, index=index, context=context) from exc
+
+    raise exceptions.AstroidTypeError('Could not use %s as subscript index' % index)
 
-    raise exceptions.AstroidTypeError(
-        'Could not use %s as subscript index' % index
-    )
 
+OP_PRECEDENCE = {
+    op: precedence
+    for precedence, ops in enumerate([
+        ['Lambda'],  # lambda x: x + 1
+        ['IfExp'],  # 1 if True else 2
+        ['or'],
+        ['and'],
+        ['not'],
+        ['Compare'],  # in, not in, is, is not, <, <=, >, >=, !=, ==
+        ['|'],
+        ['^'],
+        ['&'],
+        ['<<', '>>'],
+        ['+', '-'],
+        ['*', '@', '/', '//', '%'],
+        ['UnaryOp'],  # +, -, ~
+        ['**'],
+        ['Await'],
+    ]) for op in ops
+}
 
-class NodeNG(object):
+
+class NodeNG:
     """ A node of the new Abstract Syntax Tree (AST).
 
     This is the base class for all Astroid node classes.
@@ -223,6 +254,7 @@
 
     :type: bool
     """
+    is_lambda = False
     # Attributes below are set by the builder module or by raw factories
     lineno = None
     """The line that this node appears on in the source code.
@@ -288,6 +320,8 @@
         :returns: The inferred values.
         :rtype: iterable
         """
+        if context is not None:
+            context = context.extra_context.get(self, context)
         if self._explicit_inference is not None:
             # explicit_inference is not bound, give it self explicitly
             try:
@@ -304,7 +338,9 @@
         if key in context.inferred:
             return iter(context.inferred[key])
 
-        return context.cache_generator(key, self._infer(context, **kwargs))
+        gen = context.cache_generator(
+            key, self._infer(context, **kwargs))
+        return util.limit_inference(gen, MANAGER.max_inferable_values)
 
     def _repr_name(self):
         """Get a name for nice representation.
@@ -314,7 +350,10 @@
         :returns: The nice name.
         :rtype: str
         """
-        return getattr(self, 'name', getattr(self, 'attrname', ''))
+        names = {'name', 'attrname'}
+        if all(name not in self._astroid_fields for name in names):
+            return getattr(self, 'name', getattr(self, 'attrname', ''))
+        return ''
 
     def __str__(self):
         rname = self._repr_name()
@@ -368,8 +407,7 @@
             if attr is None:
                 continue
             if isinstance(attr, (list, tuple)):
-                for elt in attr:
-                    yield elt
+                yield from attr
             else:
                 yield attr
 
@@ -630,15 +668,34 @@
         """
         if isinstance(self, klass):
             yield self
+
+        if skip_klass is None:
+            for child_node in self.get_children():
+                yield from child_node.nodes_of_class(klass, skip_klass)
+
+            return
+
         for child_node in self.get_children():
-            if skip_klass is not None and isinstance(child_node, skip_klass):
+            if isinstance(child_node, skip_klass):
                 continue
-            for matching in child_node.nodes_of_class(klass, skip_klass):
-                yield matching
+            yield from child_node.nodes_of_class(klass, skip_klass)
+
+    def _get_assign_nodes(self):
+        yield from ()
 
-    def _infer_name(self, frame, name): #pylint: disable=useless-return
+    def _get_name_nodes(self):
+        for child_node in self.get_children():
+            yield from child_node._get_name_nodes()
+
+    def _get_return_nodes_skip_functions(self):
+        yield from ()
+
+    def _get_yield_nodes_skip_lambdas(self):
+        yield from ()
+
+    def _infer_name(self, frame, name):
         # overridden for ImportFrom, Import, Global, TryExcept and Arguments
-        return None
+        pass
 
     def _infer(self, context=None):
         """we don't know how to resolve a statement by default"""
@@ -656,20 +713,6 @@
         """
         return list(self.infer())
 
-    def infered(self):
-        """A deprecated alias of :meth:`inferred`.
-
-        .. deprecated:: 1.5
-
-        :returns: The inferred values.
-        :rtype: list
-        """
-        warnings.warn('%s.infered() is deprecated and slated for removal '
-                      'in astroid 2.0, use %s.inferred() instead.'
-                      % (type(self).__name__, type(self).__name__),
-                      PendingDeprecationWarning, stacklevel=2)
-        return self.inferred()
-
     def instantiate_class(self):
         """Instantiate a instance of the defined class.
 
@@ -741,6 +784,7 @@
         :returns: The string representation of the AST.
         :rtype: str
         """
+        # pylint: disable=too-many-statements
         @_singledispatch
         def _repr_tree(node, result, done, cur_indent='', depth=1):
             """Outputs a representation of a non-tuple/list, non-node that's
@@ -793,8 +837,8 @@
                 result.append(indent + '<Recursion on %s with id=%s' %
                               (type(node).__name__, id(node)))
                 return False
-            else:
-                done.add(node)
+            done.add(node)
+
             if max_depth and depth > max_depth:
                 result.append('...')
                 return False
@@ -857,6 +901,15 @@
         """
         return util.Uninferable
 
+    def op_precedence(self):
+        # Look up by class name or default to highest precedence
+        return OP_PRECEDENCE.get(
+            self.__class__.__name__, len(OP_PRECEDENCE))
+
+    def op_left_associative(self):
+        # Everything is left associative except `**` and IfExp
+        return True
+
 
 class Statement(NodeNG):
     """Statement node adding a few attributes"""
@@ -891,9 +944,10 @@
             return stmts[index -1]
         return None
 
-@six.add_metaclass(abc.ABCMeta)
+
 class _BaseContainer(mixins.ParentAssignTypeMixin,
-                     NodeNG, bases.Instance):
+                     NodeNG, bases.Instance,
+                     metaclass=abc.ABCMeta):
     """Base class for Set, FrozenSet, Tuple and List."""
 
     _astroid_fields = ('elts',)
@@ -967,10 +1021,14 @@
         :rtype: str
         """
 
+    def get_children(self):
+        yield from self.elts
+
 
-class LookupMixIn(object):
+class LookupMixIn:
     """Mixin to look up a name in the right scope."""
 
+    @lru_cache(maxsize=None)
     def lookup(self, name):
         """Lookup where the given variable is assigned.
 
@@ -1060,8 +1118,13 @@
         for node in stmts:
             stmt = node.statement()
             # line filtering is on and we have reached our location, break
-            if mylineno > 0 and stmt.fromlineno > mylineno:
+            if stmt.fromlineno > mylineno > 0:
                 break
+            # Ignore decorators with the same name as the
+            # decorated function
+            # Fixes issue #375
+            if mystmt is stmt and is_from_decorator(self):
+                continue
             assert hasattr(node, 'assign_type'), (node, node.scope(),
                                                   node.scope().locals)
             assign_type = node.assign_type()
@@ -1133,7 +1196,8 @@
 
 # Name classes
 
-class AssignName(LookupMixIn, mixins.ParentAssignTypeMixin, NodeNG):
+class AssignName(mixins.NoChildrenMixin, LookupMixIn,
+                 mixins.ParentAssignTypeMixin, NodeNG):
     """Variation of :class:`ast.Assign` representing assignment to a name.
 
     An :class:`AssignName` is the name of something that is assigned to.
@@ -1173,7 +1237,8 @@
         super(AssignName, self).__init__(lineno, col_offset, parent)
 
 
-class DelName(LookupMixIn, mixins.ParentAssignTypeMixin, NodeNG):
+class DelName(mixins.NoChildrenMixin, LookupMixIn,
+              mixins.ParentAssignTypeMixin, NodeNG):
     """Variation of :class:`ast.Delete` represention deletion of a name.
 
     A :class:`DelName` is the name of something that is deleted.
@@ -1210,7 +1275,7 @@
         super(DelName, self).__init__(lineno, col_offset, parent)
 
 
-class Name(LookupMixIn, NodeNG):
+class Name(mixins.NoChildrenMixin, LookupMixIn, NodeNG):
     """Class representing an :class:`ast.Name` node.
 
     A :class:`Name` node is something that is named, but not covered by
@@ -1249,6 +1314,12 @@
 
         super(Name, self).__init__(lineno, col_offset, parent)
 
+    def _get_name_nodes(self):
+        yield self
+
+        for child_node in self.get_children():
+            yield from child_node._get_name_nodes()
+
 
 class Arguments(mixins.AssignTypeMixin, NodeNG):
     """Class representing an :class:`ast.arguments` node.
@@ -1262,33 +1333,31 @@
     >>> node.args
     <Arguments l.1 at 0x7effe1db82e8>
     """
-    if six.PY3:
-        # Python 3.4+ uses a different approach regarding annotations,
-        # each argument is a new class, _ast.arg, which exposes an
-        # 'annotation' attribute. In astroid though, arguments are exposed
-        # as is in the Arguments node and the only way to expose annotations
-        # is by using something similar with Python 3.3:
-        #  - we expose 'varargannotation' and 'kwargannotation' of annotations
-        #    of varargs and kwargs.
-        #  - we expose 'annotation', a list with annotations for
-        #    for each normal argument. If an argument doesn't have an
-        #    annotation, its value will be None.
-
-        _astroid_fields = ('args', 'defaults', 'kwonlyargs',
-                           'kw_defaults', 'annotations', 'varargannotation',
-                           'kwargannotation', 'kwonlyargs_annotations')
-        varargannotation = None
-        """The type annotation for the variable length arguments.
+    # Python 3.4+ uses a different approach regarding annotations,
+    # each argument is a new class, _ast.arg, which exposes an
+    # 'annotation' attribute. In astroid though, arguments are exposed
+    # as is in the Arguments node and the only way to expose annotations
+    # is by using something similar with Python 3.3:
+    #  - we expose 'varargannotation' and 'kwargannotation' of annotations
+    #    of varargs and kwargs.
+    #  - we expose 'annotation', a list with annotations for
+    #    for each normal argument. If an argument doesn't have an
+    #    annotation, its value will be None.
+
+    _astroid_fields = ('args', 'defaults', 'kwonlyargs',
+                       'kw_defaults', 'annotations', 'varargannotation',
+                       'kwargannotation', 'kwonlyargs_annotations')
+    varargannotation = None
+    """The type annotation for the variable length arguments.
 
-        :type: NodeNG
-        """
-        kwargannotation = None
-        """The type annotation for the variable length keyword arguments.
+    :type: NodeNG
+    """
+    kwargannotation = None
+    """The type annotation for the variable length keyword arguments.
+
+    :type: NodeNG
+    """
 
-        :type: NodeNG
-        """
-    else:
-        _astroid_fields = ('args', 'defaults', 'kwonlyargs', 'kw_defaults')
     _other_fields = ('vararg', 'kwarg')
 
     def __init__(self, vararg=None, kwarg=None, parent=None):
@@ -1493,16 +1562,28 @@
         return None, None
 
     def get_children(self):
-        """Get the child nodes below this node.
+        yield from self.args or ()
 
-        This skips over `None` elements in :attr:`kw_defaults`.
+        yield from self.defaults
+        yield from self.kwonlyargs
 
-        :returns: The children.
-        :rtype: iterable(NodeNG)
-        """
-        for child in super(Arguments, self).get_children():
-            if child is not None:
-                yield child
+        for elt in self.kw_defaults:
+            if elt is not None:
+                yield elt
+
+        for elt in self.annotations:
+            if elt is not None:
+                yield elt
+
+        if self.varargannotation is not None:
+            yield self.varargannotation
+
+        if self.kwargannotation is not None:
+            yield self.kwargannotation
+
+        for elt in self.kwonlyargs_annotations:
+            if elt is not None:
+                yield elt
 
 
 def _find_arg(argname, args, rec=False):
@@ -1525,7 +1606,7 @@
         annotations = []
     if defaults is not None:
         default_offset = len(args) - len(defaults)
-    packed = six.moves.zip_longest(args, annotations)
+    packed = itertools.zip_longest(args, annotations)
     for i, (arg, annotation) in enumerate(packed):
         if isinstance(arg, Tuple):
             values.append('(%s)' % _format_args(arg.elts))
@@ -1591,6 +1672,9 @@
         """
         self.expr = expr
 
+    def get_children(self):
+        yield self.expr
+
 
 class Assert(Statement):
     """Class representing an :class:`ast.Assert` node.
@@ -1625,6 +1709,12 @@
         self.fail = fail
         self.test = test
 
+    def get_children(self):
+        yield self.test
+
+        if self.fail is not None:
+            yield self.fail
+
 
 class Assign(mixins.AssignTypeMixin, Statement):
     """Class representing an :class:`ast.Assign` node.
@@ -1637,6 +1727,7 @@
     <Assign l.1 at 0x7effe1db8550>
     """
     _astroid_fields = ('targets', 'value',)
+    _other_other_fields = ('type_annotation',)
     targets = None
     """What is being assigned to.
 
@@ -1647,8 +1738,13 @@
 
     :type: NodeNG or None
     """
+    type_annotation = None
+    """If present, this will contain the type annotation passed by a type comment
+
+    :type: NodeNG or None
+    """
 
-    def postinit(self, targets=None, value=None):
+    def postinit(self, targets=None, value=None, type_annotation=None):
         """Do some setup after initialisation.
 
         :param targets: What is being assigned to.
@@ -1659,6 +1755,17 @@
         """
         self.targets = targets
         self.value = value
+        self.type_annotation = type_annotation
+
+    def get_children(self):
+        yield from self.targets
+
+        yield self.value
+
+    def _get_assign_nodes(self):
+        yield self
+
+        yield from self.value._get_assign_nodes()
 
 
 class AnnAssign(mixins.AssignTypeMixin, Statement):
@@ -1715,6 +1822,13 @@
         self.value = value
         self.simple = simple
 
+    def get_children(self):
+        yield self.target
+        yield self.annotation
+
+        if self.value is not None:
+            yield self.value
+
 
 class AugAssign(mixins.AssignTypeMixin, Statement):
     """Class representing an :class:`ast.AugAssign` node.
@@ -1796,6 +1910,10 @@
         except exceptions.InferenceError:
             return []
 
+    def get_children(self):
+        yield self.target
+        yield self.value
+
 
 class Repr(NodeNG):
     """Class representing an :class:`ast.Repr` node.
@@ -1900,6 +2018,17 @@
         except exceptions.InferenceError:
             return []
 
+    def get_children(self):
+        yield self.left
+        yield self.right
+
+    def op_precedence(self):
+        return OP_PRECEDENCE[self.op]
+
+    def op_left_associative(self):
+        # 2**3**4 == 2**(3**4)
+        return self.op != '**'
+
 
 class BoolOp(NodeNG):
     """Class representing an :class:`ast.BoolOp` node.
@@ -1949,8 +2078,14 @@
         """
         self.values = values
 
+    def get_children(self):
+        yield from self.values
+
+    def op_precedence(self):
+        return OP_PRECEDENCE[self.op]
 
-class Break(Statement):
+
+class Break(mixins.NoChildrenMixin, Statement):
     """Class representing an :class:`ast.Break` node.
 
     >>> node = astroid.extract_node('break')
@@ -2019,6 +2154,13 @@
         keywords = self.keywords or []
         return [keyword for keyword in keywords if keyword.arg is None]
 
+    def get_children(self):
+        yield self.func
+
+        yield from self.args
+
+        yield from self.keywords or ()
+
 
 class Compare(NodeNG):
     """Class representing an :class:`ast.Compare` node.
@@ -2159,20 +2301,6 @@
         """
         return self
 
-    def ass_type(self):
-        """A deprecated alias of :meth:`assign_type`.
-
-        .. deprecated:: 1.5
-
-        :returns: The assignment type.
-        :rtype: NodeNG
-        """
-        warnings.warn('%s.ass_type() is deprecated and slated for removal'
-                      'in astroid 2.0, use %s.assign_type() instead.'
-                      % (type(self).__name__, type(self).__name__),
-                      PendingDeprecationWarning, stacklevel=2)
-        return self.assign_type()
-
     def _get_filtered_stmts(self, lookup_node, node, stmts, mystmt):
         """method used in filter_stmts"""
         if self is mystmt:
@@ -2187,8 +2315,14 @@
 
         return stmts, False
 
+    def get_children(self):
+        yield self.target
+        yield self.iter
+
+        yield from self.ifs
+
 
-class Const(NodeNG, bases.Instance):
+class Const(mixins.NoChildrenMixin, NodeNG, bases.Instance):
     """Class representing any constant including num, str, bool, None, bytes.
 
     >>> node = astroid.extract_node('(5, "This is a string.", True, None, b"bytes")')
@@ -2226,6 +2360,17 @@
 
         super(Const, self).__init__(lineno, col_offset, parent)
 
+    def __getattr__(self, name):
+        # This is needed because of Proxy's __getattr__ method.
+        # Calling object.__new__ on this class without calling
+        # __init__ would result in an infinite loop otherwise
+        # since __getattr__ is called when an attribute doesn't
+        # exist and self._proxied indirectly calls self.value
+        # and Proxy __getattr__ calls self.value
+        if name == "value":
+            raise AttributeError
+        return super().__getattr__(name)
+
     def getitem(self, index, context=None):
         """Get an item from this node if subscriptable.
 
@@ -2246,21 +2391,16 @@
             )
 
         try:
-            if isinstance(self.value, six.string_types):
-                return Const(self.value[index_value])
-            if isinstance(self.value, bytes) and six.PY3:
-                # Bytes aren't instances of six.string_types
-                # on Python 3. Also, indexing them should return
-                # integers.
+            if isinstance(self.value, (str, bytes)):
                 return Const(self.value[index_value])
         except IndexError as exc:
-            util.reraise(exceptions.AstroidIndexError(
-                message='Index {index!r} out of range', error=exc,
-                node=self, index=index, context=context))
+            raise exceptions.AstroidIndexError(
+                message='Index {index!r} out of range',
+                node=self, index=index, context=context) from exc
         except TypeError as exc:
-            util.reraise(exceptions.AstroidTypeError(
-                message='Type error {error!r}', error=exc,
-                node=self, index=index, context=context))
+            raise exceptions.AstroidTypeError(
+                message='Type error {error!r}',
+                node=self, index=index, context=context) from exc
 
         raise exceptions.AstroidTypeError(
             '%r (value=%s)' % (self, self.value)
@@ -2284,7 +2424,7 @@
 
         :raises TypeError: If this node does not represent something that is iterable.
         """
-        if isinstance(self.value, six.string_types):
+        if isinstance(self.value, str):
             return self.value
         raise TypeError()
 
@@ -2305,7 +2445,7 @@
         return bool(self.value)
 
 
-class Continue(Statement):
+class Continue(mixins.NoChildrenMixin, Statement):
     """Class representing an :class:`ast.Continue` node.
 
     >>> node = astroid.extract_node('continue')
@@ -2354,6 +2494,9 @@
         # skip the function node to go directly to the upper level scope
         return self.parent.parent.scope()
 
+    def get_children(self):
+        yield from self.nodes
+
 
 class DelAttr(mixins.ParentAssignTypeMixin, NodeNG):
     """Variation of :class:`ast.Delete` representing deletion of an attribute.
@@ -2403,6 +2546,9 @@
         """
         self.expr = expr
 
+    def get_children(self):
+        yield self.expr
+
 
 class Delete(mixins.AssignTypeMixin, Statement):
     """Class representing an :class:`ast.Delete` node.
@@ -2428,6 +2574,9 @@
         """
         self.targets = targets
 
+    def get_children(self):
+        yield from self.targets
+
 
 class Dict(NodeNG, bases.Instance):
     """Class representing an :class:`ast.Dict` node.
@@ -2463,7 +2612,7 @@
     def postinit(self, items):
         """Do some setup after initialisation.
 
-        :param items: The ley-value pairs contained in the dictionary.
+        :param items: The key-value pairs contained in the dictionary.
         :type items: list(tuple(NodeNG, NodeNG))
         """
         self.items = items
@@ -2523,7 +2672,7 @@
         :returns: The keys of this node.
         :rtype: iterable(NodeNG)
         """
-        return self.items[::2]
+        return [key for (key, _) in self.items]
 
     def getitem(self, index, context=None):
         """Get an item from this node.
@@ -2588,8 +2737,15 @@
         """
         self.value = value
 
+    def get_children(self):
+        yield self.value
+
+    def _get_yield_nodes_skip_lambdas(self):
+        if not self.value.is_lambda:
+            yield from self.value._get_yield_nodes_skip_lambdas()
 
-class Ellipsis(NodeNG): # pylint: disable=redefined-builtin
+
+class Ellipsis(mixins.NoChildrenMixin, NodeNG): # pylint: disable=redefined-builtin
     """Class representing an :class:`ast.Ellipsis` node.
 
     An :class:`Ellipsis` is the ``...`` syntax.
@@ -2609,13 +2765,14 @@
         return True
 
 
-class EmptyNode(NodeNG):
+class EmptyNode(mixins.NoChildrenMixin, NodeNG):
     """Holds an arbitrary object in the :attr:`LocalsDictNodeNG.locals`."""
 
     object = None
 
 
-class ExceptHandler(mixins.AssignTypeMixin, Statement):
+class ExceptHandler(mixins.MultiLineBlockMixin,
+                    mixins.AssignTypeMixin, Statement):
     """Class representing an :class:`ast.ExceptHandler`. node.
 
     An :class:`ExceptHandler` is an ``except`` block on a try-except.
@@ -2632,6 +2789,7 @@
     [<ExceptHandler l.4 at 0x7f23b2e9e860>]
     """
     _astroid_fields = ('type', 'name', 'body',)
+    _multi_line_block_fields = ('body',)
     type = None
     """The types that the block handles.
 
@@ -2648,6 +2806,15 @@
     :type: list(NodeNG) or None
     """
 
+    def get_children(self):
+        if self.type is not None:
+            yield self.type
+
+        if self.name is not None:
+            yield self.name
+
+        yield from self.body
+
     # pylint: disable=redefined-builtin; had to use the same name as builtin ast module.
     def postinit(self, type=None, name=None, body=None):
         """Do some setup after initialisation.
@@ -2673,9 +2840,8 @@
         """
         if self.name:
             return self.name.tolineno
-        elif self.type:
+        if self.type:
             return self.type.tolineno
-
         return self.lineno
 
     def catch(self, exceptions): # pylint: disable=redefined-outer-name
@@ -2688,7 +2854,7 @@
         """
         if self.type is None or exceptions is None:
             return True
-        for node in self.type.nodes_of_class(Name):
+        for node in self.type._get_name_nodes():
             if node.name in exceptions:
                 return True
         return False
@@ -2763,7 +2929,8 @@
         self.dims = dims
 
 
-class For(mixins.BlockRangeMixIn, mixins.AssignTypeMixin, Statement):
+class For(mixins.MultiLineBlockMixin, mixins.BlockRangeMixIn,
+          mixins.AssignTypeMixin, Statement):
     """Class representing an :class:`ast.For` node.
 
     >>> node = astroid.extract_node('for thing in things: print(thing)')
@@ -2771,6 +2938,8 @@
     <For l.1 at 0x7f23b2e8cf28>
     """
     _astroid_fields = ('target', 'iter', 'body', 'orelse',)
+    _other_other_fields = ('type_annotation',)
+    _multi_line_block_fields = ('body', 'orelse')
     target = None
     """What the loop assigns to.
 
@@ -2791,9 +2960,14 @@
 
     :type: list(NodeNG) or None
     """
+    type_annotation = None
+    """If present, this will contain the type annotation passed by a type comment
+
+    :type: NodeNG or None
+    """
 
     # pylint: disable=redefined-builtin; had to use the same name as builtin ast module.
-    def postinit(self, target=None, iter=None, body=None, orelse=None):
+    def postinit(self, target=None, iter=None, body=None, orelse=None, type_annotation=None):
         """Do some setup after initialisation.
 
         :param target: What the loop assigns to.
@@ -2812,6 +2986,7 @@
         self.iter = iter
         self.body = body
         self.orelse = orelse
+        self.type_annotation = type_annotation
 
     optional_assign = True
     """Whether this node optionally assigns a variable.
@@ -2829,6 +3004,13 @@
         """
         return self.iter.tolineno
 
+    def get_children(self):
+        yield self.target
+        yield self.iter
+
+        yield from self.body
+        yield from self.orelse
+
 
 class AsyncFor(For):
     """Class representing an :class:`ast.AsyncFor` node.
@@ -2880,8 +3062,11 @@
         """
         self.value = value
 
+    def get_children(self):
+        yield self.value
+
 
-class ImportFrom(mixins.ImportFromMixin, Statement):
+class ImportFrom(mixins.NoChildrenMixin, mixins.ImportFromMixin, Statement):
     """Class representing an :class:`ast.ImportFrom` node.
 
     >>> node = astroid.extract_node('from my_package import my_module')
@@ -2982,8 +3167,11 @@
         """
         self.expr = expr
 
+    def get_children(self):
+        yield self.expr
 
-class Global(Statement):
+
+class Global(mixins.NoChildrenMixin, Statement):
     """Class representing an :class:`ast.Global` node.
 
     >>> node = astroid.extract_node('global a_global')
@@ -3019,7 +3207,7 @@
         return name
 
 
-class If(mixins.BlockRangeMixIn, Statement):
+class If(mixins.MultiLineBlockMixin, mixins.BlockRangeMixIn, Statement):
     """Class representing an :class:`ast.If` node.
 
     >>> node = astroid.extract_node('if condition: print(True)')
@@ -3027,6 +3215,7 @@
     <If l.1 at 0x7f23b2e9dd30>
     """
     _astroid_fields = ('test', 'body', 'orelse')
+    _multi_line_block_fields = ('body', 'orelse')
     test = None
     """The condition that the statement tests.
 
@@ -3084,6 +3273,14 @@
         return self._elsed_block_range(lineno, self.orelse,
                                        self.body[0].fromlineno - 1)
 
+    def get_children(self):
+        yield self.test
+
+        yield from self.body
+        yield from self.orelse
+
+    def has_elif_block(self):
+        return len(self.orelse) == 1 and isinstance(self.orelse[0], If)
 
 class IfExp(NodeNG):
     """Class representing an :class:`ast.IfExp` node.
@@ -3125,7 +3322,18 @@
         self.body = body
         self.orelse = orelse
 
-class Import(mixins.ImportFromMixin, Statement):
+    def get_children(self):
+        yield self.test
+        yield self.body
+        yield self.orelse
+
+    def op_left_associative(self):
+        # `1 if True else 2 if False else 3` is parsed as
+        # `1 if True else (2 if False else 3)`
+        return False
+
+
+class Import(mixins.NoChildrenMixin, mixins.ImportFromMixin, Statement):
     """Class representing an :class:`ast.Import` node.
 
     >>> node = astroid.extract_node('import astroid')
@@ -3187,6 +3395,9 @@
         """
         self.value = value
 
+    def get_children(self):
+        yield self.value
+
 
 class Keyword(NodeNG):
     """Class representing an :class:`ast.keyword` node.
@@ -3236,6 +3447,9 @@
         """
         self.value = value
 
+    def get_children(self):
+        yield self.value
+
 
 class List(_BaseContainer):
     """Class representing an :class:`ast.List` node.
@@ -3287,7 +3501,7 @@
         return _container_getitem(self, self.elts, index, context=context)
 
 
-class Nonlocal(Statement):
+class Nonlocal(mixins.NoChildrenMixin, Statement):
     """Class representing an :class:`ast.Nonlocal` node.
 
     >>> node = astroid.extract_node('''
@@ -3328,7 +3542,7 @@
         return name
 
 
-class Pass(Statement):
+class Pass(mixins.NoChildrenMixin, Statement):
     """Class representing an :class:`ast.Pass` node.
 
     >>> node = astroid.extract_node('pass')
@@ -3404,53 +3618,24 @@
 
     :type: NodeNG or None
     """
-    if six.PY2:
-        _astroid_fields = ('exc', 'inst', 'tback')
-        inst = None
-        """The "value" of the exception being raised.
+    _astroid_fields = ('exc', 'cause')
+    cause = None
+    """The exception being used to raise this one.
 
-        :type: NodeNG or None
-        """
-        tback = None
-        """The traceback object to raise with.
-
-        :type: NodeNG or None
-        """
-
-        def postinit(self, exc=None, inst=None, tback=None):
-            """Do some setup after initialisation.
-
-            :param exc: What is being raised.
-            :type exc: NodeNG or None
+    :type: NodeNG or None
+    """
 
-            :param inst: The "value" of the exception being raised.
-            :type inst: NodeNG or None
+    def postinit(self, exc=None, cause=None):
+        """Do some setup after initialisation.
 
-            :param tback: The traceback object to raise with.
-            :type tback: NodeNG or None
-            """
-            self.exc = exc
-            self.inst = inst
-            self.tback = tback
-    else:
-        _astroid_fields = ('exc', 'cause')
-        cause = None
-        """The exception being used to raise this one.
+        :param exc: What is being raised.
+        :type exc: NodeNG or None
 
-        :type: NodeNG or None
+        :param cause: The exception being used to raise this one.
+        :type cause: NodeNG or None
         """
-
-        def postinit(self, exc=None, cause=None):
-            """Do some setup after initialisation.
-
-            :param exc: What is being raised.
-            :type exc: NodeNG or None
-
-            :param cause: The exception being used to raise this one.
-            :type cause: NodeNG or None
-            """
-            self.exc = exc
-            self.cause = cause
+        self.exc = exc
+        self.cause = cause
 
     def raises_not_implemented(self):
         """Check if this node raises a :class:`NotImplementedError`.
@@ -3461,11 +3646,18 @@
         """
         if not self.exc:
             return False
-        for name in self.exc.nodes_of_class(Name):
+        for name in self.exc._get_name_nodes():
             if name.name == 'NotImplementedError':
                 return True
         return False
 
+    def get_children(self):
+        if self.exc is not None:
+            yield self.exc
+
+        if self.cause is not None:
+            yield self.cause
+
 
 class Return(Statement):
     """Class representing an :class:`ast.Return` node.
@@ -3489,6 +3681,16 @@
         """
         self.value = value
 
+    def get_children(self):
+        if self.value is not None:
+            yield self.value
+
+    def is_tuple_return(self):
+        return isinstance(self.value, Tuple)
+
+    def _get_return_nodes_skip_functions(self):
+        yield self
+
 
 class Set(_BaseContainer):
     """Class representing an :class:`ast.Set` node.
@@ -3586,12 +3788,21 @@
         elif attrname == 'step':
             yield self._wrap_attribute(self.step)
         else:
-            for value in self.getattr(attrname, context=context):
-                yield value
+            yield from self.getattr(attrname, context=context)
 
     def getattr(self, attrname, context=None):
         return self._proxied.getattr(attrname, context)
 
+    def get_children(self):
+        if self.lower is not None:
+            yield self.lower
+
+        if self.upper is not None:
+            yield self.upper
+
+        if self.step is not None:
+            yield self.step
+
 
 class Starred(mixins.ParentAssignTypeMixin, NodeNG):
     """Class representing an :class:`ast.Starred` node.
@@ -3640,6 +3851,9 @@
         """
         self.value = value
 
+    def get_children(self):
+        yield self.value
+
 
 class Subscript(NodeNG):
     """Class representing an :class:`ast.Subscript` node.
@@ -3698,8 +3912,12 @@
         self.value = value
         self.slice = slice
 
+    def get_children(self):
+        yield self.value
+        yield self.slice
+
 
-class TryExcept(mixins.BlockRangeMixIn, Statement):
+class TryExcept(mixins.MultiLineBlockMixin, mixins.BlockRangeMixIn, Statement):
     """Class representing an :class:`ast.TryExcept` node.
 
     >>> node = astroid.extract_node('''
@@ -3712,6 +3930,7 @@
     <TryExcept l.2 at 0x7f23b2e9d908>
     """
     _astroid_fields = ('body', 'handlers', 'orelse',)
+    _multi_line_block_fields = ('body', 'handlers', 'orelse')
     body = None
     """The contents of the block to catch exceptions from.
 
@@ -3767,8 +3986,15 @@
                 last = exhandler.body[0].fromlineno - 1
         return self._elsed_block_range(lineno, self.orelse, last)
 
+    def get_children(self):
+        yield from self.body
+
+        yield from self.handlers or ()
+        yield from self.orelse or ()
+
 
-class TryFinally(mixins.BlockRangeMixIn, Statement):
+class TryFinally(mixins.MultiLineBlockMixin,
+                 mixins.BlockRangeMixIn, Statement):
     """Class representing an :class:`ast.TryFinally` node.
 
     >>> node = astroid.extract_node('''
@@ -3783,6 +4009,7 @@
     <TryFinally l.2 at 0x7f23b2e41d68>
     """
     _astroid_fields = ('body', 'finalbody',)
+    _multi_line_block_fields = ('body', 'finalbody')
     body = None
     """The try-except that the finally is attached to.
 
@@ -3823,6 +4050,10 @@
             return child.block_range(lineno)
         return self._elsed_block_range(lineno, self.finalbody)
 
+    def get_children(self):
+        yield from self.body
+        yield from self.finalbody
+
 
 class Tuple(_BaseContainer):
     """Class representing an :class:`ast.Tuple` node.
@@ -3941,8 +4172,17 @@
         except exceptions.InferenceError:
             return []
 
+    def get_children(self):
+        yield self.operand
+
+    def op_precedence(self):
+        if self.op == 'not':
+            return OP_PRECEDENCE[self.op]
 
-class While(mixins.BlockRangeMixIn, Statement):
+        return super().op_precedence()
+
+
+class While(mixins.MultiLineBlockMixin, mixins.BlockRangeMixIn, Statement):
     """Class representing an :class:`ast.While` node.
 
     >>> node = astroid.extract_node('''
@@ -3953,6 +4193,7 @@
     <While l.2 at 0x7f23b2e4e390>
     """
     _astroid_fields = ('test', 'body', 'orelse',)
+    _multi_line_block_fields = ('body', 'orelse')
     test = None
     """The condition that the loop tests.
 
@@ -4005,8 +4246,15 @@
         """
         return self. _elsed_block_range(lineno, self.orelse)
 
+    def get_children(self):
+        yield self.test
+
+        yield from self.body
+        yield from self.orelse
+
 
-class With(mixins.BlockRangeMixIn, mixins.AssignTypeMixin, Statement):
+class With(mixins.MultiLineBlockMixin, mixins.BlockRangeMixIn,
+           mixins.AssignTypeMixin, Statement):
     """Class representing an :class:`ast.With` node.
 
     >>> node = astroid.extract_node('''
@@ -4016,7 +4264,9 @@
     >>> node
     <With l.2 at 0x7f23b2e4e710>
     """
-    _astroid_fields = ('items', 'body')
+    _astroid_fields = ('items', 'body',)
+    _other_other_fields = ('type_annotation',)
+    _multi_line_block_fields = ('body',)
     items = None
     """The pairs of context managers and the names they are assigned to.
 
@@ -4027,8 +4277,13 @@
 
     :type: list(NodeNG) or None
     """
+    type_annotation = None
+    """If present, this will contain the type annotation passed by a type comment
+
+    :type: NodeNG or None
+    """
 
-    def postinit(self, items=None, body=None):
+    def postinit(self, items=None, body=None, type_annotation=None):
         """Do some setup after initialisation.
 
         :param items: The pairs of context managers and the names
@@ -4040,6 +4295,7 @@
         """
         self.items = items
         self.body = body
+        self.type_annotation = type_annotation
 
     @decorators.cachedproperty
     def blockstart_tolineno(self):
@@ -4059,8 +4315,7 @@
             yield expr
             if var:
                 yield var
-        for elt in self.body:
-            yield elt
+        yield from self.body
 
 
 class AsyncWith(With):
@@ -4089,12 +4344,19 @@
         """
         self.value = value
 
+    def get_children(self):
+        if self.value is not None:
+            yield self.value
+
+    def _get_yield_nodes_skip_lambdas(self):
+        yield self
+
 
 class YieldFrom(Yield):
     """Class representing an :class:`ast.YieldFrom` node."""
 
 
-class DictUnpack(NodeNG):
+class DictUnpack(mixins.NoChildrenMixin, NodeNG):
     """Represents the unpacking of dicts into dicts using :pep:`448`."""
 
 
@@ -4148,6 +4410,12 @@
         self.conversion = conversion
         self.format_spec = format_spec
 
+    def get_children(self):
+        yield self.value
+
+        if self.format_spec is not None:
+            yield self.format_spec
+
 
 class JoinedStr(NodeNG):
     """Represents a list of string expressions to be joined.
@@ -4172,6 +4440,9 @@
         """
         self.values = values
 
+    def get_children(self):
+        yield from self.values
+
 
 class Unknown(mixins.AssignTypeMixin, NodeNG):
     """This node represents a node in a constructed AST where
@@ -4179,6 +4450,11 @@
     the args attribute of FunctionDef nodes where function signature
     introspection failed.
     """
+    name = "Unknown"
+
+    def qname(self):
+        return "Unknown"
+
     def infer(self, context=None, **kwargs):
         """Inference on an Unknown node immediately terminates."""
         yield util.Uninferable
@@ -4197,11 +4473,7 @@
 
 def _update_const_classes():
     """update constant classes, so the keys of CONST_CLS can be reused"""
-    klasses = (bool, int, float, complex, str)
-    if six.PY2:
-        # pylint: disable=undefined-variable
-        klasses += (unicode, long)
-    klasses += (bytes,)
+    klasses = (bool, int, float, complex, str, bytes)
     for kls in klasses:
         CONST_CLS[kls] = Const
 _update_const_classes()
@@ -4256,12 +4528,11 @@
         return node
 
 
-# Backward-compatibility aliases
-
-Backquote = util.proxy_alias('Backquote', Repr)
-Discard = util.proxy_alias('Discard', Expr)
-AssName = util.proxy_alias('AssName', AssignName)
-AssAttr = util.proxy_alias('AssAttr', AssignAttr)
-Getattr = util.proxy_alias('Getattr', Attribute)
-CallFunc = util.proxy_alias('CallFunc', Call)
-From = util.proxy_alias('From', ImportFrom)
+def is_from_decorator(node):
+    """Return True if the given node is the child of a decorator"""
+    parent = node.parent
+    while parent is not None:
+        if isinstance(parent, Decorators):
+            return True
+        parent = parent.parent
+    return False
diff -Nru astroid-1.6.5/astroid/nodes.py astroid-2.0/astroid/nodes.py
--- astroid-1.6.5/astroid/nodes.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/nodes.py	2018-07-15 09:19:26.000000000 +0200
@@ -1,7 +1,12 @@
 # Copyright (c) 2006-2011, 2013 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
-# Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2010 Daniel Harding <dharding@gmail.com>
+# Copyright (c) 2014-2018 Claudiu Popa <pcmanticore@gmail.com>
 # Copyright (c) 2014 Google, Inc.
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2016 Jared Garst <jgarst@users.noreply.github.com>
+# Copyright (c) 2017 Ashley Whetter <ashley@awhetter.co.uk>
+# Copyright (c) 2017 rr- <rr-@sakuya.pl>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -26,8 +31,6 @@
     const_factory,
     AsyncFor, Await, AsyncWith,
     FormattedValue, JoinedStr,
-    # Backwards-compatibility aliases
-    Backquote, Discard, AssName, AssAttr, Getattr, CallFunc, From,
     # Node not present in the builtin ast module.
     DictUnpack,
     Unknown,
@@ -36,8 +39,6 @@
     Module, GeneratorExp, Lambda, DictComp,
     ListComp, SetComp, FunctionDef, ClassDef,
     AsyncFunctionDef,
-    # Backwards-compatibility aliases
-    Class, Function, GenExpr,
 )
 
 
diff -Nru astroid-1.6.5/astroid/objects.py astroid-2.0/astroid/objects.py
--- astroid-1.6.5/astroid/objects.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/objects.py	2018-07-15 09:19:24.000000000 +0200
@@ -1,5 +1,8 @@
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
-# Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016, 2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>
+# Copyright (c) 2016 Derek Gustafson <degustaf@gmail.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -14,7 +17,7 @@
     Call(func=Name('frozenset'), args=Tuple(...))
 """
 
-import six
+import builtins
 
 from astroid import bases
 from astroid import decorators
@@ -25,7 +28,7 @@
 from astroid import util
 
 
-BUILTINS = six.moves.builtins.__name__
+BUILTINS = builtins.__name__
 objectmodel = util.lazy_import('interpreter.objectmodel')
 
 
@@ -40,8 +43,8 @@
 
     @decorators.cachedproperty
     def _proxied(self): # pylint: disable=method-hidden
-        builtins = MANAGER.astroid_cache[BUILTINS]
-        return builtins.getattr('frozenset')[0]
+        ast_builtins = MANAGER.astroid_cache[BUILTINS]
+        return ast_builtins.getattr('frozenset')[0]
 
 
 class Super(node_classes.NodeNG):
@@ -104,8 +107,8 @@
 
     @decorators.cachedproperty
     def _proxied(self):
-        builtins = MANAGER.astroid_cache[BUILTINS]
-        return builtins.getattr('super')[0]
+        ast_builtins = MANAGER.astroid_cache[BUILTINS]
+        return ast_builtins.getattr('super')[0]
 
     def pytype(self):
         return '%s.super' % BUILTINS
@@ -118,6 +121,9 @@
         """Get the name of the MRO pointer."""
         return self.mro_pointer.name
 
+    def qname(self):
+        return "super"
+
     def igetattr(self, name, context=None):
         """Retrieve the inferred values of the given attribute name."""
 
@@ -130,16 +136,16 @@
         # Don't let invalid MROs or invalid super calls
         # leak out as is from this function.
         except exceptions.SuperError as exc:
-            util.reraise(exceptions.AttributeInferenceError(
+            raise exceptions.AttributeInferenceError(
                 ('Lookup for {name} on {target!r} because super call {super!r} '
                  'is invalid.'),
-                target=self, attribute=name, context=context, super_=exc.super_))
+                target=self, attribute=name, context=context, super_=exc.super_) from exc
         except exceptions.MroError as exc:
-            util.reraise(exceptions.AttributeInferenceError(
+            raise exceptions.AttributeInferenceError(
                 ('Lookup for {name} on {target!r} failed because {cls!r} has an '
                  'invalid MRO.'),
                 target=self, attribute=name, context=context, mros=exc.mros,
-                cls=exc.cls))
+                cls=exc.cls) from exc
         found = False
         for cls in mro:
             if name not in cls.locals:
diff -Nru astroid-1.6.5/astroid/__pkginfo__.py astroid-2.0/astroid/__pkginfo__.py
--- astroid-1.6.5/astroid/__pkginfo__.py	2018-06-06 17:01:12.000000000 +0200
+++ astroid-2.0/astroid/__pkginfo__.py	2018-07-15 09:19:22.000000000 +0200
@@ -1,48 +1,38 @@
+# -*- coding: utf-8 -*-
 # Copyright (c) 2006-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
-# Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2014-2018 Claudiu Popa <pcmanticore@gmail.com>
 # Copyright (c) 2014 Google, Inc.
+# Copyright (c) 2015-2017 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>
+# Copyright (c) 2015 Radosław Ganczarek <radoslaw@ganczarek.in>
+# Copyright (c) 2016 Moises Lopez <moylop260@vauxoo.com>
+# Copyright (c) 2017 Hugo <hugovk@users.noreply.github.com>
+# Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
+# Copyright (c) 2017 Calen Pennington <cale@edx.org>
+# Copyright (c) 2018 Ashley Whetter <ashley@awhetter.co.uk>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
 
 """astroid packaging information"""
 
-from sys import version_info as py_version
-
-from pkg_resources import parse_version
-from setuptools import __version__ as setuptools_version
-
 distname = 'astroid'
 
 modname = 'astroid'
 
-version = '1.6.5'
-numversion = tuple(map(int, version.split('.')))
+version = '2.0'
+numversion = tuple(int(elem) for elem in version.split('.') if elem.isdigit())
 
 extras_require = {}
-install_requires = ['lazy_object_proxy', 'six', 'wrapt']
-
-
-def has_environment_marker_range_operators_support():
-    """Code extracted from 'pytest/setup.py'
-    https://github.com/pytest-dev/pytest/blob/7538680c/setup.py#L31
-
-    The first known release to support environment marker with range operators
-    it is 17.1, see: https://setuptools.readthedocs.io/en/latest/history.html#id113
-    """
-    return parse_version(setuptools_version) >= parse_version('17.1')
-
-
-if has_environment_marker_range_operators_support():
-    extras_require[':python_version<"3.4"'] = ['enum34>=1.1.3',
-                                               'singledispatch',
-                                               'backports.functools_lru_cache']
-else:
-    if py_version < (3, 4):
-        install_requires.extend(['enum34',
-                                 'singledispatch',
-                                 'backports.functools_lru_cache'])
+install_requires = [
+    'lazy_object_proxy',
+    'six',
+    'wrapt',
+    'typing;python_version<"3.5"',
+    'typed_ast;python_version<"3.7" and implementation_name== "cpython"'
 
+]
 
 # pylint: disable=redefined-builtin; why license is a builtin anyway?
 license = 'LGPL'
@@ -57,12 +47,11 @@
 classifiers = ["Topic :: Software Development :: Libraries :: Python Modules",
                "Topic :: Software Development :: Quality Assurance",
                "Programming Language :: Python",
-               "Programming Language :: Python :: 2",
-               "Programming Language :: Python :: 2.7",
                "Programming Language :: Python :: 3",
                "Programming Language :: Python :: 3.4",
                "Programming Language :: Python :: 3.5",
                "Programming Language :: Python :: 3.6",
+               "Programming Language :: Python :: 3.7",
                "Programming Language :: Python :: Implementation :: CPython",
                "Programming Language :: Python :: Implementation :: PyPy",
               ]
diff -Nru astroid-1.6.5/astroid/protocols.py astroid-2.0/astroid/protocols.py
--- astroid-1.6.5/astroid/protocols.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/protocols.py	2018-07-15 09:19:26.000000000 +0200
@@ -1,7 +1,17 @@
+# -*- coding: utf-8 -*-
 # Copyright (c) 2009-2011, 2013-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
-# Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2014-2018 Claudiu Popa <pcmanticore@gmail.com>
 # Copyright (c) 2014 Google, Inc.
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2014 Eevee (Alex Munroe) <amunroe@yelp.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2015 Dmitry Pribysh <dmand@yandex.ru>
+# Copyright (c) 2016 Derek Gustafson <degustaf@gmail.com>
+# Copyright (c) 2017-2018 Ashley Whetter <ashley@awhetter.co.uk>
+# Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
+# Copyright (c) 2017 rr- <rr-@sakuya.pl>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
+# Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>
+# Copyright (c) 2018 HoverHell <hoverhell@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -14,8 +24,7 @@
 import operator as operator_mod
 import sys
 
-import six
-
+from astroid import Store
 from astroid import arguments
 from astroid import bases
 from astroid import context as contextmod
@@ -39,7 +48,7 @@
 _CONTEXTLIB_MGR = 'contextlib.contextmanager'
 BIN_OP_METHOD = {'+':  '__add__',
                  '-':  '__sub__',
-                 '/':  '__div__' if six.PY2 else '__truediv__',
+                 '/':  '__truediv__',
                  '//': '__floordiv__',
                  '*':  '__mul__',
                  '**': '__pow__',
@@ -123,7 +132,7 @@
                 yield util.Uninferable
         except TypeError:
             yield not_implemented
-    elif isinstance(self.value, six.string_types) and operator == '%':
+    elif isinstance(self.value, str) and operator == '%':
         # TODO(cpopa): implement string interpolation later on.
         yield util.Uninferable
     else:
@@ -238,9 +247,7 @@
                 # we are not yet on the last part of the path
                 # search on each possibly inferred value
                 try:
-                    for inferred in _resolve_looppart(assigned.infer(context),
-                                                      asspath, context):
-                        yield inferred
+                    yield from _resolve_looppart(assigned.infer(context), asspath, context)
                 except exceptions.InferenceError:
                     break
 
@@ -248,21 +255,18 @@
 def for_assigned_stmts(self, node=None, context=None, asspath=None):
     if isinstance(self, nodes.AsyncFor) or getattr(self, 'is_async', False):
         # Skip inferring of async code for now
-        raise StopIteration(dict(node=self, unknown=node,
-                                 assign_path=asspath, context=context))
+        return dict(node=self, unknown=node,
+                    assign_path=asspath, context=context)
     if asspath is None:
         for lst in self.iter.infer(context):
             if isinstance(lst, (nodes.Tuple, nodes.List)):
-                for item in lst.elts:
-                    yield item
+                yield from lst.elts
     else:
-        for inferred in _resolve_looppart(self.iter.infer(context),
-                                          asspath, context):
-            yield inferred
+        yield from _resolve_looppart(self.iter.infer(context), asspath, context)
     # Explicit StopIteration to return error information, see comment
     # in raise_if_nothing_inferred.
-    raise StopIteration(dict(node=self, unknown=node,
-                             assign_path=asspath, context=context))
+    return dict(node=self, unknown=node,
+                assign_path=asspath, context=context)
 
 nodes.For.assigned_stmts = for_assigned_stmts
 nodes.Comprehension.assigned_stmts = for_assigned_stmts
@@ -273,10 +277,10 @@
         asspath = []
     try:
         index = self.elts.index(node)
-    except ValueError:
-        util.reraise(exceptions.InferenceError(
+    except ValueError as exc:
+        raise exceptions.InferenceError(
             'Tried to retrieve a node {node!r} which does not exist',
-            node=self, assign_path=asspath, context=context))
+            node=self, assign_path=asspath, context=context) from exc
 
     asspath.insert(0, index)
     return self.parent.assigned_stmts(node=self, context=context, asspath=asspath)
@@ -312,12 +316,12 @@
             return
 
     if context and context.callcontext:
-        call_site = arguments.CallSite(context.callcontext)
+        call_site = arguments.CallSite(context.callcontext,
+                                       context.extra_context)
         for value in call_site.infer_argument(self.parent, name, context):
             yield value
         return
 
-    # TODO: just provide the type here, no need to have an empty Dict.
     if name == self.vararg:
         vararg = nodes.const_factory(())
         vararg.parent = self
@@ -332,8 +336,7 @@
     # we can't guess given argument value
     try:
         context = contextmod.copy_context(context)
-        for inferred in self.default_value(name).infer(context):
-            yield inferred
+        yield from self.default_value(name).infer(context)
         yield util.Uninferable
     except exceptions.NoDefault:
         yield util.Uninferable
@@ -356,13 +359,13 @@
 def assign_assigned_stmts(self, node=None, context=None, asspath=None):
     if not asspath:
         yield self.value
-        return
-    for inferred in _resolve_asspart(self.value.infer(context), asspath, context):
-        yield inferred
+        return None
+    yield from _resolve_asspart(self.value.infer(context), asspath, context)
+
     # Explicit StopIteration to return error information, see comment
     # in raise_if_nothing_inferred.
-    raise StopIteration(dict(node=self, unknown=node,
-                             assign_path=asspath, context=context))
+    return dict(node=self, unknown=node,
+                assign_path=asspath, context=context)
 
 
 def assign_annassigned_stmts(self, node=None, context=None, asspath=None):
@@ -382,7 +385,15 @@
     asspath = asspath[:]
     index = asspath.pop(0)
     for part in parts:
-        if hasattr(part, 'getitem'):
+        assigned = None
+        if isinstance(part, nodes.Dict):
+            # A dictionary in an iterating context
+            try:
+                assigned, _ = part.items[index]
+            except IndexError:
+                return
+
+        elif hasattr(part, 'getitem'):
             index_node = nodes.Const(index)
             try:
                 assigned = part.getitem(index_node, context)
@@ -390,21 +401,23 @@
             # unexpected exception ?
             except (exceptions.AstroidTypeError, exceptions.AstroidIndexError):
                 return
-            if not asspath:
-                # we achieved to resolved the assignment path, don't infer the
-                # last part
-                yield assigned
-            elif assigned is util.Uninferable:
+
+        if not assigned:
+            return
+
+        if not asspath:
+            # we achieved to resolved the assignment path, don't infer the
+            # last part
+            yield assigned
+        elif assigned is util.Uninferable:
+            return
+        else:
+            # we are not yet on the last part of the path search on each
+            # possibly inferred value
+            try:
+                yield from _resolve_asspart(assigned.infer(context), asspath, context)
+            except exceptions.InferenceError:
                 return
-            else:
-                # we are not yet on the last part of the path search on each
-                # possibly inferred value
-                try:
-                    for inferred in _resolve_asspart(assigned.infer(context),
-                                                     asspath, context):
-                        yield inferred
-                except exceptions.InferenceError:
-                    return
 
 
 @decorators.raise_if_nothing_inferred
@@ -416,8 +429,8 @@
         yield assigned
     # Explicit StopIteration to return error information, see comment
     # in raise_if_nothing_inferred.
-    raise StopIteration(dict(node=self, unknown=node,
-                             assign_path=asspath, context=context))
+    return dict(node=self, unknown=node,
+                assign_path=asspath, context=context)
 
 
 nodes.ExceptHandler.assigned_stmts = excepthandler_assigned_stmts
@@ -426,7 +439,7 @@
 def _infer_context_manager(self, mgr, context):
     try:
         inferred = next(mgr.infer(context=context))
-    except exceptions.InferenceError:
+    except (StopIteration, exceptions.InferenceError):
         return
     if isinstance(inferred, bases.Generator):
         # Check if it is decorated with contextlib.contextmanager.
@@ -434,7 +447,10 @@
         if not func.decorators:
             return
         for decorator_node in func.decorators.nodes:
-            decorator = next(decorator_node.infer(context))
+            try:
+                decorator = next(decorator_node.infer(context))
+            except StopIteration:
+                return
             if isinstance(decorator, nodes.FunctionDef):
                 if decorator.qname() == _CONTEXTLIB_MGR:
                     break
@@ -444,25 +460,24 @@
 
         # Get the first yield point. If it has multiple yields,
         # then a RuntimeError will be raised.
-        # TODO(cpopa): Handle flows.
+
         possible_yield_points = func.nodes_of_class(nodes.Yield)
         # Ignore yields in nested functions
         yield_point = next((node for node in possible_yield_points
-                            if node.scope() == func), None)
+                            if node.scope() == func),
+                           None)
         if yield_point:
             if not yield_point.value:
-                # TODO(cpopa): an empty yield. Should be wrapped to Const.
                 const = nodes.Const(None)
                 const.parent = yield_point
                 const.lineno = yield_point.lineno
                 yield const
             else:
-                for inferred in yield_point.value.infer(context=context):
-                    yield inferred
+                yield from yield_point.value.infer(context=context)
     elif isinstance(inferred, bases.Instance):
         try:
             enter = next(inferred.igetattr('__enter__', context=context))
-        except (exceptions.InferenceError, exceptions.AttributeInferenceError):
+        except (StopIteration, exceptions.InferenceError, exceptions.AttributeInferenceError):
             return
         if not isinstance(enter, bases.BoundMethod):
             return
@@ -498,7 +513,10 @@
         context: TODO
         asspath: TODO
     """
-    mgr = next(mgr for (mgr, vars) in self.items if vars == node)
+    try:
+        mgr = next(mgr for (mgr, vars) in self.items if vars == node)
+    except StopIteration:
+        return None
     if asspath is None:
         for result in _infer_context_manager(self, mgr, context):
             yield result
@@ -514,21 +532,21 @@
                         context=context)
                 try:
                     obj = obj.elts[index]
-                except IndexError:
-                    util.reraise(exceptions.InferenceError(
+                except IndexError as exc:
+                    raise exceptions.InferenceError(
                         'Tried to infer a nonexistent target with index {index} '
                         'in {node!r}.', node=self, targets=node,
-                        assign_path=asspath, context=context))
-                except TypeError:
-                    util.reraise(exceptions.InferenceError(
+                        assign_path=asspath, context=context) from exc
+                except TypeError as exc:
+                    raise exceptions.InferenceError(
                         'Tried to unpack an non-iterable value '
                         'in {node!r}.', node=self, targets=node,
-                        assign_path=asspath, context=context))
+                        assign_path=asspath, context=context) from exc
             yield obj
     # Explicit StopIteration to return error information, see comment
     # in raise_if_nothing_inferred.
-    raise StopIteration(dict(node=self, unknown=node,
-                             assign_path=asspath, context=context))
+    return dict(node=self, unknown=node,
+                assign_path=asspath, context=context)
 
 nodes.With.assigned_stmts = with_assigned_stmts
 
@@ -542,6 +560,18 @@
         context: TODO
         asspath: TODO
     """
+    # pylint: disable=too-many-locals,too-many-branches,too-many-statements
+    def _determine_starred_iteration_lookups(starred, target, lookups):
+        # Determine the lookups for the rhs of the iteration
+        itered = target.itered()
+        for index, element in enumerate(itered):
+            if isinstance(element, nodes.Starred) and element.value.name == starred.value.name:
+                lookups.append((index, len(itered)))
+                break
+            if isinstance(element, nodes.Tuple):
+                lookups.append((index, len(element.itered())))
+                _determine_starred_iteration_lookups(starred, element, lookups)
+
     stmt = self.statement()
     if not isinstance(stmt, (nodes.Assign, nodes.For)):
         raise exceptions.InferenceError('Statement {stmt!r} enclosing {node!r} '
@@ -549,35 +579,33 @@
                                         node=self, stmt=stmt, unknown=node,
                                         context=context)
 
+    if context is None:
+        context = contextmod.InferenceContext()
+
     if isinstance(stmt, nodes.Assign):
         value = stmt.value
         lhs = stmt.targets[0]
 
-        if sum(1 for node in lhs.nodes_of_class(nodes.Starred)) > 1:
+        if sum(1 for _ in lhs.nodes_of_class(nodes.Starred)) > 1:
             raise exceptions.InferenceError('Too many starred arguments in the '
                                             ' assignment targets {lhs!r}.',
                                             node=self, targets=lhs,
                                             unknown=node, context=context)
 
-        if context is None:
-            context = contextmod.InferenceContext()
         try:
             rhs = next(value.infer(context))
         except exceptions.InferenceError:
             yield util.Uninferable
             return
-        if rhs is util.Uninferable or not hasattr(rhs, 'elts'):
-            # Not interested in inferred values without elts.
+        if rhs is util.Uninferable or not hasattr(rhs, 'itered'):
             yield util.Uninferable
             return
 
-        elts = collections.deque(rhs.elts[:])
-        if len(lhs.elts) > len(rhs.elts):
-            raise exceptions.InferenceError('More targets, {targets!r}, than '
-                                            'values to unpack, {values!r}.',
-                                            node=self, targets=lhs,
-                                            values=rhs, unknown=node,
-                                            context=context)
+        try:
+            elts = collections.deque(rhs.itered())
+        except TypeError:
+            yield util.Uninferable
+            return
 
         # Unpack iteratively the values from the rhs of the assignment,
         # until the find the starred node. What will remain will
@@ -588,18 +616,111 @@
 
         for index, left_node in enumerate(lhs.elts):
             if not isinstance(left_node, nodes.Starred):
+                if not elts:
+                    break
                 elts.popleft()
                 continue
             lhs_elts = collections.deque(reversed(lhs.elts[index:]))
             for right_node in lhs_elts:
                 if not isinstance(right_node, nodes.Starred):
+                    if not elts:
+                        break
                     elts.pop()
                     continue
                 # We're done
-                packed = nodes.List()
-                packed.elts = elts
-                packed.parent = self
+                packed = nodes.List(
+                    ctx=Store,
+                    parent=self,
+                    lineno=lhs.lineno,
+                    col_offset=lhs.col_offset,
+                )
+                packed.postinit(elts=elts)
                 yield packed
                 break
 
+    if isinstance(stmt, nodes.For):
+        try:
+            inferred_iterable = next(stmt.iter.infer(context=context))
+        except exceptions.InferenceError:
+            yield util.Uninferable
+            return
+        if inferred_iterable is util.Uninferable or not hasattr(inferred_iterable, 'itered'):
+            yield util.Uninferable
+            return
+        try:
+            itered = inferred_iterable.itered()
+        except TypeError:
+            yield util.Uninferable
+            return
+
+        target = stmt.target
+
+        if not isinstance(target, nodes.Tuple):
+            raise exceptions.InferenceError(
+                'Could not make sense of this, the target must be a tuple',
+                context=context,
+            )
+
+        lookups = []
+        _determine_starred_iteration_lookups(self, target, lookups)
+        if not lookups:
+            raise exceptions.InferenceError(
+                'Could not make sense of this, needs at least a lookup',
+                context=context,
+            )
+
+        # Make the last lookup a slice, since that what we want for a Starred node
+        last_element_index, last_element_length = lookups[-1]
+        is_starred_last = last_element_index == (last_element_length - 1)
+
+        lookup_slice = slice(
+            last_element_index,
+            None if is_starred_last else (last_element_length - last_element_index)
+        )
+        lookups[-1] = lookup_slice
+
+        for element in itered:
+
+            # We probably want to infer the potential values *for each* element in an
+            # iterable, but we can't infer a list of all values, when only a list of
+            # step values are expected:
+            #
+            # for a, *b in [...]:
+            #   b
+            #
+            # *b* should now point to just the elements at that particular iteration step,
+            # which astroid can't know about.
+
+            found_element = None
+            for lookup in lookups:
+                if not hasattr(element, 'itered'):
+                    break
+                if not isinstance(lookup, slice):
+                    # Grab just the index, not the whole length
+                    lookup = lookup[0]
+                try:
+                    itered_inner_element = element.itered()
+                    element = itered_inner_element[lookup]
+                except IndexError:
+                    break
+                except TypeError:
+                    # Most likely the itered() call failed, cannot make sense of this
+                    yield util.Uninferable
+                    return
+                else:
+                    found_element = element
+
+            unpacked = nodes.List(
+                ctx=Store,
+                parent=self,
+                lineno=self.lineno,
+                col_offset=self.col_offset,
+            )
+            unpacked.postinit(elts=found_element or [])
+            yield unpacked
+            return
+
+        yield util.Uninferable
+
+
 nodes.Starred.assigned_stmts = starred_assigned_stmts
diff -Nru astroid-1.6.5/astroid/raw_building.py astroid-2.0/astroid/raw_building.py
--- astroid-1.6.5/astroid/raw_building.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/raw_building.py	2018-07-15 09:19:25.000000000 +0200
@@ -1,7 +1,14 @@
 # Copyright (c) 2006-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
-# Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2012 FELD Boris <lothiraldan@gmail.com>
+# Copyright (c) 2014-2018 Claudiu Popa <pcmanticore@gmail.com>
 # Copyright (c) 2014 Google, Inc.
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>
+# Copyright (c) 2015 Ovidiu Sabou <ovidiu@sabou.org>
+# Copyright (c) 2016 Derek Gustafson <degustaf@gmail.com>
+# Copyright (c) 2016 Jakub Wilk <jwilk@jwilk.net>
+# Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -10,14 +17,13 @@
 (build_* functions) or from living object (object_build_* functions)
 """
 
+import builtins
 import inspect
 import logging
 import os
 import sys
 import types
 
-import six
-
 from astroid import bases
 from astroid import manager
 from astroid import node_classes
@@ -26,9 +32,9 @@
 
 MANAGER = manager.AstroidManager()
 # the keys of CONST_CLS eg python builtin types
+
 _CONSTANTS = tuple(node_classes.CONST_CLS)
-_JYTHON = os.name == 'java'
-_BUILTINS = vars(six.moves.builtins)
+_BUILTINS = vars(builtins)
 _LOG = logging.getLogger(__name__)
 
 
@@ -221,7 +227,7 @@
 def _build_from_function(node, name, member, module):
     # verify this is not an imported function
     try:
-        code = six.get_function_code(member)
+        code = member.__code__
     except AttributeError:
         # Some implementations don't provide the code object,
         # such as Jython.
@@ -236,7 +242,7 @@
         object_build_function(node, member, name)
 
 
-class InspectBuilder(object):
+class InspectBuilder:
     """class for building nodes from living object
 
     this is actually a really minimal representation, including only Module,
@@ -285,7 +291,7 @@
                 attach_dummy_node(node, name)
                 continue
             if inspect.ismethod(member):
-                member = six.get_method_function(member)
+                member = member.__func__
             if inspect.isfunction(member):
                 _build_from_function(node, name, member, self._module)
             elif inspect.isbuiltin(member):
@@ -335,12 +341,11 @@
                            'astroid from living object')
             modname = None
         if modname is None:
-            if (name in ('__new__', '__subclasshook__')
-                    or (name in _BUILTINS and _JYTHON)):
+            if name in ('__new__', '__subclasshook__'):
                 # Python 2.5.1 (r251:54863, Sep  1 2010, 22:03:14)
                 # >>> print object.__new__.__module__
                 # None
-                modname = six.moves.builtins.__name__
+                modname = builtins.__name__
             else:
                 attach_dummy_node(node, name, member)
                 return True
@@ -372,7 +377,6 @@
     # this boot strapping is necessary since we need the Const nodes to
     # inspect_build builtins, and then we can proxy Const
     if astroid_builtin is None:
-        from six.moves import builtins
         astroid_builtin = Astroid_BUILDER.inspect_build(builtins)
 
     # pylint: disable=redefined-outer-name
@@ -393,18 +397,16 @@
 _astroid_bootstrapping()
 
 # TODO : find a nicer way to handle this situation;
-# However __proxied introduced an
-# infinite recursion (see https://bugs.launchpad.net/pylint/+bug/456870)
 def _set_proxied(const):
     return _CONST_PROXY[const.value.__class__]
 nodes.Const._proxied = property(_set_proxied)
 
 _GeneratorType = nodes.ClassDef(types.GeneratorType.__name__, types.GeneratorType.__doc__)
-_GeneratorType.parent = MANAGER.astroid_cache[six.moves.builtins.__name__]
+_GeneratorType.parent = MANAGER.astroid_cache[builtins.__name__]
 bases.Generator._proxied = _GeneratorType
 Astroid_BUILDER.object_build(bases.Generator._proxied, types.GeneratorType)
 
-_builtins = MANAGER.astroid_cache[six.moves.builtins.__name__]
+_builtins = MANAGER.astroid_cache[builtins.__name__]
 BUILTIN_TYPES = (types.GetSetDescriptorType, types.GeneratorType,
                  types.MemberDescriptorType, type(None), type(NotImplemented),
                  types.FunctionType, types.MethodType,
@@ -412,6 +414,6 @@
 for _type in BUILTIN_TYPES:
     if _type.__name__ not in _builtins:
         cls = nodes.ClassDef(_type.__name__, _type.__doc__)
-        cls.parent = MANAGER.astroid_cache[six.moves.builtins.__name__]
+        cls.parent = MANAGER.astroid_cache[builtins.__name__]
         Astroid_BUILDER.object_build(cls, _type)
         _builtins[_type.__name__] = cls
diff -Nru astroid-1.6.5/astroid/rebuilder.py astroid-2.0/astroid/rebuilder.py
--- astroid-1.6.5/astroid/rebuilder.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/rebuilder.py	2018-07-15 09:19:27.000000000 +0200
@@ -1,7 +1,17 @@
+# -*- coding: utf-8 -*-
 # Copyright (c) 2009-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
-# Copyright (c) 2013-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2013-2018 Claudiu Popa <pcmanticore@gmail.com>
 # Copyright (c) 2013-2014 Google, Inc.
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2014 Alexander Presnyakov <flagist0@gmail.com>
+# Copyright (c) 2014 Eevee (Alex Munroe) <amunroe@yelp.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2016-2017 Derek Gustafson <degustaf@gmail.com>
+# Copyright (c) 2016 Jared Garst <jgarst@users.noreply.github.com>
+# Copyright (c) 2017 Hugo <hugovk@users.noreply.github.com>
+# Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
+# Copyright (c) 2017 rr- <rr-@sakuya.pl>
+# Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -11,52 +21,12 @@
 """
 
 import sys
-import _ast
 
 import astroid
-from astroid import astpeephole
+from astroid._ast import _parse, _get_parser_module, parse_function_type_comment
 from astroid import nodes
 
 
-
-_BIN_OP_CLASSES = {_ast.Add: '+',
-                   _ast.BitAnd: '&',
-                   _ast.BitOr: '|',
-                   _ast.BitXor: '^',
-                   _ast.Div: '/',
-                   _ast.FloorDiv: '//',
-                   _ast.Mod: '%',
-                   _ast.Mult: '*',
-                   _ast.Pow: '**',
-                   _ast.Sub: '-',
-                   _ast.LShift: '<<',
-                   _ast.RShift: '>>',
-                  }
-if sys.version_info >= (3, 5):
-    _BIN_OP_CLASSES[_ast.MatMult] = '@'
-
-_BOOL_OP_CLASSES = {_ast.And: 'and',
-                    _ast.Or: 'or',
-                   }
-
-_UNARY_OP_CLASSES = {_ast.UAdd: '+',
-                     _ast.USub: '-',
-                     _ast.Not: 'not',
-                     _ast.Invert: '~',
-                    }
-
-_CMP_OP_CLASSES = {_ast.Eq: '==',
-                   _ast.Gt: '>',
-                   _ast.GtE: '>=',
-                   _ast.In: 'in',
-                   _ast.Is: 'is',
-                   _ast.IsNot: 'is not',
-                   _ast.Lt: '<',
-                   _ast.LtE: '<=',
-                   _ast.NotEq: '!=',
-                   _ast.NotIn: 'not in',
-                  }
-
 CONST_NAME_TRANSFORMS = {'None':  None,
                          'True':  True,
                          'False': False,
@@ -71,21 +41,68 @@
            }
 PY3 = sys.version_info >= (3, 0)
 PY34 = sys.version_info >= (3, 4)
-CONTEXTS = {_ast.Load: astroid.Load,
-            _ast.Store: astroid.Store,
-            _ast.Del: astroid.Del,
-            _ast.Param: astroid.Store}
+PY37 = sys.version_info >= (3, 7)
+
 
+def _binary_operators_from_module(module):
+    binary_operators = {
+        module.Add: '+',
+        module.BitAnd: '&',
+        module.BitOr: '|',
+        module.BitXor: '^',
+        module.Div: '/',
+        module.FloorDiv: '//',
+        module.Mod: '%',
+        module.Mult: '*',
+        module.Pow: '**',
+        module.Sub: '-',
+        module.LShift: '<<',
+        module.RShift: '>>',
+    }
+    if sys.version_info >= (3, 5):
+        binary_operators[module.MatMult] = '@'
+    return binary_operators
+
+
+def _bool_operators_from_module(module):
+    return {
+        module.And: 'and',
+        module.Or: 'or',
+    }
+
+
+def _unary_operators_from_module(module):
+    return {
+        module.UAdd: '+',
+        module.USub: '-',
+        module.Not: 'not',
+        module.Invert: '~',
+    }
+
+
+def _compare_operators_from_module(module):
+    return {
+        module.Eq: '==',
+        module.Gt: '>',
+        module.GtE: '>=',
+        module.In: 'in',
+        module.Is: 'is',
+        module.IsNot: 'is not',
+        module.Lt: '<',
+        module.LtE: '<=',
+        module.NotEq: '!=',
+        module.NotIn: 'not in',
+    }
+
+
+def _contexts_from_module(module):
+    return {
+        module.Load: astroid.Load,
+        module.Store: astroid.Store,
+        module.Del: astroid.Del,
+        module.Param: astroid.Store,
+    }
 
-def _get_doc(node):
-    try:
-        if isinstance(node.body[0], _ast.Expr) and isinstance(node.body[0].value, _ast.Str):
-            doc = node.body[0].value.s
-            node.body = node.body[1:]
-            return node, doc
-    except IndexError:
-        pass # ast built from scratch
-    return node, None
 
 def _visit_or_none(node, attr, visitor, parent, visit='visit',
                    **kws):
@@ -100,25 +117,47 @@
     return None
 
 
-def _get_context(node):
-    return CONTEXTS.get(type(node.ctx), astroid.Load)
-
-
-class TreeRebuilder(object):
+class TreeRebuilder:
     """Rebuilds the _ast tree to become an Astroid tree"""
 
-    def __init__(self, manager):
+    def __init__(self, manager, parse_python_two: bool = False):
         self._manager = manager
         self._global_names = []
         self._import_from_nodes = []
         self._delayed_assattr = []
         self._visit_meths = {}
-        self._peepholer = astpeephole.ASTPeepholeOptimizer()
+
+        # Configure the right classes for the right module
+        self._parser_module = _get_parser_module(parse_python_two=parse_python_two)
+        self._unary_op_classes = _unary_operators_from_module(self._parser_module)
+        self._cmp_op_classes = _compare_operators_from_module(self._parser_module)
+        self._bool_op_classes = _bool_operators_from_module(self._parser_module)
+        self._bin_op_classes = _binary_operators_from_module(self._parser_module)
+        self._context_classes = _contexts_from_module(self._parser_module)
+
+    def _get_doc(self, node):
+        try:
+            if PY37 and hasattr(node, 'docstring'):
+                doc = node.docstring
+                return node, doc
+            if (node.body
+                    and isinstance(node.body[0], self._parser_module.Expr)
+                    and isinstance(node.body[0].value, self._parser_module.Str)):
+                doc = node.body[0].value.s
+                node.body = node.body[1:]
+                return node, doc
+        except IndexError:
+            pass  # ast built from scratch
+        return node, None
+
+    def _get_context(self, node):
+        return self._context_classes.get(type(node.ctx), astroid.Load)
 
     def visit_module(self, node, modname, modpath, package):
         """visit a Module node by returning a fresh instance of it"""
-        node, doc = _get_doc(node)
-        newnode = nodes.Module(name=modname, doc=doc, file=modpath, path=modpath,
+        node, doc = self._get_doc(node)
+        newnode = nodes.Module(name=modname, doc=doc, file=modpath,
+                               path=[modpath],
                                package=package, parent=None)
         newnode.postinit([self.visit(child, newnode) for child in node.body])
         return newnode
@@ -213,12 +252,50 @@
         newnode.postinit(self.visit(node.test, newnode), msg)
         return newnode
 
+    def check_type_comment(self, node):
+        type_comment = getattr(node, 'type_comment', None)
+        if not type_comment:
+            return None
+
+        try:
+            type_comment_ast = _parse(type_comment)
+        except SyntaxError:
+            # Invalid type comment, just skip it.
+            return None
+
+        type_object = self.visit(type_comment_ast.body[0], node)
+        if not isinstance(type_object, nodes.Expr):
+            return None
+
+        return type_object.value
+
+    def check_function_type_comment(self, node):
+        type_comment = getattr(node, 'type_comment', None)
+        if not type_comment:
+            return None
+
+        try:
+            type_comment_ast = parse_function_type_comment(type_comment)
+        except SyntaxError:
+            # Invalid type comment, just skip it.
+            return None
+
+        returns = None
+        argtypes = [self.visit(elem, node) for elem in (type_comment_ast.argtypes or [])]
+        if type_comment_ast.returns:
+            returns = self.visit(type_comment_ast.returns, node)
+
+        return returns, argtypes
+
     def visit_assign(self, node, parent):
         """visit a Assign node by returning a fresh instance of it"""
+        type_annotation = self.check_type_comment(node)
         newnode = nodes.Assign(node.lineno, node.col_offset, parent)
-        newnode.postinit([self.visit(child, newnode)
-                          for child in node.targets],
-                         self.visit(node.value, newnode))
+        newnode.postinit(
+            targets=[self.visit(child, newnode) for child in node.targets],
+            value=self.visit(node.value, newnode),
+            type_annotation=type_annotation,
+        )
         return newnode
 
     def visit_assignname(self, node, parent, node_name=None):
@@ -230,7 +307,7 @@
 
     def visit_augassign(self, node, parent):
         """visit a AugAssign node by returning a fresh instance of it"""
-        newnode = nodes.AugAssign(_BIN_OP_CLASSES[type(node.op)] + "=",
+        newnode = nodes.AugAssign(self._bin_op_classes[type(node.op)] + "=",
                                   node.lineno, node.col_offset, parent)
         newnode.postinit(self.visit(node.target, newnode),
                          self.visit(node.value, newnode))
@@ -244,24 +321,7 @@
 
     def visit_binop(self, node, parent):
         """visit a BinOp node by returning a fresh instance of it"""
-        if isinstance(node.left, _ast.BinOp) and self._manager.optimize_ast:
-            # Optimize BinOp operations in order to remove
-            # redundant recursion. For instance, if the
-            # following code is parsed in order to obtain
-            # its ast, then the rebuilder will fail with an
-            # infinite recursion, the same will happen with the
-            # inference engine as well. There's no need to hold
-            # so many objects for the BinOp if they can be reduced
-            # to something else (also, the optimization
-            # might handle only Const binops, which isn't a big
-            # problem for the correctness of the program).
-            #
-            # ("a" + "b" + # one thousand more + "c")
-            optimized = self._peepholer.optimize_binop(node, parent)
-            if optimized:
-                return optimized
-
-        newnode = nodes.BinOp(_BIN_OP_CLASSES[type(node.op)],
+        newnode = nodes.BinOp(self._bin_op_classes[type(node.op)],
                               node.lineno, node.col_offset, parent)
         newnode.postinit(self.visit(node.left, newnode),
                          self.visit(node.right, newnode))
@@ -269,7 +329,7 @@
 
     def visit_boolop(self, node, parent):
         """visit a BoolOp node by returning a fresh instance of it"""
-        newnode = nodes.BoolOp(_BOOL_OP_CLASSES[type(node.op)],
+        newnode = nodes.BoolOp(self._bool_op_classes[type(node.op)],
                                node.lineno, node.col_offset, parent)
         newnode.postinit([self.visit(child, newnode)
                           for child in node.values])
@@ -316,7 +376,7 @@
 
     def visit_classdef(self, node, parent, newstyle=None):
         """visit a ClassDef node to become astroid"""
-        node, doc = _get_doc(node)
+        node, doc = self._get_doc(node)
         newnode = nodes.ClassDef(node.name, doc, node.lineno,
                                  node.col_offset, parent)
         metaclass = None
@@ -354,7 +414,7 @@
         """visit a Compare node by returning a fresh instance of it"""
         newnode = nodes.Compare(node.lineno, node.col_offset, parent)
         newnode.postinit(self.visit(node.left, newnode),
-                         [(_CMP_OP_CLASSES[op.__class__],
+                         [(self._cmp_op_classes[op.__class__],
                            self.visit(expr, newnode))
                           for (op, expr) in zip(node.ops, node.comparators)])
         return newnode
@@ -459,12 +519,14 @@
     def _visit_for(self, cls, node, parent):
         """visit a For node by returning a fresh instance of it"""
         newnode = cls(node.lineno, node.col_offset, parent)
-        newnode.postinit(self.visit(node.target, newnode),
-                         self.visit(node.iter, newnode),
-                         [self.visit(child, newnode)
-                          for child in node.body],
-                         [self.visit(child, newnode)
-                          for child in node.orelse])
+        type_annotation = self.check_type_comment(node)
+        newnode.postinit(
+            target=self.visit(node.target, newnode),
+            iter=self.visit(node.iter, newnode),
+            body=[self.visit(child, newnode) for child in node.body],
+            orelse=[self.visit(child, newnode) for child in node.orelse],
+            type_annotation=type_annotation,
+        )
         return newnode
 
     def visit_for(self, node, parent):
@@ -483,7 +545,7 @@
     def _visit_functiondef(self, cls, node, parent):
         """visit an FunctionDef node to become astroid"""
         self._global_names.append({})
-        node, doc = _get_doc(node)
+        node, doc = self._get_doc(node)
         newnode = cls(node.name, doc, node.lineno,
                       node.col_offset, parent)
         if node.decorator_list:
@@ -494,10 +556,19 @@
             returns = self.visit(node.returns, newnode)
         else:
             returns = None
-        newnode.postinit(self.visit(node.args, newnode),
-                         [self.visit(child, newnode)
-                          for child in node.body],
-                         decorators, returns)
+
+        type_comment_args = type_comment_returns = None
+        type_comment_annotation = self.check_function_type_comment(node)
+        if type_comment_annotation:
+            type_comment_returns, type_comment_args = type_comment_annotation
+        newnode.postinit(
+            args=self.visit(node.args, newnode),
+            body=[self.visit(child, newnode) for child in node.body],
+            decorators=decorators,
+            returns=returns,
+            type_comment_returns=type_comment_returns,
+            type_comment_args=type_comment_args,
+        )
         self._global_names.pop()
         return newnode
 
@@ -514,7 +585,7 @@
 
     def visit_attribute(self, node, parent):
         """visit an Attribute node by returning a fresh instance of it"""
-        context = _get_context(node)
+        context = self._get_context(node)
         if context == astroid.Del:
             # FIXME : maybe we should reintroduce and visit_delattr ?
             # for instance, deactivating assign_ctx
@@ -591,7 +662,7 @@
 
     def visit_list(self, node, parent):
         """visit a List node by returning a fresh instance of it"""
-        context = _get_context(node)
+        context = self._get_context(node)
         newnode = nodes.List(ctx=context,
                              lineno=node.lineno,
                              col_offset=node.col_offset,
@@ -610,7 +681,7 @@
 
     def visit_name(self, node, parent):
         """visit a Name node by returning a fresh instance of it"""
-        context = _get_context(node)
+        context = self._get_context(node)
         # True and False can be assigned to something in py2x, so we have to
         # check first the context.
         if context == astroid.Del:
@@ -657,6 +728,7 @@
     def visit_raise(self, node, parent):
         """visit a Raise node by returning a fresh instance of it"""
         newnode = nodes.Raise(node.lineno, node.col_offset, parent)
+        # pylint: disable=too-many-function-args
         newnode.postinit(_visit_or_none(node, 'type', self, newnode),
                          _visit_or_none(node, 'inst', self, newnode),
                          _visit_or_none(node, 'tback', self, newnode))
@@ -694,7 +766,7 @@
 
     def visit_subscript(self, node, parent):
         """visit a Subscript node by returning a fresh instance of it"""
-        context = _get_context(node)
+        context = self._get_context(node)
         newnode = nodes.Subscript(ctx=context,
                                   lineno=node.lineno,
                                   col_offset=node.col_offset,
@@ -725,7 +797,7 @@
 
     def visit_tuple(self, node, parent):
         """visit a Tuple node by returning a fresh instance of it"""
-        context = _get_context(node)
+        context = self._get_context(node)
         newnode = nodes.Tuple(ctx=context,
                               lineno=node.lineno,
                               col_offset=node.col_offset,
@@ -736,7 +808,7 @@
 
     def visit_unaryop(self, node, parent):
         """visit a UnaryOp node by returning a fresh instance of it"""
-        newnode = nodes.UnaryOp(_UNARY_OP_CLASSES[node.op.__class__],
+        newnode = nodes.UnaryOp(self._unary_op_classes[node.op.__class__],
                                 node.lineno, node.col_offset, parent)
         newnode.postinit(self.visit(node.operand, newnode))
         return newnode
@@ -758,9 +830,13 @@
             optional_vars = self.visit(node.optional_vars, newnode)
         else:
             optional_vars = None
-        newnode.postinit([(expr, optional_vars)],
-                         [self.visit(child, newnode)
-                          for child in node.body])
+
+        type_annotation = self.check_type_comment(node)
+        newnode.postinit(
+            items=[(expr, optional_vars)],
+            body=[self.visit(child, newnode) for child in node.body],
+            type_annotation=type_annotation,
+        )
         return newnode
 
     def visit_yield(self, node, parent):
@@ -776,7 +852,6 @@
 
     def visit_arg(self, node, parent):
         """visit a arg node by returning a fresh AssName instance"""
-        # TODO(cpopa): introduce an Arg node instead of using AssignName.
         return self.visit_assignname(node, parent, node.arg)
 
     def visit_nameconstant(self, node, parent):
@@ -802,7 +877,6 @@
         return nodes.Nonlocal(node.names, getattr(node, 'lineno', None),
                               getattr(node, 'col_offset', None), parent)
 
-
     def visit_raise(self, node, parent):
         """visit a Raise node by returning a fresh instance of it"""
         newnode = nodes.Raise(node.lineno, node.col_offset, parent)
@@ -813,7 +887,7 @@
 
     def visit_starred(self, node, parent):
         """visit a Starred node and return a new instance of it"""
-        context = _get_context(node)
+        context = self._get_context(node)
         newnode = nodes.Starred(ctx=context, lineno=node.lineno,
                                 col_offset=node.col_offset,
                                 parent=parent)
@@ -858,9 +932,13 @@
             expr = self.visit(child.context_expr, newnode)
             var = _visit_or_none(child, 'optional_vars', self, newnode)
             return expr, var
-        newnode.postinit([visit_child(child) for child in node.items],
-                         [self.visit(child, newnode)
-                          for child in node.body])
+
+        type_annotation = self.check_type_comment(node)
+        newnode.postinit(
+            items=[visit_child(child) for child in node.items],
+            body=[self.visit(child, newnode) for child in node.body],
+            type_annotation=type_annotation,
+        )
         return newnode
 
     def visit_with(self, node, parent):
diff -Nru astroid-1.6.5/astroid/scoped_nodes.py astroid-2.0/astroid/scoped_nodes.py
--- astroid-1.6.5/astroid/scoped_nodes.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/scoped_nodes.py	2018-07-15 09:19:31.000000000 +0200
@@ -1,8 +1,22 @@
+# -*- coding: utf-8 -*-
 # Copyright (c) 2006-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
+# Copyright (c) 2010 Daniel Harding <dharding@gmail.com>
 # Copyright (c) 2011, 2013-2015 Google, Inc.
-# Copyright (c) 2013-2016 Claudiu Popa <pcmanticore@gmail.com>
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2013-2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2013 Phil Schaf <flying-sheep@web.de>
+# Copyright (c) 2014 Eevee (Alex Munroe) <amunroe@yelp.com>
+# Copyright (c) 2015-2016 Florian Bruhin <me@the-compiler.org>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
 # Copyright (c) 2015 Rene Zhang <rz99@cornell.edu>
+# Copyright (c) 2015 Philip Lorenz <philip@bithub.de>
+# Copyright (c) 2016-2017 Derek Gustafson <degustaf@gmail.com>
+# Copyright (c) 2017-2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
+# Copyright (c) 2017-2018 Ashley Whetter <ashley@awhetter.co.uk>
+# Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
+# Copyright (c) 2017 David Euresti <david@dropbox.com>
+# Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>
+# Copyright (c) 2018 Anthony Sottile <asottile@umich.edu>
+# Copyright (c) 2018 HoverHell <hoverhell@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -14,12 +28,11 @@
 Lambda, GeneratorExp, DictComp and SetComp to some extent).
 """
 
+import builtins
 import sys
 import io
 import itertools
-import warnings
-
-import six
+from typing import Optional, List
 
 from astroid import bases
 from astroid import context as contextmod
@@ -33,7 +46,7 @@
 from astroid import util
 
 
-BUILTINS = six.moves.builtins.__name__
+BUILTINS = builtins.__name__
 ITER_METHODS = ('__iter__', '__getitem__')
 
 
@@ -96,7 +109,7 @@
     return the list of matching statements and the astroid for the builtin
     module
     """
-    builtin_astroid = MANAGER.ast_from_module(six.moves.builtins)
+    builtin_astroid = MANAGER.ast_from_module(builtins)
     if name == '__dict__':
         return builtin_astroid, ()
     try:
@@ -355,7 +368,9 @@
                      'pure_python', 'future_imports')
     _other_other_fields = ('locals', 'globals')
 
-    def __init__(self, name, doc, file=None, path=None, package=None,
+    def __init__(self, name, doc, file=None,
+                 path: Optional[List[str]] = None,
+                 package=None,
                  parent=None, pure_python=True):
         """
         :param name: The name of the module.
@@ -368,7 +383,7 @@
         :type file: str or None
 
         :param path:
-        :type path: str or None
+        :type path: Optional[List[str]]
 
         :param package: Whether the node represents a package or a module.
         :type package: bool or None
@@ -418,8 +433,6 @@
     def stream(self):
         """Get a stream to the underlying file or bytes.
 
-        .. deprecated:: 1.5
-
         :type: file or io.BytesIO or None
         """
         return self._get_stream()
@@ -487,10 +500,12 @@
         elif self.package:
             try:
                 result = [self.import_module(name, relative_only=True)]
-            except (exceptions.AstroidBuildingError, SyntaxError):
-                util.reraise(exceptions.AttributeInferenceError(target=self,
-                                                                attribute=name,
-                                                                context=context))
+            except (exceptions.AstroidBuildingError, SyntaxError) as exc:
+                raise exceptions.AttributeInferenceError(
+                    target=self,
+                    attribute=name,
+                    context=context,
+                ) from exc
         result = [n for n in result if not isinstance(n, node_classes.DelName)]
         if result:
             return result
@@ -514,8 +529,12 @@
             return bases._infer_stmts(self.getattr(name, context),
                                       context, frame=self)
         except exceptions.AttributeInferenceError as error:
-            util.reraise(exceptions.InferenceError(
-                error.message, target=self, attribute=name, context=context))
+            raise exceptions.InferenceError(
+                error.message,
+                target=self,
+                attribute=name,
+                context=context,
+            ) from error
 
     def fully_defined(self):
         """Check if this module has been build from a .py file.
@@ -536,31 +555,21 @@
         """
         return self
 
-    def previous_sibling(self): #pylint: disable=useless-return
+    def previous_sibling(self):
         """The previous sibling statement.
 
         :returns: The previous sibling statement node.
         :rtype: NodeNG or None
         """
-        return
 
-    def next_sibling(self): #pylint: disable=useless-return
+    def next_sibling(self):
         """The next sibling statement node.
 
         :returns: The next sibling statement node.
         :rtype: NodeNG or None
         """
-        return
 
-    if six.PY2:
-        @decorators_mod.cachedproperty
-        def _absolute_import_activated(self):
-            for stmt in self.locals.get('absolute_import', ()):
-                if isinstance(stmt, node_classes.ImportFrom) and stmt.modname == '__future__':
-                    return True
-            return False
-    else:
-        _absolute_import_activated = True
+    _absolute_import_activated = True
 
     def absolute_import_activated(self):
         """Whether :pep:`328` absolute import behaviour has been enabled.
@@ -675,7 +684,7 @@
             return default
 
         str_const = lambda node: (isinstance(node, node_classes.Const) and
-                                  isinstance(node.value, six.string_types))
+                                  isinstance(node.value, str))
         for node in explicit.elts:
             if str_const(node):
                 inferred.append(node.value)
@@ -705,6 +714,9 @@
         """
         return True
 
+    def get_children(self):
+        yield from self.body
+
 
 class ComprehensionScope(LocalsDictNodeNG):
     """Scoping for different types of comprehensions."""
@@ -786,6 +798,11 @@
         """
         return True
 
+    def get_children(self):
+        yield self.elt
+
+        yield from self.generators
+
 
 class DictComp(ComprehensionScope):
     """Class representing an :class:`ast.DictComp` node.
@@ -860,6 +877,12 @@
         """
         return util.Uninferable
 
+    def get_children(self):
+        yield self.key
+        yield self.value
+
+        yield from self.generators
+
 
 class SetComp(ComprehensionScope):
     """Class representing an :class:`ast.SetComp` node.
@@ -925,6 +948,11 @@
         """
         return util.Uninferable
 
+    def get_children(self):
+        yield self.elt
+
+        yield from self.generators
+
 
 class _ListComp(node_classes.NodeNG):
     """Class representing an :class:`ast.ListComp` node.
@@ -966,34 +994,30 @@
         """
         return util.Uninferable
 
+    def get_children(self):
+        yield self.elt
+
+        yield from self.generators
+
+
+class ListComp(_ListComp, ComprehensionScope):
+    """Class representing an :class:`ast.ListComp` node.
+
+    >>> node = astroid.extract_node('[thing for thing in things if thing]')
+    >>> node
+    <ListComp l.1 at 0x7f23b2e418d0>
+    """
+    _other_other_fields = ('locals',)
+
+    def __init__(self, lineno=None, col_offset=None, parent=None):
+        self.locals = {}
+        """A map of the name of a local variable to the node defining it.
 
-if six.PY3:
-    class ListComp(_ListComp, ComprehensionScope):
-        """Class representing an :class:`ast.ListComp` node.
-
-        >>> node = astroid.extract_node('[thing for thing in things if thing]')
-        >>> node
-        <ListComp l.1 at 0x7f23b2e418d0>
-        """
-        _other_other_fields = ('locals',)
-
-        def __init__(self, lineno=None, col_offset=None, parent=None):
-            self.locals = {}
-            """A map of the name of a local variable to the node defining it.
-
-            :type: dict(str, NodeNG)
-            """
-
-            super(ListComp, self).__init__(lineno, col_offset, parent)
-else:
-    class ListComp(_ListComp):
-        """Class representing an :class:`ast.ListComp` node.
-
-        >>> node = astroid.extract_node('[thing for thing in things if thing]')
-        >>> node
-        <ListComp l.1 at 0x7f23b2e418d0>
+        :type: dict(str, NodeNG)
         """
 
+        super(ListComp, self).__init__(lineno, col_offset, parent)
+
 
 def _infer_decorator_callchain(node):
     """Detect decorator call chaining and see if the end result is a
@@ -1004,9 +1028,6 @@
     if not node.parent:
         return None
     try:
-        # TODO: We don't handle multiple inference results right now,
-        #       because there's no flow to reason when the return
-        #       is what we are looking for, a static or a class method.
         result = next(node.infer_call_result(node.parent))
     except (StopIteration, exceptions.InferenceError):
         return None
@@ -1030,6 +1051,10 @@
     _astroid_fields = ('args', 'body',)
     _other_other_fields = ('locals',)
     name = '<lambda>'
+    is_lambda = True
+
+    def implicit_parameters(self):
+        return 0
 
     # function's type, 'function' | 'method' | 'staticmethod' | 'classmethod'
     @property
@@ -1148,7 +1173,6 @@
         # pylint: disable=no-member; github.com/pycqa/astroid/issues/291
         # args is in fact redefined later on by postinit. Can't be changed
         # to None due to a strong interaction between Lambda and FunctionDef.
-
         return self.body.infer(context)
 
     def scope_lookup(self, node, name, offset=0):
@@ -1192,8 +1216,12 @@
         """
         return True
 
+    def get_children(self):
+        yield self.args
+        yield self.body
 
-class FunctionDef(node_classes.Statement, Lambda):
+
+class FunctionDef(mixins.MultiLineBlockMixin, node_classes.Statement, Lambda):
     """Class representing an :class:`ast.FunctionDef`.
 
     >>> node = astroid.extract_node('''
@@ -1203,11 +1231,9 @@
     >>> node
     <FunctionDef.my_func l.2 at 0x7f23b2e71e10>
     """
-    if six.PY3:
-        _astroid_fields = ('decorators', 'args', 'returns', 'body')
-        returns = None
-    else:
-        _astroid_fields = ('decorators', 'args', 'body')
+    _astroid_fields = ('decorators', 'args', 'returns', 'body')
+    _multi_line_block_fields = ('body',)
+    returns = None
     decorators = None
     """The decorators that are applied to this method or function.
 
@@ -1225,9 +1251,26 @@
 
     :type: bool
     """
+    type_annotation = None
+    """If present, this will contain the type annotation passed by a type comment
+
+    :type: NodeNG or None
+    """
+    type_comment_args = None
+    """
+    If present, this will contain the type annotation for arguments
+    passed by a type comment
+    """
+    type_comment_returns = None
+    """If present, this will contain the return type annotation, passed by a type comment"""
     # attributes below are set by the builder module or by raw factories
     _other_fields = ('name', 'doc')
-    _other_other_fields = ('locals', '_type')
+    _other_other_fields = (
+        'locals',
+        '_type',
+        'type_comment_returns',
+        'type_comment_args',
+    )
     _type = None
 
     def __init__(self, name=None, doc=None, lineno=None,
@@ -1268,7 +1311,11 @@
             frame.set_local(name, self)
 
     # pylint: disable=arguments-differ; different than Lambdas
-    def postinit(self, args, body, decorators=None, returns=None):
+    def postinit(self, args, body,
+                 decorators=None,
+                 returns=None,
+                 type_comment_returns=None,
+                 type_comment_args=None):
         """Do some setup after initialisation.
 
         :param args: The arguments that the function takes.
@@ -1280,13 +1327,19 @@
         :param decorators: The decorators that are applied to this
             method or function.
         :type decorators: Decorators or None
+        :params type_comment_returns:
+            The return type annotation passed via a type comment.
+        :params type_comment_args:
+            The args type annotation passed via a type comment.
         """
         self.args = args
         self.body = body
         self.decorators = decorators
         self.returns = returns
+        self.type_comment_returns = type_comment_returns
+        self.type_comment_args = type_comment_args
 
-        if six.PY3 and isinstance(self.parent.frame(), ClassDef):
+        if isinstance(self.parent.frame(), ClassDef):
             self.set_local('__class__', self.parent.frame())
 
     @decorators_mod.cachedproperty
@@ -1305,7 +1358,7 @@
             return []
 
         decorators = []
-        for assign in frame.nodes_of_class(node_classes.Assign):
+        for assign in frame._get_assign_nodes():
             if (isinstance(assign.value, node_classes.Call)
                     and isinstance(assign.value.func, node_classes.Name)):
                 for assign_node in assign.targets:
@@ -1348,10 +1401,10 @@
         if isinstance(frame, ClassDef):
             if self.name == '__new__':
                 return 'classmethod'
-            elif sys.version_info >= (3, 6) and self.name == '__init_subclass__':
+            if sys.version_info >= (3, 6) and self.name == '__init_subclass__':
                 return 'classmethod'
-            else:
-                type_name = 'method'
+
+            type_name = 'method'
 
         if not self.decorators:
             return type_name
@@ -1388,7 +1441,7 @@
                             continue
                         if ancestor.is_subtype_of('%s.classmethod' % BUILTINS):
                             return 'classmethod'
-                        elif ancestor.is_subtype_of('%s.staticmethod' % BUILTINS):
+                        if ancestor.is_subtype_of('%s.staticmethod' % BUILTINS):
                             return 'staticmethod'
             except exceptions.InferenceError:
                 pass
@@ -1444,8 +1497,12 @@
             return bases._infer_stmts(self.getattr(name, context),
                                       context, frame=self)
         except exceptions.AttributeInferenceError as error:
-            util.reraise(exceptions.InferenceError(
-                error.message, target=self, attribute=name, context=context))
+            raise exceptions.InferenceError(
+                error.message,
+                target=self,
+                attribute=name,
+                context=context,
+            ) from error
 
     def is_method(self):
         """Check if this function node represents a method.
@@ -1522,11 +1579,9 @@
         :returns: True is this is a generator function, False otherwise.
         :rtype: bool
         """
-        yield_nodes = (node_classes.Yield, node_classes.YieldFrom)
-        return next(self.nodes_of_class(yield_nodes,
-                                        skip_klass=(FunctionDef, Lambda)), False)
+        return next(self._get_yield_nodes_skip_lambdas(), False)
 
-    def infer_call_result(self, caller, context=None):
+    def infer_call_result(self, caller=None, context=None):
         """Infer what the function returns when called.
 
         :returns: What the function returns.
@@ -1547,22 +1602,30 @@
                 self.args.vararg is not None):
             metaclass = next(caller.args[0].infer(context))
             if isinstance(metaclass, ClassDef):
-                c = ClassDef('temporary_class', None)
-                c.hide = True
-                c.parent = self
-                class_bases = [next(b.infer(context)) for b in caller.args[1:]]
-                c.bases = [base for base in class_bases if base != util.Uninferable]
-                c._metaclass = metaclass
-                yield c
+                class_bases = [next(arg.infer(context)) for arg in caller.args[1:]]
+                new_class = ClassDef(name='temporary_class')
+                new_class.hide = True
+                new_class.parent = self
+                new_class.postinit(
+                    bases=[base for base in class_bases if base != util.Uninferable],
+                    body=[],
+                    decorators=[],
+                    metaclass=metaclass,
+                )
+                yield new_class
                 return
-        returns = self.nodes_of_class(node_classes.Return, skip_klass=FunctionDef)
-        for returnnode in returns:
+        returns = self._get_return_nodes_skip_functions()
+
+        first_return = next(returns, None)
+        if not first_return:
+            raise exceptions.InferenceError('Empty return iterator')
+
+        for returnnode in itertools.chain((first_return,), returns):
             if returnnode.value is None:
                 yield node_classes.Const(None)
             else:
                 try:
-                    for inferred in returnnode.value.infer(context):
-                        yield inferred
+                    yield from returnnode.value.infer(context)
                 except exceptions.InferenceError:
                     yield util.Uninferable
 
@@ -1575,6 +1638,17 @@
         """
         return True
 
+    def get_children(self):
+        if self.decorators is not None:
+            yield self.decorators
+
+        yield self.args
+
+        if self.returns is not None:
+            yield self.returns
+
+        yield from self.body
+
 
 class AsyncFunctionDef(FunctionDef):
     """Class representing an :class:`ast.FunctionDef` node.
@@ -1693,7 +1767,6 @@
     return klass
 
 
-
 class ClassDef(mixins.FilterStmtsMixin, LocalsDictNodeNG,
                node_classes.Statement):
     """Class representing an :class:`ast.ClassDef` node.
@@ -1797,6 +1870,24 @@
         if parent is not None:
             parent.frame().set_local(name, self)
 
+        for local_name, node in self.implicit_locals():
+            self.add_local_node(node, local_name)
+
+    def implicit_parameters(self):
+        return 1
+
+    def implicit_locals(self):
+        """Get implicitly defined class definition locals.
+
+        :returns: the the name and Const pair for each local
+        :rtype: tuple(tuple(str, node_classes.Const), ...)
+        """
+        locals_ = (('__module__', self.special_attributes.py__module__),)
+        if sys.version_info >= (3, 3):
+            # __qualname__ is defined in PEP3155
+            locals_ += (("__qualname__", self.special_attributes.py__qualname__),)
+        return locals_
+
     # pylint: disable=redefined-outer-name
     def postinit(self, bases, body, decorators, newstyle=None, metaclass=None, keywords=None):
         """Do some setup after initialisation.
@@ -1921,7 +2012,7 @@
     def _infer_type_call(self, caller, context):
         name_node = next(caller.args[0].infer(context))
         if (isinstance(name_node, node_classes.Const) and
-                isinstance(name_node.value, six.string_types)):
+                isinstance(name_node.value, str)):
             name = name_node.value
         else:
             return util.Uninferable
@@ -1947,7 +2038,7 @@
         if members and isinstance(members, node_classes.Dict):
             for attr, value in members.items:
                 if (isinstance(attr, node_classes.Const) and
-                        isinstance(attr.value, six.string_types)):
+                        isinstance(attr.value, str)):
                     result.locals[attr.value] = [value]
 
         result.parent = caller.parent
@@ -1959,7 +2050,23 @@
                 and len(caller.args) == 3):
             result = self._infer_type_call(caller, context)
             yield result
+            return
+
+        dunder_call = None
+        try:
+            metaclass = self.metaclass(context=context)
+            if metaclass is not None:
+                dunder_call = next(metaclass.igetattr("__call__", context))
+        except exceptions.AttributeInferenceError:
+            pass
+        if (dunder_call is not None and
+                dunder_call.qname() != "builtins.type.__call__"):
+            context = contextmod.bind_context_to_node(context, self)
+            yield from dunder_call.infer_call_result(
+                caller, context)
         else:
+            # Call type.__call__ if not set metaclass
+            # (since type is the default metaclass)
             yield bases.Instance(self)
 
     def scope_lookup(self, node, name, offset=0):
@@ -1986,7 +2093,7 @@
         # inside this class.
         lookup_upper_frame = (
             isinstance(node.parent, node_classes.Decorators) and
-            name in MANAGER.astroid_cache[six.moves.builtins.__name__]
+            name in MANAGER.astroid_cache[builtins.__name__]
         )
         if any(node == base or base.parent_of(node)
                for base in self.bases) or lookup_upper_frame:
@@ -2032,13 +2139,12 @@
         """
         # FIXME: should be possible to choose the resolution order
         # FIXME: inference make infinite loops possible here
-        yielded = set([self])
+        yielded = {self}
         if context is None:
             context = contextmod.InferenceContext()
-        if six.PY3:
-            if not self.bases and self.qname() != 'builtins.object':
-                yield builtin_lookup("object")[1][0]
-                return
+        if not self.bases and self.qname() != 'builtins.object':
+            yield builtin_lookup("object")[1][0]
+            return
 
         for stmt in self.bases:
             with context.restore_path():
@@ -2172,21 +2278,6 @@
         """
         return bases.Instance(self)
 
-    def instanciate_class(self):
-        """A deprecated alias for :meth:`instanciate_class`.
-
-        .. deprecated:: 1.5
-
-        :returns: An :class:`Instance` of the :class:`ClassDef` node,
-            or self if this is not possible.
-        :rtype: Instance or ClassDef
-        """
-        warnings.warn('%s.instanciate_class() is deprecated and slated for '
-                      'removal in astroid 2.0, use %s.instantiate_class() '
-                      'instead.' % (type(self).__name__, type(self).__name__),
-                      PendingDeprecationWarning, stacklevel=2)
-        return self.instantiate_class()
-
     def getattr(self, name, context=None, class_context=True):
         """Get an attribute from this class, using Python's attribute semantic.
 
@@ -2260,9 +2351,7 @@
                 continue
 
             if bases._is_property(attr):
-                # TODO(cpopa): don't use a private API.
-                for inferred in attr.infer_call_result(self, context):
-                    yield inferred
+                yield from attr.infer_call_result(self, context)
                 continue
             if attr.type == 'classmethod':
                 # If the method is a classmethod, then it will
@@ -2291,8 +2380,8 @@
         context = contextmod.copy_context(context)
         context.lookupname = name
         try:
-            attrs = self.getattr(name, context, class_context=class_context)
-            for inferred in bases._infer_stmts(attrs, context, frame=self):
+            attr = self.getattr(name, context, class_context=class_context)[0]
+            for inferred in bases._infer_stmts([attr], context, frame=self):
                 # yield Uninferable object instead of descriptors when necessary
                 if (not isinstance(inferred, node_classes.Const)
                         and isinstance(inferred, bases.Instance)):
@@ -2309,8 +2398,12 @@
                 # class handle some dynamic attributes, return a Uninferable object
                 yield util.Uninferable
             else:
-                util.reraise(exceptions.InferenceError(
-                    error.message, target=self, attribute=name, context=context))
+                raise exceptions.InferenceError(
+                    error.message,
+                    target=self,
+                    attribute=name,
+                    context=context,
+                )
 
     def has_dynamic_getattr(self, context=None):
         """Check if the class has a custom __getattr__ or __getattribute__.
@@ -2352,23 +2445,13 @@
         try:
             methods = dunder_lookup.lookup(self, '__getitem__')
         except exceptions.AttributeInferenceError as exc:
-            util.reraise(
-                exceptions.AstroidTypeError(
-                    node=self, error=exc,
-                    context=context
-                )
-            )
+            raise exceptions.AstroidTypeError(node=self, context=context) from exc
 
         method = methods[0]
 
         # Create a new callcontext for providing index as an argument.
-        if context:
-            new_context = context.clone()
-        else:
-            new_context = contextmod.InferenceContext()
-
+        new_context = contextmod.bind_context_to_node(context, self)
         new_context.callcontext = contextmod.CallContext(args=[index])
-        new_context.boundnode = self
 
         return next(method.infer_call_result(self, new_context))
 
@@ -2411,7 +2494,7 @@
         return None
 
     _metaclass = None
-    def declared_metaclass(self):
+    def declared_metaclass(self, context=None):
         """Return the explicit declared metaclass for the current class.
 
         An explicit declared metaclass is defined
@@ -2426,7 +2509,7 @@
         """
         for base in self.bases:
             try:
-                for baseobj in base.infer():
+                for baseobj in base.infer(context=context):
                     if isinstance(baseobj, ClassDef) and baseobj.hide:
                         self._metaclass = baseobj._metaclass
                         self._metaclass_hack = True
@@ -2437,49 +2520,28 @@
         if self._metaclass:
             # Expects this from Py3k TreeRebuilder
             try:
-                return next(node for node in self._metaclass.infer()
+                return next(node for node in self._metaclass.infer(context=context)
                             if node is not util.Uninferable)
             except (exceptions.InferenceError, StopIteration):
                 return None
-        if six.PY3:
-            return None
-
-        if '__metaclass__' in self.locals:
-            assignment = self.locals['__metaclass__'][-1]
-        elif self.bases:
-            return None
-        elif '__metaclass__' in self.root().locals:
-            assignments = [ass for ass in self.root().locals['__metaclass__']
-                           if ass.lineno < self.lineno]
-            if not assignments:
-                return None
-            assignment = assignments[-1]
-        else:
-            return None
 
-        try:
-            inferred = next(assignment.infer())
-        except exceptions.InferenceError:
-            return None
-        if inferred is util.Uninferable: # don't expose this
-            return None
-        return inferred
+        return None
 
-    def _find_metaclass(self, seen=None):
+    def _find_metaclass(self, seen=None, context=None):
         if seen is None:
             seen = set()
         seen.add(self)
 
-        klass = self.declared_metaclass()
+        klass = self.declared_metaclass(context=context)
         if klass is None:
-            for parent in self.ancestors():
+            for parent in self.ancestors(context=context):
                 if parent not in seen:
                     klass = parent._find_metaclass(seen)
                     if klass is not None:
                         break
         return klass
 
-    def metaclass(self):
+    def metaclass(self, context=None):
         """Get the metaclass of this class.
 
         If this class does not define explicitly a metaclass,
@@ -2489,7 +2551,7 @@
         :returns: The metaclass of this class.
         :rtype: NodeNG or None
         """
-        return self._find_metaclass()
+        return self._find_metaclass(context=context)
 
     def has_metaclass_hack(self):
         return self._metaclass_hack
@@ -2497,7 +2559,7 @@
     def _islots(self):
         """ Return an iterator with the inferred slots. """
         if '__slots__' not in self.locals:
-            return
+            return None
         for slots in self.igetattr('__slots__'):
             # check if __slots__ is a valid type
             for meth in ITER_METHODS:
@@ -2528,7 +2590,7 @@
             if not values:
                 # Stop the iteration, because the class
                 # has an empty list of slots.
-                raise StopIteration(values)
+                return values
 
             for elt in values:
                 try:
@@ -2536,8 +2598,7 @@
                         if inferred is util.Uninferable:
                             continue
                         if (not isinstance(inferred, node_classes.Const) or
-                                not isinstance(inferred.value,
-                                               six.string_types)):
+                                not isinstance(inferred.value, str)):
                             continue
                         if not inferred.value:
                             continue
@@ -2545,6 +2606,8 @@
                 except exceptions.InferenceError:
                     continue
 
+        return None
+
     def _slots(self):
         if not self.newstyle:
             raise NotImplementedError(
@@ -2579,8 +2642,7 @@
                 except NotImplementedError:
                     continue
                 if cls_slots is not None:
-                    for slot in cls_slots:
-                        yield slot
+                    yield from cls_slots
                 else:
                     yield None
 
@@ -2595,8 +2657,7 @@
         return sorted(slots, key=lambda item: item.value)
 
     def _inferred_bases(self, context=None):
-        # TODO(cpopa): really similar with .ancestors,
-        # but the difference is when one base is inferred,
+        # Similar with .ancestors, but the difference is when one base is inferred,
         # only the first object is wanted. That's because
         # we aren't interested in superclasses, as in the following
         # example:
@@ -2611,10 +2672,9 @@
 
         if context is None:
             context = contextmod.InferenceContext()
-        if six.PY3:
-            if not self.bases and self.qname() != 'builtins.object':
-                yield builtin_lookup("object")[1][0]
-                return
+        if not self.bases and self.qname() != 'builtins.object':
+            yield builtin_lookup("object")[1][0]
+            return
 
         for stmt in self.bases:
             try:
@@ -2628,8 +2688,7 @@
             if not baseobj.hide:
                 yield baseobj
             else:
-                for base in baseobj.bases:
-                    yield base
+                yield from baseobj.bases
 
     def _compute_mro(self, context=None):
         inferred_bases = list(self._inferred_bases(context=context))
@@ -2662,6 +2721,8 @@
 
         :raises NotImplementedError: If this is an old style class,
             since they don't have the concept of an MRO.
+        :raises DuplicateBasesError: Duplicate bases in the same class base
+        :raises InconsistentMroError: A class' MRO is inconsistent
         """
 
         if not self.newstyle:
@@ -2679,8 +2740,13 @@
         """
         return True
 
+    def get_children(self):
+        if self.decorators is not None:
+            yield self.decorators
 
-# Backwards-compatibility aliases
-Class = util.proxy_alias('Class', ClassDef)
-Function = util.proxy_alias('Function', FunctionDef)
-GenExpr = util.proxy_alias('GenExpr', GeneratorExp)
+        yield from self.bases
+        yield from self.body
+
+    def _get_assign_nodes(self):
+        for child_node in self.body:
+            yield from child_node._get_assign_nodes()
diff -Nru astroid-1.6.5/astroid/tests/resources.py astroid-2.0/astroid/tests/resources.py
--- astroid-1.6.5/astroid/tests/resources.py	2018-05-13 12:38:38.000000000 +0200
+++ astroid-2.0/astroid/tests/resources.py	2018-07-15 09:19:28.000000000 +0200
@@ -1,5 +1,7 @@
 # Copyright (c) 2014 Google, Inc.
 # Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -27,7 +29,7 @@
     return builder.AstroidBuilder().file_build(find(path), modname)
 
 
-class SysPathSetup(object):
+class SysPathSetup:
     def setUp(self):
         sys.path.insert(0, find(''))
 
@@ -39,7 +41,7 @@
                 del sys.path_importer_cache[key]
 
 
-class AstroidCacheSetupMixin(object):
+class AstroidCacheSetupMixin:
     """Mixin for handling the astroid cache problems.
 
     When clearing the astroid cache, some tests fails due to
diff -Nru astroid-1.6.5/astroid/tests/testdata/python2/data/joined_strings.py astroid-2.0/astroid/tests/testdata/python2/data/joined_strings.py
--- astroid-1.6.5/astroid/tests/testdata/python2/data/joined_strings.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/tests/testdata/python2/data/joined_strings.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,1051 +0,0 @@
-x = ('R0lGODlhigJnAef/AAABAAEEAAkCAAMGAg0GBAYJBQoMCBMODQ4QDRITEBkS'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7')
\ Pas de fin de ligne à la fin du fichier
diff -Nru astroid-1.6.5/astroid/tests/testdata/python2/data/module2.py astroid-2.0/astroid/tests/testdata/python2/data/module2.py
--- astroid-1.6.5/astroid/tests/testdata/python2/data/module2.py	2018-05-13 12:38:38.000000000 +0200
+++ astroid-2.0/astroid/tests/testdata/python2/data/module2.py	2018-07-15 09:19:32.000000000 +0200
@@ -71,10 +71,10 @@
 del YO
 [SYN1, SYN2] = (Concrete0, Concrete1)
 assert '1'
-b = (1) | (((2) & (3)) ^ (8))
-bb = ((1) | (two)) | (6)
-ccc = ((one) & (two)) & (three)
-dddd = ((x) ^ (o)) ^ (r)
+b = (1 | 2) & (3 ^ 8)
+bb = 1 | (two | 6)
+ccc = one & two & three
+dddd = x ^ (o ^ r)
 exec 'c = 3'
 exec 'c = 3' in {}, {}
 
@@ -82,15 +82,15 @@
     raise Exception, 'yo'
     yield 'coucou'
     yield
-a = (b) + (2)
-c = (b) * (2)
-c = (b) / (2)
-c = (b) // (2)
-c = (b) - (2)
-c = (b) % (2)
-c = (b) ** (2)
-c = (b) << (2)
-c = (b) >> (2)
+a = b + 2
+c = b * 2
+c = b / 2
+c = b // 2
+c = b - 2
+c = b % 2
+c = b**2
+c = b << 2
+c = b >> 2
 c = ~b
 c = not b
 d = [c]
@@ -131,7 +131,7 @@
     
     def generator():
         yield
-    genl = lambda : (yield)
+    genl = lambda: (yield)
 
 def with_metaclass(meta, *bases):
     return meta('NewBase', bases, {})
diff -Nru astroid-1.6.5/astroid/tests/testdata/python2/data/module.py astroid-2.0/astroid/tests/testdata/python2/data/module.py
--- astroid-1.6.5/astroid/tests/testdata/python2/data/module.py	2018-05-13 12:38:38.000000000 +0200
+++ astroid-2.0/astroid/tests/testdata/python2/data/module.py	2018-07-15 09:19:32.000000000 +0200
@@ -23,7 +23,8 @@
 
 
 class YO:
-    """hehe"""
+    """hehe
+    haha"""
     a = 1
     
     def __init__(self):
@@ -45,7 +46,8 @@
         self.member = None
     
     def method(self):
-        """method test"""
+        """method
+        test"""
         global MY_DICT
         try:
             MY_DICT = {}
@@ -53,9 +55,8 @@
             autre = [a for (a, b) in MY_DICT if b]
             if b in autre:
                 return b
-            else:
-                if a in autre:
-                    return a
+            elif a in autre:
+                return a
             global_access(local, val=autre)
         finally:
             return local
@@ -81,9 +82,9 @@
     else:
         b += -2
     if c:
-        d = ((a) and (b)) or (c)
+        d = a and (b or c)
     else:
-        c = ((a) and (b)) or (d)
+        c = a and b or d
     map(lambda x, y: (y, x), a)
 redirect = four_args
 
diff -Nru astroid-1.6.5/astroid/tests/testdata/python2/data/operator_precedence.py astroid-2.0/astroid/tests/testdata/python2/data/operator_precedence.py
--- astroid-1.6.5/astroid/tests/testdata/python2/data/operator_precedence.py	1970-01-01 01:00:00.000000000 +0100
+++ astroid-2.0/astroid/tests/testdata/python2/data/operator_precedence.py	2018-07-15 09:19:32.000000000 +0200
@@ -0,0 +1,27 @@
+assert not not True == True
+assert (not False or True) == True
+assert True or False and True
+assert (True or False) and True
+
+assert True is not (False is True) == False
+assert True is (not False is True == False)
+
+assert 1 + 2 + 3 == 6
+assert 5 - 4 + 3 == 4
+assert 4 - 5 - 6 == -7
+assert 7 - (8 - 9) == 8
+assert 2**3**4 == 2**81
+assert (2**3)**4 == 8**4
+
+assert 1 + 2 if (0.5 if True else 0.2) else 1 if True else 2 == 3
+assert (0 if True else 1) if False else 2 == 2
+assert lambda x: x if (0 if False else 0) else 0 if False else 0
+assert (lambda x: x) if (0 if True else 0.2) else 1 if True else 2 == 1
+
+assert ('1' + '2').replace('1', '3') == '32'
+assert (lambda x: x)(1) == 1
+assert ([0] + [1])[1] == 1
+assert (lambda x: lambda: x + 1)(2)() == 3
+
+f = lambda x, y, z: y(x, z)
+assert f(1, lambda x, y: x + y[1], (2, 3)) == 4
diff -Nru astroid-1.6.5/astroid/tests/testdata/python3/data/joined_strings.py astroid-2.0/astroid/tests/testdata/python3/data/joined_strings.py
--- astroid-1.6.5/astroid/tests/testdata/python3/data/joined_strings.py	2018-05-13 21:48:04.000000000 +0200
+++ astroid-2.0/astroid/tests/testdata/python3/data/joined_strings.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,1051 +0,0 @@
-x = ('R0lGODlhigJnAef/AAABAAEEAAkCAAMGAg0GBAYJBQoMCBMODQ4QDRITEBkS'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7'
-     +'CxsSEhkWDhYYFQ0aJhkaGBweGyccGh8hHiIkIiMmGTEiHhQoPSYoJSkqKDcp'
-     +'Ii0uLDAxLzI0Mh44U0gxMDI5JkM0JjU3NDY6Kjc5Njo7OUE8Ozw+Oz89QTxA'
-     +'F1akOFFiRIgPHTZksKBAgMCLGTdGNIAAQgKfDAcgZbj0odOnUA8GBAA7')
\ Pas de fin de ligne à la fin du fichier
diff -Nru astroid-1.6.5/astroid/tests/testdata/python3/data/module2.py astroid-2.0/astroid/tests/testdata/python3/data/module2.py
--- astroid-1.6.5/astroid/tests/testdata/python3/data/module2.py	2018-05-13 12:38:38.000000000 +0200
+++ astroid-2.0/astroid/tests/testdata/python3/data/module2.py	2018-07-15 09:19:35.000000000 +0200
@@ -72,10 +72,10 @@
 del YO
 [SYN1, SYN2] = (Concrete0, Concrete1)
 assert repr(1)
-b = (1) | (((2) & (3)) ^ (8))
-bb = ((1) | (two)) | (6)
-ccc = ((one) & (two)) & (three)
-dddd = ((x) ^ (o)) ^ (r)
+b = (1 | 2) & (3 ^ 8)
+bb = 1 | (two | 6)
+ccc = one & two & three
+dddd = x ^ (o ^ r)
 exec('c = 3')
 exec('c = 3', {}, {})
 
@@ -83,15 +83,15 @@
     raise Exception('yo')
     yield 'coucou'
     yield
-a = (b) + (2)
-c = (b) * (2)
-c = (b) / (2)
-c = (b) // (2)
-c = (b) - (2)
-c = (b) % (2)
-c = (b) ** (2)
-c = (b) << (2)
-c = (b) >> (2)
+a = b + 2
+c = b * 2
+c = b / 2
+c = b // 2
+c = b - 2
+c = b % 2
+c = b**2
+c = b << 2
+c = b >> 2
 c = ~b
 c = not b
 d = [c]
@@ -132,7 +132,7 @@
     
     def generator():
         yield
-    genl = lambda : (yield)
+    genl = lambda: (yield)
 
 def with_metaclass(meta, *bases):
     return meta('NewBase', bases, {})
diff -Nru astroid-1.6.5/astroid/tests/testdata/python3/data/module.py astroid-2.0/astroid/tests/testdata/python3/data/module.py
--- astroid-1.6.5/astroid/tests/testdata/python3/data/module.py	2018-05-13 12:38:38.000000000 +0200
+++ astroid-2.0/astroid/tests/testdata/python3/data/module.py	2018-07-15 09:19:35.000000000 +0200
@@ -23,7 +23,8 @@
 
 
 class YO:
-    """hehe"""
+    """hehe
+    haha"""
     a = 1
     
     def __init__(self):
@@ -45,7 +46,8 @@
         self.member = None
     
     def method(self):
-        """method test"""
+        """method
+        test"""
         global MY_DICT
         try:
             MY_DICT = {}
@@ -53,9 +55,8 @@
             autre = [a for (a, b) in MY_DICT if b]
             if b in autre:
                 return
-            else:
-                if a in autre:
-                    return 'hehe'
+            elif a in autre:
+                return 'hehe'
             global_access(local, val=autre)
         finally:
             return local
@@ -80,9 +81,9 @@
     else:
         b += -2
     if c:
-        d = ((a) and (b)) or (c)
+        d = a and (b or c)
     else:
-        c = ((a) and (b)) or (d)
+        c = a and b or d
     list(map(lambda x, y: (y, x), a))
 redirect = four_args
 
diff -Nru astroid-1.6.5/astroid/tests/testdata/python3/data/operator_precedence.py astroid-2.0/astroid/tests/testdata/python3/data/operator_precedence.py
--- astroid-1.6.5/astroid/tests/testdata/python3/data/operator_precedence.py	1970-01-01 01:00:00.000000000 +0100
+++ astroid-2.0/astroid/tests/testdata/python3/data/operator_precedence.py	2018-07-15 09:19:35.000000000 +0200
@@ -0,0 +1,27 @@
+assert not not True == True
+assert (not False or True) == True
+assert True or False and True
+assert (True or False) and True
+
+assert True is not (False is True) == False
+assert True is (not False is True == False)
+
+assert 1 + 2 + 3 == 6
+assert 5 - 4 + 3 == 4
+assert 4 - 5 - 6 == -7
+assert 7 - (8 - 9) == 8
+assert 2**3**4 == 2**81
+assert (2**3)**4 == 8**4
+
+assert 1 + 2 if (0.5 if True else 0.2) else 1 if True else 2 == 3
+assert (0 if True else 1) if False else 2 == 2
+assert lambda x: x if (0 if False else 0) else 0 if False else 0
+assert (lambda x: x) if (0 if True else 0.2) else 1 if True else 2
+
+assert ('1' + '2').replace('1', '3') == '32'
+assert (lambda x: x)(1) == 1
+assert ([0] + [1])[1] == 1
+assert (lambda x: lambda: x + 1)(2)() == 3
+
+f = lambda x, y, z: y(x, z)
+assert f(1, lambda x, y: x + y[1], (2, 3)) == 4
diff -Nru astroid-1.6.5/astroid/tests/unittest_brain_numpy.py astroid-2.0/astroid/tests/unittest_brain_numpy.py
--- astroid-1.6.5/astroid/tests/unittest_brain_numpy.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/tests/unittest_brain_numpy.py	2018-07-15 09:19:28.000000000 +0200
@@ -1,5 +1,7 @@
 #-*- encoding=utf-8 -*-
-# Copyright (c) 2017 Guillaume Peillex <guillaume.peillex@gmail.com>
+# Copyright (c) 2017-2018 hippo91 <guillaume.peillex@gmail.com>
+# Copyright (c) 2017 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -243,11 +245,18 @@
     """
     Test of all the missing types defined in numerictypes module.
     """
-    all_types = ['uint16', 'uint32', 'uint64', 'int128', 'uint128',
-                 'float16', 'float32', 'float64', 'float80', 'float96',
-                 'float128', 'float256', 'complex32', 'complex64', 'complex128',
-                 'complex160', 'complex192', 'complex256', 'complex512',
-                 'timedelta64', 'datetime64', 'unicode_', 'string_', 'object_']
+    all_types = ['uint16', 'uint32', 'uint64',
+                 'float16', 'float32', 'float64', 'float96',
+                 'complex64', 'complex128',
+                 'complex192', 'timedelta64', 'datetime64', 'unicode_',
+                 'str_', 'bool_', 'bool8', 'byte', 'int8', 'bytes0', 'bytes_',
+                 'cdouble', 'cfloat', 'character', 'clongdouble',
+                 'clongfloat', 'complexfloating', 'csingle', 'double',
+                 'flexible', 'floating', 'half', 'inexact', 'int0',
+                 'longcomplex', 'longdouble', 'longfloat',
+                 'short', 'signedinteger', 'single', 'singlecomplex',
+                 'str0', 'ubyte', 'uint', 'uint0', 'uintc', 'uintp',
+                 'ulonglong', 'unsignedinteger', 'ushort', 'void0']
 
     def _inferred_numpy_attribute(self, attrib):
         node = builder.extract_node("""
@@ -264,6 +273,63 @@
                 inferred = self._inferred_numpy_attribute(typ)
                 self.assertIsInstance(inferred, nodes.ClassDef)
 
+    def test_generic_types_have_methods(self):
+        """
+        Test that all generic derived types have specified methods
+        """
+        generic_methods = ['all', 'any', 'argmax', 'argmin', 'argsort',
+                           'astype', 'base', 'byteswap', 'choose',
+                           'clip', 'compress', 'conj', 'conjugate',
+                           'copy', 'cumprod', 'cumsum', 'data',
+                           'diagonal', 'dtype', 'dump', 'dumps', 'fill',
+                           'flags', 'flat', 'flatten', 'getfield',
+                           'imag', 'item', 'itemset', 'itemsize', 'max',
+                           'mean', 'min', 'nbytes', 'ndim',
+                           'newbyteorder', 'nonzero', 'prod', 'ptp',
+                           'put', 'ravel', 'real', 'repeat', 'reshape',
+                           'resize', 'round', 'searchsorted',
+                           'setfield', 'setflags', 'shape', 'size',
+                           'sort', 'squeeze', 'std', 'strides', 'sum',
+                           'swapaxes', 'take', 'tobytes', 'tofile',
+                           'tolist', 'tostring', 'trace', 'transpose',
+                           'var', 'view']
+
+        for type_ in ('bool_', 'bytes_', 'character', 'complex128',
+                      'complex192', 'complex64', 'complexfloating',
+                      'datetime64', 'flexible', 'float16', 'float32',
+                      'float64', 'float96', 'floating', 'generic', 'inexact',
+                      'int16', 'int32', 'int32', 'int64', 'int8', 'integer',
+                      'number', 'signedinteger', 'str_',
+                      'timedelta64', 'uint16', 'uint32', 'uint32', 'uint64',
+                      'uint8', 'unsignedinteger', 'void'):
+            with self.subTest(typ=type_):
+                inferred = self._inferred_numpy_attribute(type_)
+                for meth in generic_methods:
+                    with self.subTest(meth=meth):
+                        self.assertTrue(meth in {m.name for m in inferred.methods()})
+
+    def test_generic_types_have_attributes(self):
+        """
+        Test that all generic derived types have specified attributes
+        """
+        generic_attr = ['base', 'data', 'dtype', 'flags', 'flat', 'imag',
+                        'itemsize', 'nbytes', 'ndim', 'real', 'size',
+                        'strides']
+
+        for type_ in ('bool_', 'bytes_', 'character', 'complex128',
+                      'complex192', 'complex64', 'complexfloating',
+                      'datetime64', 'flexible', 'float16', 'float32',
+                      'float64', 'float96', 'floating', 'generic', 'inexact',
+                      'int16', 'int32', 'int32', 'int64', 'int8', 'integer',
+                      'number', 'signedinteger', 'str_',
+                      'timedelta64', 'uint16', 'uint32', 'uint32', 'uint64',
+                      'uint8', 'unsignedinteger', 'void'):
+            with self.subTest(typ=type_):
+                inferred = self._inferred_numpy_attribute(type_)
+                for attr in generic_attr:
+                    with self.subTest(attr=attr):
+                        self.assertNotEqual(len(inferred.getattr(attr)), 0)
+
 
 if __name__ == '__main__':
     unittest.main()
diff -Nru astroid-1.6.5/astroid/tests/unittest_brain.py astroid-2.0/astroid/tests/unittest_brain.py
--- astroid-1.6.5/astroid/tests/unittest_brain.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/tests/unittest_brain.py	2018-07-15 09:19:30.000000000 +0200
@@ -1,14 +1,27 @@
+# -*- coding: utf-8 -*-
 # Copyright (c) 2013-2014 Google, Inc.
-# Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
-# Copyright (c) 2015 Philip Lorenz <philip@bithub.de>
+# Copyright (c) 2014-2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
 # Copyright (c) 2015 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
 # Copyright (c) 2015 raylu <lurayl@gmail.com>
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2015 Philip Lorenz <philip@bithub.de>
+# Copyright (c) 2016 Florian Bruhin <me@the-compiler.org>
+# Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
+# Copyright (c) 2017-2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
+# Copyright (c) 2017 hippo91 <guillaume.peillex@gmail.com>
+# Copyright (c) 2017 David Euresti <github@euresti.com>
+# Copyright (c) 2017 Derek Gustafson <degustaf@gmail.com>
+# Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>
+# Copyright (c) 2018 Anthony Sottile <asottile@umich.edu>
+# Copyright (c) 2018 Ioana Tagirta <ioana.tagirta@gmail.com>
+# Copyright (c) 2018 Ahmed Azzaoui <ahmed.azzaoui@engie.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
 
 """Tests for basic functionality in astroid.brain."""
+import queue
+
 try:
     import multiprocessing # pylint: disable=unused-import
     HAS_MULTIPROCESSING = True
@@ -39,11 +52,8 @@
 except ImportError:
     HAS_DATEUTIL = False
 
-try:
-    import pytest
-    HAS_PYTEST = True
-except ImportError:
-    HAS_PYTEST = False
+import pytest
+HAS_PYTEST = True
 
 try:
     import attr as attr_module # pylint: disable=unused-import
@@ -51,8 +61,6 @@
 except ImportError:
     HAS_ATTR = False
 
-import six
-
 from astroid import MANAGER
 from astroid import bases
 from astroid import builder
@@ -63,21 +71,31 @@
 
 
 class HashlibTest(unittest.TestCase):
+    def _assert_hashlib_class(self, class_obj):
+        self.assertIn('update', class_obj)
+        self.assertIn('digest', class_obj)
+        self.assertIn('hexdigest', class_obj)
+        self.assertIn('block_size', class_obj)
+        self.assertIn('digest_size', class_obj)
+        self.assertEqual(len(class_obj['__init__'].args.args), 2)
+        self.assertEqual(len(class_obj['__init__'].args.defaults), 1)
+        self.assertEqual(len(class_obj['update'].args.args), 2)
+        self.assertEqual(len(class_obj['digest'].args.args), 1)
+        self.assertEqual(len(class_obj['hexdigest'].args.args), 1)
+
     def test_hashlib(self):
         """Tests that brain extensions for hashlib work."""
         hashlib_module = MANAGER.ast_from_module_name('hashlib')
         for class_name in ['md5', 'sha1']:
             class_obj = hashlib_module[class_name]
-            self.assertIn('update', class_obj)
-            self.assertIn('digest', class_obj)
-            self.assertIn('hexdigest', class_obj)
-            self.assertIn('block_size', class_obj)
-            self.assertIn('digest_size', class_obj)
-            self.assertEqual(len(class_obj['__init__'].args.args), 2)
-            self.assertEqual(len(class_obj['__init__'].args.defaults), 1)
-            self.assertEqual(len(class_obj['update'].args.args), 2)
-            self.assertEqual(len(class_obj['digest'].args.args), 1)
-            self.assertEqual(len(class_obj['hexdigest'].args.args), 1)
+            self._assert_hashlib_class(class_obj)
+
+    @test_utils.require_version(minver='3.6')
+    def test_hashlib_py36(self):
+        hashlib_module = MANAGER.ast_from_module_name('hashlib')
+        for class_name in ['sha3_224', 'sha3_512', 'shake_128']:
+            class_obj = hashlib_module[class_name]
+            self._assert_hashlib_class(class_obj)
 
 
 class CollectionsDequeTests(unittest.TestCase):
@@ -101,6 +119,21 @@
         self.assertIn('index', inferred.locals)
 
 
+class OrderedDictTest(unittest.TestCase):
+    def _inferred_ordered_dict_instance(self):
+        node = builder.extract_node("""
+        import collections
+        d = collections.OrderedDict()
+        d
+        """)
+        return next(node.infer())
+
+    @test_utils.require_version(minver='3.4')
+    def test_ordered_dict_py34method(self):
+        inferred = self._inferred_ordered_dict_instance()
+        self.assertIn('move_to_end', inferred.locals)
+
+
 class NamedTupleTest(unittest.TestCase):
 
     def test_namedtuple_base(self):
@@ -239,6 +272,17 @@
         self.assertIn('b', inferred.locals)
         self.assertIn('c', inferred.locals)
 
+    def test_namedtuple_bases_are_actually_names_not_nodes(self):
+        node = builder.extract_node("""
+        from collections import namedtuple
+        Tuple = namedtuple("Tuple", field_names="a b c", rename=UNINFERABLE)
+        Tuple #@
+        """)
+        inferred = next(node.infer())
+        self.assertIsInstance(inferred, astroid.ClassDef)
+        self.assertIsInstance(inferred.bases[0], astroid.Name)
+        self.assertEqual(inferred.bases[0].name, 'tuple')
+
 
 class DefaultDictTest(unittest.TestCase):
 
@@ -300,65 +344,35 @@
         ''')
         http_client = next(ast_nodes[0].infer())
         self.assertIsInstance(http_client, nodes.Module)
-        self.assertEqual(http_client.name,
-                         'http.client' if six.PY3 else 'httplib')
+        self.assertEqual(http_client.name, 'http.client')
 
         urllib_parse = next(ast_nodes[1].infer())
-        if six.PY3:
-            self.assertIsInstance(urllib_parse, nodes.Module)
-            self.assertEqual(urllib_parse.name, 'urllib.parse')
-        else:
-            # On Python 2, this is a fake module, the same behaviour
-            # being mimicked in brain's tip for six.moves.
-            self.assertIsInstance(urllib_parse, astroid.Instance)
+        self.assertIsInstance(urllib_parse, nodes.Module)
+        self.assertEqual(urllib_parse.name, 'urllib.parse')
         urljoin = next(urllib_parse.igetattr('urljoin'))
         urlencode = next(urllib_parse.igetattr('urlencode'))
-        if six.PY2:
-            # In reality it's a function, but our implementations
-            # transforms it into a method.
-            self.assertIsInstance(urljoin, astroid.FunctionDef)
-            self.assertEqual(urljoin.qname(), 'urlparse.urljoin')
-            self.assertIsInstance(urlencode, astroid.FunctionDef)
-            self.assertEqual(urlencode.qname(), 'urllib.urlencode')
-        else:
-            self.assertIsInstance(urljoin, nodes.FunctionDef)
-            self.assertEqual(urljoin.qname(), 'urllib.parse.urljoin')
-            self.assertIsInstance(urlencode, nodes.FunctionDef)
-            self.assertEqual(urlencode.qname(), 'urllib.parse.urlencode')
+        self.assertIsInstance(urljoin, nodes.FunctionDef)
+        self.assertEqual(urljoin.qname(), 'urllib.parse.urljoin')
+        self.assertIsInstance(urlencode, nodes.FunctionDef)
+        self.assertEqual(urlencode.qname(), 'urllib.parse.urlencode')
 
         urllib_error = next(ast_nodes[2].infer())
-        if six.PY3:
-            self.assertIsInstance(urllib_error, nodes.Module)
-            self.assertEqual(urllib_error.name, 'urllib.error')
-        else:
-            # On Python 2, this is a fake module, the same behaviour
-            # being mimicked in brain's tip for six.moves.
-            self.assertIsInstance(urllib_error, astroid.Instance)
+        self.assertIsInstance(urllib_error, nodes.Module)
+        self.assertEqual(urllib_error.name, 'urllib.error')
         urlerror = next(urllib_error.igetattr('URLError'))
         self.assertIsInstance(urlerror, nodes.ClassDef)
         content_too_short = next(urllib_error.igetattr('ContentTooShortError'))
         self.assertIsInstance(content_too_short, nodes.ClassDef)
 
         urllib_request = next(ast_nodes[3].infer())
-        if six.PY3:
-            self.assertIsInstance(urllib_request, nodes.Module)
-            self.assertEqual(urllib_request.name, 'urllib.request')
-        else:
-            self.assertIsInstance(urllib_request, astroid.Instance)
+        self.assertIsInstance(urllib_request, nodes.Module)
+        self.assertEqual(urllib_request.name, 'urllib.request')
         urlopen = next(urllib_request.igetattr('urlopen'))
         urlretrieve = next(urllib_request.igetattr('urlretrieve'))
-        if six.PY2:
-            # In reality it's a function, but our implementations
-            # transforms it into a method.
-            self.assertIsInstance(urlopen, astroid.FunctionDef)
-            self.assertEqual(urlopen.qname(), 'urllib2.urlopen')
-            self.assertIsInstance(urlretrieve, astroid.FunctionDef)
-            self.assertEqual(urlretrieve.qname(), 'urllib.urlretrieve')
-        else:
-            self.assertIsInstance(urlopen, nodes.FunctionDef)
-            self.assertEqual(urlopen.qname(), 'urllib.request.urlopen')
-            self.assertIsInstance(urlretrieve, nodes.FunctionDef)
-            self.assertEqual(urlretrieve.qname(), 'urllib.request.urlretrieve')
+        self.assertIsInstance(urlopen, nodes.FunctionDef)
+        self.assertEqual(urlopen.qname(), 'urllib.request.urlopen')
+        self.assertIsInstance(urlretrieve, nodes.FunctionDef)
+        self.assertEqual(urlretrieve.qname(), 'urllib.request.urlretrieve')
 
     def test_from_imports(self):
         ast_node = builder.extract_node('''
@@ -367,14 +381,9 @@
         ''')
         inferred = next(ast_node.infer())
         self.assertIsInstance(inferred, nodes.ClassDef)
-        if six.PY3:
-            qname = 'http.client.HTTPSConnection'
-        else:
-            qname = 'httplib.HTTPSConnection'
+        qname = 'http.client.HTTPSConnection'
         self.assertEqual(inferred.qname(), qname)
 
-    @unittest.skipIf(six.PY2,
-                     "The python 2 six brain uses dummy classes")
     def test_from_submodule_imports(self):
         """Make sure ulrlib submodules can be imported from
 
@@ -437,16 +446,15 @@
         array = manager.Array()
         namespace = manager.Namespace()
         """)
-        queue = next(module['queue'].infer())
-        self.assertEqual(queue.qname(),
-                         "{}.Queue".format(six.moves.queue.__name__))
+        ast_queue = next(module['queue'].infer())
+        self.assertEqual(ast_queue.qname(), "{}.Queue".format(queue.__name__))
 
         joinable_queue = next(module['joinable_queue'].infer())
         self.assertEqual(joinable_queue.qname(),
-                         "{}.Queue".format(six.moves.queue.__name__))
+                         "{}.Queue".format(queue.__name__))
 
         event = next(module['event'].infer())
-        event_name = "threading.{}".format("Event" if six.PY3 else "_Event")
+        event_name = "threading.Event"
         self.assertEqual(event.qname(), event_name)
 
         rlock = next(module['rlock'].infer())
@@ -454,8 +462,7 @@
         self.assertEqual(rlock.qname(), rlock_name)
 
         bounded_semaphore = next(module['bounded_semaphore'].infer())
-        semaphore_name = "threading.{}".format(
-            "BoundedSemaphore" if six.PY3 else "_BoundedSemaphore")
+        semaphore_name = "threading.BoundedSemaphore"
         self.assertEqual(bounded_semaphore.qname(), semaphore_name)
 
         pool = next(module['pool'].infer())
@@ -492,7 +499,7 @@
     def _test_lock_object(self, object_name):
         lock_instance = builder.extract_node("""
         import threading
-        threading.{0}()
+        threading.{}()
         """.format(object_name))
         inferred = next(lock_instance.infer())
         self.assert_is_valid_lock(inferred)
@@ -628,6 +635,23 @@
         self.assertIsInstance(instance, astroid.Const)
         self.assertIsInstance(instance.value, str)
 
+    def test_infer_enum_value_as_the_right_type(self):
+        string_value, int_value = builder.extract_node('''
+        from enum import Enum
+        class A(Enum):
+            a = 'a'
+            b = 1
+        A.a.value #@
+        A.b.value #@
+        ''')
+        inferred_string = string_value.inferred()
+        assert any(isinstance(elem, astroid.Const) and elem.value == 'a'
+                   for elem in inferred_string)
+
+        inferred_int = int_value.inferred()
+        assert any(isinstance(elem, astroid.Const) and elem.value == 1
+                   for elem in inferred_int)
+
 
 @unittest.skipUnless(HAS_DATEUTIL, "This test requires the dateutil library.")
 class DateutilBrainTest(unittest.TestCase):
@@ -676,7 +700,7 @@
 
 class IOBrainTest(unittest.TestCase):
     @unittest.skipUnless(
-        six.PY3 and streams_are_fine(),
+        streams_are_fine(),
         "Needs Python 3 io model / doesn't work with plain pytest."
         "use pytest -s for this test to work")
     def test_sys_streams(self):
@@ -710,6 +734,24 @@
         for anc in klass.ancestors():
             self.assertFalse(anc.parent is None)
 
+    def test_namedtuple_can_correcty_access_methods(self):
+        klass, called = builder.extract_node("""
+        from typing import NamedTuple
+
+        class X(NamedTuple): #@
+            a: int
+            b: int
+            def as_string(self):
+                return '%s' % self.a
+            def as_integer(self):
+                return 2 + 3
+        X().as_integer() #@
+        """)
+        self.assertEqual(len(klass.getattr('as_string')), 1)
+        inferred = next(called.infer())
+        self.assertIsInstance(inferred, astroid.Const)
+        self.assertEqual(inferred.value, 5)
+
     def test_namedtuple_inference(self):
         klass = builder.extract_node("""
         from typing import NamedTuple
@@ -782,6 +824,20 @@
         inferred = next(result.infer())
         self.assertIsInstance(inferred, astroid.Instance)
 
+    def test_typing_types(self):
+        ast_nodes = builder.extract_node("""
+        from typing import TypeVar, Iterable, Tuple, NewType, Dict, Union
+        TypeVar('MyTypeVar', int, float, complex) #@
+        Iterable[Tuple[MyTypeVar, MyTypeVar]] #@
+        TypeVar('AnyStr', str, bytes) #@
+        NewType('UserId', str) #@
+        Dict[str, str] #@
+        Union[int, str] #@
+        """)
+        for node in ast_nodes:
+            inferred = next(node.infer())
+            self.assertIsInstance(inferred, nodes.ClassDef, node.as_string())
+
 
 class ReBrainTest(unittest.TestCase):
     def test_regex_flags(self):
@@ -850,10 +906,18 @@
 
         f = Foo()
         f.d['answer'] = 42
+
+        @attr.s(slots=True)
+        class Bar:
+            d = attr.ib(attr.Factory(dict))
+
+        g = Bar()
+        g.d['answer'] = 42
         """)
 
-        should_be_attribute = next(module.getattr('f')[0].infer()).getattr('d')[0]
-        self.assertIsInstance(should_be_attribute, astroid.Unknown)
+        for name in ('f', 'g'):
+            should_be_unknown = next(module.getattr(name)[0].infer()).getattr('d')[0]
+            self.assertIsInstance(should_be_unknown, astroid.Unknown)
 
     def test_special_attributes(self):
         """Make sure special attrs attributes exist"""
@@ -886,5 +950,541 @@
         next(astroid.extract_node(code).infer())
 
 
+class RandomSampleTest(unittest.TestCase):
+
+    def test_inferred_successfully(self):
+        node = astroid.extract_node('''
+        import random
+        random.sample([1, 2], 2) #@
+        ''')
+        inferred = next(node.infer())
+        self.assertIsInstance(inferred, astroid.List)
+        elems = sorted(elem.value for elem in inferred.elts)
+        self.assertEqual(elems, [1, 2])
+
+
+class SubprocessTest(unittest.TestCase):
+    """Test subprocess brain"""
+    @unittest.skipIf(sys.version_info < (3, 3),
+                     reason="Python 2.7 subprocess doesnt have args")
+    def test_subprocess_args(self):
+        """Make sure the args attribute exists for Popen
+
+        Test for https://github.com/PyCQA/pylint/issues/1860"""
+        name = astroid.extract_node("""
+        import subprocess
+        p = subprocess.Popen(['ls'])
+        p #@
+        """)
+        [inst] = name.inferred()
+        self.assertIsInstance(next(inst.igetattr("args")), nodes.List)
+
+
+class TestIsinstanceInference:
+    """Test isinstance builtin inference"""
+
+    def test_type_type(self):
+        assert _get_result("isinstance(type, type)") == "True"
+
+    def test_object_type(self):
+        assert _get_result("isinstance(object, type)") == "True"
+
+    def test_type_object(self):
+        assert _get_result("isinstance(type, object)") == "True"
+
+    def test_isinstance_int_true(self):
+        """Make sure isinstance can check builtin int types"""
+        assert _get_result("isinstance(1, int)") == "True"
+
+    def test_isinstance_int_false(self):
+        assert _get_result("isinstance('a', int)") == "False"
+
+    def test_isinstance_object_true(self):
+        assert _get_result("""
+        class Bar(object):
+            pass
+        isinstance(Bar(), object)
+        """) == "True"
+
+    def test_isinstance_object_true3(self):
+        assert _get_result("""
+        class Bar(object):
+            pass
+        isinstance(Bar(), Bar)
+        """) == "True"
+
+    def test_isinstance_class_false(self):
+        assert _get_result("""
+        class Foo(object):
+            pass
+        class Bar(object):
+            pass
+        isinstance(Bar(), Foo)
+        """) == "False"
+
+    def test_isinstance_type_false(self):
+        assert _get_result("""
+        class Bar(object):
+            pass
+        isinstance(Bar(), type)
+        """) == "False"
+
+    def test_isinstance_str_true(self):
+        """Make sure isinstance can check bultin str types"""
+        assert _get_result("isinstance('a', str)") == "True"
+
+    def test_isinstance_str_false(self):
+        assert _get_result("isinstance(1, str)") == "False"
+
+    def test_isinstance_tuple_argument(self):
+        """obj just has to be an instance of ANY class/type on the right"""
+        assert _get_result("isinstance(1, (str, int))") == "True"
+
+    def test_isinstance_type_false2(self):
+        assert _get_result("""
+        isinstance(1, type)
+        """) == "False"
+
+    def test_isinstance_object_true2(self):
+        assert _get_result("""
+        class Bar(type):
+            pass
+        mainbar = Bar("Bar", tuple(), {})
+        isinstance(mainbar, object)
+        """) == "True"
+
+    def test_isinstance_type_true(self):
+        assert _get_result("""
+        class Bar(type):
+            pass
+        mainbar = Bar("Bar", tuple(), {})
+        isinstance(mainbar, type)
+        """) == "True"
+
+    def test_isinstance_edge_case(self):
+        """isinstance allows bad type short-circuting"""
+        assert _get_result("isinstance(1, (int, 1))") == "True"
+
+    def test_uninferable_bad_type(self):
+        """The second argument must be a class or a tuple of classes"""
+        with pytest.raises(astroid.InferenceError):
+            _get_result_node("isinstance(int, 1)")
+
+    def test_uninferable_keywords(self):
+        """isinstance does not allow keywords"""
+        with pytest.raises(astroid.InferenceError):
+            _get_result_node("isinstance(1, class_or_tuple=int)")
+
+    def test_too_many_args(self):
+        """isinstance must have two arguments"""
+        with pytest.raises(astroid.InferenceError):
+            _get_result_node("isinstance(1, int, str)")
+
+    def test_first_param_is_uninferable(self):
+        with pytest.raises(astroid.InferenceError):
+            _get_result_node('isinstance(something, int)')
+
+
+class TestIssubclassBrain:
+    """Test issubclass() builtin inference"""
+
+    def test_type_type(self):
+        assert _get_result("issubclass(type, type)") == "True"
+
+    def test_object_type(self):
+        assert _get_result("issubclass(object, type)") == "False"
+
+    def test_type_object(self):
+        assert _get_result("issubclass(type, object)") == "True"
+
+    def test_issubclass_same_class(self):
+        assert _get_result("issubclass(int, int)") == "True"
+
+    def test_issubclass_not_the_same_class(self):
+        assert _get_result("issubclass(str, int)") == "False"
+
+    def test_issubclass_object_true(self):
+        assert _get_result("""
+        class Bar(object):
+            pass
+        issubclass(Bar, object)
+        """) == "True"
+
+    def test_issubclass_same_user_defined_class(self):
+        assert _get_result("""
+        class Bar(object):
+            pass
+        issubclass(Bar, Bar)
+        """) == "True"
+
+    def test_issubclass_different_user_defined_classes(self):
+        assert _get_result("""
+        class Foo(object):
+            pass
+        class Bar(object):
+            pass
+        issubclass(Bar, Foo)
+        """) == "False"
+
+    def test_issubclass_type_false(self):
+        assert _get_result("""
+        class Bar(object):
+            pass
+        issubclass(Bar, type)
+        """) == "False"
+
+    def test_isinstance_tuple_argument(self):
+        """obj just has to be a subclass of ANY class/type on the right"""
+        assert _get_result("issubclass(int, (str, int))") == "True"
+
+    def test_isinstance_object_true2(self):
+        assert _get_result("""
+        class Bar(type):
+            pass
+        issubclass(Bar, object)
+        """) == "True"
+
+    def test_issubclass_short_circuit(self):
+        """issubclasss allows bad type short-circuting"""
+        assert _get_result("issubclass(int, (int, 1))") == "True"
+
+    def test_uninferable_bad_type(self):
+        """The second argument must be a class or a tuple of classes"""
+        # Should I subclass
+        with pytest.raises(astroid.InferenceError):
+            _get_result_node("issubclass(int, 1)")
+
+    def test_uninferable_keywords(self):
+        """issubclass does not allow keywords"""
+        with pytest.raises(astroid.InferenceError):
+            _get_result_node("issubclass(int, class_or_tuple=int)")
+
+    def test_too_many_args(self):
+        """issubclass must have two arguments"""
+        with pytest.raises(astroid.InferenceError):
+            _get_result_node("issubclass(int, int, str)")
+
+
+def _get_result_node(code):
+    node = next(astroid.extract_node(code).infer())
+    return node
+
+
+def _get_result(code):
+    return _get_result_node(code).as_string()
+
+
+class TestLenBuiltinInference:
+    def test_len_list(self):
+        # Uses .elts
+        node = astroid.extract_node("""
+        len(['a','b','c'])
+        """)
+        node = next(node.infer())
+        assert node.as_string() == '3'
+        assert isinstance(node, nodes.Const)
+
+    def test_len_tuple(self):
+        node = astroid.extract_node("""
+        len(('a','b','c'))
+        """)
+        node = next(node.infer())
+        assert node.as_string() == '3'
+
+    def test_len_var(self):
+        # Make sure argument is inferred
+        node = astroid.extract_node("""
+        a = [1,2,'a','b','c']
+        len(a)
+        """)
+        node = next(node.infer())
+        assert node.as_string() == '5'
+
+    def test_len_dict(self):
+        # Uses .items
+        node = astroid.extract_node("""
+        a = {'a': 1, 'b': 2}
+        len(a)
+        """)
+        node = next(node.infer())
+        assert node.as_string() == '2'
+
+    def test_len_set(self):
+        node = astroid.extract_node("""
+        len({'a'})
+        """)
+        inferred_node = next(node.infer())
+        assert inferred_node.as_string() == '1'
+
+    def test_len_object(self):
+        """Test len with objects that implement the len protocol"""
+        node = astroid.extract_node("""
+        class A:
+            def __len__(self):
+                return 57
+        len(A())
+        """)
+        inferred_node = next(node.infer())
+        assert inferred_node.as_string() == '57'
+
+    def test_len_class_with_metaclass(self):
+        """Make sure proper len method is located"""
+        cls_node, inst_node = astroid.extract_node("""
+        class F2(type):
+            def __new__(cls, name, bases, attrs):
+                return super().__new__(cls, name, bases, {})
+            def __len__(self):
+                return 57
+        class F(metaclass=F2):
+            def __len__(self):
+                return 4
+        len(F) #@
+        len(F()) #@
+        """)
+        assert next(cls_node.infer()).as_string() == '57'
+        assert next(inst_node.infer()).as_string() == '4'
+
+    def test_len_object_failure(self):
+        """If taking the length of a class, do not use an instance method"""
+        node = astroid.extract_node("""
+        class F:
+            def __len__(self):
+                return 57
+        len(F)
+        """)
+        with pytest.raises(astroid.InferenceError):
+            next(node.infer())
+
+    def test_len_string(self):
+        node = astroid.extract_node("""
+        len("uwu")
+        """)
+        assert next(node.infer()).as_string() == "3"
+
+    def test_len_generator_failure(self):
+        node = astroid.extract_node("""
+        def gen():
+            yield 'a'
+            yield 'b'
+        len(gen())
+        """)
+        with pytest.raises(astroid.InferenceError):
+            next(node.infer())
+
+    def test_len_failure_missing_variable(self):
+        node = astroid.extract_node("""
+        len(a)
+        """)
+        with pytest.raises(astroid.InferenceError):
+            next(node.infer())
+
+    def test_len_bytes(self):
+        node = astroid.extract_node("""
+        len(b'uwu')
+        """)
+        assert next(node.infer()).as_string() == '3'
+
+
+    @pytest.mark.xfail(reason="Can't retrieve subclassed type value ")
+    def test_int_subclass_result(self):
+        """I am unable to figure out the value of an
+        object which subclasses int"""
+        node = astroid.extract_node("""
+        class IntSubclass(int):
+            pass
+
+        class F:
+            def __len__(self):
+                return IntSubclass(5)
+        len(F())
+        """)
+        assert next(node.infer()).as_string() == '5'
+
+    @pytest.mark.xfail(reason="Can't use list special astroid fields")
+    def test_int_subclass_argument(self):
+        """I am unable to access the length of a object which
+        subclasses list"""
+        node = astroid.extract_node("""
+        class ListSubclass(list):
+            pass
+        len(ListSubclass([1,2,3,4,4]))
+        """)
+        assert next(node.infer()).as_string() == '5'
+
+    def test_len_builtin_inference_attribute_error_str(self):
+        """Make sure len builtin doesn't raise an AttributeError
+        on instances of str or bytes
+
+        See https://github.com/PyCQA/pylint/issues/1942
+        """
+        code = 'len(str("F"))'
+        try:
+            next(astroid.extract_node(code).infer())
+        except astroid.InferenceError:
+            pass
+
+
+def test_infer_str():
+    ast_nodes = astroid.extract_node('''
+    str(s) #@
+    str('a') #@
+    str(some_object()) #@
+    ''')
+    for node in ast_nodes:
+        inferred = next(node.infer())
+        assert isinstance(inferred, astroid.Const)
+
+    node = astroid.extract_node('''
+    str(s='') #@
+    ''')
+    inferred = next(node.infer())
+    assert isinstance(inferred, astroid.Instance)
+    assert inferred.qname() == 'builtins.str'
+
+
+def test_infer_int():
+    ast_nodes = astroid.extract_node('''
+    int(0) #@
+    int('1') #@
+    ''')
+    for node in ast_nodes:
+        inferred = next(node.infer())
+        assert isinstance(inferred, astroid.Const)
+
+    ast_nodes = astroid.extract_node('''
+    int(s='') #@
+    int('2.5') #@
+    int('something else') #@
+    int(unknown) #@
+    int(b'a') #@
+    ''')
+    for node in ast_nodes:
+        inferred = next(node.infer())
+        assert isinstance(inferred, astroid.Instance)
+        assert inferred.qname() == 'builtins.int'
+
+
+def test_infer_dict_from_keys():
+    bad_nodes = astroid.extract_node('''
+    dict.fromkeys() #@
+    dict.fromkeys(1, 2, 3) #@
+    dict.fromkeys(a=1) #@
+    ''')
+    for node in bad_nodes:
+        with pytest.raises(astroid.InferenceError):
+            next(node.infer())
+
+    # Test uninferable values
+    good_nodes = astroid.extract_node('''
+    from unknown import Unknown
+    dict.fromkeys(some_value) #@
+    dict.fromkeys(some_other_value) #@
+    dict.fromkeys([Unknown(), Unknown()]) #@
+    dict.fromkeys([Unknown(), Unknown()]) #@
+    ''')
+    for node in good_nodes:
+        inferred = next(node.infer())
+        assert isinstance(inferred, astroid.Dict)
+        assert inferred.items == []
+
+    # Test inferrable values
+
+    # from a dictionary's keys
+    from_dict = astroid.extract_node('''
+    dict.fromkeys({'a':2, 'b': 3, 'c': 3}) #@
+    ''')
+    inferred = next(from_dict.infer())
+    assert isinstance(inferred, astroid.Dict)
+    itered = inferred.itered()
+    assert all(isinstance(elem, astroid.Const) for elem in itered)
+    actual_values = [elem.value for elem in itered]
+    assert sorted(actual_values) == ['a', 'b', 'c']
+
+    # from a string
+    from_string = astroid.extract_node('''
+    dict.fromkeys('abc')
+    ''')
+    inferred = next(from_string.infer())
+    assert isinstance(inferred, astroid.Dict)
+    itered = inferred.itered()
+    assert all(isinstance(elem, astroid.Const) for elem in itered)
+    actual_values = [elem.value for elem in itered]
+    assert sorted(actual_values) == ['a', 'b', 'c']
+
+    # from bytes
+    from_bytes = astroid.extract_node('''
+    dict.fromkeys(b'abc')
+    ''')
+    inferred = next(from_bytes.infer())
+    assert isinstance(inferred, astroid.Dict)
+    itered = inferred.itered()
+    assert all(isinstance(elem, astroid.Const) for elem in itered)
+    actual_values = [elem.value for elem in itered]
+    assert sorted(actual_values) == [97, 98, 99]
+
+    # From list/set/tuple
+    from_others = astroid.extract_node('''
+    dict.fromkeys(('a', 'b', 'c')) #@
+    dict.fromkeys(['a', 'b', 'c']) #@
+    dict.fromkeys({'a', 'b', 'c'}) #@
+    ''')
+    for node in from_others:
+        inferred = next(node.infer())
+        assert isinstance(inferred, astroid.Dict)
+        itered = inferred.itered()
+        assert all(isinstance(elem, astroid.Const) for elem in itered)
+        actual_values = [elem.value for elem in itered]
+        assert sorted(actual_values) == ['a', 'b', 'c']
+
+
+class TestFunctoolsPartial:
+
+    def test_invalid_functools_partial_calls(self):
+        ast_nodes = astroid.extract_node('''
+        from functools import partial
+        from unknown import Unknown
+
+        def test(a, b, c):
+            return a + b + c
+
+        partial() #@
+        partial(test) #@
+        partial(func=test) #@
+        partial(some_func, a=1) #@
+        partial(Unknown, a=1) #@
+        partial(2, a=1) #@
+        partial(test, unknown=1) #@
+        ''')
+        for node in ast_nodes:
+            inferred = next(node.infer())
+            assert isinstance(inferred, (astroid.FunctionDef, astroid.Instance))
+            assert inferred.qname() in ('functools.partial', 'functools.partial.newfunc')
+
+    def test_inferred_partial_function_calls(self):
+        ast_nodes = astroid.extract_node('''
+        from functools import partial
+        def test(a, b):
+            return a + b
+        partial(test, 1)(3) #@
+        partial(test, b=4)(3) #@
+        partial(test, b=4)(a=3) #@
+        def other_test(a, b, *, c=1):
+            return (a + b) * c
+
+        partial(other_test, 1, 2)() #@
+        partial(other_test, 1, 2)(c=4) #@
+        partial(other_test, c=4)(1, 3) #@
+        partial(other_test, 4, c=4)(4) #@
+        partial(other_test, 4, c=4)(b=5) #@
+        ''')
+        expected_values = [
+            4, 7, 7, 3, 12, 16, 32, 36,
+        ]
+        for node, expected_value in zip(ast_nodes, expected_values):
+            inferred = next(node.infer())
+            assert isinstance(inferred, astroid.Const)
+            assert inferred.value == expected_value
+
+
 if __name__ == '__main__':
     unittest.main()
diff -Nru astroid-1.6.5/astroid/tests/unittest_builder.py astroid-2.0/astroid/tests/unittest_builder.py
--- astroid-1.6.5/astroid/tests/unittest_builder.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/tests/unittest_builder.py	2018-07-15 09:19:31.000000000 +0200
@@ -1,19 +1,26 @@
+# -*- coding: utf-8 -*-
 # Copyright (c) 2006-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
-# Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2014-2018 Claudiu Popa <pcmanticore@gmail.com>
 # Copyright (c) 2014-2015 Google, Inc.
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>
+# Copyright (c) 2016 Jakub Wilk <jwilk@jwilk.net>
+# Copyright (c) 2017 Bryce Guinta <bryce.paul.guinta@gmail.com>
+# Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
+# Copyright (c) 2018 brendanator <brendan.maginnis@gmail.com>
+# Copyright (c) 2018 Anthony Sottile <asottile@umich.edu>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
 
 """tests for the astroid builder and rebuilder module"""
 
+import builtins
+import collections
 import os
 import sys
 import unittest
 
-import six
-
 from astroid import builder
 from astroid import exceptions
 from astroid import manager
@@ -23,7 +30,7 @@
 from astroid.tests import resources
 
 MANAGER = manager.AstroidManager()
-BUILTINS = six.moves.builtins.__name__
+BUILTINS = builtins.__name__
 
 
 class FromToLineNoTest(unittest.TestCase):
@@ -265,17 +272,6 @@
     def test_inspect_build0(self):
         """test astroid tree build from a living object"""
         builtin_ast = MANAGER.ast_from_module_name(BUILTINS)
-        if six.PY2:
-            fclass = builtin_ast['file']
-            self.assertIn('name', fclass)
-            self.assertIn('mode', fclass)
-            self.assertIn('read', fclass)
-            self.assertTrue(fclass.newstyle)
-            self.assertTrue(fclass.pytype(), '%s.type' % BUILTINS)
-            self.assertIsInstance(fclass['read'], nodes.FunctionDef)
-            # check builtin function has args.args == None
-            dclass = builtin_ast['dict']
-            self.assertIsNone(dclass['has_key'].args.args)
         # just check type and object are there
         builtin_ast.getattr('type')
         objectastroid = builtin_ast.getattr('object')[0]
@@ -290,12 +286,8 @@
         self.assertIsInstance(builtin_ast['None'], nodes.Const)
         self.assertIsInstance(builtin_ast['True'], nodes.Const)
         self.assertIsInstance(builtin_ast['False'], nodes.Const)
-        if six.PY3:
-            self.assertIsInstance(builtin_ast['Exception'], nodes.ClassDef)
-            self.assertIsInstance(builtin_ast['NotImplementedError'], nodes.ClassDef)
-        else:
-            self.assertIsInstance(builtin_ast['Exception'], nodes.ImportFrom)
-            self.assertIsInstance(builtin_ast['NotImplementedError'], nodes.ImportFrom)
+        self.assertIsInstance(builtin_ast['Exception'], nodes.ClassDef)
+        self.assertIsInstance(builtin_ast['NotImplementedError'], nodes.ClassDef)
 
     def test_inspect_build1(self):
         time_ast = MANAGER.ast_from_module_name('time')
@@ -417,14 +409,9 @@
                 "new style"
         '''
         mod_ast = builder.parse(data, __name__)
-        if six.PY3:
-            self.assertTrue(mod_ast['A'].newstyle)
-            self.assertTrue(mod_ast['B'].newstyle)
-            self.assertTrue(mod_ast['E'].newstyle)
-        else:
-            self.assertFalse(mod_ast['A'].newstyle)
-            self.assertFalse(mod_ast['B'].newstyle)
-            self.assertFalse(mod_ast['E'].newstyle)
+        self.assertTrue(mod_ast['A'].newstyle)
+        self.assertTrue(mod_ast['B'].newstyle)
+        self.assertTrue(mod_ast['E'].newstyle)
         self.assertTrue(mod_ast['C'].newstyle)
         self.assertTrue(mod_ast['D'].newstyle)
         self.assertTrue(mod_ast['F'].newstyle)
@@ -451,11 +438,6 @@
         with self.assertRaises(exceptions.InferenceError):
             next(astroid['global_no_effect'].ilookup('CSTE2'))
 
-    @unittest.skipIf(os.name == 'java',
-                     'This test is skipped on Jython, because the '
-                     'socket object is patched later on with the '
-                     'methods we are looking for. Since we do not '
-                     'understand setattr in for loops yet, we skip this')
     def test_socket_build(self):
         import socket
         astroid = self.builder.module_build(socket)
@@ -485,14 +467,14 @@
 
     def test_future_imports(self):
         mod = builder.parse("from __future__ import print_function")
-        self.assertEqual(set(['print_function']), mod.future_imports)
+        self.assertEqual({'print_function'}, mod.future_imports)
 
     def test_two_future_imports(self):
         mod = builder.parse("""
             from __future__ import print_function
             from __future__ import absolute_import
             """)
-        self.assertEqual(set(['print_function', 'absolute_import']), mod.future_imports)
+        self.assertEqual({'print_function', 'absolute_import'}, mod.future_imports)
 
     def test_inferred_build(self):
         code = '''
@@ -529,7 +511,7 @@
             '''
         builder.parse(code)
         nonetype = nodes.const_factory(None)
-        # pylint: disable=no-member; union type in const_factory, this shouldn't happen
+        # pylint: disable=no-member; Infers two potential values
         self.assertNotIn('custom_attr', nonetype.locals)
         self.assertNotIn('custom_attr', nonetype.instance_attrs)
         nonetype = nodes.const_factory({})
@@ -630,17 +612,14 @@
         module = self.module
         klass = module['YO']
         self.assertEqual(klass.name, 'YO')
-        self.assertEqual(klass.doc, 'hehe')
+        self.assertEqual(klass.doc, 'hehe\n    haha')
         self.assertEqual(klass.fromlineno, 25)
         self.assertTrue(klass.parent)
         self.assertEqual(klass.frame(), klass)
         self.assertEqual(klass.parent.frame(), module)
         self.assertEqual(klass.root(), module)
         self.assertEqual(klass.basenames, [])
-        if six.PY3:
-            self.assertTrue(klass.newstyle)
-        else:
-            self.assertFalse(klass.newstyle)
+        self.assertTrue(klass.newstyle)
 
     def test_class_locals(self):
         """test the 'locals' dictionary of a astroid class"""
@@ -648,13 +627,20 @@
         klass1 = module['YO']
         locals1 = klass1.locals
         keys = sorted(locals1.keys())
-        self.assertEqual(keys, ['__init__', 'a'])
+        assert_keys = ['__init__', '__module__', '__qualname__', 'a']
+        if sys.version_info < (3, 3):
+            assert_keys.pop(assert_keys.index('__qualname__'))
+        self.assertEqual(keys, assert_keys)
         klass2 = module['YOUPI']
         locals2 = klass2.locals
         keys = locals2.keys()
-        self.assertEqual(sorted(keys),
-                         ['__init__', 'class_attr', 'class_method',
-                          'method', 'static_method'])
+        assert_keys = [
+            '__init__', '__module__', '__qualname__', 'class_attr', 'class_method',
+            'method', 'static_method'
+        ]
+        if sys.version_info < (3, 3):
+            assert_keys.pop(assert_keys.index('__qualname__'))
+        self.assertEqual(sorted(keys), assert_keys)
 
     def test_class_instance_attrs(self):
         module = self.module
@@ -677,8 +663,8 @@
         method = klass2['method']
         self.assertEqual(method.name, 'method')
         self.assertEqual([n.name for n in method.args.args], ['self'])
-        self.assertEqual(method.doc, 'method test')
-        self.assertEqual(method.fromlineno, 47)
+        self.assertEqual(method.doc, 'method\n        test')
+        self.assertEqual(method.fromlineno, 48)
         self.assertEqual(method.type, 'method')
         # class method
         method = klass2['class_method']
@@ -719,55 +705,11 @@
         else:
             self.module = abuilder.module_build(data.module, 'data.module')
 
-@unittest.skipIf(six.PY3, "guess_encoding not used on Python 3")
-class TestGuessEncoding(unittest.TestCase):
-    def setUp(self):
-        self.guess_encoding = builder._guess_encoding
-
-    def testEmacs(self):
-        e = self.guess_encoding('# -*- coding: UTF-8  -*-')
-        self.assertEqual(e, 'UTF-8')
-        e = self.guess_encoding('# -*- coding:UTF-8 -*-')
-        self.assertEqual(e, 'UTF-8')
-        e = self.guess_encoding('''
-        ### -*- coding: ISO-8859-1  -*-
-        ''')
-        self.assertEqual(e, 'ISO-8859-1')
-        e = self.guess_encoding('''
-
-        ### -*- coding: ISO-8859-1  -*-
-        ''')
-        self.assertIsNone(e)
-
-    def testVim(self):
-        e = self.guess_encoding('# vim:fileencoding=UTF-8')
-        self.assertEqual(e, 'UTF-8')
-        e = self.guess_encoding('''
-        ### vim:fileencoding=ISO-8859-1
-        ''')
-        self.assertEqual(e, 'ISO-8859-1')
-        e = self.guess_encoding('''
-
-        ### vim:fileencoding= ISO-8859-1
-        ''')
-        self.assertIsNone(e)
 
-    def test_wrong_coding(self):
-        # setting "coding" variable
-        e = self.guess_encoding("coding = UTF-8")
-        self.assertIsNone(e)
-        # setting a dictionary entry
-        e = self.guess_encoding("coding:UTF-8")
-        self.assertIsNone(e)
-        # setting an argument
-        e = self.guess_encoding("def do_something(a_word_with_coding=None):")
-        self.assertIsNone(e)
-
-    def testUTF8(self):
-        e = self.guess_encoding('\xef\xbb\xbf any UTF-8 data')
-        self.assertEqual(e, 'UTF-8')
-        e = self.guess_encoding(' any UTF-8 data \xef\xbb\xbf')
-        self.assertIsNone(e)
+def test_module_build_dunder_file():
+    """Test that module_build() can work with modules that have the *__file__* attribute"""
+    module = builder.AstroidBuilder().module_build(collections)
+    assert module.path[0] == collections.__file__
 
 
 if __name__ == '__main__':
diff -Nru astroid-1.6.5/astroid/tests/unittest_helpers.py astroid-2.0/astroid/tests/unittest_helpers.py
--- astroid-1.6.5/astroid/tests/unittest_helpers.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/tests/unittest_helpers.py	2018-07-15 09:19:28.000000000 +0200
@@ -1,14 +1,12 @@
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
-# Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016, 2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
 
 
 import unittest
-
-import six
-from six.moves import builtins
+import builtins
 
 from astroid import builder
 from astroid import exceptions
@@ -93,10 +91,10 @@
         self.assert_classes_equal(instance_type, cls)
 
         expected_method_types = [
-            (ast_nodes[3], 'instancemethod' if six.PY2 else 'function'),
-            (ast_nodes[4], 'instancemethod' if six.PY2 else 'method'),
-            (ast_nodes[5], 'instancemethod' if six.PY2 else 'method'),
-            (ast_nodes[6], 'instancemethod' if six.PY2 else 'method'),
+            (ast_nodes[3], 'function'),
+            (ast_nodes[4], 'method'),
+            (ast_nodes[5], 'method'),
+            (ast_nodes[6], 'method'),
             (ast_nodes[7], 'function'),
             (ast_nodes[8], 'function'),
             (ast_nodes[9], 'generator'),
diff -Nru astroid-1.6.5/astroid/tests/unittest_inference.py astroid-2.0/astroid/tests/unittest_inference.py
--- astroid-1.6.5/astroid/tests/unittest_inference.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/tests/unittest_inference.py	2018-07-15 09:19:34.000000000 +0200
@@ -1,9 +1,21 @@
+# -*- coding: utf-8 -*-
 # Copyright (c) 2006-2015 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
+# Copyright (c) 2007 Marien Zwart <marienz@gentoo.org>
 # Copyright (c) 2013-2014 Google, Inc.
-# Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2014-2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2014 Eevee (Alex Munroe) <amunroe@yelp.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
 # Copyright (c) 2015 Dmitry Pribysh <dmand@yandex.ru>
 # Copyright (c) 2015 Rene Zhang <rz99@cornell.edu>
+# Copyright (c) 2016 Jakub Wilk <jwilk@jwilk.net>
+# Copyright (c) 2017 Hugo <hugovk@users.noreply.github.com>
+# Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
+# Copyright (c) 2017 Calen Pennington <cale@edx.org>
+# Copyright (c) 2017 Calen Pennington <calen.pennington@gmail.com>
+# Copyright (c) 2017 David Euresti <david@dropbox.com>
+# Copyright (c) 2017 Derek Gustafson <degustaf@gmail.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
+# Copyright (c) 2018 Anthony Sottile <asottile@umich.edu>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -11,13 +23,13 @@
 """tests for the astroid inference capabilities
 """
 # pylint: disable=too-many-lines
-import os
+import platform
 import sys
 from functools import partial
 import unittest
-import warnings
+from unittest.mock import patch
 
-import six
+import pytest
 
 from astroid import InferenceError, builder, nodes
 from astroid.builder import parse, extract_node
@@ -84,8 +96,8 @@
         inferred = next(node.infer())
         self.assertIsInstance(inferred, nodes.Dict)
 
-        elts = set([(key.value, value.value)
-                    for (key, value) in inferred.items])
+        elts = {(key.value, value.value)
+                for (key, value) in inferred.items}
         self.assertEqual(sorted(elts), sorted(expected.items()))
 
     assertInferTuple = partialmethod(_assertInferElts, nodes.Tuple)
@@ -221,7 +233,7 @@
         inferred = self.ast['i'].infer()
         const = next(inferred)
         self.assertIsInstance(const, nodes.Const)
-        self.assertEqual(const.value, u"glup")
+        self.assertEqual(const.value, "glup")
         self.assertRaises(StopIteration, partial(next, inferred))
         inferred = self.ast['j'].infer()
         const = next(inferred)
@@ -368,21 +380,6 @@
         self.assertEqual(a_inferred[0].value, 1)
         self.assertEqual(len(a_inferred), 1)
 
-    def test_infered_warning(self):
-        code = '''
-            def f(f=1):
-                return f
-
-            a = f()
-        '''
-        ast = parse(code, __name__)
-        a = ast['a']
-
-        with warnings.catch_warnings(record=True) as w:
-            with test_utils.enable_warning(PendingDeprecationWarning):
-                a.infered()
-            self.assertIsInstance(w[0].message, PendingDeprecationWarning)
-
     def test_exc_ancestors(self):
         code = '''
         def f():
@@ -732,10 +729,7 @@
         node = extract_node('''b'a'[0]''')
         inferred = next(node.infer())
         self.assertIsInstance(inferred, nodes.Const)
-        if six.PY2:
-            self.assertEqual(inferred.value, 'a')
-        else:
-            self.assertEqual(inferred.value, 97)
+        self.assertEqual(inferred.value, 97)
 
     def test_simple_tuple(self):
         module = parse("""
@@ -801,14 +795,9 @@
         node = extract_node(code, __name__).func
         inferred = list(node.infer())
         self.assertEqual(len(inferred), 1)
-        if hasattr(sys, 'pypy_version_info'):
-            self.assertIsInstance(inferred[0], nodes.ClassDef)
-            self.assertEqual(inferred[0].name, 'file')
-        else:
-            self.assertIsInstance(inferred[0], nodes.FunctionDef)
-            self.assertEqual(inferred[0].name, 'open')
-
-    if os.name == 'java':
+        self.assertIsInstance(inferred[0], nodes.FunctionDef)
+        self.assertEqual(inferred[0].name, 'open')
+    if platform.python_implementation() == 'PyPy':
         test_builtin_open = unittest.expectedFailure(test_builtin_open)
 
     def test_callfunc_context_func(self):
@@ -859,6 +848,56 @@
         self.assertEqual(inferred[0]._proxied.name, 'Sub')
 
 
+    def test_factory_methods_cls_call(self):
+        ast = extract_node("""
+        class C:
+            @classmethod
+            def factory(cls):
+                return cls()
+
+        class D(C):
+            pass
+
+        C.factory() #@
+        D.factory() #@
+        """, 'module')
+        should_be_C = list(ast[0].infer())
+        should_be_D = list(ast[1].infer())
+        self.assertEqual(1, len(should_be_C))
+        self.assertEqual(1, len(should_be_D))
+        self.assertEqual('module.C', should_be_C[0].qname())
+        self.assertEqual('module.D', should_be_D[0].qname())
+
+
+    def test_factory_methods_object_new_call(self):
+        ast = extract_node("""
+        class C:
+            @classmethod
+            def factory(cls):
+                return object.__new__(cls)
+
+        class D(C):
+            pass
+
+        C.factory() #@
+        D.factory() #@
+        """, 'module')
+        should_be_C = list(ast[0].infer())
+        should_be_D = list(ast[1].infer())
+        self.assertEqual(1, len(should_be_C))
+        self.assertEqual(1, len(should_be_D))
+        self.assertEqual('module.C', should_be_C[0].qname())
+        self.assertEqual('module.D', should_be_D[0].qname())
+
+    def test_factory_methods_inside_binary_operation(self):
+        node = extract_node("""
+        from pathlib import Path
+        h = Path("/home")
+        u = h / "user"
+        u #@
+        """)
+        assert next(node.infer()).qname() == 'pathlib.Path'
+
     def test_import_as(self):
         code = '''
             import os.path as osp
@@ -1076,7 +1115,7 @@
         # (__name__ == '__main__') and through pytest (__name__ ==
         # 'unittest_inference')
         self.assertEqual(value, ['Instance of %s.myarray' % __name__,
-                                 'Instance of %s.int' % BUILTINS])
+                                 'Const.int(value=5)'])
 
     def test_nonregr_lambda_arg(self):
         code = '''
@@ -1129,6 +1168,51 @@
         self.assertEqual(len(foo_class.instance_attrs['attr']), 1)
         self.assertEqual(bar_class.instance_attrs, {'attr': [assattr]})
 
+    def test_nonregr_multi_referential_addition(self):
+        """Regression test for https://github.com/PyCQA/astroid/issues/483
+        Make sure issue where referring to the same variable
+        in the same inferred expression caused an uninferable result.
+        """
+        code = """
+        b = 1
+        a = b + b
+        a #@
+        """
+        variable_a = extract_node(code)
+        self.assertEqual(variable_a.inferred()[0].value, 2)
+
+    @test_utils.require_version(minver='3.5')
+    def test_nonregr_layed_dictunpack(self):
+        """Regression test for https://github.com/PyCQA/astroid/issues/483
+        Make sure mutliple dictunpack references are inferable
+        """
+        code = """
+        base = {'data': 0}
+        new = {**base, 'data': 1}
+        new3 = {**base, **new}
+        new3 #@
+        """
+        ass = extract_node(code)
+        self.assertIsInstance(ass.inferred()[0], nodes.Dict)
+
+    def test_nonregr_inference_modifying_col_offset(self):
+        """Make sure inference doesn't improperly modify col_offset
+
+        Regression test for https://github.com/PyCQA/pylint/issues/1839
+        """
+
+        code = """
+        class F:
+            def _(self):
+                return type(self).f
+        """
+        mod = parse(code)
+        cdef = mod.body[0]
+        call = cdef.body[0].body[0].value.expr
+        orig_offset = cdef.col_offset
+        call.inferred()
+        self.assertEqual(cdef.col_offset, orig_offset)
+
     def test_python25_no_relative_import(self):
         ast = resources.build_file('data/package/absimport.py')
         self.assertTrue(ast.absolute_import_activated(), True)
@@ -1185,7 +1269,7 @@
             my_smtp = SendMailController().smtp
             my_me = SendMailController().me
             '''
-        decorators = set(['%s.property' % BUILTINS])
+        decorators = {'%s.property' % BUILTINS}
         ast = parse(code, __name__)
         self.assertEqual(ast['SendMailController']['smtp'].decoratornames(),
                          decorators)
@@ -1885,6 +1969,30 @@
             node = extract_node(code)
             self.assertInferDict(node, expected_value)
 
+    @test_utils.require_version('3.5')
+    def test_dict_inference_unpack_repeated_key(self):
+        """Make sure astroid does not infer repeated keys in a dictionary
+
+        Regression test for https://github.com/PyCQA/pylint/issues/1843
+        """
+        code = """
+        base = {'data': 0}
+        new = {**base, 'data': 1} #@
+        new2 = {'data': 1, **base} #@ # Make sure overwrite works
+        a = 'd' + 'ata'
+        b3 = {**base, a: 3} #@  Make sure keys are properly inferred
+        b4 = {a: 3, **base} #@
+        """
+        ast = extract_node(code)
+        final_values = (
+            "{'data': 1}",
+            "{'data': 0}",
+            "{'data': 3}",
+            "{'data': 0}",
+        )
+        for node, final_value in zip(ast, final_values):
+            assert node.targets[0].inferred()[0].as_string() == final_value
+
     def test_dict_invalid_args(self):
         invalid_values = [
             'dict(*1)',
@@ -1922,7 +2030,7 @@
         ' '.count() #@
         """
         ast = extract_node(code, __name__)
-        self.assertInferConst(ast[0], u'')
+        self.assertInferConst(ast[0], '')
         for i in range(1, 16):
             self.assertInferConst(ast[i], '')
         for i in range(16, 19):
@@ -1955,7 +2063,7 @@
         ast = extract_node(code, __name__)
         self.assertInferConst(ast[0], '')
         for i in range(1, 16):
-            self.assertInferConst(ast[i], u'')
+            self.assertInferConst(ast[i], '')
         for i in range(16, 19):
             self.assertInferConst(ast[i], 0)
 
@@ -3209,16 +3317,16 @@
         self.assertIsInstance(attributes[0], nodes.Const)
         self.assertEqual(attributes[0].value, 1)
 
+
     def test_type__new__not_enough_arguments(self):
         ast_nodes = extract_node('''
-        type.__new__(1) #@
-        type.__new__(1, 2) #@
-        type.__new__(1, 2, 3) #@
-        type.__new__(1, 2, 3, 4, 5) #@
+        type.__new__(type, 'foo') #@
+        type.__new__(type, 'foo', ()) #@
+        type.__new__(type, 'foo', (), {}, ()) #@
         ''')
         for node in ast_nodes:
-            inferred = next(node.infer())
-            self.assertIsInstance(inferred, Instance)
+            with pytest.raises(InferenceError):
+                next(node.infer())
 
     def test_type__new__invalid_mcs_argument(self):
         ast_nodes = extract_node('''
@@ -3227,8 +3335,8 @@
         type.__new__(Class, 2, 3, 4) #@
         ''')
         for node in ast_nodes:
-            inferred = next(node.infer())
-            self.assertIsInstance(inferred, Instance)
+            with pytest.raises(InferenceError):
+                next(node.infer())
 
     def test_type__new__invalid_name(self):
         ast_nodes = extract_node('''
@@ -3238,8 +3346,8 @@
         type.__new__(Class, [], 1, 2) #@
         ''')
         for node in ast_nodes:
-            inferred = next(node.infer())
-            self.assertIsInstance(inferred, Instance)
+            with pytest.raises(InferenceError):
+                next(node.infer())
 
     def test_type__new__invalid_bases(self):
         ast_nodes = extract_node('''
@@ -3250,20 +3358,27 @@
         type.__new__(type, 'a', (object, 1), 2) #@
         ''')
         for node in ast_nodes:
-            inferred = next(node.infer())
-            self.assertIsInstance(inferred, Instance)
+            with pytest.raises(InferenceError):
+                next(node.infer())
 
     def test_type__new__invalid_attrs(self):
-        ast_nodes = extract_node('''
+        type_error_nodes = extract_node('''
         type.__new__(type, 'a', (), ()) #@
         type.__new__(type, 'a', (), object) #@
         type.__new__(type, 'a', (), 1) #@
-        type.__new__(type, 'a', (), {object: 1}) #@
-        type.__new__(type, 'a', (), {1:2, "a":5}) #@
+        ''')
+        for node in type_error_nodes:
+            with pytest.raises(InferenceError):
+                next(node.infer())
+
+        # Ignore invalid keys
+        ast_nodes = extract_node('''
+            type.__new__(type, 'a', (), {object: 1}) #@
+            type.__new__(type, 'a', (), {1:2, "a":5}) #@
         ''')
         for node in ast_nodes:
             inferred = next(node.infer())
-            self.assertIsInstance(inferred, Instance)
+            self.assertIsInstance(inferred, nodes.ClassDef)
 
     def test_type__new__metaclass_lookup(self):
         ast_node = extract_node('''
@@ -3301,7 +3416,8 @@
         ''')
         inferred = next(ast_node.infer())
         self.assertIsInstance(inferred, nodes.ClassDef)
-        titles = [title.value for title in inferred.igetattr('title')]
+        titles = [title.value for attr in inferred.getattr('title')
+                  for title in attr.inferred()]
         self.assertEqual(titles, ['Catch 22', 'Ubik', 'Grimus'])
 
     @unittest.expectedFailure
@@ -3462,6 +3578,36 @@
         inferred = next(ast_node.infer())
         self.assertIsInstance(inferred, nodes.ClassDef)
 
+    def test_metaclass_custom_dunder_call(self):
+        """The Metaclass __call__ should take precedence
+        over the default metaclass type call (initialization)
+
+        See https://github.com/PyCQA/pylint/issues/2159
+        """
+        val = extract_node("""
+        class _Meta(type):
+            def __call__(cls):
+                return 1
+        class Clazz(metaclass=_Meta):
+            def __call__(self):
+                return 5.5
+
+        Clazz() #@
+        """).inferred()[0].value
+        assert val == 1
+
+    def test_metaclass_custom_dunder_call_boundnode(self):
+        """The boundnode should be the calling class"""
+        cls = extract_node("""
+        class _Meta(type):
+            def __call__(cls):
+                return cls
+        class Clazz(metaclass=_Meta):
+            pass
+        Clazz() #@
+        """).inferred()[0]
+        assert isinstance(cls, nodes.ClassDef) and cls.name == "Clazz"
+
     def test_delayed_attributes_without_slots(self):
         ast_node = extract_node('''
         class A(object):
@@ -4098,7 +4244,7 @@
         ''')
         for ast_node, value in zip(ast_nodes, expected_values):
             inferred = next(ast_node.infer())
-            self.assertIsInstance(inferred, nodes.Const)
+            self.assertIsInstance(inferred, nodes.Const, inferred)
             self.assertEqual(inferred.value, value)
 
     @test_utils.require_version('3.5')
@@ -4333,5 +4479,250 @@
     assert next(cls_node.infer()) is util.Uninferable
 
 
+def test_infer_custom_inherit_from_property():
+    node = extract_node('''
+    class custom_property(property):
+        pass
+
+    class MyClass(object):
+        @custom_property
+        def my_prop(self):
+            return 1
+
+    MyClass().my_prop
+    ''')
+    inferred = next(node.infer())
+    assert isinstance(inferred, nodes.Const)
+    assert inferred.value == 1
+
+
+def test_cannot_infer_call_result_for_builtin_methods():
+    node = extract_node("""
+    a = "fast"
+    a
+    """)
+    inferred = next(node.infer())
+    lenmeth = next(inferred.igetattr("__len__"))
+    with pytest.raises(InferenceError):
+        next(lenmeth.infer_call_result(None, None))
+
+
+def test_unpack_dicts_in_assignment():
+    ast_nodes = extract_node('''
+    a, b = {1:2, 2:3}
+    a #@
+    b #@
+    ''')
+    first_inferred = next(ast_nodes[0].infer())
+    second_inferred = next(ast_nodes[1].infer())
+    assert isinstance(first_inferred, nodes.Const)
+    assert first_inferred.value == 1
+    assert isinstance(second_inferred, nodes.Const)
+    assert second_inferred.value == 2
+
+
+def test_slice_inference_in_for_loops():
+    node = extract_node('''
+    for a, (c, *b) in [(1, (2, 3, 4)), (4, (5, 6))]:
+       b #@
+    ''')
+    inferred = next(node.infer())
+    assert isinstance(inferred, nodes.List)
+    assert inferred.as_string() == '[3, 4]'
+
+    node = extract_node('''
+    for a, *b in [(1, 2, 3, 4)]:
+       b #@
+    ''')
+    inferred = next(node.infer())
+    assert isinstance(inferred, nodes.List)
+    assert inferred.as_string() == '[2, 3, 4]'
+
+    node = extract_node('''
+    for a, *b in [(1,)]:
+       b #@
+    ''')
+    inferred = next(node.infer())
+    assert isinstance(inferred, nodes.List)
+    assert inferred.as_string() == '[]'
+
+
+def test_slice_inference_in_for_loops_not_working():
+    ast_nodes = extract_node('''
+    from unknown import Unknown
+    for a, *b in something:
+        b #@
+    for a, *b in Unknown:
+        b #@
+    for a, *b in (1):
+        b #@
+    ''')
+    for node in ast_nodes:
+        inferred = next(node.infer())
+        assert inferred == util.Uninferable
+
+
+def test_unpacking_starred_and_dicts_in_assignment():
+    node = extract_node('''
+    a, *b = {1:2, 2:3, 3:4}
+    b
+    ''')
+    inferred = next(node.infer())
+    assert isinstance(inferred, nodes.List)
+    assert inferred.as_string() == '[2, 3]'
+
+    node = extract_node('''
+    a, *b = {1:2}
+    b
+    ''')
+    inferred = next(node.infer())
+    assert isinstance(inferred, nodes.List)
+    assert inferred.as_string() == '[]'
+
+
+def test_unpacking_starred_empty_list_in_assignment():
+    node = extract_node('''
+    a, *b, c = [1, 2]
+    b #@
+    ''')
+    inferred = next(node.infer())
+    assert isinstance(inferred, nodes.List)
+    assert inferred.as_string() == '[]'
+
+
+def test_regression_infinite_loop_decorator():
+    """Make sure decorators with the same names
+    as a decorated method do not cause an infinite loop
+
+    See https://github.com/PyCQA/astroid/issues/375
+    """
+    code = """
+    from functools import lru_cache
+
+    class Foo():
+        @lru_cache()
+        def lru_cache(self, value):
+            print('Computing {}'.format(value))
+            return value
+    Foo().lru_cache(1)
+    """
+    node = extract_node(code)
+    [result] = node.inferred()
+    assert result.value == 1
+
+
+def test_call_on_instance_with_inherited_dunder_call_method():
+    """Stop inherited __call__ method from incorrectly returning wrong class
+
+    See https://github.com/PyCQA/pylint/issues/2199
+    """
+    node = extract_node("""
+    class Base:
+        def __call__(self):
+            return self
+
+    class Sub(Base):
+        pass
+    obj = Sub()
+    val = obj()
+    val #@
+    """)
+    [val] = node.inferred()
+    assert isinstance(val, Instance)
+    assert val.name == "Sub"
+
+
+class TestInferencePropagation:
+    """Make sure function argument values are properly
+    propagated to sub functions"""
+    def test_call_context_propagation(self):
+        n = extract_node("""
+        def chest(a):
+            return a * a
+        def best(a, b):
+            return chest(a)
+        def test(a, b, c):
+            return best(a, b)
+        test(4, 5, 6) #@
+        """)
+        assert next(n.infer()).as_string() == "16"
+
+    def test_call_starargs_propagation(self):
+        code = """
+        def foo(*args):
+            return args
+        def bar(*args):
+            return foo(*args)
+        bar(4, 5, 6, 7) #@
+        """
+        assert next(extract_node(code).infer()).as_string() == "(4, 5, 6, 7)"
+
+    def test_call_kwargs_propagation(self):
+        code = """
+        def b(**kwargs):
+            return kwargs
+        def f(**kwargs):
+            return b(**kwargs)
+        f(**{'f': 1}) #@
+        """
+        assert next(extract_node(code).infer()).as_string() == "{'f': 1}"
+
+
+def test_limit_inference_result_amount():
+    """Test setting limit inference result amount"""
+    code = """
+    args = []
+
+    if True:
+        args += ['a']
+
+    if True:
+        args += ['b']
+
+    if True:
+        args += ['c']
+
+    if True:
+        args += ['d']
+
+    args #@
+    """
+    result = extract_node(code).inferred()
+    assert len(result) == 16
+    with patch('astroid.node_classes.MANAGER.max_inferable_values', 4):
+        result_limited = extract_node(code).inferred()
+    # Can't guarentee exact size
+    assert len(result_limited) < 16
+    # Will not always be at the end
+    assert util.Uninferable in result_limited
+
+
+def test_attribute_inference_should_not_access_base_classes():
+    """attributes of classes should mask ancestor attribues"""
+    code = """
+    type.__new__ #@
+    """
+    res = extract_node(code).inferred()
+    assert len(res) == 1
+    assert res[0].parent.name == "type"
+
+
+def test_attribute_mro_object_inference():
+    """
+    Inference should only infer results from the first available method
+    """
+    inferred = extract_node("""
+    class A:
+        def foo(self):
+            return 1
+    class B(A):
+        def foo(self):
+            return 2
+    B().foo() #@
+    """).inferred()
+    assert len(inferred) == 1
+    assert inferred[0].value == 2
+
+
 if __name__ == '__main__':
     unittest.main()
diff -Nru astroid-1.6.5/astroid/tests/unittest_lookup.py astroid-2.0/astroid/tests/unittest_lookup.py
--- astroid-1.6.5/astroid/tests/unittest_lookup.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/tests/unittest_lookup.py	2018-07-15 09:19:29.000000000 +0200
@@ -1,7 +1,8 @@
 # Copyright (c) 2007-2013 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
-# Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2010 Daniel Harding <dharding@gmail.com>
+# Copyright (c) 2014-2016, 2018 Claudiu Popa <pcmanticore@gmail.com>
 # Copyright (c) 2014 Google, Inc.
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -257,7 +258,7 @@
         self.assertEqual(len(intstmts), 1)
         self.assertIsInstance(intstmts[0], nodes.ClassDef)
         self.assertEqual(intstmts[0].name, 'int')
-        # pylint: disable=no-member; union type in const_factory, this shouldn't happen
+        # pylint: disable=no-member; Infers two potential values
         self.assertIs(intstmts[0], nodes.const_factory(1)._proxied)
 
     def test_decorator_arguments_lookup(self):
diff -Nru astroid-1.6.5/astroid/tests/unittest_manager.py astroid-2.0/astroid/tests/unittest_manager.py
--- astroid-1.6.5/astroid/tests/unittest_manager.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/tests/unittest_manager.py	2018-07-15 09:19:30.000000000 +0200
@@ -1,6 +1,12 @@
 # Copyright (c) 2006, 2009-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
-# Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2013 AndroWiiid <androwiiid@gmail.com>
+# Copyright (c) 2014-2018 Claudiu Popa <pcmanticore@gmail.com>
 # Copyright (c) 2014 Google, Inc.
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2017 Chris Philip <chrisp533@gmail.com>
+# Copyright (c) 2017 Hugo <hugovk@users.noreply.github.com>
+# Copyright (c) 2017 ioanatia <ioanatia@users.noreply.github.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -125,7 +131,7 @@
     def test_namespace_package_pth_support(self):
         pth = 'foogle_fax-0.12.5-py2.7-nspkg.pth'
         site.addpackage(resources.RESOURCE_PATH, pth, [])
-        pkg_resources._namespace_packages['foogle'] = []  # pylint: disable=no-member
+        pkg_resources._namespace_packages['foogle'] = []
 
         try:
             module = self.manager.ast_from_module_name('foogle.fax')
@@ -135,18 +141,18 @@
             with self.assertRaises(exceptions.AstroidImportError):
                 self.manager.ast_from_module_name('foogle.moogle')
         finally:
-            del pkg_resources._namespace_packages['foogle'] # pylint: disable=no-member
+            del pkg_resources._namespace_packages['foogle']
             sys.modules.pop('foogle')
 
     def test_nested_namespace_import(self):
         pth = 'foogle_fax-0.12.5-py2.7-nspkg.pth'
         site.addpackage(resources.RESOURCE_PATH, pth, [])
-        pkg_resources._namespace_packages['foogle'] = ['foogle.crank'] # pylint: disable=no-member
-        pkg_resources._namespace_packages['foogle.crank'] = [] # pylint: disable=no-member
+        pkg_resources._namespace_packages['foogle'] = ['foogle.crank']
+        pkg_resources._namespace_packages['foogle.crank'] = []
         try:
             self.manager.ast_from_module_name('foogle.crank')
         finally:
-            del pkg_resources._namespace_packages['foogle'] # pylint: disable=no-member
+            del pkg_resources._namespace_packages['foogle']
             sys.modules.pop('foogle')
 
     def test_namespace_and_file_mismatch(self):
@@ -155,12 +161,12 @@
         self.assertEqual(ast.name, 'unittest')
         pth = 'foogle_fax-0.12.5-py2.7-nspkg.pth'
         site.addpackage(resources.RESOURCE_PATH, pth, [])
-        pkg_resources._namespace_packages['foogle'] = [] # pylint: disable=no-member
+        pkg_resources._namespace_packages['foogle'] = []
         try:
             with self.assertRaises(exceptions.AstroidImportError):
                 self.manager.ast_from_module_name('unittest.foogle.fax')
         finally:
-            del pkg_resources._namespace_packages['foogle'] # pylint: disable=no-member
+            del pkg_resources._namespace_packages['foogle']
             sys.modules.pop('foogle')
 
     def _test_ast_from_zip(self, archive):
@@ -207,7 +213,6 @@
         """check if the unittest filepath is equals to the result of the method"""
         self.assertEqual(
             _get_file_from_object(unittest),
-            # pylint: disable=no-member; can't infer the ModuleSpec
             self.manager.file_from_module_name('unittest', None).location)
 
     def test_file_from_module_name_astro_building_exception(self):
@@ -258,8 +263,8 @@
         def hook(modname):
             if modname == 'foo.bar':
                 return unittest
-            else:
-                raise exceptions.AstroidBuildingError()
+
+            raise exceptions.AstroidBuildingError()
 
         with self.assertRaises(exceptions.AstroidBuildingError):
             self.manager.ast_from_module_name('foo.bar')
diff -Nru astroid-1.6.5/astroid/tests/unittest_modutils.py astroid-2.0/astroid/tests/unittest_modutils.py
--- astroid-1.6.5/astroid/tests/unittest_modutils.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/tests/unittest_modutils.py	2018-07-15 09:19:29.000000000 +0200
@@ -1,8 +1,12 @@
 # -*- coding: utf-8 -*-
 # Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
 # Copyright (c) 2014 Google, Inc.
+# Copyright (c) 2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
 # Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>
 # Copyright (c) 2015 Radosław Ganczarek <radoslaw@ganczarek.in>
+# Copyright (c) 2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2018 Mario Corchero <mcorcherojim@bloomberg.net>
+# Copyright (c) 2018 Mario Corchero <mariocj89@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -15,6 +19,8 @@
 import sys
 import unittest
 from xml import etree
+import tempfile
+import shutil
 
 import astroid
 from astroid.interpreter._import import spec
@@ -110,6 +116,58 @@
     def test_raise_modpath_from_file_Exception(self):
         self.assertRaises(Exception, modutils.modpath_from_file, '/turlututu')
 
+    def test_import_symlink_with_source_outside_of_path(self):
+        with tempfile.NamedTemporaryFile() as tmpfile:
+            linked_file_name = 'symlinked_file.py'
+            try:
+                os.symlink(tmpfile.name, linked_file_name)
+                self.assertEqual(modutils.modpath_from_file(linked_file_name),
+                                 ['symlinked_file'])
+            finally:
+                os.remove(linked_file_name)
+
+    def test_import_symlink_both_outside_of_path(self):
+        with tempfile.NamedTemporaryFile() as tmpfile:
+            linked_file_name = os.path.join(tempfile.gettempdir(),
+                                            'symlinked_file.py')
+            try:
+                os.symlink(tmpfile.name, linked_file_name)
+                self.assertRaises(ImportError,
+                                  modutils.modpath_from_file, linked_file_name)
+            finally:
+                os.remove(linked_file_name)
+
+    def test_load_from_module_symlink_on_symlinked_paths_in_syspath(self):
+        # constants
+        tmp = tempfile.gettempdir()
+        deployment_path = os.path.join(tmp, 'deployment')
+        path_to_include = os.path.join(tmp, 'path_to_include')
+        real_secret_path = os.path.join(tmp, 'secret.py')
+        symlink_secret_path = os.path.join(path_to_include, 'secret.py')
+
+        # setup double symlink
+        # /tmp/deployment
+        # /tmp/path_to_include (symlink to /tmp/deployment)
+        # /tmp/secret.py
+        # /tmp/deployment/secret.py (points to /tmp/secret.py)
+        os.mkdir(deployment_path)
+        self.addCleanup(shutil.rmtree, deployment_path)
+        os.symlink(deployment_path, path_to_include)
+        self.addCleanup(os.remove, path_to_include)
+        with open(real_secret_path, "w"):
+            pass
+        os.symlink(real_secret_path, symlink_secret_path)
+        self.addCleanup(os.remove, real_secret_path)
+
+        # add the symlinked path to sys.path
+        sys.path.append(path_to_include)
+        self.addCleanup(sys.path.pop)
+
+        # this should be equivalent to: import secret
+        self.assertEqual(
+            modutils.modpath_from_file(symlink_secret_path),
+            ['secret'])
+
 
 class LoadModuleFromPathTest(resources.SysPathSetup, unittest.TestCase):
 
diff -Nru astroid-1.6.5/astroid/tests/unittest_nodes.py astroid-2.0/astroid/tests/unittest_nodes.py
--- astroid-1.6.5/astroid/tests/unittest_nodes.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/tests/unittest_nodes.py	2018-07-15 09:19:31.000000000 +0200
@@ -1,8 +1,16 @@
 # Copyright (c) 2006-2007, 2009-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
-# Copyright (c) 2013-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2012 FELD Boris <lothiraldan@gmail.com>
+# Copyright (c) 2013-2018 Claudiu Popa <pcmanticore@gmail.com>
 # Copyright (c) 2014 Google, Inc.
+# Copyright (c) 2014 Eevee (Alex Munroe) <amunroe@yelp.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
 # Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2016 Jakub Wilk <jwilk@jwilk.net>
+# Copyright (c) 2017 rr- <rr-@sakuya.pl>
+# Copyright (c) 2017 Derek Gustafson <degustaf@gmail.com>
+# Copyright (c) 2018 brendanator <brendan.maginnis@gmail.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
+# Copyright (c) 2018 Anthony Sottile <asottile@umich.edu>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -10,11 +18,13 @@
 """tests for specific behaviour of astroid nodes
 """
 import os
+import platform
 import sys
 import textwrap
 import unittest
-import warnings
+import copy
 
+import pytest
 import six
 
 import astroid
@@ -33,6 +43,10 @@
 
 abuilder = builder.AstroidBuilder()
 BUILTINS = six.moves.builtins.__name__
+HAS_TYPED_AST = (
+    platform.python_implementation() == 'CPython'
+    and sys.version_info.minor < 7
+)
 
 
 class AsStringTest(resources.SysPathSetup, unittest.TestCase):
@@ -63,7 +77,7 @@
         binop = node.body[0].value
         inferred = next(binop.infer())
         self.assertEqual(inferred.as_string(), '[Uninferable]')
-        self.assertEqual(binop.as_string(), '([arg]) * (1)')
+        self.assertEqual(binop.as_string(), '[arg] * 1')
 
     def test_frozenset_as_string(self):
         ast_nodes = builder.extract_node('''
@@ -168,6 +182,26 @@
         ast = abuilder.string_build(code)
         self.assertEqual(ast.as_string(), code)
 
+    def test_operator_precedence(self):
+        with open(resources.find('data/operator_precedence.py')) as f:
+            for code in f:
+                self.check_as_string_ast_equality(code)
+
+    @staticmethod
+    def check_as_string_ast_equality(code):
+        """
+        Check that as_string produces source code with exactly the same
+        semantics as the source it was originally parsed from
+        """
+        pre = builder.parse(code)
+        post = builder.parse(pre.as_string())
+
+        pre_repr = pre.repr_tree()
+        post_repr = post.repr_tree()
+
+        assert pre_repr == post_repr
+        assert pre.as_string().strip() == code.strip()
+
 
 class _NodeTest(unittest.TestCase):
     """test transformation of If Node"""
@@ -412,8 +446,8 @@
 class ConstNodeTest(unittest.TestCase):
 
     def _test(self, value):
-        # pylint: disable=no-member; union type in const_factory, this shouldn't happen
         node = nodes.const_factory(value)
+        # pylint: disable=no-member; Infers two potential values
         self.assertIsInstance(node._proxied, nodes.ClassDef)
         self.assertEqual(node._proxied.name, value.__class__.__name__)
         self.assertIs(node.value, value)
@@ -439,7 +473,14 @@
         self._test('a')
 
     def test_unicode(self):
-        self._test(u'a')
+        self._test('a')
+
+    def test_copy(self):
+        """
+        Make sure copying a Const object doesn't result in infinite recursion
+        """
+        const = copy.copy(nodes.Const(1))
+        assert const.value == 1
 
 
 class NameNodeTest(unittest.TestCase):
@@ -670,14 +711,14 @@
                 return node
             return None
 
-        self.transformer.register_transform(nodes.From, test_from)
-        self.transformer.register_transform(nodes.Class, test_class)
-        self.transformer.register_transform(nodes.Function, test_function)
-        self.transformer.register_transform(nodes.CallFunc, test_callfunc)
-        self.transformer.register_transform(nodes.AssName, test_assname)
-        self.transformer.register_transform(nodes.AssAttr, test_assattr)
-        self.transformer.register_transform(nodes.Getattr, test_getattr)
-        self.transformer.register_transform(nodes.GenExpr, test_genexpr)
+        self.transformer.register_transform(nodes.ImportFrom, test_from)
+        self.transformer.register_transform(nodes.ClassDef, test_class)
+        self.transformer.register_transform(nodes.FunctionDef, test_function)
+        self.transformer.register_transform(nodes.Call, test_callfunc)
+        self.transformer.register_transform(nodes.AssignName, test_assname)
+        self.transformer.register_transform(nodes.AssignAttr, test_assattr)
+        self.transformer.register_transform(nodes.Attribute, test_getattr)
+        self.transformer.register_transform(nodes.GeneratorExp, test_genexpr)
 
         string = '''
         from __future__ import print_function
@@ -712,58 +753,6 @@
         self.assertEqual(module.body[6].value.elt.value, 2)
         self.assertIsInstance(module.body[6].value, nodes.GeneratorExp)
 
-    @unittest.skipIf(six.PY3, "Python 3 doesn't have Repr nodes.")
-    def test_repr(self):
-        def test_backquote(node):
-            node.value.name = 'bar'
-            return node
-
-        self.transformer.register_transform(nodes.Backquote, test_backquote)
-
-        module = self.parse_transform('`foo`')
-
-        self.assertEqual(module.body[0].value.value.name, 'bar')
-        self.assertIsInstance(module.body[0].value, nodes.Repr)
-
-
-class DeprecationWarningsTest(unittest.TestCase):
-    def test_asstype_warnings(self):
-        string = '''
-        class C: pass
-        c = C()
-        with warnings.catch_warnings(record=True) as w:
-            pass
-        '''
-        module = parse(string)
-        filter_stmts_mixin = module.body[0]
-        assign_type_mixin = module.body[1].targets[0]
-        parent_assign_type_mixin = module.body[2]
-
-        with warnings.catch_warnings(record=True) as w:
-            with test_utils.enable_warning(PendingDeprecationWarning):
-                filter_stmts_mixin.ass_type()
-                self.assertIsInstance(w[0].message, PendingDeprecationWarning)
-        with warnings.catch_warnings(record=True) as w:
-            with test_utils.enable_warning(PendingDeprecationWarning):
-                assign_type_mixin.ass_type()
-                self.assertIsInstance(w[0].message, PendingDeprecationWarning)
-        with warnings.catch_warnings(record=True) as w:
-            with test_utils.enable_warning(PendingDeprecationWarning):
-                parent_assign_type_mixin.ass_type()
-                self.assertIsInstance(w[0].message, PendingDeprecationWarning)
-
-    def test_isinstance_warnings(self):
-        msg_format = ("%r is deprecated and slated for removal in astroid "
-                      "2.0, use %r instead")
-        for cls in (nodes.Discard, nodes.Backquote, nodes.AssName,
-                    nodes.AssAttr, nodes.Getattr, nodes.CallFunc, nodes.From):
-            with warnings.catch_warnings(record=True) as w:
-                with test_utils.enable_warning(PendingDeprecationWarning):
-                    isinstance(42, cls)
-            self.assertIsInstance(w[0].message, PendingDeprecationWarning)
-            actual_msg = msg_format % (cls.__class__.__name__, cls.__wrapped__.__name__)
-            self.assertEqual(str(w[0].message), actual_msg)
-
 
 @test_utils.require_version('3.5')
 class Python35AsyncTest(unittest.TestCase):
@@ -790,13 +779,16 @@
         code = textwrap.dedent('''
         async def function():
             await 42
+            await x[0]
+            (await x)[0]
+            await (x + y)[0]
         ''')
         self._test_await_async_as_string(code)
 
     def test_asyncwith_as_string(self):
         code = textwrap.dedent('''
         async def function():
-            async with (42):
+            async with 42:
                 pass
         ''')
         self._test_await_async_as_string(code)
@@ -858,5 +850,118 @@
         self.assertIs(starred.ctx, astroid.Store)
 
 
+def test_unknown():
+    """Test Unknown node"""
+    assert isinstance(next(nodes.Unknown().infer()),
+                      type(util.Uninferable))
+    assert isinstance(nodes.Unknown().name, str)
+    assert isinstance(nodes.Unknown().qname(), str)
+
+
+@pytest.mark.skipif(not HAS_TYPED_AST, reason="requires typed_ast")
+def test_type_comments_with():
+    module = builder.parse('''
+    with a as b: # type: int
+        pass
+    with a as b: # type: ignore
+        pass
+    ''')
+    node = module.body[0]
+    ignored_node = module.body[1]
+    assert isinstance(node.type_annotation, astroid.Name)
+
+    assert ignored_node.type_annotation is None
+
+
+@pytest.mark.skipif(not HAS_TYPED_AST, reason="requires typed_ast")
+def test_type_comments_for():
+    module = builder.parse('''
+    for a, b in [1, 2, 3]: # type: List[int]
+        pass
+    for a, b in [1, 2, 3]: # type: ignore
+        pass
+    ''')
+    node = module.body[0]
+    ignored_node = module.body[1]
+    assert isinstance(node.type_annotation, astroid.Subscript)
+    assert node.type_annotation.as_string() == 'List[int]'
+
+    assert ignored_node.type_annotation is None
+
+
+@pytest.mark.skipif(not HAS_TYPED_AST, reason="requires typed_ast")
+def test_type_coments_assign():
+    module = builder.parse('''
+    a, b = [1, 2, 3] # type: List[int]
+    a, b = [1, 2, 3] # type: ignore
+    ''')
+    node = module.body[0]
+    ignored_node = module.body[1]
+    assert isinstance(node.type_annotation, astroid.Subscript)
+    assert node.type_annotation.as_string() == 'List[int]'
+
+    assert ignored_node.type_annotation is None
+
+
+@pytest.mark.skipif(not HAS_TYPED_AST, reason="requires typed_ast")
+def test_type_comments_invalid_expression():
+    module = builder.parse('''
+    a, b = [1, 2, 3] # type: something completely invalid
+    a, b = [1, 2, 3] # typeee: 2*+4
+    a, b = [1, 2, 3] # type: List[int
+    ''')
+    for node in module.body:
+        assert node.type_annotation is None
+
+
+@pytest.mark.skipif(not HAS_TYPED_AST, reason="requires typed_ast")
+def test_type_comments_invalid_function_comments():
+    module = builder.parse('''
+    def func():
+        # type: something completely invalid
+        pass
+    def func1():
+        # typeee: 2*+4
+        pass
+    def func2():
+        # type: List[int
+        pass
+    ''')
+    for node in module.body:
+        assert node.type_comment_returns is None
+        assert node.type_comment_args is None
+
+
+@pytest.mark.skipif(not HAS_TYPED_AST, reason="requires typed_ast")
+def test_type_comments_function():
+    module = builder.parse('''
+    def func():
+        # type: (int) -> str
+        pass
+    def func1():
+        # type: (int, int, int) -> (str, str)
+        pass
+    def func2():
+        # type: (int, int, str, List[int]) -> List[int]
+        pass
+    ''')
+    expected_annotations = [
+        (["int"], astroid.Name, "str"),
+        (["int", "int", "int"], astroid.Tuple, "(str, str)"),
+        (["int", "int", "str", "List[int]"], astroid.Subscript, "List[int]"),
+    ]
+    for node, (
+            expected_args,
+            expected_returns_type,
+            expected_returns_string
+        ) in zip(module.body, expected_annotations):
+        assert node.type_comment_returns is not None
+        assert node.type_comment_args is not None
+        for expected_arg, actual_arg in zip(expected_args, node.type_comment_args):
+            assert actual_arg.as_string() == expected_arg
+        assert isinstance(node.type_comment_returns, expected_returns_type)
+        assert node.type_comment_returns.as_string() == expected_returns_string
+
+
 if __name__ == '__main__':
     unittest.main()
diff -Nru astroid-1.6.5/astroid/tests/unittest_object_model.py astroid-2.0/astroid/tests/unittest_object_model.py
--- astroid-1.6.5/astroid/tests/unittest_object_model.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/tests/unittest_object_model.py	2018-07-15 09:19:30.000000000 +0200
@@ -1,12 +1,15 @@
-# Copyright (c) 2016 Claudiu Popa <pcmanticore@gmail.com>
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016-2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016 Derek Gustafson <degustaf@gmail.com>
+# Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
 
+import builtins
 import unittest
 import xml
 
-import six
-
 import astroid
 from astroid import builder
 from astroid import exceptions
@@ -15,7 +18,7 @@
 from astroid import objects
 
 
-BUILTINS = MANAGER.astroid_cache[six.moves.builtins.__name__]
+BUILTINS = MANAGER.astroid_cache[builtins.__name__]
 
 
 class InstanceModelTest(unittest.TestCase):
@@ -103,10 +106,7 @@
 
         cls = next(ast_nodes[0].infer())
         self.assertIsInstance(cls, astroid.ClassDef)
-        if six.PY2:
-            unbound_name = 'instancemethod'
-        else:
-            unbound_name = 'function'
+        unbound_name = 'function'
 
         self.assertEqual(cls.name, unbound_name)
 
@@ -169,16 +169,6 @@
             self.assertIsInstance(inferred.bound, astroid.ClassDef)
             self.assertEqual(inferred.bound.name, 'type')
 
-    @unittest.skipUnless(six.PY2, "Needs old style classes")
-    def test_old_style_classes_no_mro(self):
-        ast_node = builder.extract_node('''
-        class A:
-            pass
-        A.mro #@
-        ''')
-        with self.assertRaises(exceptions.InferenceError):
-            next(ast_node.infer())
-
     def test_class_model(self):
         ast_nodes = builder.extract_node('''
         class A(object):
@@ -318,6 +308,17 @@
         self.assertIsInstance(result, astroid.Const)
         self.assertEqual(result.value, 42)
 
+    def test___get__has_extra_params_defined(self):
+        node = builder.extract_node('''
+        def test(self): return 42
+        test.__get__
+        ''')
+        inferred = next(node.infer())
+        self.assertIsInstance(inferred, astroid.BoundMethod)
+        args = inferred.args.args
+        self.assertEqual(len(args), 2)
+        self.assertEqual([arg.name for arg in args], ['self', 'type'])
+
     @unittest.expectedFailure
     def test_descriptor_not_inferrring_self(self):
         # We can't infer __get__(X, Y)() when the bounded function
@@ -345,6 +346,26 @@
             with self.assertRaises(exceptions.InferenceError):
                 next(node.infer())
 
+    def test_descriptor_error_regression(self):
+        """Make sure the following code does
+        node cause an exception"""
+        node = builder.extract_node('''
+        class MyClass:
+            text = "MyText"
+
+            def mymethod1(self):
+                return self.text
+
+            def mymethod2(self):
+                return self.mymethod1.__get__(self, MyClass)
+
+
+        cl = MyClass().mymethod2()()
+        cl #@
+        ''')
+        [const] = node.inferred()
+        assert const.value == "MyText"
+
     def test_function_model(self):
         ast_nodes = builder.extract_node('''
         def func(a=1, b=2):
@@ -499,7 +520,6 @@
 
 class ExceptionModelTest(unittest.TestCase):
 
-    @unittest.skipIf(six.PY2, "needs Python 3")
     def test_model_py3(self):
         ast_nodes = builder.extract_node('''
         try:
@@ -519,25 +539,6 @@
         with self.assertRaises(exceptions.InferenceError):
             next(ast_nodes[2].infer())
 
-    @unittest.skipUnless(six.PY2, "needs Python 2")
-    def test_model_py2(self):
-        ast_nodes = builder.extract_node('''
-        try:
-            x[42]
-        except ValueError as err:
-           err.args #@
-           err.message #@
-
-           err.__traceback__ #@
-        ''')
-        args = next(ast_nodes[0].infer())
-        self.assertIsInstance(args, astroid.Tuple)
-        message = next(ast_nodes[1].infer())
-        self.assertIsInstance(message, astroid.Const)
-
-        with self.assertRaises(exceptions.InferenceError):
-            next(ast_nodes[2].infer())
-
 
 class DictObjectModelTest(unittest.TestCase):
 
@@ -557,28 +558,6 @@
             inferred = next(node.infer())
             self.assertIsInstance(inferred, astroid.BoundMethod)
 
-    @unittest.skipUnless(six.PY2, "needs Python 2")
-    def test_concrete_objects_for_dict_methods(self):
-        ast_nodes = builder.extract_node('''
-        {1:1, 2:3}.values() #@
-        {1:1, 2:3}.keys() #@
-        {1:1, 2:3}.items() #@
-        ''')
-        values = next(ast_nodes[0].infer())
-        self.assertIsInstance(values, astroid.List)
-        self.assertEqual([value.value for value in values.elts], [1, 3])
-
-        keys = next(ast_nodes[1].infer())
-        self.assertIsInstance(keys, astroid.List)
-        self.assertEqual([key.value for key in keys.elts], [1, 2])
-
-        items = next(ast_nodes[2].infer())
-        self.assertIsInstance(items, astroid.List)
-        for expected, elem in zip([(1, 1), (2, 3)], items.elts):
-            self.assertIsInstance(elem, astroid.Tuple)
-            self.assertEqual(list(expected), [elt.value for elt in elem.elts])
-
-    @unittest.skipIf(six.PY2, "needs Python 3")
     def test_wrapper_objects_for_dict_methods_python3(self):
         ast_nodes = builder.extract_node('''
         {1:1, 2:3}.values() #@
@@ -597,7 +576,6 @@
 
 class LruCacheModelTest(unittest.TestCase):
 
-    @unittest.skipIf(six.PY2, "needs Python 3")
     def test_lru_cache(self):
         ast_nodes = builder.extract_node('''
         import functools
diff -Nru astroid-1.6.5/astroid/tests/unittest_objects.py astroid-2.0/astroid/tests/unittest_objects.py
--- astroid-1.6.5/astroid/tests/unittest_objects.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/tests/unittest_objects.py	2018-07-15 09:19:30.000000000 +0200
@@ -1,5 +1,6 @@
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
 # Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -502,6 +503,19 @@
         self.assertIsInstance(inferred, nodes.Const)
         self.assertEqual(inferred.value, 42)
 
+    def test_super_qname(self):
+        """Make sure a Super object generates a qname
+        equivalent to super.__qname__
+        """
+        # See issue 533
+        code = """
+        class C:
+           def foo(self): return super()
+        C().foo() #@
+        """
+        super_obj = next(builder.extract_node(code).infer())
+        self.assertEqual(super_obj.qname(), "super")
+
 
 if __name__ == '__main__':
     unittest.main()
diff -Nru astroid-1.6.5/astroid/tests/unittest_peephole.py astroid-2.0/astroid/tests/unittest_peephole.py
--- astroid-1.6.5/astroid/tests/unittest_peephole.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/tests/unittest_peephole.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,109 +0,0 @@
-# Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
-
-# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
-# For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
-
-
-"""Tests for the astroid AST peephole optimizer."""
-
-import ast
-import textwrap
-import unittest
-
-import astroid
-from astroid import astpeephole
-from astroid import builder
-from astroid import manager
-from astroid import test_utils
-from astroid.tests import resources
-
-
-MANAGER = manager.AstroidManager()
-
-
-class PeepholeOptimizer(unittest.TestCase):
-    @classmethod
-    def setUpClass(cls):
-        MANAGER.optimize_ast = True
-
-    @classmethod
-    def tearDownClass(cls):
-        MANAGER.optimize_ast = False
-
-    def setUp(self):
-        self._optimizer = astpeephole.ASTPeepholeOptimizer()
-
-    @staticmethod
-    def _get_binops(code):
-        module = ast.parse(textwrap.dedent(code))
-        return [node.value for node in module.body
-                if isinstance(node, ast.Expr)]
-
-    @test_utils.require_version(maxver='3.0')
-    def test_optimize_binop_unicode(self):
-        nodes = self._get_binops("""
-        u"a" + u"b" + u"c"
-
-        u"a" + "c" + "b"
-        u"a" + b"c"
-        """)
-
-        result = self._optimizer.optimize_binop(nodes[0])
-        self.assertIsInstance(result, astroid.Const)
-        self.assertEqual(result.value, u"abc")
-
-        self.assertIsNone(self._optimizer.optimize_binop(nodes[1]))
-        self.assertIsNone(self._optimizer.optimize_binop(nodes[2]))
-
-    def test_optimize_binop(self):
-        nodes = self._get_binops("""
-        "a" + "b" + "c" + "d"
-        b"a" + b"b" + b"c" + b"d"
-        "a" + "b"
-
-        "a" + "b" + 1 + object
-        var = 4
-        "a" + "b" + var + "c"
-        "a" + "b" + "c" - "4"
-        "a" + "b" + "c" + "d".format()
-        "a" - "b"
-        "a"
-        1 + 4 + 5 + 6
-        """)
-
-        result = self._optimizer.optimize_binop(nodes[0])
-        self.assertIsInstance(result, astroid.Const)
-        self.assertEqual(result.value, "abcd")
-
-        result = self._optimizer.optimize_binop(nodes[1])
-        self.assertIsInstance(result, astroid.Const)
-        self.assertEqual(result.value, b"abcd")
-
-        for node in nodes[2:]:
-            self.assertIsNone(self._optimizer.optimize_binop(node))
-
-    def test_big_binop_crash(self):
-        # Test that we don't fail on a lot of joined strings
-        # through the addition operator.
-        module = resources.build_file('data/joined_strings.py')
-        element = next(module['x'].infer())
-        self.assertIsInstance(element, astroid.Const)
-        self.assertEqual(len(element.value), 61660)
-
-    def test_optimisation_disabled(self):
-        try:
-            MANAGER.optimize_ast = False
-            module = builder.parse("""
-            '1' + '2' + '3'
-            """)
-            self.assertIsInstance(module.body[0], astroid.Expr)
-            self.assertIsInstance(module.body[0].value, astroid.BinOp)
-            self.assertIsInstance(module.body[0].value.left, astroid.BinOp)
-            self.assertIsInstance(module.body[0].value.left.left,
-                                  astroid.Const)
-        finally:
-            MANAGER.optimize_ast = True
-
-
-if __name__ == '__main__':
-    unittest.main()
diff -Nru astroid-1.6.5/astroid/tests/unittest_protocols.py astroid-2.0/astroid/tests/unittest_protocols.py
--- astroid-1.6.5/astroid/tests/unittest_protocols.py	2018-05-13 12:38:38.000000000 +0200
+++ astroid-2.0/astroid/tests/unittest_protocols.py	2018-07-15 09:19:30.000000000 +0200
@@ -1,4 +1,9 @@
-# Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
+# -*- coding: utf-8 -*-
+# Copyright (c) 2015-2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2016 Jakub Wilk <jwilk@jwilk.net>
+# Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
+# Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -67,7 +72,8 @@
 
         for1_starred = next(assign_stmts.nodes_of_class(Starred))
         assigned = next(for1_starred.assigned_stmts())
-        self.assertEqual(assigned, util.Uninferable)
+        assert isinstance(assigned, astroid.List)
+        assert assigned.as_string() == '[1, 2]'
 
     def _get_starred_stmts(self, code):
         assign_stmt = extract_node("{} #@".format(code))
@@ -123,8 +129,6 @@
     def test_assign_stmts_starred_fails(self):
         # Too many starred
         self._helper_starred_inference_error("a, *b, *c = (1, 2, 3) #@")
-        # Too many lhs values
-        self._helper_starred_inference_error("a, *b, c = (1, 2) #@")
         # This could be solved properly, but it complicates needlessly the
         # code for assigned_stmts, without offering real benefit.
         self._helper_starred_inference_error(
@@ -178,7 +182,7 @@
             module.wildcard_import_names()
 
     def test_not_passing_uninferable_in_seq_inference(self):
-        class Visitor(object):
+        class Visitor:
 
             def visit(self, node):
                 for child in node.get_children():
diff -Nru astroid-1.6.5/astroid/tests/unittest_python3.py astroid-2.0/astroid/tests/unittest_python3.py
--- astroid-1.6.5/astroid/tests/unittest_python3.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/tests/unittest_python3.py	2018-07-15 09:19:31.000000000 +0200
@@ -1,6 +1,12 @@
-# Copyright (c) 2013-2016 Claudiu Popa <pcmanticore@gmail.com>
+# -*- coding: utf-8 -*-
+# Copyright (c) 2010, 2013-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
+# Copyright (c) 2012 FELD Boris <lothiraldan@gmail.com>
+# Copyright (c) 2013-2018 Claudiu Popa <pcmanticore@gmail.com>
 # Copyright (c) 2014 Google, Inc.
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2016 Jared Garst <jgarst@users.noreply.github.com>
+# Copyright (c) 2017 Hugo <hugovk@users.noreply.github.com>
+# Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -307,12 +313,12 @@
         # will be allowed outside of coroutines body
         comprehensions = [
             "[i async for i in aiter() if condition(i)]",
-            "[await fun() for fun in funcs]",
-            "{await fun() for fun in funcs}",
-            "{fun: await fun() for fun in funcs}",
-            "[await fun() for fun in funcs if await smth]",
-            "{await fun() for fun in funcs if await smth}",
-            "{fun: await fun() for fun in funcs if await smth}",
+            "[await fun() async for fun in funcs]",
+            "{await fun() async for fun in funcs}",
+            "{fun: await fun() async for fun in funcs}",
+            "[await fun() async for fun in funcs if await smth]",
+            "{await fun() async for fun in funcs if await smth}",
+            "{fun: await fun() async for fun in funcs if await smth}",
             "[await fun() async for fun in funcs]",
             "{await fun() async for fun in funcs}",
             "{fun: await fun() async for fun in funcs}",
diff -Nru astroid-1.6.5/astroid/tests/unittest_raw_building.py astroid-2.0/astroid/tests/unittest_raw_building.py
--- astroid-1.6.5/astroid/tests/unittest_raw_building.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/tests/unittest_raw_building.py	2018-07-15 09:19:31.000000000 +0200
@@ -1,23 +1,22 @@
+# Copyright (c) 2013 AndroWiiid <androwiiid@gmail.com>
+# Copyright (c) 2014-2016, 2018 Claudiu Popa <pcmanticore@gmail.com>
 # Copyright (c) 2014 Google, Inc.
-# Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2018 Anthony Sottile <asottile@umich.edu>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
 
-import inspect
-import os
+import platform
 import unittest
 
-from six.moves import builtins
-
-from astroid.builder import AstroidBuilder, extract_node
+from astroid.builder import AstroidBuilder
 from astroid.raw_building import (
     attach_dummy_node, build_module,
     build_class, build_function, build_from_import
 )
 from astroid import test_utils
-from astroid import nodes
-from astroid.bases import BUILTINS
 
 
 class RawBuildingTC(unittest.TestCase):
@@ -46,14 +45,12 @@
 
     def test_build_function_args(self):
         args = ['myArgs1', 'myArgs2']
-        # pylint: disable=no-member; not aware of postinit
         node = build_function('MyFunction', args)
         self.assertEqual('myArgs1', node.args.args[0].name)
         self.assertEqual('myArgs2', node.args.args[1].name)
         self.assertEqual(2, len(node.args.args))
 
     def test_build_function_defaults(self):
-        # pylint: disable=no-member; not aware of postinit
         defaults = ['defaults1', 'defaults2']
         node = build_function('MyFunction', None, defaults)
         self.assertEqual(2, len(node.args.defaults))
@@ -63,6 +60,8 @@
         node = build_from_import('astroid', names)
         self.assertEqual(len(names), len(node.names))
 
+    @unittest.skipIf(platform.python_implementation() == 'PyPy',
+                     'Only affects CPython')
     @test_utils.require_version(minver='3.0')
     def test_io_is__io(self):
         # _io module calls itself io. This leads
@@ -77,17 +76,6 @@
         buffered_reader = module.getattr('BufferedReader')[0]
         self.assertEqual(buffered_reader.root().name, 'io')
 
-    @unittest.skipUnless(os.name == 'java', 'Requires Jython')
-    def test_open_is_inferred_correctly(self):
-        # Lot of Jython builtins don't have a __module__ attribute.
-        for name, _ in inspect.getmembers(builtins, predicate=inspect.isbuiltin):
-            if name == 'print':
-                continue
-            node = extract_node('{0} #@'.format(name))
-            inferred = next(node.infer())
-            self.assertIsInstance(inferred, nodes.FunctionDef, name)
-            self.assertEqual(inferred.root().name, BUILTINS, name)
-
 
 if __name__ == '__main__':
     unittest.main()
diff -Nru astroid-1.6.5/astroid/tests/unittest_regrtest.py astroid-2.0/astroid/tests/unittest_regrtest.py
--- astroid-1.6.5/astroid/tests/unittest_regrtest.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/tests/unittest_regrtest.py	2018-07-15 09:19:31.000000000 +0200
@@ -1,6 +1,12 @@
 # Copyright (c) 2006-2008, 2010-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
+# Copyright (c) 2007 Marien Zwart <marienz@gentoo.org>
 # Copyright (c) 2013-2014 Google, Inc.
-# Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2014-2016, 2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2014 Eevee (Alex Munroe) <amunroe@yelp.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2016 Jakub Wilk <jwilk@jwilk.net>
+# Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>
+# Copyright (c) 2018 Anthony Sottile <asottile@umich.edu>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -9,8 +15,6 @@
 import unittest
 import textwrap
 
-import six
-
 from astroid import MANAGER, Instance, nodes
 from astroid.bases import BUILTINS
 from astroid.builder import AstroidBuilder, extract_node
@@ -131,18 +135,6 @@
         self.assertEqual(default.name, 'x')
         self.assertEqual(next(default.infer()).value, True)
 
-    @require_version('2.7')
-    def test_with_infer_assignnames(self):
-        builder = AstroidBuilder()
-        data = """
-with open('a.txt') as stream, open('b.txt'):
-    stream.read()
-"""
-        astroid = builder.string_build(data, __name__, __file__)
-        # Used to crash due to the fact that the second
-        # context manager didn't use an assignment name.
-        list(astroid.nodes_of_class(nodes.Call))[-1].inferred()
-
     def test_recursion_regression_issue25(self):
         builder = AstroidBuilder()
         data = """
@@ -237,12 +229,9 @@
             pass
         """)
         ancestors = list(node.ancestors())
-        if six.PY3:
-            self.assertEqual(len(ancestors), 1)
-            self.assertEqual(ancestors[0].qname(),
-                             "{}.object".format(BUILTINS))
-        else:
-            self.assertEqual(len(ancestors), 0)
+        self.assertEqual(len(ancestors), 1)
+        self.assertEqual(ancestors[0].qname(),
+                         "{}.object".format(BUILTINS))
 
     def test_ancestors_missing_from_function(self):
         # Test for https://www.logilab.org/ticket/122793
@@ -258,7 +247,7 @@
         # Test for https://bitbucket.org/logilab/astroid/issues/273/
 
         # In a regular file, "coding: utf-8" would have been used.
-        node = extract_node(u'''
+        node = extract_node('''
         from __future__ import unicode_literals
 
         class MyClass(object):
@@ -266,7 +255,7 @@
                 "With unicode : %s "
 
         instance = MyClass()
-        ''' % u"\u2019")
+        ''' % "\u2019")
 
         next(node.value.infer()).as_string()
 
@@ -338,8 +327,9 @@
         self.assertEqual(len(node.inferred()), 1)
 
 
-class Whatever(object):
+class Whatever:
     a = property(lambda x: x, lambda x: x)
 
+
 if __name__ == '__main__':
     unittest.main()
diff -Nru astroid-1.6.5/astroid/tests/unittest_scoped_nodes.py astroid-2.0/astroid/tests/unittest_scoped_nodes.py
--- astroid-1.6.5/astroid/tests/unittest_scoped_nodes.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/tests/unittest_scoped_nodes.py	2018-07-15 09:19:34.000000000 +0200
@@ -1,9 +1,19 @@
+# -*- coding: utf-8 -*-
 # Copyright (c) 2006-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
 # Copyright (c) 2011, 2013-2015 Google, Inc.
-# Copyright (c) 2013-2016 Claudiu Popa <pcmanticore@gmail.com>
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
-# Copyright (c) 2015 Philip Lorenz <philip@bithub.de>
+# Copyright (c) 2013-2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2013 Phil Schaf <flying-sheep@web.de>
+# Copyright (c) 2014 Eevee (Alex Munroe) <amunroe@yelp.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
 # Copyright (c) 2015 Rene Zhang <rz99@cornell.edu>
+# Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>
+# Copyright (c) 2015 Philip Lorenz <philip@bithub.de>
+# Copyright (c) 2016 Jakub Wilk <jwilk@jwilk.net>
+# Copyright (c) 2017-2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
+# Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
+# Copyright (c) 2017 Derek Gustafson <degustaf@gmail.com>
+# Copyright (c) 2018 brendanator <brendan.maginnis@gmail.com>
+# Copyright (c) 2018 Anthony Sottile <asottile@umich.edu>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -31,7 +41,6 @@
     BUILTINS, Instance,
     BoundMethod, UnboundMethod, Generator
 )
-from astroid import __pkginfo__
 from astroid import test_utils
 from astroid.tests import resources
 
@@ -233,7 +242,7 @@
         path = resources.find('data/all.py')
         astroid = builder.AstroidBuilder().file_build(path, 'all')
         with self.assertRaises(AttributeError):
-            # pylint: disable=pointless-statement
+            # pylint: disable=pointless-statement,no-member
             astroid.file_stream
 
     def test_stream_api(self):
@@ -646,8 +655,11 @@
         self.assertEqual(cls.getattr('__name__')[0].value, 'YO')
         self.assertEqual(len(cls.getattr('__doc__')), 1)
         self.assertIsInstance(cls.getattr('__doc__')[0], nodes.Const)
-        self.assertEqual(cls.getattr('__doc__')[0].value, 'hehe')
-        self.assertEqual(len(cls.getattr('__module__')), 1)
+        self.assertEqual(cls.getattr('__doc__')[0].value, 'hehe\n    haha')
+        # YO is an old styled class for Python 2.7
+        # May want to stop locals from referencing namespaced variables in the future
+        module_attr_num = 4 if sys.version_info > (3, 3) else 1
+        self.assertEqual(len(cls.getattr('__module__')), module_attr_num)
         self.assertIsInstance(cls.getattr('__module__')[0], nodes.Const)
         self.assertEqual(cls.getattr('__module__')[0].value, 'data.module')
         self.assertEqual(len(cls.getattr('__dict__')), 1)
@@ -658,7 +670,7 @@
             self.assertEqual(len(cls.getattr('__name__')), 1)
             self.assertEqual(len(cls.getattr('__doc__')), 1, (cls, cls.getattr('__doc__')))
             self.assertEqual(cls.getattr('__doc__')[0].value, cls.doc)
-            self.assertEqual(len(cls.getattr('__module__')), 1)
+            self.assertEqual(len(cls.getattr('__module__')), 4)
             self.assertEqual(len(cls.getattr('__dict__')), 1)
             self.assertEqual(len(cls.getattr('__mro__')), 1)
 
@@ -792,7 +804,7 @@
         self.assertSetEqual(expected_methods, methods)
         klass2 = self.module2['Specialization']
         methods = {m.name for m in klass2.mymethods()}
-        self.assertSetEqual(set([]), methods)
+        self.assertSetEqual(set(), methods)
         method_locals = klass2.local_attr('method')
         self.assertEqual(len(method_locals), 1)
         self.assertEqual(method_locals[0].name, 'method')
@@ -854,8 +866,10 @@
         '''
         astroid = builder.parse(data, __name__)
         cls = astroid['WebAppObject']
-        self.assertEqual(sorted(cls.locals.keys()),
-                         ['appli', 'config', 'registered', 'schema'])
+        assert_keys = ['__module__', '__qualname__', 'appli', 'config', 'registered', 'schema']
+        if sys.version_info < (3, 3):
+            assert_keys.pop(assert_keys.index('__qualname__'))
+        self.assertEqual(sorted(cls.locals.keys()), assert_keys)
 
     def test_class_getattr(self):
         data = '''
@@ -1183,7 +1197,7 @@
         inferred = next(klass.infer())
         metaclass = inferred.metaclass()
         self.assertIsInstance(metaclass, scoped_nodes.ClassDef)
-        self.assertEqual(metaclass.qname(), 'abc.ABCMeta')
+        self.assertIn(metaclass.qname(), ('abc.ABCMeta', '_py_abc.ABCMeta'))
 
     def test_using_invalid_six_add_metaclass_call(self):
         klass = builder.extract_node('''
@@ -1312,7 +1326,7 @@
         ''')
         cls = module['Third']
         slots = cls.slots()
-        self.assertEqual(sorted(set(slot.value for slot in slots)),
+        self.assertEqual(sorted({slot.value for slot in slots}),
                          ['a', 'b', 'c', 'd', 'e'])
 
     def test_all_ancestors_need_slots(self):
@@ -1512,7 +1526,7 @@
         def test(): #@
             yield
         """)
-        result = next(func.infer_call_result(func))
+        result = next(func.infer_call_result())
         self.assertIsInstance(result, Generator)
         self.assertEqual(result.parent, func)
 
diff -Nru astroid-1.6.5/astroid/tests/unittest_transforms.py astroid-2.0/astroid/tests/unittest_transforms.py
--- astroid-1.6.5/astroid/tests/unittest_transforms.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/tests/unittest_transforms.py	2018-07-15 09:19:31.000000000 +0200
@@ -1,5 +1,7 @@
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
-# Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2017 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2016 Jakub Wilk <jwilk@jwilk.net>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -146,7 +148,7 @@
                 for decorator in node.decorators.nodes:
                     inferred = next(decorator.infer())
                     if inferred.qname() == 'abc.abstractmethod':
-                        return next(node.infer_call_result(node))
+                        return next(node.infer_call_result())
             return None
 
         manager = builder.MANAGER
diff -Nru astroid-1.6.5/astroid/tests/unittest_utils.py astroid-2.0/astroid/tests/unittest_utils.py
--- astroid-1.6.5/astroid/tests/unittest_utils.py	2018-05-13 12:38:38.000000000 +0200
+++ astroid-2.0/astroid/tests/unittest_utils.py	2018-07-15 09:19:31.000000000 +0200
@@ -1,5 +1,8 @@
-# Copyright (c) 2014, 2016 Google, Inc.
+# Copyright (c) 2008-2010, 2013 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
+# Copyright (c) 2014 Google, Inc.
 # Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2016 Dave Baum <dbaum@google.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
diff -Nru astroid-1.6.5/astroid/test_utils.py astroid-2.0/astroid/test_utils.py
--- astroid-1.6.5/astroid/test_utils.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/test_utils.py	2018-07-15 09:19:25.000000000 +0200
@@ -1,6 +1,9 @@
 # Copyright (c) 2013-2014 Google, Inc.
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
-# Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
+# Copyright (c) 2015-2016, 2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2016 Jakub Wilk <jwilk@jwilk.net>
+# Copyright (c) 2018 Anthony Sottile <asottile@umich.edu>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -12,7 +15,6 @@
 import warnings
 
 from astroid import nodes
-from astroid import util
 
 
 def require_version(minver=None, maxver=None):
@@ -23,8 +25,10 @@
         string = string or default
         try:
             return tuple(int(v) for v in string.split('.'))
-        except ValueError:
-            util.reraise(ValueError('%s is not a correct version : should be X.Y[.Z].' % string))
+        except ValueError as exc:
+            raise ValueError(
+                '{string} is not a correct version : should be X.Y[.Z].'.format(string=string)
+            ) from exc
 
     def check_require_version(f):
         current = sys.version_info[:3]
@@ -58,4 +62,3 @@
         # Reset it to default value, so it will take
         # into account the values from the -W flag.
         warnings.simplefilter('default', warning)
-        
\ Pas de fin de ligne à la fin du fichier
diff -Nru astroid-1.6.5/astroid/transforms.py astroid-2.0/astroid/transforms.py
--- astroid-1.6.5/astroid/transforms.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/transforms.py	2018-07-15 09:19:26.000000000 +0200
@@ -1,14 +1,15 @@
-# Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016, 2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
 
 
 import collections
-import warnings
 
 
-class TransformVisitor(object):
+class TransformVisitor:
     """A visitor for handling transforms.
 
     The standard approach of using it is to call
@@ -30,18 +31,16 @@
             return node
 
         transforms = self.transforms[cls]
-        orig_node = node  # copy the reference
         for transform_func, predicate in transforms:
             if predicate is None or predicate(node):
                 ret = transform_func(node)
                 # if the transformation function returns something, it's
                 # expected to be a replacement for the node
                 if ret is not None:
-                    if node is not orig_node:
-                        # node has already be modified by some previous
-                        # transformation, warn about it
-                        warnings.warn('node %s substituted multiple times' % node)
                     node = ret
+                if ret.__class__ != cls:
+                    # Can no longer apply the rest of the transforms.
+                    break
         return node
 
     def _visit(self, node):
@@ -55,7 +54,7 @@
     def _visit_generic(self, node):
         if isinstance(node, list):
             return [self._visit_generic(child) for child in node]
-        elif isinstance(node, tuple):
+        if isinstance(node, tuple):
             return tuple(self._visit_generic(child) for child in node)
 
         return self._visit(node)
diff -Nru astroid-1.6.5/astroid/util.py astroid-2.0/astroid/util.py
--- astroid-1.6.5/astroid/util.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/astroid/util.py	2018-07-15 09:19:26.000000000 +0200
@@ -1,15 +1,16 @@
-# Copyright (c) 2015-2016 Cara Vinson <ceridwenv@gmail.com>
-# Copyright (c) 2015-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2018 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2015-2016 Ceridwen <ceridwenv@gmail.com>
+# Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
+# Copyright (c) 2018 Nick Drozd <nicholasdrozd@gmail.com>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
 
-import sys
 import warnings
+from itertools import islice
 
 import importlib
 import lazy_object_proxy
-import six
 
 
 def lazy_descriptor(obj):
@@ -24,14 +25,8 @@
         lambda: importlib.import_module('.' + module_name, 'astroid'))
 
 
-def reraise(exception):
-    '''Reraises an exception with the traceback from the current exception
-    block.'''
-    six.reraise(type(exception), exception, sys.exc_info()[2])
-
-
 @object.__new__
-class Uninferable(object):
+class Uninferable:
     """Special inference object, which is returned when inference fails."""
     def __repr__(self):
         return 'Uninferable'
@@ -58,7 +53,7 @@
         func = getattr(visitor, "visit_uninferable")
         return func(self)
 
-class BadOperationMessage(object):
+class BadOperationMessage:
     """Object which describes a TypeError occurred somewhere in the inference chain
 
     This is not an exception, but a container object which holds the types and
@@ -134,5 +129,28 @@
     return proxy(lambda: node_type)
 
 
+def limit_inference(iterator, size):
+    """Limit inference amount.
+
+    Limit inference amount to help with performance issues with
+    exponentially exploding possible results.
+
+    :param iterator: Inference generator to limit
+    :type iterator: Iterator(NodeNG)
+
+    :param size: Maximum mount of nodes yielded plus an
+        Uninferable at the end if limit reached
+    :type size: int
+
+    :yields: A possibly modified generator
+    :rtype param: Iterable
+    """
+    yield from islice(iterator, size)
+    has_more = next(iterator, False)
+    if has_more is not False:
+        yield Uninferable
+        return
+
+
 # Backwards-compatibility aliases
 YES = Uninferable
diff -Nru astroid-1.6.5/astroid.egg-info/PKG-INFO astroid-2.0/astroid.egg-info/PKG-INFO
--- astroid-1.6.5/astroid.egg-info/PKG-INFO	2018-06-06 17:07:54.000000000 +0200
+++ astroid-2.0/astroid.egg-info/PKG-INFO	2018-07-15 09:27:19.000000000 +0200
@@ -1,6 +1,6 @@
 Metadata-Version: 1.2
 Name: astroid
-Version: 1.6.5
+Version: 2.0
 Summary: A abstract syntax tree for Python with inference support.
 Home-page: https://github.com/PyCQA/astroid
 Author: Python Code Quality Authority
@@ -29,16 +29,14 @@
         ------------
         
         The aim of this module is to provide a common base representation of
-        python source code for projects such as pychecker, pyreverse,
-        pylint... Well, actually the development of this library is essentially
-        governed by pylint's needs. It used to be called logilab-astng.
+        python source code. It is currently the powering pylint's capabilities.
         
         It provides a compatible representation which comes from the `_ast`
         module.  It rebuilds the tree generated by the builtin _ast module by
         recursively walking down the AST and building an extended ast. The new
         node classes have additional methods and attributes for different
-        usages.  They include some support for static inference and local name
-        scopes.  Furthermore, astroid builds partial trees by inspecting living
+        usages. They include some support for static inference and local name
+        scopes. Furthermore, astroid can also build partial trees by inspecting living
         objects.
         
         
@@ -47,43 +45,43 @@
         
         Extract the tarball, jump into the created directory and run::
         
-        	python setup.py install
+        	pip install .
         
-        For installation options, see::
         
-        	python setup.py install --help
+        If you want to do an editable installation, you can run::
+        
+            pip install -e .
         
         
         If you have any questions, please mail the code-quality@python.org
         mailing list for support. See
         http://mail.python.org/mailman/listinfo/code-quality for subscription
-        information and archives. You may find older archives at
-        http://lists.logilab.org/mailman/listinfo/python-projects .
+        information and archives.
         
         Python Versions
         ---------------
         
-        astroid is compatible with Python 2.7 as well as 3.4 and later. astroid uses
-        the same code base for both Python versions, using six.
+        astroid 2.0 is currently available for Python 3 only. If you want Python 2
+        support, older versions of astroid will still supported until 2020.
         
         Test
         ----
         
-        Tests are in the 'test' subdirectory. To launch the whole tests suite
-        at once, you can use unittest discover::
+        Tests are in the 'test' subdirectory. To launch the whole tests suite, you can use
+        either `tox` or `pytest`::
         
-          python -m unittest discover -p "unittest*.py"
+          tox
+          pytest astroid
         
 Platform: UNKNOWN
 Classifier: Topic :: Software Development :: Libraries :: Python Modules
 Classifier: Topic :: Software Development :: Quality Assurance
 Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 2
-Classifier: Programming Language :: Python :: 2.7
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.4
 Classifier: Programming Language :: Python :: 3.5
 Classifier: Programming Language :: Python :: 3.6
+Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: Implementation :: CPython
 Classifier: Programming Language :: Python :: Implementation :: PyPy
-Requires-Python: >=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*
+Requires-Python: >=3.4.*
diff -Nru astroid-1.6.5/astroid.egg-info/requires.txt astroid-2.0/astroid.egg-info/requires.txt
--- astroid-1.6.5/astroid.egg-info/requires.txt	2018-06-06 17:07:54.000000000 +0200
+++ astroid-2.0/astroid.egg-info/requires.txt	2018-07-15 09:27:19.000000000 +0200
@@ -2,7 +2,8 @@
 six
 wrapt
 
-[:python_version<"3.4"]
-enum34>=1.1.3
-singledispatch
-backports.functools_lru_cache
+[:python_version < "3.5"]
+typing
+
+[:python_version < "3.7" and implementation_name == "cpython"]
+typed_ast
diff -Nru astroid-1.6.5/astroid.egg-info/SOURCES.txt astroid-2.0/astroid.egg-info/SOURCES.txt
--- astroid-1.6.5/astroid.egg-info/SOURCES.txt	2018-06-06 17:07:54.000000000 +0200
+++ astroid-2.0/astroid.egg-info/SOURCES.txt	2018-07-15 09:27:19.000000000 +0200
@@ -3,14 +3,14 @@
 ChangeLog
 MANIFEST.in
 README.rst
+pytest.ini
 setup.cfg
 setup.py
-tox.ini
 astroid/__init__.py
 astroid/__pkginfo__.py
+astroid/_ast.py
 astroid/arguments.py
 astroid/as_string.py
-astroid/astpeephole.py
 astroid/bases.py
 astroid/builder.py
 astroid/context.py
@@ -54,6 +54,7 @@
 astroid/brain/brain_pkg_resources.py
 astroid/brain/brain_pytest.py
 astroid/brain/brain_qt.py
+astroid/brain/brain_random.py
 astroid/brain/brain_re.py
 astroid/brain/brain_six.py
 astroid/brain/brain_ssl.py
@@ -80,7 +81,6 @@
 astroid/tests/unittest_nodes.py
 astroid/tests/unittest_object_model.py
 astroid/tests/unittest_objects.py
-astroid/tests/unittest_peephole.py
 astroid/tests/unittest_protocols.py
 astroid/tests/unittest_python3.py
 astroid/tests/unittest_raw_building.py
@@ -98,12 +98,12 @@
 astroid/tests/testdata/python2/data/foogle_fax-0.12.5-py2.7-nspkg.pth
 astroid/tests/testdata/python2/data/format.py
 astroid/tests/testdata/python2/data/invalid_encoding.py
-astroid/tests/testdata/python2/data/joined_strings.py
 astroid/tests/testdata/python2/data/module.py
 astroid/tests/testdata/python2/data/module2.py
 astroid/tests/testdata/python2/data/noendingnewline.py
 astroid/tests/testdata/python2/data/nonregr.py
 astroid/tests/testdata/python2/data/notall.py
+astroid/tests/testdata/python2/data/operator_precedence.py
 astroid/tests/testdata/python2/data/recursion.py
 astroid/tests/testdata/python2/data/tmp__init__.py
 astroid/tests/testdata/python2/data/SSL1/Connection1.py
@@ -157,12 +157,12 @@
 astroid/tests/testdata/python3/data/foogle_fax-0.12.5-py2.7-nspkg.pth
 astroid/tests/testdata/python3/data/format.py
 astroid/tests/testdata/python3/data/invalid_encoding.py
-astroid/tests/testdata/python3/data/joined_strings.py
 astroid/tests/testdata/python3/data/module.py
 astroid/tests/testdata/python3/data/module2.py
 astroid/tests/testdata/python3/data/noendingnewline.py
 astroid/tests/testdata/python3/data/nonregr.py
 astroid/tests/testdata/python3/data/notall.py
+astroid/tests/testdata/python3/data/operator_precedence.py
 astroid/tests/testdata/python3/data/recursion.py
 astroid/tests/testdata/python3/data/tmp__init__.py
 astroid/tests/testdata/python3/data/SSL1/Connection1.py
diff -Nru astroid-1.6.5/ChangeLog astroid-2.0/ChangeLog
--- astroid-1.6.5/ChangeLog	2018-06-06 17:01:12.000000000 +0200
+++ astroid-2.0/ChangeLog	2018-07-15 09:17:55.000000000 +0200
@@ -1,77 +1,175 @@
-Change log for the astroid package (used to be astng)
-=====================================================
+===================
+astroid's ChangeLog
+===================
 
-2018-06-06 -- 1.6.5
+What's New in astroid 2.0?
+==========================
 
-  *  Don't propagate Uninferable objects when inferring BinOps
+Release Date: 2018-07-15
+   
+   * String representation of nodes takes in account precedence and associativity rules of operators.
+
+   * Fix loading files with `modutils.load_from_module` when
+     the path that contains it in `sys.path` is a symlink and
+     the file is contained in a symlinked folder.
+
+     Close #583
+
+   * Reworking of the numpy brain dealing with numerictypes
+     (use of inspect module to determine the class hierarchy of
+      numpy.core.numerictypes module)
+
+     Close PyCQA/pylint#2140
+
+   * Added inference support for starred nodes in for loops
+
+     Close #146
+
+   * Support unpacking for dicts in assignments
+
+     Close #268
+
+   * Add support for inferring functools.partial
+
+     Close #125
+
+   * Inference support for `dict.fromkeys`
+
+     Close #110
+
+   * `int()` builtin is inferred as returning integers.
 
-     Close PyCQA/pylint#2059
+     Close #150
 
-  *  Protect against passing lookup_class to non-class proxied objects
+   * `str()` builtin is inferred as returning strings.
 
-     In some cases the _proxied object points to another Instance, not to the
-     Class of an Instance node (usually this happens with enum and with our
-     hardcoded inference support for this library). Instead of getting a TypeError,
-     we check before if the _proxied matches what we expect.
+     Close #148
 
-     Found by #2080
+   * DescriptorBoundMethod has the correct number of arguments defined.
 
+   * Improvement of the numpy numeric types definition.
 
-2018-05-15 -- 1.6.4
+     Close PyCQA/pylint#1971
 
-   * Skip non-attrs specific attributes in attr wrapped classes. Close PyCQA/pylint#2055
+   * Subclasses of *property* are now interpreted as properties
 
-   * Add brain tip for numpy.sum. Close PyCQA/pylint#1558
+     Close PyCQA/pylint#1601
 
-   * deque.rotate has a default parameter. Close PyCQA/pylint#2013
+   * AsStringRegexpPredicate has been removed.
 
-2018-04-05 -- 1.6.3
+     Use transform predicates instead of it.
 
-   * Fixes nested namespace package import for old-style namespace packages
+   * Switched to using typed_ast for getting access to type comments
 
-   * Use .path for inferring a module's __path__ attribute. Close #528
+     As a side effect of this change, some nodes gained a new `type_annotation` attribute,
+     which, if the type comments were correctly parsed, should contain a node object
+     with the corresponding objects from the type comment.
 
-   * Improve the six urllib functions for Python 2 by setting them as instance attributes
+   * typing.X[...] and typing.NewType are inferred as classes instead of instances.
 
-    Because they were at the class level, we were considering them BoundMethods, resulting
-    in a too-many-function-args error when calling these functions.
-    Close PyCQA/pylint#1965
+   * Module.__path__ is now a list
 
-2018-03-16 -- 1.6.2
+     It used to be a string containing the path, but it doesn't reflect the situation
+     on Python, where it is actually a list.
+
+   * Fix a bug with namespace package's __path__ attribute.
+
+     Close #528
+
+   * Added brain tips for random.sample
+
+     Part of PyCQA/pylint#811
+
+   * Add brain tip for `issubclass` builtin
+
+     Close #101.
 
    * Fix submodule imports from six
 
-     Close PYCQA/pylint#1640
+     Close PyCQA/pylint#1640
+
+   * Fix missing __module__ and __qualname__ from class definition locals
+
+     Close PYCQA/pylint#1753
+
+   * Fix a crash when __annotations__ access a parent's __init__ that does not have arguments
+
+     Close #473
+
+   * Fix multiple objects sharing the same InferenceContext.path causing uninferable results
 
-   * Enhancement of brain_numpy by adding different types from
-     numpy.core.numerictypes
+     Close #483
+
+   * Fix improper modification of col_offset, lineno upon inference of builtin functions
+
+     Close PyCQA/pylint#1839
+
+   * Subprocess.Popen brain now knows of the args member
+
+     Close PyCQA/pylint#1860
+
+   * add move_to_end method to collections.OrderedDict brain
+
+     Close PyCQA/pylint#1872
+
+   * Include new hashlib classes added in python 3.6
 
    * Fix RecursionError for augmented assign
 
      Close #437, #447, #313, PyCQA/pylint#1642, PyCQA/pylint#1805, PyCQA/pylint#1854, PyCQA/pylint#1452
 
+   * Add missing attrs special attribute
 
-   * Stop most inference tip overwrites from happening by using
-     predicates on existing inference_tip transforms.
+     Close PyCQA/pylint#1884
 
-     Close #472
+   * Inference now understands the 'isinstance' builtin
 
-   * Add missing attrs special attribute
+     Close #98
 
-	 Close PyCQA/pylint#1884
+   * Stop duplicate nodes with the same key values
+     from appearing in dictionaries from dictionary unpacking.
+
+     Close PyCQA/pylint#1843
 
    * Fix ``contextlib.contextmanager`` inference for nested context managers
 
      Close #1699
 
+   * Implement inference for len builtin
 
-2018-01-23 -- 1.6.1
+     Close #112
 
-   * Fix a crash when __annotations__ access a parent's __init__ that does not have arguments
+   * Add qname method to Super object preventing potential errors in upstream
+     pylint
 
-     Close #473
+     Close #533
+
+   * Stop astroid from getting stuck in an infinite loop if a function shares
+   its name with its decorator
+
+     Close #375
+
+   * Fix issue with inherited __call__ improperly inferencing self
+
+     Close #PyCQA/pylint#2199
+
+   * Fix __call__ precedence for classes with custom metaclasses
+
+     Close PyCQA/pylint#2159
+
+   * Limit the maximum amount of interable result in an NodeNG.infer() call to
+    100 by default for performance issues with variables with large amounts of
+    possible values.
+
+    The max inferable value can be tuned by setting the `max_inferable_values` flag on
+    astroid.MANAGER.
+
+
+What's New in astroid 1.6.0?
+============================
+
+Release Date: 2017-12-15
 
-2017-12-15 -- 1.6.0
 
    * When verifying duplicates classes in MRO, ignore on-the-fly generated classes
 
@@ -125,11 +223,35 @@
 
       Close PyCQA/pylint#1530
 
+    * Fix inference for nested calls
+
     * Dunder class at method level is now inferred as the class of the method
 
       Close PyCQA/pylint#1328
 
-2017-06-03 -- 1.5.3
+    * Stop most inference tip overwrites from happening by using
+		predicates on existing inference_tip transforms.
+
+      Close #472
+
+    * Fix object.__new__(cls) calls in classmethods by using
+        a context which has the proper boundnode for the given
+        argument
+
+        Close #404
+
+    * Fix Pathlib type inference
+
+        Close PyCQA/pylint#224
+        Close PyCQA/pylint#1660
+
+
+
+What's New in astroid 1.5.3?
+============================
+
+Release Date: 2017-06-03
+
 
     * enum34 dependency is forced to be at least version 1.1.3. Fixes spurious
     bug related to enum classes being falsy in boolean context, which caused
@@ -145,14 +267,24 @@
     * Lock objects from ``threading`` module are now correctly recognised
       as context managers.
 
-2017-04-17 -- 1.5.2
+
+What's New in astroid 1.5.2?
+============================
+
+Release Date: 2017-04-17
+
 
    * Basic support for the class form of typing.NamedTuple
 
    * mro() can be computed for classes with old style classes in the hierarchy
 
 
-2017-04-13 -- 1.5.0
+
+What's New in astroid 1.5.0?
+============================
+
+Release Date: 2017-04-13
+
 
     * Arguments node gained a new attribute, ``kwonlyargs_annotations``
 
@@ -340,7 +472,12 @@
 
       Fixes #399. See PEP530 for details.
 
-2015-11-29 -- 1.4.1
+
+What's New in astroid 1.4.1?
+============================
+
+Release Date: 2015-11-29
+
 
     * Add support for handling Uninferable nodes when calling as_string
 
@@ -353,7 +490,12 @@
       Closes issue #270.
 
 
-2015-11-29 -- 1.4.0 
+
+What's New in astroid 1.4.0?
+============================
+
+Release Date: 2015-11-29
+ 
 
     * Class.getattr('__mro__') returns the actual MRO. Closes issue #128.
 
@@ -682,7 +824,12 @@
      
 
 
-2015-03-14 -- 1.3.6
+
+What's New in astroid 1.3.6?
+============================
+
+Release Date: 2015-03-14
+
 
     * Class.slots raises NotImplementedError for old style classes.
       Closes issue #67.
@@ -694,7 +841,12 @@
       in the resulting AST. Closes issue #82.
 
 
-2015-03-11 -- 1.3.5
+
+What's New in astroid 1.3.5?
+============================
+
+Release Date: 2015-03-11
+
 
     * Add the ability to optimize small ast subtrees,
       with the first use in the optimization of multiple
@@ -723,12 +875,22 @@
       Closes issue #36.
            
 
-2015-01-17 -- 1.3.4
+
+What's New in astroid 1.3.4?
+============================
+
+Release Date: 2015-01-17
+
 
     * Get the first element from the method list when obtaining
       the functions from nose.tools.trivial. Closes Pylint issue #448.
 
-2015-01-16 -- 1.3.3
+
+What's New in astroid 1.3.3?
+============================
+
+Release Date: 2015-01-16
+
 
     * Restore file_stream to a property, but deprecate it in favour of
       the newly added method Module.stream. By using a method instead of a
@@ -762,7 +924,12 @@
     * Add inference tips for nose.tools.
 
 
-2014-11-22 -- 1.3.2
+
+What's New in astroid 1.3.2?
+============================
+
+Release Date: 2014-11-22
+
 
     * Fixed a crash with invalid subscript index.
  
@@ -772,11 +939,21 @@
     * Allow more fine-grained control over C extension loading
       in the manager.
 
-2014-11-21 -- 1.3.1
+
+What's New in astroid 1.3.1?
+============================
+
+Release Date: 2014-11-21
+
    
     * Fixed a crash issue with the pytest brain module.
 
-2014-11-20 -- 1.3.0
+
+What's New in astroid 1.3.0?
+============================
+
+Release Date: 2014-11-20
+
 
     * Fix a maximum recursion error occurred during the inference,
       where statements with the same name weren't filtered properly.
@@ -823,7 +1000,12 @@
       `setup.py develop` now works correctly.
 
 
-2014-08-24 -- 1.2.1
+
+What's New in astroid 1.2.1?
+============================
+
+Release Date: 2014-08-24
+
 
     * Fix a crash occurred when inferring decorator call chain.
       Closes issue #42.
@@ -852,7 +1034,12 @@
     * Don't crash when trying to infer unbound object.__new__ call.
       Closes issue #11.
 
-2014-07-25  --  1.2.0
+
+What's New in astroid 1.2.0?
+============================
+
+Release Date: 2014-07-25
+
 
     * Function nodes can detect decorator call chain and see if they are
       decorated with builtin descriptors (`classmethod` and `staticmethod`).
@@ -885,7 +1072,12 @@
 
     * Add support in pylint-brain for understanding enum classes.
 
-2014-04-30  --  1.1.1
+
+What's New in astroid 1.1.1?
+============================
+
+Release Date: 2014-04-30
+
     * `Class.metaclass()` looks in ancestors when the current class
       does not define explicitly a metaclass.
 
@@ -893,7 +1085,12 @@
       known, and only return cached modules if both name and filepath
       match. Fixes pylint Bitbucket issue #136.
 
-2014-04-18  --  1.1.0
+
+What's New in astroid 1.1.0?
+============================
+
+Release Date: 2014-04-18
+
     * All class nodes are marked as new style classes for Py3k.
 
     * Add a `metaclass` function to `Class` nodes to
@@ -917,7 +1114,12 @@
 
 
 
-2013-10-18  --  1.0.1
+
+What's New in astroid 1.0.1?
+============================
+
+Release Date: 2013-10-18
+
     * fix py3k/windows installation issue (issue #4)
 
     * fix bug with namedtuple inference (issue #3)
@@ -929,7 +1131,12 @@
 
 
 
-2013-07-29  --  1.0.0
+
+What's New in astroid 1.0.0?
+=============================
+
+Release Date: 2013-07-29
+
     * Fix some omissions in py2stdlib's version of hashlib and
       add a small test for it.
 
@@ -952,7 +1159,12 @@
 
 
 
-2013-04-16  --  0.24.3
+
+What's New in astroid 0.24.3?
+=============================
+
+Release Date: 2013-04-16
+
     * #124360 [py3.3]: Don't crash on 'yield from' nodes
 
     * #123062 [pylint-brain]: Use correct names for keywords for urlparse
@@ -972,7 +1184,12 @@
 
 
 
-2013-02-27  --  0.24.2
+
+What's New in astroid 0.24.2?
+=============================
+
+Release Date: 2013-02-27
+
     * pylint-brain: more subprocess.Popen faking (see #46273)
 
     * #109562 [jython]: java modules have no __doc__, causing crash
@@ -983,7 +1200,12 @@
 
 
 
-2012-10-05  --  0.24.1
+
+What's New in astroid 0.24.1?
+=============================
+
+Release Date: 2012-10-05
+
     * #106191: fix __future__ absolute import w/ From node
 
     * #50395: fix function fromlineno when some decorator is splited on
@@ -999,7 +1221,12 @@
 
 
 
-2012-07-18  --  0.24.0
+
+What's New in astroid 0.24.0?
+=============================
+
+Release Date: 2012-07-18
+
     * include pylint brain extension, describing some stuff not properly understood until then.
       (#100013, #53049, #23986, #72355)
 
@@ -1009,7 +1236,12 @@
 
 
 
-2011-12-08  --  0.23.1
+
+What's New in astroid 0.23.1?
+=============================
+
+Release Date: 2011-12-08
+
     * #62295: avoid "OSError: Too many open files" by moving
       .file_stream as a Module property opening the file only when needed
 
@@ -1019,7 +1251,12 @@
 
 
 
-2011-10-07  --  0.23.0
+
+What's New in astroid 0.23.0?
+=============================
+
+Release Date: 2011-10-07
+
     * #77187: ancestor() only returns the first class when inheriting
       from two classes coming from the same module
 
@@ -1041,7 +1278,12 @@
 
 
 
-2011-07-18  --  0.22.0
+
+What's New in astroid 0.22.0?
+=============================
+
+Release Date: 2011-07-18
+
     * added column offset information on nodes (patch by fawce)
 
     * #70497: Crash on AttributeError: 'NoneType' object has no attribute '_infer_name'
@@ -1057,7 +1299,12 @@
 
 
 
-2011-01-11  --  0.21.1
+
+What's New in astroid 0.21.1?
+=============================
+
+Release Date: 2011-01-11
+
     * python3: handle file encoding; fix a lot of tests
 
     * fix #52006: "True" and "False" can be assigned as variable in Python2x
@@ -1076,7 +1323,12 @@
 
 
 
-2010-11-15  --  0.21.0
+
+What's New in astroid 0.21.0?
+=============================
+
+Release Date: 2010-11-15
+
     * python3.x: first python3.x release
 
     * fix #37105: Crash on AttributeError: 'NoneType' object has no attribute '_infer_name'
@@ -1085,7 +1337,12 @@
 
 
 
-2010-10-27  --  0.20.4
+
+What's New in astroid 0.20.4?
+=============================
+
+Release Date: 2010-10-27
+
     * fix #37868 #37665 #33638 #37909: import problems with absolute_import_activated
 
     * fix #8969: false positive when importing from zip-safe eggs
@@ -1098,7 +1355,12 @@
 
 
 
-2010-09-28  --  0.20.3
+
+What's New in astroid 0.20.3?
+=============================
+
+Release Date: 2010-09-28
+
     * restored python 2.3 compatibility
 
     * fix #45959: AttributeError: 'NoneType' object has no attribute 'frame', due
@@ -1107,7 +1369,12 @@
 
 
 
-2010-09-10  --  0.20.2
+
+What's New in astroid 0.20.2?
+=============================
+
+Release Date: 2010-09-10
+
     * fix astng building bug: we've to set module.package flag at the node
       creation time otherwise we'll miss this information when inferring relative
       import during the build process (this should fix for instance some problems
@@ -1121,7 +1388,12 @@
 
 
 
-2010-05-11  --  0.20.1
+
+What's New in astroid 0.20.1?
+=============================
+
+Release Date: 2010-05-11
+
     * fix licensing to LGPL
 
     * add ALL_NODES_CLASSES constant to nodes module
@@ -1133,7 +1405,12 @@
 
 
 
-2010-03-22  --  0.20.0
+
+What's New in astroid 0.20.0?
+=============================
+
+Release Date: 2010-03-22
+
     * fix #20464: raises ?TypeError: '_Yes' object is not iterable? on list inference
 
     * fix #19882: pylint hangs
@@ -1163,12 +1440,22 @@
 
 
 
-2009-12-18  --  0.19.3
+
+What's New in astroid 0.19.3?
+=============================
+
+Release Date: 2009-12-18
+
     * fix name error making 0.19.2 almost useless
 
 
 
-2009-12-18  --  0.19.2
+
+What's New in astroid 0.19.2?
+=============================
+
+Release Date: 2009-12-18
+
     * fix #18773: inference bug on class member (due to bad handling of instance
       / class nodes "bounded" to method calls)
 
@@ -1185,7 +1472,12 @@
 
 
 
-2009-08-27  --  0.19.1
+
+What's New in astroid 0.19.1?
+=============================
+
+Release Date: 2009-08-27
+
     * fix #8771: crash on yield expression
 
     * fix #10024: line numbering bug with try/except/finally
@@ -1198,7 +1490,12 @@
 
 
 
-2009-03-25  --  0.19.0
+
+What's New in astroid 0.19.0?
+=============================
+
+Release Date: 2009-03-25
+
     * fixed python 2.6 issue (tests ok w/ 2.4, 2.5, 2.6. Anyone using 2.2 / 2.3
       to tell us if it works?)
 
@@ -1208,7 +1505,12 @@
 
 
 
-2009-03-19  --  0.18.0
+
+What's New in astroid 0.18.0?
+=============================
+
+Release Date: 2009-03-19
+
     * major api / tree structure changes to make it works with compiler *and*
       python >= 2.5 _ast module
 
@@ -1216,7 +1518,12 @@
 
 
 
-2008-11-19  --  0.17.4
+
+What's New in astroid 0.17.4?
+=============================
+
+Release Date: 2008-11-19
+
     * fix #6015: filter statements bug triggering W0631 false positive in pylint
 
     * fix #5571: Function.is_method() should return False on module level
@@ -1226,7 +1533,12 @@
 
 
 
-2008-09-10  --  0.17.3
+
+What's New in astroid 0.17.3?
+=============================
+
+Release Date: 2008-09-10
+
     * fix #5889: astng crash on certain pyreverse projects
 
     * fix bug w/ loop assignment in .lookup
@@ -1236,7 +1548,12 @@
 
 
 
-2008-01-14  --  0.17.2
+
+What's New in astroid 0.17.2?
+=============================
+
+Release Date: 2008-01-14
+
     * "with" statement support, patch provided by Brian Hawthorne
 
     * fixed recursion arguments in nodes_of_class method as notified by
@@ -1247,7 +1564,12 @@
 
 
 
-2007-06-07  --  0.17.1
+
+What's New in astroid 0.17.1?
+=============================
+
+Release Date: 2007-06-07
+
     * fix #3651: crash when callable as default arg
 
     * fix #3670: subscription inference crash in some cases
@@ -1267,7 +1589,12 @@
 
 
 
-2007-02-22  --  0.17.0
+
+What's New in astroid 0.17.0?
+=============================
+
+Release Date: 2007-02-22
+
     * api change to be able to infer using a context (used to infer function call
       result only for now)
 
@@ -1288,13 +1615,23 @@
 
 
 
-2006-11-23  --  0.16.3
+
+What's New in astroid 0.16.3?
+=============================
+
+Release Date: 2006-11-23
+
     * enhance inference for the subscription notation (motivated by a patch from Amaury)
       and for unary sub/add
 
 
 
-2006-11-15  --  0.16.2
+
+What's New in astroid 0.16.2?
+=============================
+
+Release Date: 2006-11-15
+
     * grrr, fixed python 2.3 incompatibility introduced by generator expression
       scope handling
 
@@ -1305,7 +1642,12 @@
 
 
 
-2006-09-25  --  0.16.1
+
+What's New in astroid 0.16.1?
+=============================
+
+Release Date: 2006-09-25
+
     * python 2.5 support, patch provided by Marien Zwart
 
     * fix [Class|Module].block_range method (this fixes pylint's inline
@@ -1322,7 +1664,12 @@
 
 
 
-2006-04-19  --  0.16.0
+
+What's New in astroid 0.16.0?
+=============================
+
+Release Date: 2006-04-19
+
     * fix living object building to consider classes such as property as
       a class instead of a data descriptor
 
@@ -1333,14 +1680,24 @@
 
 
 
-2006-03-10  --  0.15.1
+
+What's New in astroid 0.15.1?
+=============================
+
+Release Date: 2006-03-10
+
     * fix avoiding to load everything from living objects... Thanks Amaury!
 
     * fix a possible NameError in Instance.infer_call_result
 
 
 
-2006-03-06  --  0.15.0
+
+What's New in astroid 0.15.0?
+=============================
+
+Release Date: 2006-03-06
+
     * fix possible infinite recursion on global statements (close #10342)
       and in various other cases...
 
@@ -1369,7 +1726,12 @@
 
 
 
-2006-01-10  --  0.14.0
+
+What's New in astroid 0.14.0?
+=============================
+
+Release Date: 2006-01-10
+
     * some major inference improvements and refactoring ! The drawback is
       the introduction of some non backward compatible change in the API
       but it's imho much cleaner and powerful now :)
@@ -1404,7 +1766,12 @@
 
 
 
-2005-11-07  --  0.13.1
+
+What's New in astroid 0.13.1?
+=============================
+
+Release Date: 2005-11-07
+
     * fix bug on building from living module the same object in
       encountered more than once time (e.g. builtins.object) (close #10069)
 
@@ -1429,7 +1796,12 @@
 
 
 
-2005-10-21  --  0.13.0
+
+What's New in astroid 0.13.0?
+=============================
+
+Release Date: 2005-10-21
+
     * .locals  and .globals on scoped node handle now a list of references
        to each assignment statements instead of a single reference to the
        first assignment statement.
@@ -1448,3 +1820,6 @@
       longer be maintained (this explains that this package is starting with
       the 0.13 version number, since the fork occurs with the version
       released in logilab-common 0.12).
+
+
+
diff -Nru astroid-1.6.5/debian/changelog astroid-2.0/debian/changelog
--- astroid-1.6.5/debian/changelog	2018-06-10 01:00:36.000000000 +0200
+++ astroid-2.0/debian/changelog	2018-07-17 16:43:55.000000000 +0200
@@ -1,3 +1,22 @@
+astroid (2.0-1) UNRELEASED; urgency=medium
+
+  * Team upload
+  * Drop git-dpm to fit the python team policy which is gbp.
+  * New upstream release 2.0; Closes: #902631
+  * debian/control
+    - bump Standards-Version to 4.1.5 (no changes needed)
+    - raise debhelper dependency to 11
+    - add pytest/pytest-runner build-dependencies
+  * debian/compat
+    - bump compat level to 11
+  * debian/patches
+    - Add patch 0001 to remove the setup_requires field of setup.py, the build
+      dependencies will be provided via Build-Depends: field.
+  * debian/copyright
+    - Update d/copyright authors, dates
+
+ -- Pierre-Elliott Bécue <becue@crans.org>  Tue, 17 Jul 2018 16:43:55 +0200
+
 astroid (1.6.5-1) unstable; urgency=medium
 
   * New upstream release
diff -Nru astroid-1.6.5/debian/compat astroid-2.0/debian/compat
--- astroid-1.6.5/debian/compat	2018-06-10 01:00:36.000000000 +0200
+++ astroid-2.0/debian/compat	2018-07-17 16:43:55.000000000 +0200
@@ -1 +1 @@
-9
+11
diff -Nru astroid-1.6.5/debian/control astroid-2.0/debian/control
--- astroid-1.6.5/debian/control	2018-06-10 01:00:36.000000000 +0200
+++ astroid-2.0/debian/control	2018-07-17 16:43:55.000000000 +0200
@@ -3,8 +3,8 @@
 Priority: optional
 Maintainer: Sandro Tosi <morph@debian.org>
 Uploaders: Debian Python Modules Team <python-modules-team@lists.alioth.debian.org>
-Build-Depends: debhelper (>= 9.0.0), python, python3, dh-python, python-setuptools, python3-setuptools, python-nose, python3-nose, python-wrapt, python3-wrapt, python-lazy-object-proxy, python3-lazy-object-proxy, python-singledispatch, python-enum34
-Standards-Version: 4.1.4
+Build-Depends: debhelper (>= 11.0.0), python, python3, dh-python, python-setuptools, python3-setuptools, python-nose, python3-nose, python-wrapt, python3-wrapt, python-lazy-object-proxy, python3-lazy-object-proxy, python-singledispatch, python-enum34, python-pytest, python3-pytest, python-pytest-runner, python3-pytest-runner
+Standards-Version: 4.1.5
 Homepage: http://www.astroid.org/
 Vcs-Git: https://salsa.debian.org/python-team/modules/astroid.git
 Vcs-Browser: https://salsa.debian.org/python-team/modules/astroid
diff -Nru astroid-1.6.5/debian/copyright astroid-2.0/debian/copyright
--- astroid-1.6.5/debian/copyright	2018-06-10 01:00:36.000000000 +0200
+++ astroid-2.0/debian/copyright	2018-07-17 16:43:55.000000000 +0200
@@ -1,29 +1,70 @@
 Format: https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
 Upstream-Name: astroid
 Source: http://www.astroid.org/
+Comment: For Connection1.py, see the M2Crypto license.
 
 Files: *
-Copyright: 2003-2015 Logilab <pylint-dev@lists.logilab.org>
+Copyright: 2013 - 2018 Claudiu Popa <pcmanticore@gmail.com>
+           2017 - 2018 Ashley Whetter <ashley@awhetter.co.uk>
+           2017 - 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
+           2017 - 2018 hippo91 <guillaume.peillex@gmail.com>
+           2018 Ahmed Azzaoui <ahmed.azzaoui@engie.com>
+           2018 Anthony Sottile <asottile@umich.edu>
+           2018 brendanator <brendan.maginnis@gmail.com>
+           2018 Daniel Colascione <dancol@dancol.org>
+           2018 HoverHell <hoverhell@gmail.com>
+           2018 Ioana Tagirta <ioana.tagirta@gmail.com>
+           2018 Mario Corchero <mcorcherojim@bloomberg.net>
+           2018 Nick Drozd <nicholasdrozd@gmail.com>
+           2015 - 2017 Ceridwen <ceridwenv@gmail.com>
+           2016 - 2017 Derek Gustafson <degustaf@gmail.com>
+           2017 Calen Pennington <calen.pennington@gmail.com>
+           2017 Chris Philip <chrisp533@gmail.com>
+           2017 David Euresti <david@dropbox.com>
+           2017 Hugo <hugovk@users.noreply.github.com>
+           2017 ioanatia <ioanatia@users.noreply.github.com>
+           2017 Iva Miholic <ivamiho@gmail.com>
+           2017 Łukasz Rogalski <rogalski.91@gmail.com>
+           2017 Michał Masłowski <m.maslowski@clearcode.cc>
+           2017 Roy Wright <roy@wright.org>
+           2017 rr- <rr-@sakuya.pl>
+           2003 - 2016 Logilab <pylint-dev@lists.logilab.org>
+           2015 - 2016 Florian Bruhin <me@the-compiler.org>
+           2016 Dave Baum <dbaum@google.com>
+           2016 Giuseppe Scrivano <gscrivan@redhat.com>
+           2016 Jakub Wilk <jwilk@jwilk.net>
+           2016 Jared Garst <jgarst@users.noreply.github.com>
+           2016 Mateusz Bysiek <mb@mbdev.pl>
+           2016 Moises Lopez <moylop260@vauxoo.com>
+           2011, 2013 - 2015 Google, Inc.
+           2015 David Shea <dshea@redhat.com>
+           2015 Dmitry Pribysh <dmand@yandex.ru>
+           2015 Philip Lorenz <philip@bithub.de>
+           2015 Ovidiu Sabou <ovidiu@sabou.org>
+           2015 Radosław Ganczarek <radoslaw@ganczarek.in>
+           2015 raylu <lurayl@gmail.com>
+           2015 Rene Zhang <rz99@cornell.edu>
+           2014 Alexander Presnyakov <flagist0@gmail.com>
+           2014 BioGeek <jeroen.vangoey@gmail.com>
+           2014 Cole Robinson <crobinso@redhat.com>
+           2014 Denis Laxalde <denis.laxalde@logilab.fr>
+           2014 Eevee (Alex Munroe) <amunroe@yelp.com>
+           2014 Jeff Quast <contact@jeffquast.com>
+           2013 AndroWiiid <androwiiid@gmail.com>
+           2013 Phil Schaf <flying-sheep@web.de>
+           2012 FELD Boris <lothiraldan@gmail.com>
+           2010 Daniel Harding <dharding@gmail.com>
+           2007 Marien Zwart <marienz@gentoo.org>
 License: LGPL-2.1+
 
 Files: debian/*
 Copyright: 2014-2018 Sandro Tosi <morph@debian.org>
+           2018 Pierre-Elliott Bécue <becue@crans.org>
 License: LGPL-2.1+
 
-Files: astroid/brain/brain_uuid.py
-Copyright: Copyright (c) 2017 Claudiu Popa <pcmanticore@gmail.com>
-License: LGPL-2.1+
-
-Files: astroid/tests/unittest_brain.py
-Copyright: Copyright 2013 Google Inc. All Rights Reserved.
-License: LGPL-2.1+
-
-Files: astroid/tests/unittest_brain_numpy.py
-Copyright: Copyright (c) 2017 Guillaume Peillex <guillaume.peillex@gmail.com>
-License: LGPL-2.1+
-
-Files: astroid/tests/testdata/python{2,3}/data/SSL1/Connection1.py
+Files: astroid/tests/testdata/python*/data/SSL1/Connection1.py
 Copyright: Copyright (c) 1999-2004 Ng Pheng Siong. All rights reserved.
+License: MIT
 
 License: LGPL-2.1+
  astroid is free software: you can redistribute it and/or modify it
@@ -41,3 +82,20 @@
  .
  On Debian systems, the complete text of the GNU Lesser General Public
  License version 2.1 can be found in "/usr/share/common-licenses/LGPL-2.1".
+
+License: MIT
+ Permission to use, copy, modify, and distribute this software and its
+ documentation for any purpose and without fee is hereby granted, provided that
+ the above copyright notice appear in all copies and that both that copyright
+ notice and this permission notice appear in supporting documentation.
+ .
+ THE AUTHOR PROVIDES THIS SOFTWARE "AS IS" AND ANY EXPRESSED OR IMPLIED
+ WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+ EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
+ IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ POSSIBILITY OF SUCH DAMAGE.
diff -Nru astroid-1.6.5/debian/.git-dpm astroid-2.0/debian/.git-dpm
--- astroid-1.6.5/debian/.git-dpm	2018-06-10 01:00:36.000000000 +0200
+++ astroid-2.0/debian/.git-dpm	1970-01-01 01:00:00.000000000 +0100
@@ -1,11 +0,0 @@
-# see git-dpm(1) from git-dpm package
-860fc3d17ff5e18f38af8f2a5cbe114f4268b8e4
-860fc3d17ff5e18f38af8f2a5cbe114f4268b8e4
-860fc3d17ff5e18f38af8f2a5cbe114f4268b8e4
-860fc3d17ff5e18f38af8f2a5cbe114f4268b8e4
-astroid_1.6.0.orig.tar.gz
-90634b0d4751b92345d0ac8394721a300cb16b4e
-255715
-debianTag="debian/%e%v"
-patchedTag="patched/%e%v"
-upstreamTag="upstream/%e%u"
diff -Nru astroid-1.6.5/debian/patches/0001-Removes-the-setup_requires-entry-in-setup.py-will-be.patch astroid-2.0/debian/patches/0001-Removes-the-setup_requires-entry-in-setup.py-will-be.patch
--- astroid-1.6.5/debian/patches/0001-Removes-the-setup_requires-entry-in-setup.py-will-be.patch	1970-01-01 01:00:00.000000000 +0100
+++ astroid-2.0/debian/patches/0001-Removes-the-setup_requires-entry-in-setup.py-will-be.patch	2018-07-17 16:43:55.000000000 +0200
@@ -0,0 +1,26 @@
+From: =?utf-8?q?Pierre-Elliott_B=C3=A9cue?= <becue@crans.org>
+Date: Tue, 17 Jul 2018 17:00:51 +0200
+Subject: Removes the setup_requires entry in setup.py,
+ will be done by the build tool
+
+ In setup.py, the setup of astroid comes with a setup_requires
+ pytest-runner. This implies installing from an external source
+ pytest_runner at build time, which is not compatible with Debian's
+ policy. Hence, this line gets removed, and these dependencies will be
+ manually installed at build time via d/control Build-Depends line.
+---
+ setup.py | 1 -
+ 1 file changed, 1 deletion(-)
+
+diff --git a/setup.py b/setup.py
+index 2ad90aa..4628a40 100644
+--- a/setup.py
++++ b/setup.py
+@@ -42,7 +42,6 @@ def install():
+                  install_requires = install_requires,
+                  extras_require=extras_require,
+                  packages=find_packages(exclude=['astroid.tests']) + ['astroid.brain'],
+-                 setup_requires=['pytest-runner'],
+                  test_suite='test',
+                  tests_require=['pytest'],
+                  )
diff -Nru astroid-1.6.5/debian/patches/series astroid-2.0/debian/patches/series
--- astroid-1.6.5/debian/patches/series	1970-01-01 01:00:00.000000000 +0100
+++ astroid-2.0/debian/patches/series	2018-07-17 16:43:55.000000000 +0200
@@ -0,0 +1 @@
+0001-Removes-the-setup_requires-entry-in-setup.py-will-be.patch
diff -Nru astroid-1.6.5/MANIFEST.in astroid-2.0/MANIFEST.in
--- astroid-1.6.5/MANIFEST.in	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/MANIFEST.in	2018-07-03 09:02:20.000000000 +0200
@@ -1,7 +1,7 @@
 include ChangeLog
-include README
+include README.rst
 include COPYING
 include COPYING.LESSER
-include tox.ini
-recursive-include astroid/tests/testdata *.py *.zip *.egg
+include pytest.ini
+recursive-include astroid/tests *.py *.zip *.egg *.pth
 recursive-include astroid/brain *.py
diff -Nru astroid-1.6.5/PKG-INFO astroid-2.0/PKG-INFO
--- astroid-1.6.5/PKG-INFO	2018-06-06 17:07:55.000000000 +0200
+++ astroid-2.0/PKG-INFO	2018-07-15 09:27:19.000000000 +0200
@@ -1,6 +1,6 @@
 Metadata-Version: 1.2
 Name: astroid
-Version: 1.6.5
+Version: 2.0
 Summary: A abstract syntax tree for Python with inference support.
 Home-page: https://github.com/PyCQA/astroid
 Author: Python Code Quality Authority
@@ -29,16 +29,14 @@
         ------------
         
         The aim of this module is to provide a common base representation of
-        python source code for projects such as pychecker, pyreverse,
-        pylint... Well, actually the development of this library is essentially
-        governed by pylint's needs. It used to be called logilab-astng.
+        python source code. It is currently the powering pylint's capabilities.
         
         It provides a compatible representation which comes from the `_ast`
         module.  It rebuilds the tree generated by the builtin _ast module by
         recursively walking down the AST and building an extended ast. The new
         node classes have additional methods and attributes for different
-        usages.  They include some support for static inference and local name
-        scopes.  Furthermore, astroid builds partial trees by inspecting living
+        usages. They include some support for static inference and local name
+        scopes. Furthermore, astroid can also build partial trees by inspecting living
         objects.
         
         
@@ -47,43 +45,43 @@
         
         Extract the tarball, jump into the created directory and run::
         
-        	python setup.py install
+        	pip install .
         
-        For installation options, see::
         
-        	python setup.py install --help
+        If you want to do an editable installation, you can run::
+        
+            pip install -e .
         
         
         If you have any questions, please mail the code-quality@python.org
         mailing list for support. See
         http://mail.python.org/mailman/listinfo/code-quality for subscription
-        information and archives. You may find older archives at
-        http://lists.logilab.org/mailman/listinfo/python-projects .
+        information and archives.
         
         Python Versions
         ---------------
         
-        astroid is compatible with Python 2.7 as well as 3.4 and later. astroid uses
-        the same code base for both Python versions, using six.
+        astroid 2.0 is currently available for Python 3 only. If you want Python 2
+        support, older versions of astroid will still supported until 2020.
         
         Test
         ----
         
-        Tests are in the 'test' subdirectory. To launch the whole tests suite
-        at once, you can use unittest discover::
+        Tests are in the 'test' subdirectory. To launch the whole tests suite, you can use
+        either `tox` or `pytest`::
         
-          python -m unittest discover -p "unittest*.py"
+          tox
+          pytest astroid
         
 Platform: UNKNOWN
 Classifier: Topic :: Software Development :: Libraries :: Python Modules
 Classifier: Topic :: Software Development :: Quality Assurance
 Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 2
-Classifier: Programming Language :: Python :: 2.7
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.4
 Classifier: Programming Language :: Python :: 3.5
 Classifier: Programming Language :: Python :: 3.6
+Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: Implementation :: CPython
 Classifier: Programming Language :: Python :: Implementation :: PyPy
-Requires-Python: >=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*
+Requires-Python: >=3.4.*
diff -Nru astroid-1.6.5/pytest.ini astroid-2.0/pytest.ini
--- astroid-1.6.5/pytest.ini	1970-01-01 01:00:00.000000000 +0100
+++ astroid-2.0/pytest.ini	2018-07-03 09:02:21.000000000 +0200
@@ -0,0 +1,3 @@
+[pytest]
+python_files=*test_*.py
+addopts=-m "not acceptance"
diff -Nru astroid-1.6.5/README.rst astroid-2.0/README.rst
--- astroid-1.6.5/README.rst	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/README.rst	2018-07-03 09:02:20.000000000 +0200
@@ -21,16 +21,14 @@
 ------------
 
 The aim of this module is to provide a common base representation of
-python source code for projects such as pychecker, pyreverse,
-pylint... Well, actually the development of this library is essentially
-governed by pylint's needs. It used to be called logilab-astng.
+python source code. It is currently the powering pylint's capabilities.
 
 It provides a compatible representation which comes from the `_ast`
 module.  It rebuilds the tree generated by the builtin _ast module by
 recursively walking down the AST and building an extended ast. The new
 node classes have additional methods and attributes for different
-usages.  They include some support for static inference and local name
-scopes.  Furthermore, astroid builds partial trees by inspecting living
+usages. They include some support for static inference and local name
+scopes. Furthermore, astroid can also build partial trees by inspecting living
 objects.
 
 
@@ -39,29 +37,30 @@
 
 Extract the tarball, jump into the created directory and run::
 
-	python setup.py install
+	pip install .
 
-For installation options, see::
 
-	python setup.py install --help
+If you want to do an editable installation, you can run::
+
+    pip install -e .
 
 
 If you have any questions, please mail the code-quality@python.org
 mailing list for support. See
 http://mail.python.org/mailman/listinfo/code-quality for subscription
-information and archives. You may find older archives at
-http://lists.logilab.org/mailman/listinfo/python-projects .
+information and archives.
 
 Python Versions
 ---------------
 
-astroid is compatible with Python 2.7 as well as 3.4 and later. astroid uses
-the same code base for both Python versions, using six.
+astroid 2.0 is currently available for Python 3 only. If you want Python 2
+support, older versions of astroid will still supported until 2020.
 
 Test
 ----
 
-Tests are in the 'test' subdirectory. To launch the whole tests suite
-at once, you can use unittest discover::
+Tests are in the 'test' subdirectory. To launch the whole tests suite, you can use
+either `tox` or `pytest`::
 
-  python -m unittest discover -p "unittest*.py"
+  tox
+  pytest astroid
diff -Nru astroid-1.6.5/setup.cfg astroid-2.0/setup.cfg
--- astroid-1.6.5/setup.cfg	2018-06-06 17:07:55.000000000 +0200
+++ astroid-2.0/setup.cfg	2018-07-15 09:27:19.000000000 +0200
@@ -1,8 +1,7 @@
-[wheel]
-universal = 1
+[aliases]
+test = pytest
 
 [tool:pytest]
-python_files = unittest_* test_*.py
 testpaths = astroid/tests
 
 [egg_info]
diff -Nru astroid-1.6.5/setup.py astroid-2.0/setup.py
--- astroid-1.6.5/setup.py	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/setup.py	2018-07-15 09:19:21.000000000 +0200
@@ -1,7 +1,10 @@
 #!/usr/bin/env python
-# Copyright (c) 2006, 2009-2013 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
+# Copyright (c) 2006, 2009-2010, 2012-2013 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
+# Copyright (c) 2010-2011 Julien Jehannet <julien.jehannet@logilab.fr>
+# Copyright (c) 2014-2016, 2018 Claudiu Popa <pcmanticore@gmail.com>
 # Copyright (c) 2014 Google, Inc.
-# Copyright (c) 2014-2016 Claudiu Popa <pcmanticore@gmail.com>
+# Copyright (c) 2017 Hugo <hugovk@users.noreply.github.com>
+# Copyright (c) 2018 Ashley Whetter <ashley@awhetter.co.uk>
 
 # Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
 # For details: https://github.com/PyCQA/astroid/blob/master/COPYING.LESSER
@@ -24,22 +27,6 @@
 with open(os.path.join(astroid_dir, 'README.rst')) as fobj:
     long_description = fobj.read()
 
-class AstroidInstallLib(install_lib.install_lib):
-    def byte_compile(self, files):
-        test_datadir = os.path.join('astroid', 'tests', 'testdata')
-        files = [f for f in files if test_datadir not in f]
-        install_lib.install_lib.byte_compile(self, files)
-
-
-class AstroidEasyInstallLib(easy_install.easy_install):
-    # override this since pip/easy_install attempt to byte compile
-    # test data files, some of them being syntactically wrong by design,
-    # and this scares the end-user
-    def byte_compile(self, files):
-        test_datadir = os.path.join('astroid', 'tests', 'testdata')
-        files = [f for f in files if test_datadir not in f]
-        easy_install.easy_install.byte_compile(self, files)
-
 
 def install():
     return setup(name = distname,
@@ -51,13 +38,13 @@
                  author = author,
                  author_email = author_email,
                  url = web,
-                 include_package_data = True,
-                 python_requires='>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*',
+                 python_requires='>=3.4.*',
                  install_requires = install_requires,
                  extras_require=extras_require,
-                 packages = find_packages(),
-                 cmdclass={'install_lib': AstroidInstallLib,
-                           'easy_install': AstroidEasyInstallLib}
+                 packages=find_packages(exclude=['astroid.tests']) + ['astroid.brain'],
+                 setup_requires=['pytest-runner'],
+                 test_suite='test',
+                 tests_require=['pytest'],
                  )
 
 
diff -Nru astroid-1.6.5/tox.ini astroid-2.0/tox.ini
--- astroid-1.6.5/tox.ini	2018-06-06 16:59:26.000000000 +0200
+++ astroid-2.0/tox.ini	1970-01-01 01:00:00.000000000 +0100
@@ -1,61 +0,0 @@
-[tox]
-envlist = py27, py34, py35, py36, pypy, pylint
-skip_missing_interpreters = true
-
-[testenv:pylint]
-commands = pylint -rn --rcfile={toxinidir}/pylintrc {toxinidir}/astroid
-
-[testenv]
-deps =
-  py27,pypy: backports.functools_lru_cache
-  py27,pypy: enum34
-  lazy-object-proxy
-  nose
-  py27,py34,py35,py36: numpy
-  py27,py34,py35,py36: attr
-  pytest
-  python-dateutil
-  py27,pypy: singledispatch
-  six
-  wrapt
-  pylint: git+https://github.com/pycqa/pylint@master
-  coverage
-
-setenv =
-    COVERAGE_FILE = {toxinidir}/.coverage.{envname}
-
-commands =
-    ; --pyargs is needed so the directory astroid doesn't shadow the tox
-    ; installed astroid package
-    ; This is important for tests' test data which create files
-    ; inside the package
-    python -Wi {envsitepackagesdir}/coverage run -m pytest --pyargs astroid {posargs:}
-    ; Transform absolute path to relative path
-    ; for compatibility with coveralls.io and fix 'source not available' error.
-    ; If you can find a cleaner way is welcome
-    python -c "import os;cov_strip_abspath = open(os.environ['COVERAGE_FILE'], 'r').read().replace('{toxinidir}' + os.sep, '');open(os.environ['COVERAGE_FILE'], 'w').write(cov_strip_abspath)"
-
-[testenv:coveralls]
-setenv =
-    COVERAGE_FILE = {toxinidir}/.coverage
-passenv =
-    *
-deps =
-    coverage
-    coveralls
-skip_install = true
-commands =
-    python {envsitepackagesdir}/coverage combine
-    python {envsitepackagesdir}/coverage report --rcfile={toxinidir}/.coveragerc -m
-    - coveralls --rcfile={toxinidir}/.coveragerc
-changedir = {toxinidir}
-
-[testenv:coverage-erase]
-setenv =
-    COVERAGE_FILE = {toxinidir}/.coverage
-deps =
-    coverage
-skip_install = true
-commands =
-    python {envsitepackagesdir}/coverage erase
-changedir = {toxinidir}
