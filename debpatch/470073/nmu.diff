diff -ruN clamav-0.92.1~dfsg/debian/changelog clamav-0.92.1~dfsg2/debian/changelog
--- clamav-0.92.1~dfsg/debian/changelog	2008-03-08 19:43:42.000000000 -0500
+++ clamav-0.92.1~dfsg2/debian/changelog	2008-03-08 19:34:42.000000000 -0500
@@ -1,3 +1,10 @@
+clamav (0.92.1~dfsg2-0.1) unstable; urgency=low
+
+  * Non-maintainer upload.
+  * Remove non-free unrar files and repack orig.tar.gz (Closes: #470073)
+
+ -- Scott Kitterman <scott@kitterman.com>  Sat, 08 Mar 2008 19:29:19 -0500
+
 clamav (0.92.1~dfsg-1) unstable; urgency=low
 
   * New upstream bugfix release
diff -ruN clamav-0.92.1~dfsg/libclamunrar/unrar15.c clamav-0.92.1~dfsg2/libclamunrar/unrar15.c
--- clamav-0.92.1~dfsg/libclamunrar/unrar15.c	2007-11-30 11:01:49.000000000 -0500
+++ clamav-0.92.1~dfsg2/libclamunrar/unrar15.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,503 +0,0 @@
-/*
- *  Extract RAR archives
- *
- *  Copyright (C) 2005 trog@uncon.org
- *
- *  This code is based on the work of Alexander L. Roshal (C)
- *
- *  The unRAR sources may be used in any software to handle RAR
- *  archives without limitations free of charge, but cannot be used
- *  to re-create the RAR compression algorithm, which is proprietary.
- *  Distribution of modified unRAR sources in separate form or as a
- *  part of other software is permitted, provided that it is clearly
- *  stated in the documentation and source comments that the code may
- *  not be used to develop a RAR (WinRAR) compatible archiver.
- *
- */
-
-#include "libclamunrar/unrar.h"
-#include "libclamunrar/unrar15.h"
-#include <string.h>
-
-#define STARTL1  2
-static unsigned int dec_l1[]={0x8000,0xa000,0xc000,0xd000,0xe000,0xea00,
-			0xee00,0xf000,0xf200,0xf200,0xffff};
-static unsigned int pos_l1[]={0,0,0,2,3,5,7,11,16,20,24,32,32};
-
-#define STARTL2  3
-static unsigned int dec_l2[]={0xa000,0xc000,0xd000,0xe000,0xea00,0xee00,
-			0xf000,0xf200,0xf240,0xffff};
-static unsigned int pos_l2[]={0,0,0,0,5,7,9,13,18,22,26,34,36};
-
-#define STARTHF0  4
-static unsigned int dec_hf0[]={0x8000,0xc000,0xe000,0xf200,0xf200,0xf200,
-			0xf200,0xf200,0xffff};
-static unsigned int pos_hf0[]={0,0,0,0,0,8,16,24,33,33,33,33,33};
-
-
-#define STARTHF1  5
-static unsigned int dec_hf1[]={0x2000,0xc000,0xe000,0xf000,0xf200,0xf200,
-			0xf7e0,0xffff};
-static unsigned int pos_hf1[]={0,0,0,0,0,0,4,44,60,76,80,80,127};
-
-
-#define STARTHF2  5
-static unsigned int dec_hf2[]={0x1000,0x2400,0x8000,0xc000,0xfa00,0xffff,
-			0xffff,0xffff};
-static unsigned int pos_hf2[]={0,0,0,0,0,0,2,7,53,117,233,0,0};
-
-
-#define STARTHF3  6
-static unsigned int dec_hf3[]={0x800,0x2400,0xee00,0xfe80,0xffff,0xffff,
-			0xffff};
-static unsigned int pos_hf3[]={0,0,0,0,0,0,0,2,16,218,251,0,0};
-
-
-#define STARTHF4  8
-static unsigned int dec_hf4[]={0xff00,0xffff,0xffff,0xffff,0xffff,0xffff};
-static unsigned int pos_hf4[]={0,0,0,0,0,0,0,0,0,255,0,0,0};
-
-static void unpack_init_data15(int solid, unpack_data_t *unpack_data)
-{
-	if (!solid) {
-		unpack_data->avr_plcb = unpack_data->avr_ln1 = unpack_data->avr_ln2 =
-			unpack_data->avr_ln3 = unpack_data->num_huf =
-			unpack_data->buf60 = 0;
-		unpack_data->avr_plc = 0x3500;
-		unpack_data->max_dist3 = 0x2001;
-		unpack_data->nhfb = unpack_data->nlzb = 0x80;
-	}
-	
-	unpack_data->flags_cnt = 0;
-	unpack_data->flag_buf = 0;
-	unpack_data->st_mode = 0;
-	unpack_data->lcount = 0;
-	unpack_data->read_top = 0;
-}
-
-static void corr_huff(unpack_data_t *unpack_data, unsigned int *char_set,
-			unsigned int *num_to_place)
-{
-	int i, j;
-	
-	for (i=7 ; i >= 0 ; i--) {
-		for (j=0 ; j < 32 ; j++, char_set++) {
-			*char_set = (*char_set & ~0xff) | i;
-		}
-	}
-	memset(num_to_place, 0, sizeof(unpack_data->ntopl));
-	for (i=6 ; i >= 0 ; i--) {
-		num_to_place[i] = (7-i) * 32;
-	}
-}
-
-static void init_huff(unpack_data_t *unpack_data)
-{
-	unsigned int i;
-	
-	for (i=0 ; i<256 ; i++) {
-		unpack_data->place[i] = unpack_data->placea[i] = unpack_data->placeb[i] = i;
-		unpack_data->placec[i] = (~i+1) & 0xff;
-		unpack_data->chset[i] = unpack_data->chsetb[i] = i << 8;
-		unpack_data->chseta[i] = i;
-		unpack_data->chsetc[i] = ((~i+1) & 0xff) << 8;
-	}
-	memset(unpack_data->ntopl, 0, sizeof(unpack_data->ntopl));
-	memset(unpack_data->ntoplb, 0, sizeof(unpack_data->ntoplb));
-	memset(unpack_data->ntoplc, 0, sizeof(unpack_data->ntoplc));
-	corr_huff(unpack_data, unpack_data->chsetb, unpack_data->ntoplb);
-}
-
-static void copy_string15(unpack_data_t *unpack_data, unsigned int distance,
-				unsigned int length)
-{
-	unpack_data->dest_unp_size -= length;
-	while (length--) {
-		unpack_data->window[unpack_data->unp_ptr] =
-			unpack_data->window[(unpack_data->unp_ptr - distance) & MAXWINMASK];
-		unpack_data->unp_ptr = (unpack_data->unp_ptr + 1) & MAXWINMASK;
-	}
-}
-
-static unsigned int decode_num(unpack_data_t *unpack_data, int num, unsigned int start_pos,
-			unsigned int *dec_tab, unsigned int *pos_tab)
-{
-	int i;
-	
-	for (num&=0xfff0, i=0 ; dec_tab[i] <= num ; i++) {
-		start_pos++;
-	}
-	rar_addbits(unpack_data, start_pos);
-	return (((num-(i ? dec_tab[i-1]:0)) >> (16-start_pos)) + pos_tab[start_pos]);
-}
-
-static void huff_decode(unpack_data_t *unpack_data)
-{
-	unsigned int cur_byte, new_byte_place, length, distance, bit_field;
-	int byte_place;
-	
-	bit_field = rar_getbits(unpack_data);
-	
-	if (unpack_data->avr_plc > 0x75ff) {
-		byte_place = decode_num(unpack_data, bit_field,
-					STARTHF4, dec_hf4, pos_hf4);
-	} else if (unpack_data->avr_plc > 0x5dff) {
-		byte_place = decode_num(unpack_data, bit_field,
-					STARTHF3, dec_hf3, pos_hf3);
-	} else if (unpack_data->avr_plc > 0x35ff) {
-		byte_place = decode_num(unpack_data, bit_field,
-					STARTHF2, dec_hf2, pos_hf2);
-	} else if (unpack_data->avr_plc > 0x0dff) {
-		byte_place = decode_num(unpack_data, bit_field,
-					STARTHF1, dec_hf1, pos_hf1);
-	} else {
-		byte_place = decode_num(unpack_data, bit_field,
-					STARTHF0, dec_hf0, pos_hf0);
-	}
-	
-	byte_place &= 0xff;
-	if (unpack_data->st_mode) {
-		if (byte_place == 0 && bit_field > 0xfff) {
-			byte_place = 0x100;
-		}
-		if (--byte_place == -1) {
-			bit_field = rar_getbits(unpack_data);
-			rar_addbits(unpack_data, 1);
-			if (bit_field & 0x8000) {
-				unpack_data->num_huf = unpack_data->st_mode = 0;
-				return;
-			} else {
-				length = (bit_field & 0x4000) ? 4 : 3;
-				rar_addbits(unpack_data, 1);
-				distance = decode_num(unpack_data, rar_getbits(unpack_data),
-					STARTHF2, dec_hf2, pos_hf2);
-				distance = (distance << 5) | (rar_getbits(unpack_data) >> 11);
-				rar_addbits(unpack_data, 5);
-				copy_string15(unpack_data, distance, length);
-				return;
-			}
-		}
-	} else if (unpack_data->num_huf++ >= 16 && unpack_data->flags_cnt == 0) {
-		unpack_data->st_mode = 1;
-	}
-	unpack_data->avr_plc += byte_place;
-	unpack_data->avr_plc -= unpack_data->avr_plc >> 8;
-	unpack_data->nhfb += 16;
-	if (unpack_data->nhfb > 0xff) {
-		unpack_data->nhfb = 0x90;
-		unpack_data->nlzb >>= 1;
-	}
-	
-	unpack_data->window[unpack_data->unp_ptr++] = 
-			(unsigned char) (unpack_data->chset[byte_place] >>8);
-	--unpack_data->dest_unp_size;
-	
-	while (1) {
-		cur_byte = unpack_data->chset[byte_place];
-		new_byte_place = unpack_data->ntopl[cur_byte++ & 0xff]++;
-		if ((cur_byte & 0xff) > 0xa1) {
-			corr_huff(unpack_data, unpack_data->chset, unpack_data->ntopl);
-		} else {
-			break;
-		}
-	}
-	
-	unpack_data->chset[byte_place] = unpack_data->chset[new_byte_place];
-	unpack_data->chset[new_byte_place] = cur_byte;
-}
-
-	
-	
-static void get_flag_buf(unpack_data_t *unpack_data)
-{
-	unsigned int flags, new_flags_place, flags_place;
-	
-	flags_place = decode_num(unpack_data, rar_getbits(unpack_data), STARTHF2,
-				dec_hf2, pos_hf2);
-	for (;;) {
-		flags = unpack_data->chsetc[flags_place];
-		unpack_data->flag_buf = flags >> 8;
-		new_flags_place = unpack_data->ntoplc[flags++ & 0xff]++;
-		if ((flags & 0xff) != 0) {
-			break;
-		}
-		corr_huff(unpack_data, unpack_data->chsetc, unpack_data->ntoplc);
-	}
-	unpack_data->chsetc[flags_place] = unpack_data->chsetc[new_flags_place];
-	unpack_data->chsetc[new_flags_place] = flags;
-}
-
-static void short_lz(unpack_data_t *unpack_data)
-{
-	static unsigned int short_len1[]={1,3,4,4,5,6,7,8,8,4,4,5,6,6,4,0};
-	static unsigned int short_xor1[]={0,0xa0,0xd0,0xe0,0xf0,0xf8,0xfc,0xfe,
-			0xff,0xc0,0x80,0x90,0x98,0x9c,0xb0};
-	static unsigned int short_len2[]={2,3,3,3,4,4,5,6,6,4,4,5,6,6,4,0};
-	static unsigned int short_xor2[]={0,0x40,0x60,0xa0,0xd0,0xe0,0xf0,0xf8,
-			0xfc,0xc0,0x80,0x90,0x98,0x9c,0xb0};
-
-	unsigned int length, save_length, last_distance, distance, bit_field;
-	int distance_place;
-	
-	unpack_data->num_huf = 0;
-	bit_field = rar_getbits(unpack_data);
-	if (unpack_data->lcount == 2) {
-		rar_addbits(unpack_data, 1);
-		if (bit_field >= 0x8000) {
-			copy_string15(unpack_data,
-				(unsigned int)unpack_data->last_dist,
-				unpack_data->last_length);
-			return;
-		}
-		bit_field <<= 1;
-		unpack_data->lcount = 0;
-	}
-	
-	bit_field >>= 8;
-	short_len1[1] = short_len2[3] = unpack_data->buf60+3;
-	if (unpack_data->avr_ln1 < 37) {
-		for (length=0 ;; length++) {
-			if (((bit_field^short_xor1[length]) &
-					(~(0xff>>short_len1[length]))) == 0) {
-				break;
-			}
-		}
-		rar_addbits(unpack_data, short_len1[length]);
-	} else {
-		for (length=0; ;length++) {
-				if (((bit_field^short_xor2[length]) &
-						(~(0xff>>short_len2[length]))) == 0) {
-					break;
-				}
-		}
-		rar_addbits(unpack_data, short_len2[length]);
-	}
-	
-	if (length >= 9) {
-		if (length == 9) {
-			unpack_data->lcount++;
-			copy_string15(unpack_data, (unsigned int) unpack_data->last_dist,
-				unpack_data->last_length);
-			return;
-		}
-		if (length == 14) {
-			unpack_data->lcount = 0;
-			length = decode_num(unpack_data, rar_getbits(unpack_data),
-					STARTL2, dec_l2, pos_l2) + 5;
-			distance = (rar_getbits(unpack_data) >> 1) | 0x8000;
-			rar_addbits(unpack_data, 15);
-			unpack_data->last_length = length;
-			unpack_data->last_dist = distance;
-			copy_string15(unpack_data, distance, length);
-			return;
-		}
-		
-		unpack_data->lcount = 0;
-		save_length = length;
-		distance = unpack_data->old_dist[(unpack_data->old_dist_ptr-(length-9)) & 3];
-		length = decode_num(unpack_data,
-				rar_getbits(unpack_data), STARTL1, dec_l1, pos_l1) + 2;
-		if (length == 0x101 && save_length == 10) {
-			unpack_data->buf60 ^= 1;
-			return;
-		}
-		if (distance > 256) {
-			length++;
-		}
-		if (distance >= unpack_data->max_dist3) {
-			length++;
-		}
-		
-		unpack_data->old_dist[unpack_data->old_dist_ptr++] = distance;
-		unpack_data->old_dist_ptr = unpack_data->old_dist_ptr & 3;
-		unpack_data->last_length = length;
-		unpack_data->last_dist = distance;
-		copy_string15(unpack_data, distance, length);
-		return;
-	}
-	
-	unpack_data->lcount = 0;
-	unpack_data->avr_ln1 += length;
-	unpack_data->avr_ln1 -= unpack_data->avr_ln1 >> 4;
-	
-	distance_place = decode_num(unpack_data, rar_getbits(unpack_data),
-					STARTHF2, dec_hf2, pos_hf2) & 0xff;
-	distance = unpack_data->chseta[distance_place];
-	if (--distance_place != -1) {
-		unpack_data->placea[distance]--;
-		last_distance = unpack_data->chseta[distance_place];
-		unpack_data->placea[last_distance]++;
-		unpack_data->chseta[distance_place+1] = last_distance;
-		unpack_data->chseta[distance_place] = distance;
-	}
-	length += 2;
-	unpack_data->old_dist[unpack_data->old_dist_ptr++] = ++distance;
-	unpack_data->old_dist_ptr = unpack_data->old_dist_ptr & 3;
-	unpack_data->last_length = length;
-	unpack_data->last_dist = distance;
-	copy_string15(unpack_data, distance, length);
-}
-
-static void long_lz(unpack_data_t *unpack_data)
-{
-	unsigned int length, distance, distance_place, new_distance_place;
-	unsigned int old_avr2, old_avr3, bit_field;
-	
-	unpack_data->num_huf = 0;
-	unpack_data->nlzb += 16;
-	
-	if (unpack_data->nlzb > 0xff) {
-		unpack_data->nlzb = 0x90;
-		unpack_data->nhfb >>= 1;
-	}
-	old_avr2 = unpack_data->avr_ln2;
-	
-	bit_field = rar_getbits(unpack_data);
-	if (unpack_data->avr_ln2 >= 122) {
-		length = decode_num(unpack_data, bit_field, STARTL2, dec_l2, pos_l2);
-	} else if (unpack_data->avr_ln2 >= 64) {
-		length = decode_num(unpack_data, bit_field, STARTL1, dec_l1, pos_l1);
-	} else if (bit_field < 0x100) {
-		length = bit_field;
-		rar_addbits(unpack_data, 16);
-	} else {
-		for (length=0 ; ((bit_field << length) & 0x8000)==0 ; length++) {
-			/* Empty loop */
-		}
-		rar_addbits(unpack_data, length+1);
-	}
-	
-	unpack_data->avr_ln2 += length;
-	unpack_data->avr_ln2 -= unpack_data->avr_ln2 >> 5;
-	
-	bit_field = rar_getbits(unpack_data);
-	if (unpack_data->avr_plcb > 0x28ff) {
-		distance_place = decode_num(unpack_data, bit_field, STARTHF2,
-					dec_hf2, pos_hf2);
-	} else if (unpack_data->avr_plcb > 0x6ff) {
-		distance_place = decode_num(unpack_data, bit_field, STARTHF1,
-					dec_hf1, pos_hf1);
-	} else {
-		distance_place = decode_num(unpack_data, bit_field, STARTHF0,
-					dec_hf0, pos_hf0);
-	}
-	
-	unpack_data->avr_plcb += distance_place;
-	unpack_data->avr_plcb -= unpack_data->avr_plcb >> 8;
-	for (;;) {
-		distance = unpack_data->chsetb[distance_place & 0xff];
-		new_distance_place = unpack_data->ntoplb[distance++ & 0xff]++;
-		if (!(distance & 0xff)) {
-			corr_huff(unpack_data, unpack_data->chsetb, unpack_data->ntoplb);
-		} else {
-			break;
-		}
-	}
-	
-	unpack_data->chsetb[distance_place] = unpack_data->chsetb[new_distance_place];
-	unpack_data->chsetb[new_distance_place] = distance;
-	
-	distance = ((distance & 0xff00) | (rar_getbits(unpack_data) >> 8)) >> 1;
-	rar_addbits(unpack_data, 7);
-	
-	old_avr3 = unpack_data->avr_ln3;
-	if (length != 1 && length != 4) {
-		if (length==0 && distance <= unpack_data->max_dist3) {
-			unpack_data->avr_ln3++;
-			unpack_data->avr_ln3 -= unpack_data->avr_ln3 >> 8;
-		} else if (unpack_data->avr_ln3 > 0) {
-			unpack_data->avr_ln3--;
-		}
-	}
-	
-	length += 3;
-	
-	if (distance >= unpack_data->max_dist3) {
-		length++;
-	}
-	if (distance <= 256) {
-		length += 8;
-	}
-	if (old_avr3 > 0xb0 || (unpack_data->avr_plc >= 0x2a00 && old_avr2 < 0x40)) {
-		unpack_data->max_dist3 = 0x7f00;
-	} else {
-		unpack_data->max_dist3 = 0x2001;
-	}
-	unpack_data->old_dist[unpack_data->old_dist_ptr++] = distance;
-	unpack_data->old_dist_ptr = unpack_data->old_dist_ptr & 3;
-	unpack_data->last_length = length;
-	unpack_data->last_dist = distance;
-	copy_string15(unpack_data, distance, length);
-}
-
-int rar_unpack15(int fd, int solid, unpack_data_t *unpack_data)
-{
-	rar_unpack_init_data(solid, unpack_data);
-	unpack_init_data15(solid, unpack_data);
-	if (!rar_unp_read_buf(fd, unpack_data)) {
-		return FALSE;
-	}
-	if (!solid) {
-		init_huff(unpack_data);
-		unpack_data->unp_ptr = 0;
-	} else {
-		unpack_data->unp_ptr = unpack_data->wr_ptr;
-	}
-	--unpack_data->dest_unp_size;
-	
-	if (unpack_data->dest_unp_size >= 0) {
-		get_flag_buf(unpack_data);
-		unpack_data->flags_cnt = 8;
-	}
-	
-	while (unpack_data->dest_unp_size >= 0) {
-		unpack_data->unp_ptr &= MAXWINMASK;
-		
-		if (unpack_data->in_addr > unpack_data->read_top-30 &&
-				!rar_unp_read_buf(fd, unpack_data)) {
-			break;
-		}
-		
-		if (((unpack_data->wr_ptr - unpack_data->unp_ptr) & MAXWINMASK) < 270 &&
-				(unpack_data->wr_ptr != unpack_data->unp_ptr)) {
-			rar_unp_write_buf_old(unpack_data);
-		}
-		if (unpack_data->st_mode) {
-			huff_decode(unpack_data);
-			continue;
-		}
-		
-		if (--unpack_data->flags_cnt < 0) {
-			get_flag_buf(unpack_data);
-			unpack_data->flags_cnt = 7;
-		}
-		
-		if (unpack_data->flag_buf & 0x80) {
-			unpack_data->flag_buf <<= 1;
-			if (unpack_data->nlzb > unpack_data->nhfb) {
-				long_lz(unpack_data);
-			} else {
-				huff_decode(unpack_data);
-			}
-		} else {
-			unpack_data->flag_buf <<= 1;
-			if (--unpack_data->flags_cnt < 0) {
-				get_flag_buf(unpack_data);
-				unpack_data->flags_cnt = 7;
-			}
-			if (unpack_data->flag_buf & 0x80) {
-				unpack_data->flag_buf <<= 1;
-				if (unpack_data->nlzb > unpack_data->nhfb) {
-					huff_decode(unpack_data);
-				} else {
-					long_lz(unpack_data);
-				}
-			} else {
-				unpack_data->flag_buf <<= 1;
-				short_lz(unpack_data);
-			}
-		}
-	}
-	rar_unp_write_buf_old(unpack_data);
-	return TRUE;
-}
diff -ruN clamav-0.92.1~dfsg/libclamunrar/unrar15.h clamav-0.92.1~dfsg2/libclamunrar/unrar15.h
--- clamav-0.92.1~dfsg/libclamunrar/unrar15.h	2007-11-20 06:36:41.000000000 -0500
+++ clamav-0.92.1~dfsg2/libclamunrar/unrar15.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,23 +0,0 @@
-/*
- * Extract RAR archives
- *
- * Copyright (C) 2005-2006 trog@uncon.org
- *
- * This code is based on the work of Alexander L. Roshal (C)
- *
- * The unRAR sources may be used in any software to handle RAR
- * archives without limitations free of charge, but cannot be used
- * to re-create the RAR compression algorithm, which is proprietary.
- * Distribution of modified unRAR sources in separate form or as a
- * part of other software is permitted, provided that it is clearly
- * stated in the documentation and source comments that the code may
- * not be used to develop a RAR (WinRAR) compatible archiver.
- *
- */
-
-#ifndef UNRAR15_H
-#define UNRAR15_H 1
-
-int rar_unpack15(int fd, int solid, unpack_data_t *unpack_data);
-
-#endif
diff -ruN clamav-0.92.1~dfsg/libclamunrar/unrar20.c clamav-0.92.1~dfsg2/libclamunrar/unrar20.c
--- clamav-0.92.1~dfsg/libclamunrar/unrar20.c	2007-11-30 11:04:01.000000000 -0500
+++ clamav-0.92.1~dfsg2/libclamunrar/unrar20.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,404 +0,0 @@
-/*
- *  Extract RAR archives
- *
- *  Copyright (C) 2005 trog@uncon.org
- *
- *  This code is based on the work of Alexander L. Roshal (C)
- *
- *  The unRAR sources may be used in any software to handle RAR
- *  archives without limitations free of charge, but cannot be used
- *  to re-create the RAR compression algorithm, which is proprietary.
- *  Distribution of modified unRAR sources in separate form or as a
- *  part of other software is permitted, provided that it is clearly
- *  stated in the documentation and source comments that the code may
- *  not be used to develop a RAR (WinRAR) compatible archiver.
- *
- */
-
-#include <string.h>
-
-#include "libclamunrar/unrar.h"
-#include "libclamunrar/unrar20.h"
-
-#ifdef RAR_HIGH_DEBUG
-#define rar_dbgmsg printf
-#else
-static void rar_dbgmsg(const char* fmt,...){}
-#endif
-
-void unpack_init_data20(int solid, unpack_data_t *unpack_data)
-{
-	if (!solid) {
-		unpack_data->unp_channel_delta = 0;
-		unpack_data->unp_cur_channel = 0;
-		unpack_data->unp_channels = 1;
-		memset(unpack_data->audv, 0, sizeof(unpack_data->audv));
-		memset(unpack_data->unp_old_table20, 0, sizeof(unpack_data->unp_old_table20));
-	}
-}
-
-static void copy_string20(unpack_data_t *unpack_data, unsigned int length, unsigned int distance)
-{
-	unsigned int dest_ptr;
-	
-	unpack_data->last_dist = unpack_data->old_dist[unpack_data->old_dist_ptr++ & 3] = distance;
-	unpack_data->last_length = length;
-	unpack_data->dest_unp_size -= length;
-	
-	dest_ptr = unpack_data->unp_ptr - distance;
-	if (dest_ptr < MAXWINSIZE-300 && unpack_data->unp_ptr < MAXWINSIZE-300) {
-		unpack_data->window[unpack_data->unp_ptr++] = unpack_data->window[dest_ptr++];
-		unpack_data->window[unpack_data->unp_ptr++] = unpack_data->window[dest_ptr++];
-		while (length > 2) {
-			length--;
-			unpack_data->window[unpack_data->unp_ptr++] = unpack_data->window[dest_ptr++];
-		}
-	} else while (length--) {
-		unpack_data->window[unpack_data->unp_ptr] = unpack_data->window[dest_ptr++ & MAXWINMASK];
-		unpack_data->unp_ptr = (unpack_data->unp_ptr+1) & MAXWINMASK;
-	}
-}
-			
-static int read_tables20(int fd, unpack_data_t *unpack_data)
-{
-	unsigned char bit_length[BC20];
-	unsigned char table[MC20 * 4];
-	int table_size, n, i, number;
-	unsigned int bit_field;
-	
-	rar_dbgmsg("in read_tables20\n");
-	
-	if (unpack_data->in_addr > unpack_data->read_top-25) {
-		if (!rar_unp_read_buf(fd, unpack_data)) {
-			return FALSE;
-		}
-	}
-	bit_field = rar_getbits(unpack_data);
-	unpack_data->unp_audio_block = (bit_field & 0x8000);
-	
-	if (!(bit_field & 0x4000)) {
-		memset(unpack_data->unp_old_table20, 0, sizeof(unpack_data->unp_old_table20));
-	}
-	rar_addbits(unpack_data, 2);
-	
-	if (unpack_data->unp_audio_block) {
-		unpack_data->unp_channels = ((bit_field>>12) & 3) + 1;
-		if (unpack_data->unp_cur_channel >= unpack_data->unp_channels) {
-			unpack_data->unp_cur_channel = 0;
-		}
-		rar_addbits(unpack_data, 2);
-		table_size = MC20 * unpack_data->unp_channels;
-	} else {
-		table_size = NC20+DC20+RC20;
-	}
-	
-	for (i=0 ; i < BC20 ; i++) {
-		bit_length[i] = (unsigned char) (rar_getbits(unpack_data) >> 12);
-		rar_addbits(unpack_data, 4);
-	}
-	rar_make_decode_tables(bit_length, (struct Decode *)&unpack_data->BD, BC20);
-	i=0;
-	while (i < table_size) {
-		if (unpack_data->in_addr > unpack_data->read_top-5) {
-			if (!rar_unp_read_buf(fd, unpack_data)) {
-				return FALSE;
-			}
-		}
-		number = rar_decode_number(unpack_data, (struct Decode *)&unpack_data->BD);
-		if (number < 16) {
-			table[i] = (number + unpack_data->unp_old_table20[i]) & 0xf;
-			i++;
-		} else if (number == 16) {
-			n = (rar_getbits(unpack_data) >> 14) + 3;
-			rar_addbits(unpack_data, 2);
-			while ((n-- > 0) && (i < table_size)) {
-				table[i] = table[i-1];
-				i++;
-			}
-		} else {
-			if (number == 17) {
-				n = (rar_getbits(unpack_data) >> 13) + 3;
-				rar_addbits(unpack_data, 3);
-			} else {
-				n = (rar_getbits(unpack_data) >> 9) + 11;
-				rar_addbits(unpack_data, 7);
-			}
-			while ((n-- > 0) && (i < table_size)) {
-				table[i++] = 0;
-			}
-		}
-	}
-	if (unpack_data->in_addr > unpack_data->read_top) {
-		return TRUE;
-	}
-	if (unpack_data->unp_audio_block) {
-		for (i=0 ; i < unpack_data->unp_channels ; i++) {
-			rar_make_decode_tables(&table[i*MC20], (struct Decode *)&unpack_data->MD[i], MC20);
-		}
-	} else {
-		rar_make_decode_tables(&table[0], (struct Decode *)&unpack_data->LD, NC20);
-		rar_make_decode_tables(&table[NC20], (struct Decode *)&unpack_data->DD, DC20);
-		rar_make_decode_tables(&table[NC20+DC20], (struct Decode *)&unpack_data->RD, RC20);
-	}
-	memcpy(unpack_data->unp_old_table20, table, sizeof(unpack_data->unp_old_table20));
-	return TRUE;
-}
-
-static void read_last_tables(int fd, unpack_data_t *unpack_data)
-{
-	if (unpack_data->read_top >= unpack_data->in_addr+5) {
-		if (unpack_data->unp_audio_block) {
-			if (rar_decode_number(unpack_data,
-				(struct Decode *)&unpack_data->MD[unpack_data->unp_cur_channel]) == 256) {
-				read_tables20(fd, unpack_data);
-			}
-		} else if (rar_decode_number(unpack_data, (struct Decode *)&unpack_data->LD) == 269) {
-			read_tables20(fd, unpack_data);
-		}
-	}
-}
-
-static unsigned char decode_audio(unpack_data_t *unpack_data, int delta)
-{
-	struct AudioVariables *v;
-	int pch, d, i;
-	unsigned int ch, mindif, num_min_dif;
-	
-	v = &unpack_data->audv[unpack_data->unp_cur_channel];
-	v->byte_count++;
-	v->D4 = v->D3;
-	v->D3 = v->D2;
-	v->D2 = v->last_delta - v->D1;
-	v->D1 = v->last_delta;
-	
-	pch = 8 * v->last_char + v->K1 * v->D1 + v->K2 * v->D2 + v->K3 *
-		v->D3 + v->K4 * v->D4 + v->K5 * unpack_data->unp_channel_delta;
-	pch = (pch >> 3) & 0xff;
-	
-	ch = pch - delta;
-	
-	d = ((signed char) delta) << 3;
-	
-	v->dif[0] += abs(d);
-	v->dif[1] += abs(d - v->D1);
-	v->dif[2] += abs(d + v->D1);
-	v->dif[3] += abs(d - v->D2);
-	v->dif[4] += abs(d + v->D2);
-	v->dif[5] += abs(d - v->D3);
-	v->dif[6] += abs(d + v->D3);
-	v->dif[7] += abs(d - v->D4);
-	v->dif[8] += abs(d + v->D4);
-	v->dif[9] += abs(d - unpack_data->unp_channel_delta);
-	v->dif[10] += abs(d + unpack_data->unp_channel_delta);
-
-	unpack_data->unp_channel_delta = v->last_delta = (signed char) (ch - v->last_char);
-	v->last_char = ch;
-	
-	if ((v->byte_count & 0x1f) == 0) {
-		mindif = v->dif[0];
-		num_min_dif = 0;
-		v->dif[0] = 0;
-		for (i = 1 ; i < 11 ; i++) {
-			if (v->dif[i] < mindif) {
-				mindif = v->dif[i];
-				num_min_dif = i;
-			}
-			v->dif[i]=0; /* ?????? looks wrong to me */
-		}
-		switch(num_min_dif) {
-			case 1:
-				if (v->K1 >= -16) {
-					v->K1--;
-				}
-				break;
-			case 2:
-				if (v->K1 < 16) {
-					v->K1++;
-				}
-				break;
-			case 3:
-				if (v->K2 >= -16) {
-					v->K2--;
-				}
-				break;
-			case 4:
-				if (v->K2 < 16) {
-					v->K2++;
-				}
-				break;
-			case 5:
-				if (v->K3 >= -16) {
-					v->K3--;
-				}
-				break;
-			case 6:
-				if (v->K3 < 16) {
-					v->K3++;
-				}
-				break;
-			case 7:
-				if (v->K4 >= -16) {
-					v->K4--;
-				}
-				break;
-			case 8:
-				if (v->K4 < 16) {
-					v->K4++;
-				}
-				break;
-			case 9:
-				if (v->K5 >= -16) {
-					v->K5--;
-				}
-				break;
-			case 10:
-				if (v->K5 < 16) {
-					v->K5++;
-				}
-				break;
-		}
-	}
-	return ((unsigned char) ch);
-}
-
-int rar_unpack20(int fd, int solid, unpack_data_t *unpack_data)
-{
-	unsigned char ldecode[]={0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,
-			32,40,48,56,64,80,96,112,128,160,192,224};
-	unsigned char lbits[]={0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5};
-	int ddecode[]={0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,
-			768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576,
-			32768U,49152U,65536,98304,131072,196608,262144,327680,393216,
-			458752,524288,589824,655360,720896,786432,851968,917504,983040};
-	unsigned char dbits[]={0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,
-			12,12,13,13,14,14,15,15,16,16,16,16,16,16,16,16,16,16,16,16,16,16};
-	unsigned char sddecode[]={0,4,8,16,32,64,128,192};
-	unsigned char sdbits[]={2,2,3,4,5,6,6,6};
-	unsigned int bits, distance;
-	int retval=TRUE, audio_number, number, length, dist_number, length_number;
-	
-	rar_dbgmsg("in rar_unpack20\n");
-
-	rar_unpack_init_data(solid, unpack_data);
-	if (!rar_unp_read_buf(fd, unpack_data)) {
-		rar_dbgmsg("rar_unp_read_buf 1 failed\n");
-		return FALSE;
-	}
-	if (!solid) {
-		if (!read_tables20(fd, unpack_data)) {
-			rar_dbgmsg("read_tables20 failed\n");
-			return FALSE;
-		}
-	}
-	--unpack_data->dest_unp_size;
-	
-	while (unpack_data->dest_unp_size >= 0) {
-		rar_dbgmsg("dest_unp_size = %ld\n", unpack_data->dest_unp_size);
-		unpack_data->unp_ptr &= MAXWINMASK;
-		
-		if (unpack_data->in_addr > unpack_data->read_top-30) {
-			if (!rar_unp_read_buf(fd, unpack_data)) {
-				rar_dbgmsg("rar_unp_read_buf 2 failed\n");
-				break;
-			}
-		}
-		if (((unpack_data->wr_ptr - unpack_data->unp_ptr) & MAXWINMASK) < 270 &&
-				(unpack_data->wr_ptr != unpack_data->unp_ptr)) {
-			rar_unp_write_buf_old(unpack_data);
-		}
-		if (unpack_data->unp_audio_block) {
-			audio_number = rar_decode_number(unpack_data,
-				(struct Decode *)&unpack_data->MD[unpack_data->unp_cur_channel]);
-			if (audio_number == 256) {
-				if (!read_tables20(fd, unpack_data)) {
-					retval = FALSE;
-					break;
-				}
-				continue;
-			}
-			unpack_data->window[unpack_data->unp_ptr++] =
-					decode_audio(unpack_data, audio_number);
-			if (++unpack_data->unp_cur_channel == unpack_data->unp_channels) {
-				unpack_data->unp_cur_channel = 0;
-			}
-			--unpack_data->dest_unp_size;
-			continue;
-		}
-		
-		number = rar_decode_number(unpack_data, (struct Decode *)&unpack_data->LD);
-		if (number < 256) {
-			unpack_data->window[unpack_data->unp_ptr++] = (unsigned char) number;
-			--unpack_data->dest_unp_size;
-			continue;
-		}
-		if (number > 269) {
-			length = ldecode[number-=270]+3;
-			if ((bits = lbits[number]) > 0) {
-				length += rar_getbits(unpack_data) >> (16-bits);
-				rar_addbits(unpack_data, bits);
-			}
-			
-			dist_number = rar_decode_number(unpack_data, (struct Decode *)&unpack_data->DD);
-			distance = ddecode[dist_number] + 1;
-			if ((bits = dbits[dist_number]) > 0) {
-				distance += rar_getbits(unpack_data)>>(16-bits);
-				rar_addbits(unpack_data, bits);
-			}
-			
-			if (distance >= 0x2000) {
-				length++;
-				if (distance >= 0x40000L) {
-					length++;
-				}
-			}
-			
-			copy_string20(unpack_data, length, distance);
-			continue;
-		}
-		if (number == 269) {
-			if (!read_tables20(fd, unpack_data)) {
-				retval = FALSE;
-				break;
-			}
-			continue;
-		}
-		if (number == 256) {
-			copy_string20(unpack_data, unpack_data->last_length, unpack_data->last_dist);
-			continue;
-		}
-		if (number < 261) {
-			distance = unpack_data->old_dist[(unpack_data->old_dist_ptr-(number-256)) & 3];
-			length_number = rar_decode_number(unpack_data, (struct Decode *)&unpack_data->RD);
-			length = ldecode[length_number]+2;
-			if ((bits = lbits[length_number]) > 0) {
-				length += rar_getbits(unpack_data) >> (16-bits);
-				rar_addbits(unpack_data, bits);
-			}
-			if (distance >= 0x101) {
-				length++;
-				if (distance >= 0x2000) {
-					length++;
-					if (distance >= 0x40000) {
-						length++;
-					}
-				}
-			}
-			copy_string20(unpack_data, length, distance);
-			continue;
-		}
-		if (number < 270) {
-			distance = sddecode[number-=261]+1;
-			if ((bits=sdbits[number]) > 0) {
-				distance += rar_getbits(unpack_data) >> (16-bits);
-				rar_addbits(unpack_data, bits);
-			}
-			copy_string20(unpack_data, 2, distance);
-			continue;
-		}
-	}
-	if (retval) {
-		read_last_tables(fd, unpack_data);
-		rar_unp_write_buf_old(unpack_data);
-	}
-	return retval;
-}
diff -ruN clamav-0.92.1~dfsg/libclamunrar/unrar20.h clamav-0.92.1~dfsg2/libclamunrar/unrar20.h
--- clamav-0.92.1~dfsg/libclamunrar/unrar20.h	2007-11-20 06:36:41.000000000 -0500
+++ clamav-0.92.1~dfsg2/libclamunrar/unrar20.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,31 +0,0 @@
-/*
- * Extract RAR archives
- *
- * Copyright (C) 2005-2006 trog@uncon.org
- *
- * This code is based on the work of Alexander L. Roshal (C)
- *
- * The unRAR sources may be used in any software to handle RAR
- * archives without limitations free of charge, but cannot be used
- * to re-create the RAR compression algorithm, which is proprietary.
- * Distribution of modified unRAR sources in separate form or as a
- * part of other software is permitted, provided that it is clearly
- * stated in the documentation and source comments that the code may
- * not be used to develop a RAR (WinRAR) compatible archiver.
- *
- */
-
-
-#ifndef UNRAR20_H
-#define UNRAR20_H 1
-
-#define BC20 19
-#define DC20 48
-#define RC20 28
-#define MC20 257
-#define NC20 298  /* alphabet = {0, 1, 2, ..., NC - 1} */
-
-void unpack_init_data20(int solid, unpack_data_t *unpack_data);
-int rar_unpack20(int fd, int solid, unpack_data_t *unpack_data);
-
-#endif
diff -ruN clamav-0.92.1~dfsg/libclamunrar/unrar.c clamav-0.92.1~dfsg2/libclamunrar/unrar.c
--- clamav-0.92.1~dfsg/libclamunrar/unrar.c	2008-01-28 15:35:38.000000000 -0500
+++ clamav-0.92.1~dfsg2/libclamunrar/unrar.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,1164 +0,0 @@
-/*
- *  Extract RAR archives
- *
- *  Copyright (C) 2005-2006 trog@uncon.org
- *
- *  This code is based on the work of Alexander L. Roshal (C)
- *
- *  The unRAR sources may be used in any software to handle RAR
- *  archives without limitations free of charge, but cannot be used
- *  to re-create the RAR compression algorithm, which is proprietary.
- *  Distribution of modified unRAR sources in separate form or as a
- *  part of other software is permitted, provided that it is clearly
- *  stated in the documentation and source comments that the code may
- *  not be used to develop a RAR (WinRAR) compatible archiver.
- *
- */
-
-#include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#include <errno.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "libclamunrar/unrar.h"
-#include "libclamunrar/unrarppm.h"
-#include "libclamunrar/unrarvm.h"
-#include "libclamunrar/unrarfilter.h"
-#include "libclamunrar/unrar20.h"
-#include "libclamunrar/unrar15.h"
-
-#define int64to32(x) ((unsigned int)(x))
-
-#ifdef RAR_HIGH_DEBUG
-#define rar_dbgmsg printf
-#else
-static void rar_dbgmsg(const char* fmt,...){}
-#endif
-
-static void dump_tables(unpack_data_t *unpack_data)
-{
-	int i;
-	
-	/* Dump LD table */
-	rar_dbgmsg("LD Table MaxNum=%d\n", unpack_data->LD.MaxNum);
-	rar_dbgmsg("\tDecodeLen:");
-	for (i=0 ; i < 16; i++) {
-		rar_dbgmsg(" %.8d", unpack_data->LD.DecodeLen[i]);
-	}
-	rar_dbgmsg("\n\tDecodePos:");
-	for (i=0 ; i < 16; i++) {
-		rar_dbgmsg(" %.8d", unpack_data->LD.DecodePos[i]);
-	}
-	rar_dbgmsg("\n\tDecodeNum:");
-	for (i=0 ; i < NC; i++) {
-		rar_dbgmsg(" %.8d", unpack_data->LD.DecodeNum[i]);
-	}
-	
-	
-	rar_dbgmsg("\nDD Table MaxNum=%d\n", unpack_data->DD.MaxNum);
-	rar_dbgmsg("\tDecodeLen:");
-	for (i=0 ; i < 16; i++) {
-		rar_dbgmsg(" %.8d", unpack_data->DD.DecodeLen[i]);
-	}
-	rar_dbgmsg("\n\tDecodePos:");
-	for (i=0 ; i < 16; i++) {
-		rar_dbgmsg(" %.8d", unpack_data->DD.DecodePos[i]);
-	}
-	rar_dbgmsg("\n\tDecodeNum:");
-	for (i=0 ; i < DC; i++) {
-		rar_dbgmsg(" %.8d", unpack_data->DD.DecodeNum[i]);
-	}
-	
-	rar_dbgmsg("\nLDD Table MaxNum=%d\n", unpack_data->LDD.MaxNum);
-	rar_dbgmsg("\tDecodeLen:");
-	for (i=0 ; i < 16; i++) {
-		rar_dbgmsg(" %.8d", unpack_data->LDD.DecodeLen[i]);
-	}
-	rar_dbgmsg("\n\tDecodePos:");
-	for (i=0 ; i < 16; i++) {
-		rar_dbgmsg(" %.8d", unpack_data->LDD.DecodePos[i]);
-	}
-	rar_dbgmsg("\n\tDecodeNum:");
-	for (i=0 ; i < LDC; i++) {
-		rar_dbgmsg(" %.8d", unpack_data->LDD.DecodeNum[i]);
-	}
-	
-	rar_dbgmsg("\nRD Table MaxNum=%d\n", unpack_data->RD.MaxNum);
-	rar_dbgmsg("\tDecodeLen:");
-	for (i=0 ; i < 16; i++) {
-		rar_dbgmsg(" %.8d", unpack_data->RD.DecodeLen[i]);
-	}
-	rar_dbgmsg("\n\tDecodePos:");
-	for (i=0 ; i < 16; i++) {
-		rar_dbgmsg(" %.8d", unpack_data->RD.DecodePos[i]);
-	}
-	rar_dbgmsg("\n\tDecodeNum:");
-	for (i=0 ; i < RC; i++) {
-		rar_dbgmsg(" %.8d", unpack_data->RD.DecodeNum[i]);
-	}
-	
-	rar_dbgmsg("\nBD Table MaxNum=%d\n", unpack_data->BD.MaxNum);
-	rar_dbgmsg("\tDecodeLen:");
-	for (i=0 ; i < 16; i++) {
-		rar_dbgmsg(" %.8d", unpack_data->BD.DecodeLen[i]);
-	}
-	rar_dbgmsg("\n\tDecodePos:");
-	for (i=0 ; i < 16; i++) {
-		rar_dbgmsg(" %.8d", unpack_data->BD.DecodePos[i]);
-	}
-	rar_dbgmsg("\n\tDecodeNum:");
-	for (i=0 ; i < BC; i++) {
-		rar_dbgmsg(" %.8d", unpack_data->BD.DecodeNum[i]);
-	}
-	rar_dbgmsg("\n");
-}
-
-static void insert_old_dist(unpack_data_t *unpack_data, unsigned int distance)
-{
-	unpack_data->old_dist[3] = unpack_data->old_dist[2];
-	unpack_data->old_dist[2] = unpack_data->old_dist[1];
-	unpack_data->old_dist[1] = unpack_data->old_dist[0];
-	unpack_data->old_dist[0] = distance;
-}
-
-static void insert_last_match(unpack_data_t *unpack_data, unsigned int length, unsigned int distance)
-{
-	unpack_data->last_dist = distance;
-	unpack_data->last_length = length;
-}
-
-static void copy_string(unpack_data_t *unpack_data, unsigned int length, unsigned int distance)
-{
-	unsigned int dest_ptr;
-	
-	dest_ptr = unpack_data->unp_ptr - distance;
-	if (dest_ptr < MAXWINSIZE-260 && unpack_data->unp_ptr < MAXWINSIZE - 260) {
-		unpack_data->window[unpack_data->unp_ptr++] = unpack_data->window[dest_ptr++];
-		while (--length > 0) {
-			unpack_data->window[unpack_data->unp_ptr++] = unpack_data->window[dest_ptr++];
-		}
-	} else {
-		while (length--) {
-			unpack_data->window[unpack_data->unp_ptr] =
-						unpack_data->window[dest_ptr++ & MAXWINMASK];
-			unpack_data->unp_ptr = (unpack_data->unp_ptr + 1) & MAXWINMASK;
-		}
-	}
-}
-
-void rar_addbits(unpack_data_t *unpack_data, int bits)
-{
-
-	/*rar_dbgmsg("rar_addbits: in_addr=%d in_bit=%d\n", unpack_data->in_addr, unpack_data->in_bit);*/
-	bits += unpack_data->in_bit;
-	unpack_data->in_addr += bits >> 3;
-	unpack_data->in_bit = bits & 7;
-}
-
-unsigned int rar_getbits(unpack_data_t *unpack_data)
-{
-	unsigned int bit_field;
-
-	/*rar_dbgmsg("rar_getbits: in_addr=%d in_bit=%d\n", unpack_data->in_addr, unpack_data->in_bit);*/
-	bit_field = (unsigned int) unpack_data->in_buf[unpack_data->in_addr] << 16;
-	bit_field |= (unsigned int) unpack_data->in_buf[unpack_data->in_addr+1] << 8;
-	bit_field |= (unsigned int) unpack_data->in_buf[unpack_data->in_addr+2];
-	bit_field >>= (8-unpack_data->in_bit);
-	/*rar_dbgmsg("rar_getbits return(%d)\n", BitField & 0xffff);*/
-	return(bit_field & 0xffff);
-}
-
-int rar_unp_read_buf(int fd, unpack_data_t *unpack_data)
-{
-	int data_size, retval;
-	unsigned int read_size;
-
-	data_size = unpack_data->read_top - unpack_data->in_addr;
-	if (data_size < 0) {
-		return FALSE;
-	}
-	
-	/* Is buffer read pos more than half way? */
-	if (unpack_data->in_addr > MAX_BUF_SIZE/2) {
-		if (data_size > 0) {
-			memmove(unpack_data->in_buf, unpack_data->in_buf+unpack_data->in_addr,
-					data_size);
-		}
-		unpack_data->in_addr = 0;
-		unpack_data->read_top = data_size;
-	} else {
-		data_size = unpack_data->read_top;
-	}
-	/* RAR2 depends on us only reading upto the end of the current compressed file */
-	if (unpack_data->pack_size < ((MAX_BUF_SIZE-data_size)&~0xf)) {
-		read_size = unpack_data->pack_size;
-	} else {
-		read_size = (MAX_BUF_SIZE-data_size)&~0xf;
-	}
-	retval = read(fd, unpack_data->in_buf+data_size, read_size);	
-	if (retval > 0) {
-		unpack_data->read_top += retval;
-		unpack_data->pack_size -= retval;
-	}
-	unpack_data->read_border = unpack_data->read_top - 30;
-	if(unpack_data->read_border < unpack_data->in_addr) {
-		const ssize_t fill = ((unpack_data->read_top + 30) < MAX_BUF_SIZE) ? 30 : (MAX_BUF_SIZE - unpack_data->read_top);
-		if(fill)
-			memset(unpack_data->in_buf + unpack_data->read_top, 0, fill);
-	}
-	return (retval!=-1);
-}
-
-unsigned int rar_get_char(int fd, unpack_data_t *unpack_data)
-{
-	if (unpack_data->in_addr > MAX_BUF_SIZE-30) {
-		if (!rar_unp_read_buf(fd, unpack_data)) {
-			rar_dbgmsg("rar_get_char: rar_unp_read_buf FAILED\n"); /* FIXME: cli_errmsg */
-			return -1;
-		}
-	}
-	rar_dbgmsg("rar_get_char = %u\n", unpack_data->in_buf[unpack_data->in_addr]);
-	return(unpack_data->in_buf[unpack_data->in_addr++]);
-}
-
-static void unp_write_data(unpack_data_t *unpack_data, uint8_t *data, int size)
-{
-	rar_dbgmsg("in unp_write_data length=%d\n", size);
-	write(unpack_data->ofd, data, size);
-	unpack_data->written_size += size;
-	unpack_data->unp_crc = rar_crc(unpack_data->unp_crc, data, size);
-}
-
-static void unp_write_area(unpack_data_t *unpack_data, unsigned int start_ptr, unsigned int end_ptr)
-{
-	if (end_ptr < start_ptr) {
-		unp_write_data(unpack_data, &unpack_data->window[start_ptr], -start_ptr & MAXWINMASK);
-		unp_write_data(unpack_data, unpack_data->window, end_ptr);
-	} else {
-		unp_write_data(unpack_data, &unpack_data->window[start_ptr], end_ptr-start_ptr);
-	}
-}
-
-void rar_unp_write_buf_old(unpack_data_t *unpack_data)
-{
-	rar_dbgmsg("in rar_unp_write_buf_old\n");
-	if (unpack_data->unp_ptr < unpack_data->wr_ptr) {
-		unp_write_data(unpack_data, &unpack_data->window[unpack_data->wr_ptr],
-				-unpack_data->wr_ptr & MAXWINMASK);
-		unp_write_data(unpack_data, unpack_data->window, unpack_data->unp_ptr);
-	} else {
-		unp_write_data(unpack_data, &unpack_data->window[unpack_data->wr_ptr],
-				unpack_data->unp_ptr - unpack_data->wr_ptr);
-	}
-	unpack_data->wr_ptr = unpack_data->unp_ptr;
-}
-
-static void execute_code(unpack_data_t *unpack_data, struct rarvm_prepared_program *prg)
-{
-	rar_dbgmsg("in execute_code\n");
-	rar_dbgmsg("global_size: %ld\n", prg->global_size);
-	if (prg->global_size > 0) {
-		prg->init_r[6] = int64to32(unpack_data->written_size);
-		rarvm_set_value(FALSE, (unsigned int *)&prg->global_data[0x24],
-				int64to32(unpack_data->written_size));
-		rarvm_set_value(FALSE, (unsigned int *)&prg->global_data[0x28],
-				int64to32(unpack_data->written_size>>32));
-		rarvm_execute(&unpack_data->rarvm_data, prg);
-	}
-}
-
-		
-static void unp_write_buf(unpack_data_t *unpack_data)
-{
-	unsigned int written_border, part_length, filtered_size;
-	unsigned int write_size, block_start, block_length, block_end;
-	struct UnpackFilter *flt, *next_filter;
-	struct rarvm_prepared_program *prg, *next_prg;
-	uint8_t *filtered_data;
-	int i, j;
-	
-	rar_dbgmsg("in unp_write_buf\n");
-	written_border = unpack_data->wr_ptr;
-	write_size = (unpack_data->unp_ptr - written_border) & MAXWINMASK;
-	for (i=0 ; i < unpack_data->PrgStack.num_items ; i++) {
-		flt = unpack_data->PrgStack.array[i];
-		if (flt == NULL) {
-			continue;
-		}
-		if (flt->next_window) {
-			flt->next_window = FALSE;
-			continue;
-		}
-		block_start = flt->block_start;
-		block_length = flt->block_length;
-		if (((block_start-written_border)&MAXWINMASK) < write_size) {
-			if (written_border != block_start) {
-				unp_write_area(unpack_data, written_border, block_start);
-				written_border = block_start;
-				write_size = (unpack_data->unp_ptr - written_border) & MAXWINMASK;
-			}
-			if (block_length <= write_size) {
-				block_end = (block_start + block_length) & MAXWINMASK;
-				if (block_start < block_end || block_end==0) {
-					rarvm_set_memory(&unpack_data->rarvm_data, 0,
-							unpack_data->window+block_start, block_length);
-				} else {
-					part_length = MAXWINMASK - block_start;
-					rarvm_set_memory(&unpack_data->rarvm_data, 0,
-							unpack_data->window+block_start, part_length);
-					rarvm_set_memory(&unpack_data->rarvm_data, part_length,
-							unpack_data->window, block_end);
-				}
-				prg = &flt->prg;
-				execute_code(unpack_data, prg);
-				
-				filtered_data = prg->filtered_data;
-				filtered_size = prg->filtered_data_size;
-				
-				rar_filter_delete(unpack_data->PrgStack.array[i]);
-				unpack_data->PrgStack.array[i] = NULL;
-				while (i+1 < unpack_data->PrgStack.num_items) {
-					next_filter = unpack_data->PrgStack.array[i+1];
-					if (next_filter==NULL ||
-							next_filter->block_start!=block_start ||
-							next_filter->block_length!=filtered_size ||
-							next_filter->next_window) {
-						break;
-					}
-					rarvm_set_memory(&unpack_data->rarvm_data, 0,
-							filtered_data, filtered_size);
-					next_prg = &unpack_data->PrgStack.array[i+1]->prg;
-					execute_code(unpack_data, next_prg);
-					filtered_data = next_prg->filtered_data;
-					filtered_size = next_prg->filtered_data_size;
-					i++;
-					rar_filter_delete(unpack_data->PrgStack.array[i]);
-					unpack_data->PrgStack.array[i] = NULL;
-				}
-				unp_write_data(unpack_data, filtered_data, filtered_size);
-				written_border = block_end;
-				write_size = (unpack_data->unp_ptr - written_border) & MAXWINMASK;
-			} else {
-				for (j=i ; j < unpack_data->PrgStack.num_items ; j++) {
-					flt = unpack_data->PrgStack.array[j];
-					if (flt != NULL && flt->next_window) {
-						flt->next_window = FALSE;
-					}
-				}
-				unpack_data->wr_ptr = written_border;
-				return;
-				
-			}
-		}
-	}
-	unp_write_area(unpack_data, written_border, unpack_data->unp_ptr);
-	unpack_data->wr_ptr = unpack_data->unp_ptr;
-}
-
-void rar_make_decode_tables(unsigned char *len_tab, struct Decode *decode, int size)
-{
-	int len_count[16], tmp_pos[16], i;
-	long m,n;
-	
-	memset(len_count, 0, sizeof(len_count));
-	memset(decode->DecodeNum,0,size*sizeof(*decode->DecodeNum));
-	for (i=0 ; i < size ; i++) {
-		len_count[len_tab[i] & 0x0f]++;
-	}
-	
-	len_count[0]=0;
-	for (tmp_pos[0]=decode->DecodePos[0]=decode->DecodeLen[0]=0,n=0,i=1;i<16;i++) {
-		n=2*(n+len_count[i]);
-		m=n<<(15-i);
-		if (m>0xFFFF) {
-			m=0xFFFF;
-		}
-		decode->DecodeLen[i]=(unsigned int)m;
-		tmp_pos[i]=decode->DecodePos[i]=decode->DecodePos[i-1]+len_count[i-1];
-	}
-	
-	for (i=0;i<size;i++) {
-		if (len_tab[i]!=0) {
-			decode->DecodeNum[tmp_pos[len_tab[i] & 0x0f]++]=i;
-		}
-	}
-	decode->MaxNum=size;
-}
-
-int rar_decode_number(unpack_data_t *unpack_data, struct Decode *decode)
-{
-	unsigned int bits, bit_field, n;
-	
-	bit_field = rar_getbits(unpack_data) & 0xfffe;
-	rar_dbgmsg("rar_decode_number BitField=%u\n", bit_field);
-	if (bit_field < decode->DecodeLen[8])
-		if (bit_field < decode->DecodeLen[4])
-			if (bit_field < decode->DecodeLen[2])
-				if (bit_field < decode->DecodeLen[1])
-					bits=1;
-				else
-					bits=2;
-			else
-				if (bit_field < decode->DecodeLen[3])
-					bits=3;
-				else
-					bits=4;
-		else
-			if (bit_field < decode->DecodeLen[6])
-				if (bit_field < decode->DecodeLen[5])
-					bits=5;
-				else
-					bits=6;
-			else
-				if (bit_field < decode->DecodeLen[7])
-					bits=7;
-				else
-					bits=8;
-	else
-		if (bit_field < decode->DecodeLen[12])
-			if (bit_field < decode->DecodeLen[10])
-				if (bit_field < decode->DecodeLen[9])
-					bits=9;
-				else
-					bits=10;
-			else
-				if (bit_field < decode->DecodeLen[11])
-					bits=11;
-				else
-					bits=12;
-		else
-			if (bit_field < decode->DecodeLen[14])
-				if (bit_field < decode->DecodeLen[13])
-					bits=13;
-				else
-					bits=14;
-			else
-				bits=15;
-
-	rar_dbgmsg("rar_decode_number: bits=%d\n", bits);
-
-	rar_addbits(unpack_data, bits);
-	n=decode->DecodePos[bits]+((bit_field-decode->DecodeLen[bits-1])>>(16-bits));
-	if (n >= decode->MaxNum) {
-		n=0;
-	}
-	/*rar_dbgmsg("rar_decode_number return(%d)\n", decode->DecodeNum[n]);*/
-
-	return(decode->DecodeNum[n]);
-}
-
-static int read_tables(int fd, unpack_data_t *unpack_data)
-{
-	uint8_t bit_length[BC];
-	unsigned char table[HUFF_TABLE_SIZE];
-	unsigned int bit_field;
-	int i, length, zero_count, number, n;
-	const int table_size=HUFF_TABLE_SIZE;
-	
-	rar_dbgmsg("in read_tables Offset=%ld in_addr=%d read_top=%d\n", lseek(fd, 0, SEEK_CUR),
-				unpack_data->in_addr, unpack_data->read_top);
-	if (unpack_data->in_addr > unpack_data->read_top-25) {
-		if (!rar_unp_read_buf(fd, unpack_data)) {
-			rar_dbgmsg("ERROR: read_tables rar_unp_read_buf failed\n");
-			return FALSE;
-		}
-	}
-	rar_addbits(unpack_data, (8-unpack_data->in_bit) & 7);
-	bit_field = rar_getbits(unpack_data);
-	rar_dbgmsg("BitField = 0x%x\n", bit_field);
-	if (bit_field & 0x8000) {
-		unpack_data->unp_block_type = BLOCK_PPM;
-		rar_dbgmsg("Calling ppm_decode_init\n");
-		if(!ppm_decode_init(&unpack_data->ppm_data, fd, unpack_data, &unpack_data->ppm_esc_char)) {
-		    rar_dbgmsg("unrar: read_tables: ppm_decode_init failed\n");
-		    return FALSE;
-		}
-		return(TRUE);
-	}
-	unpack_data->unp_block_type = BLOCK_LZ;
-	unpack_data->prev_low_dist = 0;
-	unpack_data->low_dist_rep_count = 0;
-
-	if (!(bit_field & 0x4000)) {
-		memset(unpack_data->unp_old_table, 0, sizeof(unpack_data->unp_old_table));
-	}
-	rar_addbits(unpack_data, 2);
-	
-	for (i=0 ; i < BC ; i++) {
-		length = (uint8_t)(rar_getbits(unpack_data) >> 12);
-		rar_addbits(unpack_data, 4);
-		if (length == 15) {
-			zero_count = (uint8_t)(rar_getbits(unpack_data) >> 12);
-			rar_addbits(unpack_data, 4);
-			if (zero_count == 0) {
-				bit_length[i] = 15;
-			} else {
-				zero_count += 2;
-				while (zero_count-- > 0 &&
-						i<sizeof(bit_length)/sizeof(bit_length[0])) {
-					bit_length[i++]=0;
-				}
-				i--;
-			}
-		} else {
-			bit_length[i] = length;
-		}
-	}
-	rar_make_decode_tables(bit_length,(struct Decode *)&unpack_data->BD,BC);
-	
-	for (i=0;i<table_size;) {
-		if (unpack_data->in_addr > unpack_data->read_top-5) {
-			if (!rar_unp_read_buf(fd, unpack_data)) {
-				rar_dbgmsg("ERROR: read_tables rar_unp_read_buf failed 2\n");
-				return FALSE;
-			}
-		}
-		number = rar_decode_number(unpack_data, (struct Decode *)&unpack_data->BD);
-		if (number < 16) {
-			table[i] = (number+unpack_data->unp_old_table[i]) & 0xf;
-			i++;
-		} else if (number < 18) {
-			if (number == 16) {
-				n = (rar_getbits(unpack_data) >> 13) + 3;
-				rar_addbits(unpack_data, 3);
-			} else {
-				n = (rar_getbits(unpack_data) >> 9) + 11;
-				rar_addbits(unpack_data, 7);
-			}
-			while (n-- > 0 && i < table_size) {
-				table[i] = table[i-1];
-				i++;
-			}
-		} else {
-			if (number == 18) {
-				n = (rar_getbits(unpack_data) >> 13) + 3;
-				rar_addbits(unpack_data, 3);
-			} else {
-				n = (rar_getbits(unpack_data) >> 9) + 11;
-				rar_addbits(unpack_data, 7);
-			}
-			while (n-- > 0 && i < table_size) {
-				table[i++] = 0;
-			}
-		}
-	}
-	unpack_data->tables_read = TRUE;
-	if (unpack_data->in_addr > unpack_data->read_top) {
-		rar_dbgmsg("ERROR: read_tables check failed\n");
-		return FALSE;
-	}
-	rar_make_decode_tables(&table[0], (struct Decode *)&unpack_data->LD,NC);
-	rar_make_decode_tables(&table[NC], (struct Decode *)&unpack_data->DD,DC);
-	rar_make_decode_tables(&table[NC+DC], (struct Decode *)&unpack_data->LDD,LDC);
-	rar_make_decode_tables(&table[NC+DC+LDC], (struct Decode *)&unpack_data->RD,RC);
-	memcpy(unpack_data->unp_old_table,table,sizeof(unpack_data->unp_old_table));
-	
-
-	/*dump_tables(unpack_data);*/
-	rar_dbgmsg("ReadTables finished\n");
-  	return TRUE;
-}
-
-static int read_end_of_block(int fd, unpack_data_t *unpack_data)
-{
-	unsigned int bit_field;
-	int new_table, new_file=FALSE;
-	
-	bit_field = rar_getbits(unpack_data);
-	if (bit_field & 0x8000) {
-		new_table = TRUE;
-		rar_addbits(unpack_data, 1);
-	} else {
-		new_file = TRUE;
-		new_table = (bit_field & 0x4000);
-		rar_addbits(unpack_data, 2);
-	}
-	unpack_data->tables_read = !new_table;
-	rar_dbgmsg("NewFile=%d NewTable=%d TablesRead=%d\n", new_file,
-			new_table, unpack_data->tables_read);
-	return !(new_file || (new_table && !read_tables(fd, unpack_data)));
-}
-
-void rar_init_filters(unpack_data_t *unpack_data)
-{	
-	if (unpack_data->old_filter_lengths) {
-		free(unpack_data->old_filter_lengths);
-		unpack_data->old_filter_lengths = NULL;
-	}
-	unpack_data->old_filter_lengths_size = 0;
-	unpack_data->last_filter = 0;
-	
-	rar_filter_array_reset(&unpack_data->Filters);
-	rar_filter_array_reset(&unpack_data->PrgStack);
-}
-
-static int add_vm_code(unpack_data_t *unpack_data, unsigned int first_byte,
-			unsigned char *vmcode, int code_size)
-{
-	rarvm_input_t rarvm_input;
-	unsigned int filter_pos, new_filter, block_start, init_mask, cur_size;
-	struct UnpackFilter *filter, *stack_filter;
-	int i, empty_count, stack_pos, vm_codesize, static_size, data_size;
-	unsigned char *vm_code, *global_data;
-	
-	rar_dbgmsg("in add_vm_code first_byte=0x%x code_size=%d\n", first_byte, code_size);
-	rarvm_input.in_buf = vmcode;
-	rarvm_input.buf_size = code_size;
-	rarvm_input.in_addr = 0;
-	rarvm_input.in_bit = 0;
-
-	if (first_byte & 0x80) {
-		filter_pos = rarvm_read_data(&rarvm_input);
-		if (filter_pos == 0) {
-			rar_init_filters(unpack_data);
-		} else {
-			filter_pos--;
-		}
-	} else {
-		filter_pos = unpack_data->last_filter;
-	}
-	rar_dbgmsg("filter_pos = %u\n", filter_pos);
-	if (filter_pos > unpack_data->Filters.num_items ||
-			filter_pos > unpack_data->old_filter_lengths_size) {
-		rar_dbgmsg("filter_pos check failed\n");
-		return FALSE;
-	}
-	unpack_data->last_filter = filter_pos;
-	new_filter = (filter_pos == unpack_data->Filters.num_items);
-	rar_dbgmsg("Filters.num_items=%d\n", unpack_data->Filters.num_items);
-	rar_dbgmsg("new_filter=%d\n", new_filter);
-	if (new_filter) {
-		if (!rar_filter_array_add(&unpack_data->Filters, 1)) {
-			rar_dbgmsg("rar_filter_array_add failed\n");
-			return FALSE;
-		}
-		unpack_data->Filters.array[unpack_data->Filters.num_items-1] =
-					filter = rar_filter_new();
-		if (!unpack_data->Filters.array[unpack_data->Filters.num_items-1]) {
-			rar_dbgmsg("rar_filter_new failed\n");
-			return FALSE;
-		}	
-		unpack_data->old_filter_lengths_size++;
-		unpack_data->old_filter_lengths = (int *) rar_realloc2(unpack_data->old_filter_lengths,
-				sizeof(int) * unpack_data->old_filter_lengths_size);
-		if(!unpack_data->old_filter_lengths) {
-		    rar_dbgmsg("unrar: add_vm_code: rar_realloc2 failed for unpack_data->old_filter_lengths\n");
-		    return FALSE;
-		}
-		unpack_data->old_filter_lengths[unpack_data->old_filter_lengths_size-1] = 0;
-		filter->exec_count = 0;
-	} else {
-		filter = unpack_data->Filters.array[filter_pos];
-		filter->exec_count++;
-	}
-	
-	stack_filter = rar_filter_new();
-
-	empty_count = 0;
-	for (i=0 ; i < unpack_data->PrgStack.num_items; i++) {
-		unpack_data->PrgStack.array[i-empty_count] = unpack_data->PrgStack.array[i];
-		if (unpack_data->PrgStack.array[i] == NULL) {
-			empty_count++;
-		}
-		if (empty_count > 0) {
-			unpack_data->PrgStack.array[i] = NULL;
-		}
-	}
-	
-	if (empty_count == 0) {
-		rar_filter_array_add(&unpack_data->PrgStack, 1);
-		empty_count = 1;
-	}
-	stack_pos = unpack_data->PrgStack.num_items - empty_count;
-	unpack_data->PrgStack.array[stack_pos] = stack_filter;
-	stack_filter->exec_count = filter->exec_count;
-	
-	block_start = rarvm_read_data(&rarvm_input);
-	rar_dbgmsg("block_start=%u\n", block_start);
-	if (first_byte & 0x40) {
-		block_start += 258;
-	}
-	stack_filter->block_start = (block_start + unpack_data->unp_ptr) & MAXWINMASK;
-	if (first_byte & 0x20) {
-		stack_filter->block_length = rarvm_read_data(&rarvm_input);
-	} else {
-		stack_filter->block_length = filter_pos < unpack_data->old_filter_lengths_size ?
-				unpack_data->old_filter_lengths[filter_pos] : 0;
-	}
-	rar_dbgmsg("block_length=%u\n", stack_filter->block_length);
-	stack_filter->next_window = unpack_data->wr_ptr != unpack_data->unp_ptr &&
-		((unpack_data->wr_ptr - unpack_data->unp_ptr) & MAXWINMASK) <= block_start;
-		
-	unpack_data->old_filter_lengths[filter_pos] = stack_filter->block_length;
-	
-	memset(stack_filter->prg.init_r, 0, sizeof(stack_filter->prg.init_r));
-	stack_filter->prg.init_r[3] = VM_GLOBALMEMADDR;
-	stack_filter->prg.init_r[4] = stack_filter->block_length;
-	stack_filter->prg.init_r[5] = stack_filter->exec_count;
-	if (first_byte & 0x10) {
-		init_mask = rarvm_getbits(&rarvm_input) >> 9;
-		rarvm_addbits(&rarvm_input, 7);
-		for (i=0 ; i<7 ; i++) {
-			if (init_mask & (1<<i)) {
-				stack_filter->prg.init_r[i] =
-					rarvm_read_data(&rarvm_input);
-				rar_dbgmsg("prg.init_r[%d] = %u\n", i, stack_filter->prg.init_r[i]);
-			}
-		}
-	}
-	if (new_filter) {
-		vm_codesize = rarvm_read_data(&rarvm_input);
-		if (vm_codesize >= 0x1000 || vm_codesize == 0 || (vm_codesize > rarvm_input.buf_size)) {
-			rar_dbgmsg("ERROR: vm_codesize=0x%x buf_size=0x%x\n", vm_codesize, rarvm_input.buf_size);
-			return FALSE;
-		}
-		vm_code = (unsigned char *) rar_malloc(vm_codesize);
-		if(!vm_code) {
-		    rar_dbgmsg("unrar: add_vm_code: rar_malloc failed for vm_code\n");
-		    return FALSE;
-		}
-		for (i=0 ; i < vm_codesize ; i++) {
-			vm_code[i] = rarvm_getbits(&rarvm_input) >> 8;
-			rarvm_addbits(&rarvm_input, 8);
-		}
-		if(!rarvm_prepare(&unpack_data->rarvm_data, &rarvm_input, &vm_code[0], vm_codesize, &filter->prg)) {
-		    rar_dbgmsg("unrar: add_vm_code: rarvm_prepare failed\n");
-		    free(vm_code);
-		    return FALSE;
-		}
-		free(vm_code);
-	}
-	stack_filter->prg.alt_cmd = &filter->prg.cmd.array[0];
-	stack_filter->prg.cmd_count = filter->prg.cmd_count;
-	
-	static_size = filter->prg.static_size;
-	if (static_size > 0 && static_size < VM_GLOBALMEMSIZE) {
-		stack_filter->prg.static_data = rar_malloc(static_size);
-		if(!stack_filter->prg.static_data) {
-		    rar_dbgmsg("unrar: add_vm_code: rar_malloc failed for stack_filter->prg.static_data\n");
-		    return FALSE;
-		}
-		memcpy(stack_filter->prg.static_data, filter->prg.static_data, static_size);
-	}
-	
-	if (stack_filter->prg.global_size < VM_FIXEDGLOBALSIZE) {
-		free(stack_filter->prg.global_data);
-		stack_filter->prg.global_data = rar_malloc(VM_FIXEDGLOBALSIZE);
-		if(!stack_filter->prg.global_data) {
-		    rar_dbgmsg("unrar: add_vm_code: rar_malloc failed for stack_filter->prg.global_data\n");
-		    return FALSE;
-		}
-		memset(stack_filter->prg.global_data, 0, VM_FIXEDGLOBALSIZE);
-		stack_filter->prg.global_size = VM_FIXEDGLOBALSIZE;
-	}
-	global_data = &stack_filter->prg.global_data[0];
-	for (i=0 ; i<7 ; i++) {
-		rar_dbgmsg("init_r[%d]=%u\n", i, stack_filter->prg.init_r[i]);
-		rarvm_set_value(FALSE, (unsigned int *)&global_data[i*4],
-				stack_filter->prg.init_r[i]);
-	}
-	rarvm_set_value(FALSE, (unsigned int *)&global_data[0x1c], stack_filter->block_length);
-	rarvm_set_value(FALSE, (unsigned int *)&global_data[0x20], 0);
-	rarvm_set_value(FALSE, (unsigned int *)&global_data[0x2c], stack_filter->exec_count);
-	memset(&global_data[0x30], 0, 16);
-	for (i=0 ; i< 30 ; i++) {
-		rar_dbgmsg("global_data[%d] = %d\n", i, global_data[i]);
-	}
-	if (first_byte & 8) {
-		data_size = rarvm_read_data(&rarvm_input);
-		if (data_size >= 0x10000) {
-			return FALSE;
-		}
-		cur_size = stack_filter->prg.global_size;
-		if (cur_size < data_size+VM_FIXEDGLOBALSIZE) {
-			stack_filter->prg.global_size += data_size+VM_FIXEDGLOBALSIZE-cur_size;
-			stack_filter->prg.global_data = rar_realloc2(stack_filter->prg.global_data,
-				stack_filter->prg.global_size);
-			if(!stack_filter->prg.global_data) {
-			    rar_dbgmsg("unrar: add_vm_code: rar_realloc2 failed for stack_filter->prg.global_data\n");
-			    return FALSE;
-			}
-		}
-		global_data = &stack_filter->prg.global_data[VM_FIXEDGLOBALSIZE];
-		for (i=0 ; i< data_size ; i++) {
-			if ((rarvm_input.in_addr+2) > rarvm_input.buf_size) {
-				rar_dbgmsg("Buffer truncated\n");
-				return FALSE;
-			}
-			global_data[i] = rarvm_getbits(&rarvm_input) >> 8;
-			rar_dbgmsg("global_data[%d] = %d\n", i, global_data[i]);
-			rarvm_addbits(&rarvm_input, 8);
-		}
-	}
-	return TRUE;
-}
-
-static int read_vm_code(unpack_data_t *unpack_data, int fd)
-{
-	unsigned int first_byte;
-	int length, i, retval;
-	unsigned char *vmcode;
-	
-	first_byte = rar_getbits(unpack_data)>>8;
-	rar_addbits(unpack_data, 8);
-	length = (first_byte & 7) + 1;
-	if (length == 7) {
-		length = (rar_getbits(unpack_data) >> 8) + 7;
-		rar_addbits(unpack_data, 8);
-	} else if (length == 8) {
-		length = rar_getbits(unpack_data);
-		rar_addbits(unpack_data, 16);
-	}
-	vmcode = (unsigned char *) rar_malloc(length + 2);
-	rar_dbgmsg("VM code length: %d\n", length);
-	if (!vmcode) {
-		return FALSE;
-	}
-	for (i=0 ; i < length ; i++) {
-		if (unpack_data->in_addr >= unpack_data->read_top-1 &&
-				!rar_unp_read_buf(fd, unpack_data) && i<length-1) {
-			return FALSE;
-		}
-		vmcode[i] = rar_getbits(unpack_data) >> 8;
-		rar_addbits(unpack_data, 8);
-	}
-	retval = add_vm_code(unpack_data, first_byte, vmcode, length);
-	free(vmcode);
-	return retval;
-}
-
-static int read_vm_code_PPM(unpack_data_t *unpack_data, int fd)
-{
-	unsigned int first_byte;
-	int length, i, ch, retval, b1, b2;
-	unsigned char *vmcode;
-	
-	first_byte = ppm_decode_char(&unpack_data->ppm_data, fd, unpack_data);
-	if ((int)first_byte == -1) {
-		return FALSE;
-	}
-	length = (first_byte & 7) + 1;
-	if (length == 7) {
-		b1 = ppm_decode_char(&unpack_data->ppm_data, fd, unpack_data);
-		if (b1 == -1) {
-			return FALSE;
-		}
-		length = b1 + 7;
-	} else if (length == 8) {
-		b1 = ppm_decode_char(&unpack_data->ppm_data, fd, unpack_data);
-		if (b1 == -1) {
-			return FALSE;
-		}
-		b2 = ppm_decode_char(&unpack_data->ppm_data, fd, unpack_data);
-		if (b2 == -1) {
-			return FALSE;
-		}
-		length = b1*256 + b2;
-	}
-	vmcode = (unsigned char *) rar_malloc(length + 2);
-	rar_dbgmsg("VM PPM code length: %d\n", length);
-	if (!vmcode) {
-		return FALSE;
-	}
-	for (i=0 ; i < length ; i++) {
-		ch = ppm_decode_char(&unpack_data->ppm_data, fd, unpack_data);
-		if (ch == -1) {
-			free(vmcode);
-			return FALSE;
-		}
-		vmcode[i] = ch;
-	}
-	retval = add_vm_code(unpack_data, first_byte, vmcode, length);
-	free(vmcode);
-	return retval;
-}
-
-void rar_unpack_init_data(int solid, unpack_data_t *unpack_data)
-{
-	if (!solid) {
-		unpack_data->tables_read = FALSE;
-		memset(unpack_data->old_dist, 0, sizeof(unpack_data->old_dist));
-		unpack_data->old_dist_ptr= 0;
-		memset(unpack_data->unp_old_table, 0, sizeof(unpack_data->unp_old_table));
-		unpack_data->last_dist= 0;
-		unpack_data->last_length=0;
-		unpack_data->ppm_esc_char = 2;
-		unpack_data->unp_ptr = 0;
-		unpack_data->wr_ptr = 0;
-		rar_init_filters(unpack_data);
-	}
-	unpack_data->in_bit = 0;
-	unpack_data->in_addr = 0;
-	unpack_data->read_top = 0;
-	unpack_data->ppm_error = FALSE;
-	
-	unpack_data->written_size = 0;
-	rarvm_init(&unpack_data->rarvm_data);
-	unpack_data->unp_crc = 0xffffffff;
-	
-	unpack_init_data20(solid, unpack_data);
-
-}
-
-static int rar_unpack29(int fd, int solid, unpack_data_t *unpack_data)
-{
-	unsigned char ldecode[]={0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,
-			32,40,48,56,64,80,96,112,128,160,192,224};
-	unsigned char lbits[]=  {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5};
-	int ddecode[DC]={0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,
-		1536,2048,3072,4096,6144,8192,12288,16384,24576,32768,49152,65536,
-		98304,131072,196608,262144,327680,393216,458752,524288,589824,655360,
-		720896,786432,851968,917504,983040,1048576,1310720,1572864,
-		1835008,2097152,2359296,2621440,2883584,3145728,3407872,3670016,3932160};
-	uint8_t dbits[DC]= {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,
-		11,11,12,12,13,13,14,14,15,15,16,16,16,16,16,16,16,16,16,
-		16,16,16,16,16,18,18,18,18,18,18,18,18,18,18,18,18};
-	unsigned char sddecode[]={0,4,8,16,32,64,128,192};
-	unsigned char sdbits[]=  {2,2,3, 4, 5, 6,  6,  6};
-	unsigned int bits, distance;
-	int retval=TRUE, i, number, length, dist_number, low_dist, ch, next_ch;
-	int length_number, failed;
-
-	rar_dbgmsg("Offset: %ld\n", lseek(fd, 0, SEEK_CUR));
-	if (!solid) {
-		rar_dbgmsg("Not solid\n");
-	}
-	rar_unpack_init_data(solid, unpack_data);
-	if (!rar_unp_read_buf(fd, unpack_data)) {
-		return FALSE;
-	}
-	if (!solid || !unpack_data->tables_read) {
-		rar_dbgmsg("Read tables\n");
-		if (!read_tables(fd, unpack_data)) {
-			return FALSE;
-		}
-	}
-
-	rar_dbgmsg("init done\n");
-	while(1) {
-		unpack_data->unp_ptr &= MAXWINMASK;
-		rar_dbgmsg("UnpPtr = %d\n", unpack_data->unp_ptr);
-		if (unpack_data->in_addr > unpack_data->read_border) {
-			if (!rar_unp_read_buf(fd, unpack_data)) {
-				retval = FALSE;
-				break;
-			}
-		}
-		if (((unpack_data->wr_ptr - unpack_data->unp_ptr) & MAXWINMASK) < 260 &&
-				unpack_data->wr_ptr != unpack_data->unp_ptr) {
-			unp_write_buf(unpack_data);
-		}
-		if (unpack_data->unp_block_type == BLOCK_PPM) {
-			ch = ppm_decode_char(&unpack_data->ppm_data, fd, unpack_data);
-			rar_dbgmsg("PPM char: %d\n", ch);
-			if (ch == -1) {
-				retval = FALSE;
-				unpack_data->ppm_error = TRUE;
-				break;
-			}
-			if (ch == unpack_data->ppm_esc_char) {
-				next_ch = ppm_decode_char(&unpack_data->ppm_data,
-							fd, unpack_data);
-				rar_dbgmsg("PPM next char: %d\n", next_ch);
-				if (next_ch == -1) {
-					retval = FALSE;
-					unpack_data->ppm_error = TRUE;
-					break;
-				}
-				if (next_ch == 0) {
-					if (!read_tables(fd, unpack_data)) {
-						retval = FALSE;
-						break;
-					}
-					continue;
-				}
-				if (next_ch == 2 || next_ch == -1) {
-					break;
-				}
-				if (next_ch == 3) {
-					if (!read_vm_code_PPM(unpack_data, fd)) {
-						retval = FALSE;
-						break;
-					}
-					continue;
-				}
-				if (next_ch == 4) {
-					unsigned int length;
-					distance = 0;
-					failed = FALSE;
-					for (i=0 ; i < 4 && !failed; i++) {
-						ch = ppm_decode_char(&unpack_data->ppm_data,
-								fd, unpack_data);
-						if (ch == -1) {
-							failed = TRUE;
-						} else {
-							if (i==3) {
-								length = (uint8_t)ch;
-							} else {
-								distance = (distance << 8) +
-										(uint8_t)ch;
-							}
-						}
-					}
-					if (failed) {
-						retval = FALSE;
-						break;
-					}
-					copy_string(unpack_data, length+32, distance+2);
-					continue;
-				}
-				if (next_ch == 5) {
-					int length = ppm_decode_char(&unpack_data->ppm_data,
-								fd, unpack_data);
-					rar_dbgmsg("PPM length: %d\n", length);
-					if (length == -1) {
-						retval = FALSE;
-						break;
-					}
-					copy_string(unpack_data, length+4, 1);
-					continue;
-				}
-			}
-			unpack_data->window[unpack_data->unp_ptr++] = ch;
-			continue;
-		} else {
-			number = rar_decode_number(unpack_data, (struct Decode *)&unpack_data->LD);
-			rar_dbgmsg("number = %d\n", number);
-			if (number < 256) {
-				unpack_data->window[unpack_data->unp_ptr++] = (uint8_t) number;
-				continue;
-			}
-			if (number >= 271) {
-				length = ldecode[number-=271]+3;
-				if ((bits=lbits[number]) > 0) {
-					length += rar_getbits(unpack_data) >> (16-bits);
-					rar_addbits(unpack_data, bits);
-				}
-				dist_number = rar_decode_number(unpack_data,
-							(struct Decode *)&unpack_data->DD);
-				distance = ddecode[dist_number] + 1;
-				if ((bits = dbits[dist_number]) > 0) {
-					if (dist_number > 9) {
-						if (bits > 4) {
-							distance += ((rar_getbits(unpack_data) >>
-									(20-bits)) << 4);
-							rar_addbits(unpack_data, bits-4);
-						}
-						if (unpack_data->low_dist_rep_count > 0) {
-							unpack_data->low_dist_rep_count--;
-							distance += unpack_data->prev_low_dist;
-						} else {
-							low_dist = rar_decode_number(unpack_data,
-								(struct Decode *) &unpack_data->LDD);
-							if (low_dist == 16) {
-								unpack_data->low_dist_rep_count =
-									LOW_DIST_REP_COUNT-1;
-								distance += unpack_data->prev_low_dist;
-							} else {
-								distance += low_dist;
-								unpack_data->prev_low_dist = low_dist;
-							}
-						}
-					} else {
-						distance += rar_getbits(unpack_data) >> (16-bits);
-						rar_addbits(unpack_data, bits);
-					}
-				}
-				
-				if (distance >= 0x2000) {
-					length++;
-					if (distance >= 0x40000L) {
-						length++;
-					}
-				}
-				
-				insert_old_dist(unpack_data, distance);
-				insert_last_match(unpack_data, length, distance);
-				copy_string(unpack_data, length, distance);
-				continue;
-			}
-			if (number == 256) {
-				if (!read_end_of_block(fd, unpack_data)) {
-					break;
-				}
-				continue;
-			}
-			if (number == 257) {
-				if (!read_vm_code(unpack_data, fd)) {
-					retval = FALSE;
-					break;
-				}
-				continue;
-			}
-			if (number == 258) {
-				if (unpack_data->last_length != 0) {
-					copy_string(unpack_data, unpack_data->last_length,
-							unpack_data->last_dist);
-				}
-				continue;
-			}
-			if (number < 263) {
-				dist_number = number-259;
-				distance = unpack_data->old_dist[dist_number];
-				for (i=dist_number ; i > 0 ; i--) {
-					unpack_data->old_dist[i] = unpack_data->old_dist[i-1];
-				}
-				unpack_data->old_dist[0] = distance;
-				
-				length_number = rar_decode_number(unpack_data,
-							(struct Decode *)&unpack_data->RD);
-				length = ldecode[length_number]+2;
-				if ((bits = lbits[length_number]) > 0) {
-					length += rar_getbits(unpack_data) >> (16-bits);
-					rar_addbits(unpack_data, bits);
-				}
-				insert_last_match(unpack_data, length, distance);
-				copy_string(unpack_data, length, distance);
-				continue;
-			}
-			if (number < 272) {
-				distance = sddecode[number-=263]+1;
-				if ((bits = sdbits[number]) > 0) {
-					distance += rar_getbits(unpack_data) >> (16-bits);
-					rar_addbits(unpack_data, bits);
-				}
-				insert_old_dist(unpack_data, distance);
-				insert_last_match(unpack_data, 2, distance);
-				copy_string(unpack_data, 2, distance);
-				continue;
-			}
-	
-		}
-	}
-	if (retval) {
-		unp_write_buf(unpack_data);
-	}
-	rar_dbgmsg("Finished length: %ld\n", unpack_data->written_size);
-	return retval;
-}
-
-int rar_unpack(int fd, int method, int solid, unpack_data_t *unpack_data)
-{
-	int retval = FALSE;
-	switch(method) {
-	case 15:
-		retval = rar_unpack15(fd, solid, unpack_data);
-		break;
-	case 20:
-	case 26:
-		retval = rar_unpack20(fd, solid, unpack_data);
-		break;
-	case 29:
-		retval = rar_unpack29(fd, solid, unpack_data);
-		break;
-	default:
-		break;
-	}
-	return retval;
-}
diff -ruN clamav-0.92.1~dfsg/libclamunrar/unrarcmd.c clamav-0.92.1~dfsg2/libclamunrar/unrarcmd.c
--- clamav-0.92.1~dfsg/libclamunrar/unrarcmd.c	2007-11-21 08:53:11.000000000 -0500
+++ clamav-0.92.1~dfsg2/libclamunrar/unrarcmd.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,51 +0,0 @@
-/*
- *  Extract RAR archives
- *
- *  Copyright (C) 2005 trog@uncon.org
- *
- *  This code is based on the work of Alexander L. Roshal (C)
- *
- *  The unRAR sources may be used in any software to handle RAR
- *  archives without limitations free of charge, but cannot be used
- *  to re-create the RAR compression algorithm, which is proprietary.
- *  Distribution of modified unRAR sources in separate form or as a
- *  part of other software is permitted, provided that it is clearly
- *  stated in the documentation and source comments that the code may
- *  not be used to develop a RAR (WinRAR) compatible archiver.
- */
-
-#include <string.h>
-#include <stdlib.h>
-
-#include "libclamunrar/unrar.h"
-#include "libclamunrar/unrarcmd.h"
-
-void rar_cmd_array_init(rar_cmd_array_t *cmd_a)
-{
-	cmd_a->array = NULL;
-	cmd_a->num_items = 0;
-}
-
-void rar_cmd_array_reset(rar_cmd_array_t *cmd_a)
-{	
-	if (!cmd_a) {
-		return;
-	}
-	if (cmd_a->array) {
-		free(cmd_a->array);
-	}
-	cmd_a->array = NULL;
-	cmd_a->num_items = 0;
-}
-
-int rar_cmd_array_add(rar_cmd_array_t *cmd_a, int num)
-{
-	cmd_a->num_items += num;
-	cmd_a->array = (struct rarvm_prepared_command *) rar_realloc2(cmd_a->array,
-			cmd_a->num_items * sizeof(struct rarvm_prepared_command));
-	if (cmd_a->array == NULL) {
-		return FALSE;
-	}
-	memset(&cmd_a->array[cmd_a->num_items-1], 0, sizeof(struct rarvm_prepared_command));
-	return TRUE;
-}
diff -ruN clamav-0.92.1~dfsg/libclamunrar/unrarcmd.h clamav-0.92.1~dfsg2/libclamunrar/unrarcmd.h
--- clamav-0.92.1~dfsg/libclamunrar/unrarcmd.h	2007-11-21 08:53:20.000000000 -0500
+++ clamav-0.92.1~dfsg2/libclamunrar/unrarcmd.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,36 +0,0 @@
-/*
- * Extract RAR archives
- *
- * Copyright (C) 2005-2006 trog@uncon.org
- *
- * This code is based on the work of Alexander L. Roshal (C)
- *
- * The unRAR sources may be used in any software to handle RAR
- * archives without limitations free of charge, but cannot be used
- * to re-create the RAR compression algorithm, which is proprietary.
- * Distribution of modified unRAR sources in separate form or as a
- * part of other software is permitted, provided that it is clearly
- * stated in the documentation and source comments that the code may
- * not be used to develop a RAR (WinRAR) compatible archiver.
- *
- */
-
-
-#ifndef RAR_CMD_ARRAY_H
-#define RAR_CMD_ARRAY_H
-
-#include <stdlib.h>
-
-#include "libclamunrar/unrarvm.h"
-
-typedef struct rar_cmd_array_tag
-{
-	struct rarvm_prepared_command *array;
-	size_t num_items;
-} rar_cmd_array_t;
-
-void rar_cmd_array_init(rar_cmd_array_t *cmd_a);
-void rar_cmd_array_reset(rar_cmd_array_t *cmd_a);
-int rar_cmd_array_add(rar_cmd_array_t *cmd_a, int num);
-
-#endif
diff -ruN clamav-0.92.1~dfsg/libclamunrar/unrarfilter.c clamav-0.92.1~dfsg2/libclamunrar/unrarfilter.c
--- clamav-0.92.1~dfsg/libclamunrar/unrarfilter.c	2007-11-21 08:53:29.000000000 -0500
+++ clamav-0.92.1~dfsg2/libclamunrar/unrarfilter.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,99 +0,0 @@
-/*
- *  Extract RAR archives
- *
- *  Copyright (C) 2005 trog@uncon.org
- *
- *  This code is based on the work of Alexander L. Roshal (C)
- *
- *  The unRAR sources may be used in any software to handle RAR
- *  archives without limitations free of charge, but cannot be used
- *  to re-create the RAR compression algorithm, which is proprietary.
- *  Distribution of modified unRAR sources in separate form or as a
- *  part of other software is permitted, provided that it is clearly
- *  stated in the documentation and source comments that the code may
- *  not be used to develop a RAR (WinRAR) compatible archiver.
- */
-
-#if HAVE_CONFIG_H
-#include "clamav-config.h"
-#endif
-
-#ifdef	HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-
-#include "libclamunrar/unrar.h"
-#include "libclamunrar/unrarfilter.h"
-
-void rar_filter_array_init(rar_filter_array_t *filter_a)
-{
-	filter_a->array = NULL;
-	filter_a->num_items = 0;
-}
-
-void rar_filter_array_reset(rar_filter_array_t *filter_a)
-{
-	int i;
-	
-	if (!filter_a) {
-		return;
-	}
-	for (i=0 ; i < filter_a->num_items ; i++) {
-		rar_filter_delete(filter_a->array[i]);
-	}
-	if (filter_a->array) {
-		free(filter_a->array);
-	}
-	filter_a->array = NULL;
-	filter_a->num_items = 0;
-}
-
-int rar_filter_array_add(rar_filter_array_t *filter_a, int num)
-{
-	filter_a->num_items += num;
-	filter_a->array = (struct UnpackFilter **) rar_realloc2(filter_a->array,
-			filter_a->num_items * sizeof(struct UnpackFilter **));
-	if (filter_a->array == NULL) {
-		filter_a->num_items=0;
-		return FALSE;
-	}
-	filter_a->array[filter_a->num_items-1] = NULL;
-	return TRUE;
-}
-
-struct UnpackFilter *rar_filter_new(void)
-{
-	struct UnpackFilter *filter;
-	
-	filter = (struct UnpackFilter *) rar_malloc(sizeof(struct UnpackFilter));
-	if (!filter) {
-		return NULL;
-	}
-	filter->block_start = 0;
-  	filter->block_length = 0;
-  	filter->exec_count = 0;
-  	filter->next_window = 0;
-  	
-   	rar_cmd_array_init(&filter->prg.cmd);
-	filter->prg.global_data = NULL;
-	filter->prg.static_data = NULL;
-	filter->prg.global_size = filter->prg.static_size = 0;
-	filter->prg.filtered_data = NULL;
-	filter->prg.filtered_data_size = 0;
-  	return filter;
-}
-
-void rar_filter_delete(struct UnpackFilter *filter)
-{
-	if (!filter) {
-		return;
-	}
-	if (filter->prg.global_data) {
-		free(filter->prg.global_data);
-	}
-	if (filter->prg.static_data) {
-		free(filter->prg.static_data);
-	}
-	rar_cmd_array_reset(&filter->prg.cmd);
-	free(filter);
-}
diff -ruN clamav-0.92.1~dfsg/libclamunrar/unrarfilter.h clamav-0.92.1~dfsg2/libclamunrar/unrarfilter.h
--- clamav-0.92.1~dfsg/libclamunrar/unrarfilter.h	2007-11-20 06:36:41.000000000 -0500
+++ clamav-0.92.1~dfsg2/libclamunrar/unrarfilter.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,35 +0,0 @@
-/*
- * Extract RAR archives
- *
- * Copyright (C) 2005-2006 trog@uncon.org
- *
- * This code is based on the work of Alexander L. Roshal (C)
- *
- * The unRAR sources may be used in any software to handle RAR
- * archives without limitations free of charge, but cannot be used
- * to re-create the RAR compression algorithm, which is proprietary.
- * Distribution of modified unRAR sources in separate form or as a
- * part of other software is permitted, provided that it is clearly
- * stated in the documentation and source comments that the code may
- * not be used to develop a RAR (WinRAR) compatible archiver.
- *
- */
-
-
-#ifndef RAR_FILTER_ARRAY_H
-#define RAR_FILTER_ARRAY_H
-
-#include <stdlib.h>
-
-typedef struct rar_filter_array_tag
-{
-	struct UnpackFilter **array;
-	size_t num_items;
-} rar_filter_array_t;
-
-void rar_filter_array_init(rar_filter_array_t *filter_a);
-void rar_filter_array_reset(rar_filter_array_t *filter_a);
-int rar_filter_array_add(rar_filter_array_t *filter_a, int num);
-struct UnpackFilter *rar_filter_new(void);
-void rar_filter_delete(struct UnpackFilter *filter);
-#endif
diff -ruN clamav-0.92.1~dfsg/libclamunrar/unrar.h clamav-0.92.1~dfsg2/libclamunrar/unrar.h
--- clamav-0.92.1~dfsg/libclamunrar/unrar.h	2007-11-30 11:08:36.000000000 -0500
+++ clamav-0.92.1~dfsg2/libclamunrar/unrar.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,281 +0,0 @@
-/*
- * Extract RAR archives
- *
- * Copyright (C) 2005-2006 trog@uncon.org
- *
- * This code is based on the work of Alexander L. Roshal (C)
- *
- * The unRAR sources may be used in any software to handle RAR
- * archives without limitations free of charge, but cannot be used
- * to re-create the RAR compression algorithm, which is proprietary.
- * Distribution of modified unRAR sources in separate form or as a
- * part of other software is permitted, provided that it is clearly
- * stated in the documentation and source comments that the code may
- * not be used to develop a RAR (WinRAR) compatible archiver.
- *
- */
-
-#ifndef UNRAR_H
-#define UNRAR_H 1
-
-#if HAVE_CONFIG_H
-#include "clamav-config.h"
-#endif
-
-#include <sys/types.h>
-#ifdef	HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-
-struct unpack_data_tag;
-
-#include "libclamunrar/unrarhlp.h"
-#include "libclamunrar/unrarppm.h"
-#include "libclamunrar/unrarvm.h"
-#include "libclamunrar/unrarcmd.h"
-#include "libclamunrar/unrarfilter.h"
-
-#define FALSE (0)
-#define TRUE (1)
-#ifndef MIN
-#define MIN(a,b) ((a < b) ? a : b)
-#endif
-
-#define SIZEOF_MARKHEAD 7
-#define SIZEOF_NEWMHD 13
-#define SIZEOF_NEWLHD 32
-#define SIZEOF_SHORTBLOCKHEAD 7
-#define SIZEOF_LONGBLOCKHEAD 11
-#define SIZEOF_SUBBLOCKHEAD 14
-#define SIZEOF_COMMHEAD 13
-#define SIZEOF_PROTECTHEAD 26
-#define SIZEOF_AVHEAD 14
-#define SIZEOF_SIGNHEAD 15
-#define SIZEOF_UOHEAD 18
-#define SIZEOF_MACHEAD 22
-#define SIZEOF_EAHEAD 24
-#define SIZEOF_BEEAHEAD 24
-#define SIZEOF_STREAMHEAD 26
-
-#define MHD_VOLUME		0x0001
-#define MHD_COMMENT		0x0002
-#define MHD_LOCK		0x0004
-#define MHD_SOLID		0x0008
-#define MHD_PACK_COMMENT	0x0010
-#define MHD_NEWNUMBERING	0x0010
-#define MHD_AV			0x0020
-#define MHD_PROTECT		0x0040
-#define MHD_PASSWORD		0x0080
-#define MHD_FIRSTVOLUME		0x0100
-#define MHD_ENCRYPTVER		0x0200
-
-#define LHD_SPLIT_BEFORE	0x0001
-#define LHD_SPLIT_AFTER		0x0002
-#define LHD_PASSWORD		0x0004
-#define LHD_COMMENT		0x0008
-#define LHD_SOLID		0x0010
-
-#define LONG_BLOCK         0x8000
-
-#define NC                 299  /* alphabet = {0, 1, 2, ..., NC - 1} */
-#define DC                 60
-#define RC		    28
-#define LDC		    17
-#define BC		    20
-#define HUFF_TABLE_SIZE    (NC+DC+RC+LDC)
-
-#define MAX_BUF_SIZE        32768
-#define MAXWINSIZE          0x400000
-#define MAXWINMASK          (MAXWINSIZE-1)
-#define LOW_DIST_REP_COUNT  16
-
-typedef struct mark_header_tag
-{
-	unsigned char mark[SIZEOF_MARKHEAD];
-} mark_header_t;
-
-#ifndef HAVE_ATTRIB_PACKED
-#define __attribute__(x)
-#endif
-
-#ifdef HAVE_PRAGMA_PACK
-#pragma pack(1)
-#endif
-
-#ifdef HAVE_PRAGMA_PACK_HPPA
-#pragma pack 1
-#endif
-
-struct Decode
-{
-  unsigned int MaxNum;
-  unsigned int DecodeLen[16];
-  unsigned int DecodePos[16];
-  unsigned int DecodeNum[2];
-};
-
-struct LitDecode
-{
-  unsigned int MaxNum;
-  unsigned int DecodeLen[16];
-  unsigned int DecodePos[16];
-  unsigned int DecodeNum[NC];
-};
-
-struct DistDecode
-{
-  unsigned int MaxNum;
-  unsigned int DecodeLen[16];
-  unsigned int DecodePos[16];
-  unsigned int DecodeNum[DC];
-};
-
-struct LowDistDecode
-{
-  unsigned int MaxNum;
-  unsigned int DecodeLen[16];
-  unsigned int DecodePos[16];
-  unsigned int DecodeNum[LDC];
-};
-
-struct RepDecode
-{
-  unsigned int MaxNum;
-  unsigned int DecodeLen[16];
-  unsigned int DecodePos[16];
-  unsigned int DecodeNum[RC];
-};
-
-struct BitDecode
-{
-  unsigned int MaxNum;
-  unsigned int DecodeLen[16];
-  unsigned int DecodePos[16];
-  unsigned int DecodeNum[BC];
-};
-
-struct UnpackFilter
-{
-  unsigned int block_start;
-  unsigned int block_length;
-  unsigned int exec_count;
-  int next_window;
-  struct rarvm_prepared_program prg;
-};
-
-/* RAR2 structures */
-#define MC20 257
-struct MultDecode
-{
-  unsigned int MaxNum;
-  unsigned int DecodeLen[16];
-  unsigned int DecodePos[16];
-  unsigned int DecodeNum[MC20];
-};
-
-struct AudioVariables
-{
-  int K1,K2,K3,K4,K5;
-  int D1,D2,D3,D4;
-  int last_delta;
-  unsigned int dif[11];
-  unsigned int byte_count;
-  int last_char;
-};
-/* *************** */
-
-typedef struct unpack_data_tag
-{
-	int ofd;
-	
-	unsigned char in_buf[MAX_BUF_SIZE];
-	uint8_t window[MAXWINSIZE];
-	int in_addr;
-	int in_bit;
-	unsigned int unp_ptr;
-	unsigned int wr_ptr;
-	int tables_read;
-	int read_top;
-	int read_border;
-	int unp_block_type;
-	int prev_low_dist;
-	int low_dist_rep_count;
-	unsigned char unp_old_table[HUFF_TABLE_SIZE];
-	struct LitDecode LD;
-	struct DistDecode DD;
-	struct LowDistDecode LDD;
-	struct RepDecode RD;
-	struct BitDecode BD;
-	unsigned int old_dist[4];
-	unsigned int old_dist_ptr;
-	unsigned int last_dist;
-	unsigned int last_length;
-	ppm_data_t ppm_data;
-	int ppm_esc_char;
-	int ppm_error;
-	rar_filter_array_t Filters;
-	rar_filter_array_t PrgStack;
-	int *old_filter_lengths;
-	int last_filter, old_filter_lengths_size;
-	int64_t written_size;
-	int64_t dest_unp_size;
-	uint32_t pack_size;
-	rarvm_data_t rarvm_data;
-	unsigned int unp_crc;
-	
-	/* RAR2 variables */
-	int unp_cur_channel, unp_channel_delta, unp_audio_block, unp_channels;
-	unsigned char unp_old_table20[MC20 * 4];
-	struct MultDecode MD[4];
-	struct AudioVariables audv[4];
-	
-	/* RAR1 variables */
-	unsigned int  flag_buf, avr_plc, avr_plcb, avr_ln1, avr_ln2, avr_ln3;
-	int buf60, num_huf, st_mode, lcount, flags_cnt;
-	unsigned int nhfb, nlzb, max_dist3;
-	unsigned int chset[256], chseta[256], chsetb[256], chsetc[256];
-	unsigned int place[256], placea[256], placeb[256], placec[256];
-	unsigned int ntopl[256], ntoplb[256], ntoplc[256];
-} unpack_data_t;
-
-typedef enum
-{
-	ALL_HEAD=0,
-	MARK_HEAD=0x72,
-	MAIN_HEAD=0x73,
-	FILE_HEAD=0x74,
-	COMM_HEAD=0x75,
-	AV_HEAD=0x76,
-	SUB_HEAD=0x77,
-	PROTECT_HEAD=0x78,
-	SIGN_HEAD=0x79,
-	NEWSUB_HEAD=0x7a,
-	ENDARC_HEAD=0x7b
-} header_type;
-
-enum BLOCK_TYPES
-{
-	BLOCK_LZ,
-	BLOCK_PPM
-};
-
-unsigned int rar_get_char(int fd, unpack_data_t *unpack_data);
-void rar_addbits(unpack_data_t *unpack_data, int bits);
-unsigned int rar_getbits(unpack_data_t *unpack_data);
-int rar_unp_read_buf(int fd, unpack_data_t *unpack_data);
-void rar_unpack_init_data(int solid, unpack_data_t *unpack_data);
-void rar_make_decode_tables(unsigned char *len_tab, struct Decode *decode, int size);
-void rar_unp_write_buf_old(unpack_data_t *unpack_data);
-int rar_decode_number(unpack_data_t *unpack_data, struct Decode *decode);
-void rar_init_filters(unpack_data_t *unpack_data);
-int rar_unpack(int fd, int method, int solid, unpack_data_t *unpack_data);
-
-#ifdef HAVE_PRAGMA_PACK
-#pragma pack()
-#endif
-
-#ifdef HAVE_PRAGMA_PACK_HPPA
-#pragma pack
-#endif
-
-#endif
diff -ruN clamav-0.92.1~dfsg/libclamunrar/unrarhlp.c clamav-0.92.1~dfsg2/libclamunrar/unrarhlp.c
--- clamav-0.92.1~dfsg/libclamunrar/unrarhlp.c	2007-11-21 08:53:42.000000000 -0500
+++ clamav-0.92.1~dfsg2/libclamunrar/unrarhlp.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,62 +0,0 @@
-/*
- *  Copyright (C) 2007 Sourcefire, Inc.
- *
- *  The unRAR sources may be used in any software to handle RAR
- *  archives without limitations free of charge, but cannot be used
- *  to re-create the RAR compression algorithm, which is proprietary.
- *  Distribution of modified unRAR sources in separate form or as a
- *  part of other software is permitted, provided that it is clearly
- *  stated in the documentation and source comments that the code may
- *  not be used to develop a RAR (WinRAR) compatible archiver.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include "libclamunrar/unrarhlp.h"
-
-#define RAR_MAX_ALLOCATION 184549376
-
-void *rar_malloc(size_t size)
-{
-	void *alloc;
-
-
-    if(!size || size > RAR_MAX_ALLOCATION) {
-	fprintf(stderr, "UNRAR: rar_malloc(): Attempt to allocate %u bytes. Please report to http://bugs.clamav.net\n", size);
-	return NULL;
-    }
-
-#if defined(_MSC_VER) && defined(_DEBUG)
-    alloc = _malloc_dbg(size, _NORMAL_BLOCK, __FILE__, __LINE__);
-#else
-    alloc = malloc(size);
-#endif
-
-    if(!alloc) {
-	fprintf(stderr, "UNRAR: rar_malloc(): Can't allocate memory (%u bytes).\n", size);
-	perror("malloc_problem");
-	return NULL;
-    } else return alloc;
-}
-
-void *rar_realloc2(void *ptr, size_t size)
-{
-	void *alloc;
-
-
-    if(!size || size > RAR_MAX_ALLOCATION) {
-	fprintf(stderr, "UNRAR: rar_realloc2(): Attempt to allocate %u bytes. Please report to http://bugs.clamav.net\n", size);
-	return NULL;
-    }
-
-    alloc = realloc(ptr, size);
-
-    if(!alloc) {
-	fprintf(stderr, "UNRAR: rar_realloc2(): Can't allocate memory (%u bytes).\n", size);
-	perror("rar_realloc2");
-	if(ptr)
-	    free(ptr);
-	return NULL;
-    } else return alloc;
-}
diff -ruN clamav-0.92.1~dfsg/libclamunrar/unrarhlp.h clamav-0.92.1~dfsg2/libclamunrar/unrarhlp.h
--- clamav-0.92.1~dfsg/libclamunrar/unrarhlp.h	2007-11-21 07:37:49.000000000 -0500
+++ clamav-0.92.1~dfsg2/libclamunrar/unrarhlp.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,58 +0,0 @@
-/*
- *  Copyright (C) 2007 Sourcefire, Inc.
- *
- *  The unRAR sources may be used in any software to handle RAR
- *  archives without limitations free of charge, but cannot be used
- *  to re-create the RAR compression algorithm, which is proprietary.
- *  Distribution of modified unRAR sources in separate form or as a
- *  part of other software is permitted, provided that it is clearly
- *  stated in the documentation and source comments that the code may
- *  not be used to develop a RAR (WinRAR) compatible archiver.
- */
-
-#ifndef __UNRARHLP_H
-#define __UNRARHLP_H
-
-#if HAVE_CONFIG_H
-#include "clamav-config.h"
-#endif
-
-#ifdef HAVE_STDINT_H
-#include <stdint.h>
-#elif defined HAVE_SYS_INT_TYPES_H
-#include <sys/int_types.h>
-#elif defined HAVE_INTTYPES_H
-#include <inttypes.h>
-#else
-    typedef signed char int8_t;
-    typedef unsigned char uint8_t;
-
-#if SIZEOF_INT == 2
-    typedef signed int int16_t;
-    typedef unsigned int uint16_t;
-#elif SIZEOF_SHORT == 2
-    typedef signed short int16_t;
-    typedef unsigned short uint16_t;
-#endif
-
-#if SIZEOF_INT == 4
-    typedef signed int int32_t;
-    typedef unsigned int uint32_t;
-#elif SIZEOF_LONG == 4
-    typedef signed long int32_t;
-    typedef unsigned long uint32_t;
-#endif
-
-#if SIZEOF_LONG == 8
-    typedef signed long int64_t;
-    typedef unsigned long uint64_t;
-#elif SIZEOF_LONG_LONG == 8
-    typedef signed long long int64_t;
-    typedef unsigned long long uint64_t;
-#endif
-#endif
-
-void *rar_malloc(size_t size);
-void *rar_realloc2(void *ptr, size_t size);
-
-#endif /* __UNRARHLP_H */
diff -ruN clamav-0.92.1~dfsg/libclamunrar/unrarppm.c clamav-0.92.1~dfsg2/libclamunrar/unrarppm.c
--- clamav-0.92.1~dfsg/libclamunrar/unrarppm.c	2007-11-21 08:53:56.000000000 -0500
+++ clamav-0.92.1~dfsg2/libclamunrar/unrarppm.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,1023 +0,0 @@
-/*
- *  Extract RAR archives
- *
- *  Copyright (C) 2005-2006 trog@uncon.org
- *
- *  This code is based on the work of Alexander L. Roshal (C)
- *
- *  The unRAR sources may be used in any software to handle RAR
- *  archives without limitations free of charge, but cannot be used
- *  to re-create the RAR compression algorithm, which is proprietary.
- *  Distribution of modified unRAR sources in separate form or as a
- *  part of other software is permitted, provided that it is clearly
- *  stated in the documentation and source comments that the code may
- *  not be used to develop a RAR (WinRAR) compatible archiver.
- */
-
-#include <stdio.h>
-#include <string.h>
-
-#include "libclamunrar/unrar.h"
-#include "libclamunrar/unrarppm.h"
-
-#ifdef RAR_HIGH_DEBUG
-#define rar_dbgmsg printf
-#else
-static void rar_dbgmsg(const char* fmt,...){}
-#endif
-
-#define MAX(a,b)    (((a) > (b)) ? (a) : (b))
-#define MAX_O 64
-
-const unsigned int UNIT_SIZE=MAX(sizeof(struct ppm_context), sizeof(struct rar_mem_blk_tag));
-const unsigned int FIXED_UNIT_SIZE=12;
-const int INT_BITS=7, PERIOD_BITS=7, TOT_BITS=14;
-const int INTERVAL=1 << 7, BIN_SCALE=1 << 14, MAX_FREQ=124;
-const unsigned int TOP=1 << 24, BOT=1 << 15;
-
-/************* Start of Allocator code block ********************/
-static void sub_allocator_init(sub_allocator_t *sub_alloc)
-{
-	sub_alloc->sub_allocator_size = 0;
-}
-
-static void sub_allocator_insert_node(sub_allocator_t *sub_alloc, void *p, int indx)
-{
-	((struct rar_node *) p)->next = sub_alloc->free_list[indx].next;
-	sub_alloc->free_list[indx].next = (struct rar_node *) p;
-}
-
-static void *sub_allocator_remove_node(sub_allocator_t *sub_alloc, int indx)
-{
-	struct rar_node *ret_val;
-	
-	ret_val = sub_alloc->free_list[indx].next;
-	sub_alloc->free_list[indx].next = ret_val->next;
-	return ret_val;
-}
-
-static int sub_allocator_u2b(int nu)
-{
-	return UNIT_SIZE*nu;
-}
-
-static rar_mem_blk_t* sub_allocator_mbptr(rar_mem_blk_t* base_ptr, int items)
-{
-        return ((rar_mem_blk_t*) (((unsigned char *)(base_ptr)) + sub_allocator_u2b(items) ));
-}
-
-static void sub_allocator_split_block(sub_allocator_t *sub_alloc, void *pv,
-				int old_indx, int new_indx)
-{
-	int i, udiff;
-	uint8_t *p;
-	
-	udiff = sub_alloc->indx2units[old_indx] - sub_alloc->indx2units[new_indx];
-	p = ((uint8_t *) pv) + sub_allocator_u2b(sub_alloc->indx2units[new_indx]);
-	if (sub_alloc->indx2units[i=sub_alloc->units2indx[udiff-1]] != udiff) {
-		sub_allocator_insert_node(sub_alloc, p, --i);
-		p += sub_allocator_u2b(i=sub_alloc->indx2units[i]);
-		udiff -= i;
-	}
-	sub_allocator_insert_node(sub_alloc, p, sub_alloc->units2indx[udiff-1]);
-}
-
-static long sub_allocator_get_allocated_memory(sub_allocator_t *sub_alloc)
-{
-	return sub_alloc->sub_allocator_size;
-}
-
-static void sub_allocator_stop_sub_allocator(sub_allocator_t *sub_alloc)
-{
-	if (sub_alloc->sub_allocator_size) {
-		sub_alloc->sub_allocator_size = 0;
-		free(sub_alloc->heap_start);
-	}
-}
-
-static int sub_allocator_start_sub_allocator(sub_allocator_t *sub_alloc, int sa_size)
-{
-	unsigned int t, alloc_size;
-	
-	t = sa_size << 20;
-	if (sub_alloc->sub_allocator_size == t) {
-		return TRUE;
-	}
-	sub_allocator_stop_sub_allocator(sub_alloc);
-	alloc_size = t/FIXED_UNIT_SIZE*UNIT_SIZE+UNIT_SIZE;
-#if defined(__sparc) || defined(sparc) || defined(__sparcv9)
-	/* Allow for aligned access requirements */
-	alloc_size += UNIT_SIZE;
-#endif
-	if ((sub_alloc->heap_start = (uint8_t *) rar_malloc(alloc_size)) == NULL) {
-		rar_dbgmsg("sub_alloc start failed\n");
-		return FALSE;
-	}
-	sub_alloc->heap_end = sub_alloc->heap_start + alloc_size - UNIT_SIZE;
-	sub_alloc->sub_allocator_size = t;
-	return TRUE;
-}
-
-static void sub_allocator_init_sub_allocator(sub_allocator_t *sub_alloc)
-{
-	int i, k;
-	unsigned int size1, real_size1, size2, real_size2;
-
-	memset(sub_alloc->free_list, 0, sizeof(sub_alloc->free_list));
-	sub_alloc->ptext = sub_alloc->heap_start;
-	
-	size2 = FIXED_UNIT_SIZE*(sub_alloc->sub_allocator_size/8/FIXED_UNIT_SIZE*7);
-	real_size2 = size2/FIXED_UNIT_SIZE*UNIT_SIZE;
-	size1 = sub_alloc->sub_allocator_size - size2;
-	real_size1 = size1/FIXED_UNIT_SIZE*UNIT_SIZE+size1%FIXED_UNIT_SIZE;
-#if defined(__sparc) || defined(sparc) || defined(__sparcv9)
-	/* Allow for aligned access requirements */
-	if (size1%FIXED_UNIT_SIZE != 0) {
-		real_size1 += UNIT_SIZE - size1%FIXED_UNIT_SIZE;
-	}
-#endif
-	sub_alloc->hi_unit = sub_alloc->heap_start + sub_alloc->sub_allocator_size;
-	sub_alloc->lo_unit = sub_alloc->units_start = sub_alloc->heap_start + real_size1;
-	sub_alloc->fake_units_start = sub_alloc->heap_start + size1;
-	sub_alloc->hi_unit = sub_alloc->lo_unit + real_size2;
-	
-	for (i=0,k=1; i < N1 ; i++, k+=1) {
-		sub_alloc->indx2units[i] = k;
-	}
-	for (k++; i < N1+N2 ; i++, k+=2) {
-		sub_alloc->indx2units[i] = k;
-	}
-	for (k++; i < N1+N2+N3 ; i++, k+=3) {
-		sub_alloc->indx2units[i] = k;
-	}
-	for (k++; i < N1+N2+N3+N4 ; i++, k+=4) {
-		sub_alloc->indx2units[i] = k;
-	}
-	
-	for (sub_alloc->glue_count=k=i=0; k < 128; k++) {
-		i += (sub_alloc->indx2units[i] < k+1);
-		sub_alloc->units2indx[k] = i;
-	}
-}
-
-static void rar_mem_blk_insertAt(rar_mem_blk_t *a, rar_mem_blk_t *p)
-{
-	a->next = (a->prev=p)->next;
-	p->next = a->next->prev = a;
-}
-
-static void rar_mem_blk_remove(rar_mem_blk_t *a)
-{
-	a->prev->next = a->next;
-	a->next->prev = a->prev;
-}
-
-static void sub_allocator_glue_free_blocks(sub_allocator_t *sub_alloc)
-{
-	rar_mem_blk_t s0, *p, *p1;
-	int i, k, sz;
-	
-	if (sub_alloc->lo_unit != sub_alloc->hi_unit) {
-		*sub_alloc->lo_unit = 0;
-	}
-	for (i=0, s0.next=s0.prev=&s0; i < N_INDEXES; i++) {
-		while (sub_alloc->free_list[i].next) {
-			p = (rar_mem_blk_t *) sub_allocator_remove_node(sub_alloc, i);
-			rar_mem_blk_insertAt(p, &s0);
-			p->stamp = 0xFFFF;
-			p->nu = sub_alloc->indx2units[i];
-		}
-	}
-	
-	for (p=s0.next ; p != &s0 ; p=p->next) {
-		while ((p1 = sub_allocator_mbptr(p,p->nu))->stamp == 0xFFFF &&
-				((int)p->nu)+p1->nu < 0x10000) {
-			rar_mem_blk_remove(p1);
-			p->nu += p1->nu;
-		}
-	}
-	
-	while ((p=s0.next) != &s0) {
-		for (rar_mem_blk_remove(p), sz=p->nu; sz > 128; sz-=128, p=sub_allocator_mbptr(p, 128)) {
-			sub_allocator_insert_node(sub_alloc, p, N_INDEXES-1);
-		}
-		if (sub_alloc->indx2units[i=sub_alloc->units2indx[sz-1]] != sz) {
-			k = sz-sub_alloc->indx2units[--i];
-			sub_allocator_insert_node(sub_alloc, sub_allocator_mbptr(p,sz-k), k-1);
-		}
-		sub_allocator_insert_node(sub_alloc, p, i);
-	}
-}
-
-static void *sub_allocator_alloc_units_rare(sub_allocator_t *sub_alloc, int indx)
-{
-	int i, j;
-	void *ret_val;
-	
-	if (!sub_alloc->glue_count) {
-		sub_alloc->glue_count = 255;
-		sub_allocator_glue_free_blocks(sub_alloc);
-		if (sub_alloc->free_list[indx].next) {
-			return sub_allocator_remove_node(sub_alloc, indx);
-		}
-	}
-	i=indx;
-	do {
-		if (++i == N_INDEXES) {
-			sub_alloc->glue_count--;
-			i = sub_allocator_u2b(sub_alloc->indx2units[indx]);
-			j = 12 * sub_alloc->indx2units[indx];
-			if (sub_alloc->fake_units_start - sub_alloc->ptext > j) {
-				sub_alloc->fake_units_start -= j;
-				sub_alloc->units_start -= i;
-				return sub_alloc->units_start;
-			}
-			return NULL;
-		}
-	} while ( !sub_alloc->free_list[i].next);
-	ret_val = sub_allocator_remove_node(sub_alloc, i);
-	sub_allocator_split_block(sub_alloc, ret_val, i, indx);
-	return ret_val;
-}
-
-static void *sub_allocator_alloc_units(sub_allocator_t *sub_alloc, int nu)
-{
-	int indx;
-	void *ret_val;
-	
-	indx = sub_alloc->units2indx[nu-1];
-	if (sub_alloc->free_list[indx].next) {
-		return sub_allocator_remove_node(sub_alloc, indx);
-	}
-	ret_val = sub_alloc->lo_unit;
-	sub_alloc->lo_unit += sub_allocator_u2b(sub_alloc->indx2units[indx]);
-	if (sub_alloc->lo_unit <= sub_alloc->hi_unit) {
-		return ret_val;
-	}
-	sub_alloc->lo_unit -= sub_allocator_u2b(sub_alloc->indx2units[indx]);
-	return sub_allocator_alloc_units_rare(sub_alloc, indx);
-}
-
-static void *sub_allocator_alloc_context(sub_allocator_t *sub_alloc)
-{
-	if (sub_alloc->hi_unit != sub_alloc->lo_unit) {
-		return (sub_alloc->hi_unit -= UNIT_SIZE);
-	}
-	if (sub_alloc->free_list->next) {
-		return sub_allocator_remove_node(sub_alloc, 0);
-	}
-	return sub_allocator_alloc_units_rare(sub_alloc, 0);
-}
-
-static void *sub_allocator_expand_units(sub_allocator_t *sub_alloc, void *old_ptr, int old_nu)
-{
-	int i0, i1;
-	void *ptr;
-	
-	i0 = sub_alloc->units2indx[old_nu-1];
-	i1 = sub_alloc->units2indx[old_nu];
-	if (i0 == i1) {
-		return old_ptr;
-	}
-	ptr = sub_allocator_alloc_units(sub_alloc, old_nu+1);
-	if (ptr) {
-		memcpy(ptr, old_ptr, sub_allocator_u2b(old_nu));
-		sub_allocator_insert_node(sub_alloc, old_ptr, i0);
-	}
-	return ptr;
-}
-
-static void *sub_allocator_shrink_units(sub_allocator_t *sub_alloc, void *old_ptr,
-			int old_nu, int new_nu)
-{
-	int i0, i1;
-	void *ptr;
-	
-	i0 = sub_alloc->units2indx[old_nu-1];
-	i1 = sub_alloc->units2indx[new_nu-1];
-	if (i0 == i1) {
-		return old_ptr;
-	}
-	if (sub_alloc->free_list[i1].next) {
-		ptr = sub_allocator_remove_node(sub_alloc, i1);
-		memcpy(ptr, old_ptr, sub_allocator_u2b(new_nu));
-		sub_allocator_insert_node(sub_alloc, old_ptr, i0);
-		return ptr;
-	} else {
-		sub_allocator_split_block(sub_alloc, old_ptr, i0, i1);
-		return old_ptr;
-	}
-}
-
-static void  sub_allocator_free_units(sub_allocator_t *sub_alloc, void *ptr, int old_nu)
-{
-	sub_allocator_insert_node(sub_alloc, ptr, sub_alloc->units2indx[old_nu-1]);
-}
-
-/************** End of Allocator code block *********************/
-
-/************** Start of Range Coder code block *********************/
-static void range_coder_init_decoder(range_coder_t *coder, int fd,
-			unpack_data_t *unpack_data)
-{
-	int i;
-	coder->low = coder->code = 0;
-	coder->range = (unsigned int) -1;
-	
-	for (i=0; i < 4 ; i++) {
-		coder->code = (coder->code << 8) | rar_get_char(fd, unpack_data);
-	}
-}
-
-static int coder_get_current_count(range_coder_t *coder)
-{
-	return (coder->code - coder->low) / (coder->range /= coder->scale);
-}
-
-static unsigned int  coder_get_current_shift_count(range_coder_t *coder, unsigned int shift)
-{
-	return (coder->code - coder->low) / (coder->range >>= shift);
-}
-
-#define ARI_DEC_NORMALISE(fd, unpack_data, code, low, range)					\
-{												\
-	while ((low^(low+range)) < TOP || (range < BOT && ((range=-low&(BOT-1)),1))) {		\
-		code = (code << 8) | rar_get_char(fd, unpack_data);				\
-		range <<= 8;									\
-		low <<= 8;									\
-	}											\
-}
-
-static void coder_decode(range_coder_t *coder)
-{
-	coder->low += coder->range * coder->low_count;
-	coder->range *= coder->high_count - coder->low_count;
-}
-
-/******(******** End of Range Coder code block ***********(**********/
-
-static void see2_init(struct see2_context_tag *see2_cont, int init_val)
-{
-	see2_cont->summ = init_val << (see2_cont->shift=PERIOD_BITS-4);
-	see2_cont->count = 4;
-}
-
-static unsigned int get_mean(struct see2_context_tag *see2_cont)
-{
-	unsigned int ret_val;
-	
-	ret_val = see2_cont->summ >> see2_cont->shift;
-	see2_cont->summ -= ret_val;
-	return ret_val + (ret_val == 0);
-}
-
-static void update(struct see2_context_tag *see2_cont)
-{
-	if (see2_cont->shift < PERIOD_BITS && --see2_cont->count == 0) {
-		see2_cont->summ += see2_cont->summ;
-		see2_cont->count = 3 << see2_cont->shift++;
-	}
-}
-
-static int restart_model_rare(ppm_data_t *ppm_data)
-{
-	int i, k, m;
-	static const uint16_t init_bin_esc[] = {
-		0x3cdd, 0x1f3f, 0x59bf, 0x48f3, 0x64a1, 0x5abc, 0x6632, 0x6051
-	};
-	rar_dbgmsg("in restart_model_rare\n");
-	memset(ppm_data->char_mask, 0, sizeof(ppm_data->char_mask));
-	
-	sub_allocator_init_sub_allocator(&ppm_data->sub_alloc);
-	
-	ppm_data->init_rl=-(ppm_data->max_order < 12 ? ppm_data->max_order:12)-1;
-	ppm_data->min_context = ppm_data->max_context =
-		(struct ppm_context *) sub_allocator_alloc_context(&ppm_data->sub_alloc);
-	if(!ppm_data->min_context) {
-	    rar_dbgmsg("unrar: restart_model_rare: sub_allocator_alloc_context failed\n"); /* FIXME: cli_errmsg */
-	    return FALSE;
-	}
-	ppm_data->min_context->suffix = NULL;
-	ppm_data->order_fall = ppm_data->max_order;
-	ppm_data->min_context->con_ut.u.summ_freq = (ppm_data->min_context->num_stats=256)+1;
-	ppm_data->found_state = ppm_data->min_context->con_ut.u.stats=
-		(struct state_tag *)sub_allocator_alloc_units(&ppm_data->sub_alloc, 256/2);
-	if(!ppm_data->found_state) {
-	    rar_dbgmsg("unrar: restart_model_rare: sub_allocator_alloc_units failed\n"); /* FIXME: cli_errmsg */
-	    return FALSE;
-	}
-	for (ppm_data->run_length = ppm_data->init_rl, ppm_data->prev_success=i=0; i < 256 ; i++) {
-		ppm_data->min_context->con_ut.u.stats[i].symbol = i;
-		ppm_data->min_context->con_ut.u.stats[i].freq = 1;
-		ppm_data->min_context->con_ut.u.stats[i].successor = NULL;
-	}
-	
-	for (i=0 ; i < 128 ; i++) {
-		for (k=0 ; k < 8 ; k++) {
-			for (m=0 ; m < 64 ; m+=8) {
-				ppm_data->bin_summ[i][k+m]=BIN_SCALE-init_bin_esc[k]/(i+2);
-			}
-		}
-	}
-	for (i=0; i < 25; i++) {
-		for (k=0 ; k < 16 ; k++) {
-			see2_init(&ppm_data->see2cont[i][k], 5*i+10);
-		}
-	}
-
-	return TRUE;
-}
-	
-static int start_model_rare(ppm_data_t *ppm_data, int max_order)
-{
-	int i, k, m, step, ret;
-	
-	ppm_data->esc_count = 1;
-	ppm_data->max_order = max_order;
-	
-	if (!restart_model_rare(ppm_data)) {
-	    rar_dbgmsg("unrar: start_model_rare: restart_model_rare failed\n");
-	    return FALSE;
-	}
-	
-	ppm_data->ns2bsindx[0] = 2*0;
-	ppm_data->ns2bsindx[1] = 2*1;
-	
-	memset(ppm_data->ns2bsindx+2, 2*2, 9);
-	memset(ppm_data->ns2bsindx+11, 2*3, 256-11);
-	
-	for (i=0 ; i < 3; i++) {
-		ppm_data->ns2indx[i] = i;
-	}
-	for (m=i, k=step=1; i < 256; i++) {
-		ppm_data->ns2indx[i]=m;
-		if (!--k) {
-			k = ++step;
-			m++;
-		}
-	}
-	memset(ppm_data->hb2flag, 0, 0x40);
-	memset(ppm_data->hb2flag+0x40, 0x08, 0x100-0x40);
-	ppm_data->dummy_sse2cont.shift = PERIOD_BITS;
-	return TRUE;
-}
-
-	
-/* ****************** PPM Code ***************/
-
-static void ppmd_swap(struct state_tag *p0, struct state_tag *p1)
-{
-	struct state_tag tmp;
-	
-	tmp = *p0;
-	*p0 = *p1;
-	*p1 = tmp;
-}
-
-static void rescale(ppm_data_t *ppm_data, struct ppm_context *context)
-{
-	int old_ns, i, adder, esc_freq, n0, n1;
-	struct state_tag *p1, *p;
-	
-	rar_dbgmsg("in rescale\n");
-	old_ns = context->num_stats;
-	i = context->num_stats-1;
-	
-	for (p=ppm_data->found_state ; p != context->con_ut.u.stats ; p--) {
-		ppmd_swap(&p[0], &p[-1]);
-	}
-	context->con_ut.u.stats->freq += 4;
-	context->con_ut.u.summ_freq += 4;
-	esc_freq = context->con_ut.u.summ_freq - p->freq;
-	adder = (ppm_data->order_fall != 0);
-	context->con_ut.u.summ_freq = (p->freq = (p->freq+adder) >> 1);
-	do {
-		esc_freq -= (++p)->freq;
-		context->con_ut.u.summ_freq += (p->freq = (p->freq + adder) >> 1);
-		if (p[0].freq > p[-1].freq) {
-			struct state_tag tmp = *(p1=p);
-			do {
-				p1[0] = p1[-1];
-			} while (--p1 != context->con_ut.u.stats && tmp.freq > p1[-1].freq);
-			*p1 = tmp;
-		}
-	} while (--i);
-	
-	if (p->freq == 0) {
-		do {
-			i++;
-		} while ((--p)->freq == 0);
-		esc_freq += i;
-		if ((context->num_stats -= i) == 1) {
-			struct state_tag tmp = *context->con_ut.u.stats;
-			do {
-				tmp.freq -= (tmp.freq >> 1);
-				esc_freq >>= 1;
-			} while (esc_freq > 1);
-			sub_allocator_free_units(&ppm_data->sub_alloc,
-					context->con_ut.u.stats, (old_ns+1)>>1);
-			*(ppm_data->found_state=&context->con_ut.one_state)=tmp;
-			return;
-		}
-	}
-	context->con_ut.u.summ_freq += (esc_freq -= (esc_freq >> 1));
-	n0 = (old_ns+1) >> 1;
-	n1 = (context->num_stats+1) >> 1;
-	if (n0 != n1) {
-		context->con_ut.u.stats = (struct state_tag *) sub_allocator_shrink_units(&ppm_data->sub_alloc,
-						context->con_ut.u.stats, n0, n1);
-	}
-	ppm_data->found_state = context->con_ut.u.stats;
-}
-
-static struct ppm_context *create_child(ppm_data_t *ppm_data, struct ppm_context *context,
-				struct state_tag *pstats, struct state_tag *first_state)
-{
-	struct ppm_context *pc;
-	rar_dbgmsg("in create_child\n");
-	pc = (struct ppm_context *) sub_allocator_alloc_context(&ppm_data->sub_alloc);
-	if (pc) {
-		pc->num_stats = 1;
-		pc->con_ut.one_state = *first_state;
-		pc->suffix = context;
-		pstats->successor = pc;
-	}
-	return pc;
-}
-
-static struct ppm_context *create_successors(ppm_data_t *ppm_data,
-			int skip, struct state_tag *p1)
-{
-	struct state_tag up_state;
-	struct ppm_context *pc, *up_branch;
-	struct state_tag *p, *ps[MAX_O], **pps;
-	unsigned int cf, s0;
-	
-	rar_dbgmsg("in create_successors\n");
-	pc = ppm_data->min_context;
-	up_branch = ppm_data->found_state->successor;
-	pps = ps;
-	
-	if (!skip) {
-		*pps++ = ppm_data->found_state;
-		if (!pc->suffix) {
-			goto NO_LOOP;
-		}
-	}
-	if (p1) {
-		p = p1;
-		pc = pc->suffix;
-		goto LOOP_ENTRY;
-	}
-	do {
-		pc = pc->suffix;
-		if (pc->num_stats != 1) {
-			if ((p=pc->con_ut.u.stats)->symbol != ppm_data->found_state->symbol) {
-				do {
-					p++;
-				} while (p->symbol != ppm_data->found_state->symbol);
-			}
-		} else {
-			p = &(pc->con_ut.one_state);
-		}
-LOOP_ENTRY:
-		if (p->successor != up_branch) {
-			pc = p->successor;
-			break;
-		}
-		*pps++ = p;
-	} while (pc->suffix);
-NO_LOOP:
-	if (pps == ps) {
-		return pc;
-	}
-	up_state.symbol= *(uint8_t *) up_branch;
-	up_state.successor = (struct ppm_context *) (((uint8_t *) up_branch)+1);
-	if (pc->num_stats != 1) {
-		if ((uint8_t *) pc <= ppm_data->sub_alloc.ptext) {
-			return NULL;
-		}
-		if ((p=pc->con_ut.u.stats)->symbol != up_state.symbol) {
-			do {
-				p++;
-			} while (p->symbol != up_state.symbol);
-		}
-		cf = p->freq - 1;
-		s0 = pc->con_ut.u.summ_freq - pc->num_stats - cf;
-		up_state.freq = 1 + ((2*cf <= s0)?(5*cf > s0):((2*cf+3*s0-1)/(2*s0)));
-	} else {
-		up_state.freq = pc->con_ut.one_state.freq;
-	}
-	do {
-		pc = create_child(ppm_data, pc, *--pps, &up_state);
-		if (!pc) {
-			rar_dbgmsg("create_child failed\n");
-			return NULL;
-		}
-	} while (pps != ps);
-	return pc;
-}
-
-static int update_model(ppm_data_t *ppm_data)
-{
-	struct state_tag fs, *p;
-	struct ppm_context *pc, *successor;
-	unsigned int ns1, ns, cf, sf, s0;
-	int ret;
-	
-	rar_dbgmsg("in update_model\n");
-	fs = *ppm_data->found_state;
-	p = NULL;
-
-	if (fs.freq < MAX_FREQ/4 && (pc=ppm_data->min_context->suffix) != NULL) {
-		if (pc->num_stats != 1) {
-			if ((p=pc->con_ut.u.stats)->symbol != fs.symbol) {
-				do {
-					p++;
-				} while (p->symbol != fs.symbol);
-				if (p[0].freq >= p[-1].freq) {
-					ppmd_swap(&p[0], &p[-1]);
-					p--;
-				}
-			}
-			if (p->freq < MAX_FREQ-9) {
-				p->freq += 2;
-				pc->con_ut.u.summ_freq += 2;
-			}
-		} else {
-			p = &(pc->con_ut.one_state);
-			p->freq += (p->freq < 32);
-		}
-	}
-	if (!ppm_data->order_fall) {
-		ppm_data->min_context = ppm_data->max_context =
-			ppm_data->found_state->successor = create_successors(ppm_data, TRUE, p);
-		if (!ppm_data->min_context) {
-			goto RESTART_MODEL;
-		}
-		return TRUE;
-	}
-	*ppm_data->sub_alloc.ptext++ = fs.symbol;
-	successor = (struct ppm_context *) ppm_data->sub_alloc.ptext;
-	if (ppm_data->sub_alloc.ptext >= ppm_data->sub_alloc.fake_units_start) {
-		goto RESTART_MODEL;
-	}
-	if (fs.successor) {
-		if ((uint8_t *)fs.successor <= ppm_data->sub_alloc.ptext &&
-				(fs.successor = create_successors(ppm_data, FALSE, p)) == NULL) {
-			goto RESTART_MODEL;
-		}
-		if (!--ppm_data->order_fall) {
-			successor = fs.successor;
-			ppm_data->sub_alloc.ptext -= (ppm_data->max_context != ppm_data->min_context);
-		}
-	} else {
-		ppm_data->found_state->successor = successor;
-		fs.successor = ppm_data->min_context;
-	}
-	s0 = ppm_data->min_context->con_ut.u.summ_freq-(ns=ppm_data->min_context->num_stats)-(fs.freq-1);
-	for (pc=ppm_data->max_context; pc != ppm_data->min_context ; pc=pc->suffix) {
-		if ((ns1=pc->num_stats) != 1) {
-			if ((ns1 & 1) == 0) {
-				pc->con_ut.u.stats = (struct state_tag *)
-					sub_allocator_expand_units(&ppm_data->sub_alloc,
-								pc->con_ut.u.stats, ns1>>1);
-				if (!pc->con_ut.u.stats) {
-					goto RESTART_MODEL;
-				}
-			}
-			pc->con_ut.u.summ_freq += (2*ns1 < ns)+2*((4*ns1 <= ns) & (pc->con_ut.u.summ_freq <= 8*ns1));
-		} else {
-			p = (struct state_tag *) sub_allocator_alloc_units(&ppm_data->sub_alloc, 1);
-			if (!p) {
-				goto RESTART_MODEL;
-			}
-			*p = pc->con_ut.one_state;
-			pc->con_ut.u.stats = p;
-			if (p->freq < MAX_FREQ/4-1) {
-				p->freq += p->freq;
-			} else {
-				p->freq = MAX_FREQ - 4;
-			}
-			pc->con_ut.u.summ_freq = p->freq + ppm_data->init_esc + (ns > 3);
-		}
-		cf = 2*fs.freq*(pc->con_ut.u.summ_freq+6);
-		sf = s0 + pc->con_ut.u.summ_freq;
-		if (cf < 6*sf) {
-			cf = 1 + (cf > sf) + (cf >= 4*sf);
-			pc->con_ut.u.summ_freq += 3;
-		} else {
-			cf = 4 + (cf >= 9*sf) + (cf >= 12*sf) + (cf >= 15*sf);
-			pc->con_ut.u.summ_freq += cf;
-		}
-		p = pc->con_ut.u.stats + ns1;
-		p->successor = successor;
-		p->symbol = fs.symbol;
-		p->freq = cf;
-		pc->num_stats = ++ns1;
-	}
-	ppm_data->max_context = ppm_data->min_context = fs.successor;
-	return TRUE;
-	
-RESTART_MODEL:
-	if (!restart_model_rare(ppm_data)) {
-	    rar_dbgmsg("unrar: update_model: restart_model_rare: failed\n");
-	    return FALSE;
-	}
-	ppm_data->esc_count = 0;
-	return TRUE;
-}
-
-static void update1(ppm_data_t *ppm_data, struct state_tag *p, struct ppm_context *context)
-{
-	rar_dbgmsg("in update1\n");
-	(ppm_data->found_state=p)->freq += 4;
-	context->con_ut.u.summ_freq += 4;
-	if (p[0].freq > p[-1].freq) {
-		ppmd_swap(&p[0], &p[-1]);
-		ppm_data->found_state = --p;
-		if (p->freq > MAX_FREQ) {
-			rescale(ppm_data, context);
-		}
-	}
-}
-
-static int ppm_decode_symbol1(ppm_data_t *ppm_data, struct ppm_context *context)
-{
-	struct state_tag *p;
-	int i, hi_cnt, count;
-	
-	rar_dbgmsg("in ppm_decode_symbol1\n");
-	ppm_data->coder.scale = context->con_ut.u.summ_freq;
-	p = context->con_ut.u.stats;
-	count = coder_get_current_count(&ppm_data->coder);
-	if (count >= ppm_data->coder.scale) {
-		return FALSE;
-	}
-	if (count < (hi_cnt = p->freq)) {
-		ppm_data->prev_success = (2 * (ppm_data->coder.high_count=hi_cnt) >
-						ppm_data->coder.scale);
-		ppm_data->run_length += ppm_data->prev_success;
-		(ppm_data->found_state=p)->freq=(hi_cnt += 4);
-		context->con_ut.u.summ_freq += 4;
-		if (hi_cnt > MAX_FREQ) {
-			rescale(ppm_data, context);
-		}
-		ppm_data->coder.low_count = 0;
-		return TRUE;
-	} else if (ppm_data->found_state == NULL) {
-		return FALSE;
-	}
-	ppm_data->prev_success = 0;
-	i = context->num_stats-1;
-	while ((hi_cnt += (++p)->freq) <= count) {
-		if (--i == 0) {
-			ppm_data->hi_bits_flag = ppm_data->hb2flag[ppm_data->found_state->symbol];
-			ppm_data->coder.low_count = hi_cnt;
-			ppm_data->char_mask[p->symbol] = ppm_data->esc_count;
-			i = (ppm_data->num_masked=context->num_stats) - 1;
-			ppm_data->found_state = NULL;
-			do {
-				ppm_data->char_mask[(--p)->symbol] = ppm_data->esc_count;
-			} while (--i);
-			ppm_data->coder.high_count = ppm_data->coder.scale;
-			return TRUE;
-		}
-	}
-	ppm_data->coder.low_count = (ppm_data->coder.high_count = hi_cnt) - p->freq;
-	update1(ppm_data, p, context);
-	return TRUE;
-}
-
-static const uint8_t ExpEscape[16]={ 25,14, 9, 7, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 2 };
-#define GET_MEAN(SUMM,SHIFT,ROUND) ((SUMM+(1 << (SHIFT-ROUND))) >> (SHIFT))
-
-static void ppm_decode_bin_symbol(ppm_data_t *ppm_data, struct ppm_context *context)
-{
-	struct state_tag *rs;
-	uint16_t *bs;
-	
-	rar_dbgmsg("in ppm_decode_bin_symbol\n");
-	
-	rs = &context->con_ut.one_state;
-	
-	ppm_data->hi_bits_flag = ppm_data->hb2flag[ppm_data->found_state->symbol];
-	bs = &ppm_data->bin_summ[rs->freq-1][ppm_data->prev_success +
-		ppm_data->ns2bsindx[context->suffix->num_stats-1] +
-		ppm_data->hi_bits_flag+2*ppm_data->hb2flag[rs->symbol] +
-		((ppm_data->run_length >> 26) & 0x20)];
-	if (coder_get_current_shift_count(&ppm_data->coder, TOT_BITS) < *bs) {
-		ppm_data->found_state = rs;
-		rs->freq += (rs->freq < 128);
-		ppm_data->coder.low_count = 0;
-		ppm_data->coder.high_count = *bs;
-		*bs = (uint16_t) (*bs + INTERVAL - GET_MEAN(*bs, PERIOD_BITS, 2));
-		ppm_data->prev_success = 1;
-		ppm_data->run_length++;
-	} else {
-		ppm_data->coder.low_count = *bs;
-		*bs = (uint16_t) (*bs - GET_MEAN(*bs, PERIOD_BITS, 2));
-		ppm_data->coder.high_count = BIN_SCALE;
-		ppm_data->init_esc = ExpEscape[*bs >> 10];
-		ppm_data->num_masked = 1;
-		ppm_data->char_mask[rs->symbol] = ppm_data->esc_count;
-		ppm_data->prev_success = 0;
-		ppm_data->found_state = NULL;
-	}
-}
-
-static void update2(ppm_data_t *ppm_data, struct state_tag *p, struct ppm_context *context)
-{
-	rar_dbgmsg("in update2\n");
-	(ppm_data->found_state = p)->freq += 4;
-	context->con_ut.u.summ_freq += 4;
-	if (p->freq > MAX_FREQ) {
-		rescale(ppm_data, context);
-	}
-	ppm_data->esc_count++;
-	ppm_data->run_length = ppm_data->init_rl;
-}
-
-static struct see2_context_tag *make_esc_freq(ppm_data_t *ppm_data,
-			struct ppm_context *context, int diff)
-{
-	struct see2_context_tag *psee2c;
-	
-	if (context->num_stats != 256) {
-		psee2c = ppm_data->see2cont[ppm_data->ns2indx[diff-1]] +
-			(diff < context->suffix->num_stats-context->num_stats) +
-			2 * (context->con_ut.u.summ_freq < 11*context->num_stats)+4*
-			(ppm_data->num_masked > diff) +	ppm_data->hi_bits_flag;
-		ppm_data->coder.scale = get_mean(psee2c);
-	} else {
-		psee2c = &ppm_data->dummy_sse2cont;
-		ppm_data->coder.scale = 1;
-	}
-	return psee2c;
-}
-
-static int ppm_decode_symbol2(ppm_data_t *ppm_data, struct ppm_context *context)
-{
-	int count, hi_cnt, i;
-	struct see2_context_tag *psee2c;
-	struct state_tag *ps[256], **pps, *p;
-	
-	rar_dbgmsg("in ppm_decode_symbol2\n");
-	i = context->num_stats - ppm_data->num_masked;
-	psee2c = make_esc_freq(ppm_data, context, i);
-	pps = ps;
-	p = context->con_ut.u.stats - 1;
-	hi_cnt = 0;
-	
-	do {
-		do {
-			p++;
-		} while (ppm_data->char_mask[p->symbol] == ppm_data->esc_count);
-		hi_cnt += p->freq;
-		*pps++ = p;
-	} while (--i);
-	ppm_data->coder.scale += hi_cnt;
-	count = coder_get_current_count(&ppm_data->coder);
-	if (count >= ppm_data->coder.scale) {
-		return FALSE;
-	}
-	p=*(pps=ps);
-	if (count < hi_cnt) {
-		hi_cnt = 0;
-		while ((hi_cnt += p->freq) <= count) {
-			p=*++pps;
-		}
-		ppm_data->coder.low_count = (ppm_data->coder.high_count=hi_cnt) - p->freq;
-		update(psee2c);
-		update2(ppm_data, p, context);
-	} else {
-		ppm_data->coder.low_count = hi_cnt;
-		ppm_data->coder.high_count = ppm_data->coder.scale;
-		i = context->num_stats - ppm_data->num_masked;
-		pps--;
-		do {
-			ppm_data->char_mask[(*++pps)->symbol] = ppm_data->esc_count;
-		} while (--i);
-		psee2c->summ += ppm_data->coder.scale;
-		ppm_data->num_masked = context->num_stats;
-	}
-	return TRUE;
-}
-
-static void clear_mask(ppm_data_t *ppm_data)
-{
-	ppm_data->esc_count = 1;
-	memset(ppm_data->char_mask, 0, sizeof(ppm_data->char_mask));
-}
-
-void ppm_constructor(ppm_data_t *ppm_data)
-{
-	sub_allocator_init(&ppm_data->sub_alloc);
-	ppm_data->min_context = NULL;
-	ppm_data->max_context = NULL;
-}
-
-void ppm_destructor(ppm_data_t *ppm_data)
-{
-	sub_allocator_stop_sub_allocator(&ppm_data->sub_alloc);
-}
-
-int ppm_decode_init(ppm_data_t *ppm_data, int fd, unpack_data_t *unpack_data, int *EscChar)
-{
-	int max_order, Reset, MaxMB;
-	
-	max_order = rar_get_char(fd, unpack_data);
-	rar_dbgmsg("ppm_decode_init max_order=%d\n", max_order);
-	Reset = (max_order & 0x20) ? 1 : 0;
-	rar_dbgmsg("ppm_decode_init Reset=%d\n", Reset);
-	if (Reset) {
-		MaxMB = rar_get_char(fd, unpack_data);
-		rar_dbgmsg("ppm_decode_init MaxMB=%d\n", MaxMB);
-	} else {
-		if (sub_allocator_get_allocated_memory(&ppm_data->sub_alloc) == 0) {
-			return FALSE;
-		}
-	}
-	if (max_order & 0x40) {
-		*EscChar = rar_get_char(fd, unpack_data);
-		rar_dbgmsg("ppm_decode_init EscChar=%d\n", *EscChar);
-	}
-	range_coder_init_decoder(&ppm_data->coder, fd, unpack_data);
-	if (Reset) {
-		max_order = (max_order & 0x1f) + 1;
-		if (max_order > 16) {
-			max_order = 16 + (max_order - 16) * 3;
-		}
-		if (max_order == 1) {
-			sub_allocator_stop_sub_allocator(&ppm_data->sub_alloc);
-			return FALSE;
-		}
-		if(!sub_allocator_start_sub_allocator(&ppm_data->sub_alloc, MaxMB+1)) {
-		    sub_allocator_stop_sub_allocator(&ppm_data->sub_alloc);
-		    return FALSE;
-		}
-		if (!start_model_rare(ppm_data, max_order)) {
-		    sub_allocator_stop_sub_allocator(&ppm_data->sub_alloc);
-		    return FALSE;
-		}
-	}
-	rar_dbgmsg("ppm_decode_init done: %d\n", ppm_data->min_context != NULL);
-	return (ppm_data->min_context != NULL);
-}
-
-int ppm_decode_char(ppm_data_t *ppm_data, int fd, unpack_data_t *unpack_data)
-{
-	int symbol;
-
-	if ((uint8_t *) ppm_data->min_context <= ppm_data->sub_alloc.ptext ||
-			(uint8_t *)ppm_data->min_context > ppm_data->sub_alloc.heap_end) {
-		return -1;
-	}
-	if (ppm_data->min_context->num_stats != 1) {
-		if ((uint8_t *) ppm_data->min_context->con_ut.u.stats <= ppm_data->sub_alloc.ptext ||
-			(uint8_t *) ppm_data->min_context->con_ut.u.stats > ppm_data->sub_alloc.heap_end) {
-			return -1;
-		}
-		if (!ppm_decode_symbol1(ppm_data, ppm_data->min_context)) {
-			return -1;
-		}
-	} else {
-		ppm_decode_bin_symbol(ppm_data, ppm_data->min_context);
-	}
-	coder_decode(&ppm_data->coder);
-	
-	while (!ppm_data->found_state) {
-		ARI_DEC_NORMALISE(fd, unpack_data, ppm_data->coder.code, 
-				ppm_data->coder.low, ppm_data->coder.range);
-		do {
-			ppm_data->order_fall++;
-			ppm_data->min_context = ppm_data->min_context->suffix;
-			if ((uint8_t *)ppm_data->min_context <= ppm_data->sub_alloc.ptext ||
-					(uint8_t *)ppm_data->min_context >
-					ppm_data->sub_alloc.heap_end) {
-				return -1;
-			}
-		} while (ppm_data->min_context->num_stats == ppm_data->num_masked);
-		if (!ppm_decode_symbol2(ppm_data, ppm_data->min_context)) {
-			return -1;
-		}
-		coder_decode(&ppm_data->coder);
-	}
-	
-	symbol = ppm_data->found_state->symbol;
-	if (!ppm_data->order_fall && (uint8_t *) ppm_data->found_state->successor > ppm_data->sub_alloc.ptext) {
-		ppm_data->min_context = ppm_data->max_context = ppm_data->found_state->successor;
-	} else {
-		if(!update_model(ppm_data)) {
-		    rar_dbgmsg("unrar: ppm_decode_char: update_model failed\n");
-		    return -1;
-		}
-
-		if (ppm_data->esc_count == 0) {
-			clear_mask(ppm_data);
-		}
-	}
-	ARI_DEC_NORMALISE(fd, unpack_data, ppm_data->coder.code, ppm_data->coder.low,
-				ppm_data->coder.range);
-	return symbol;
-}
diff -ruN clamav-0.92.1~dfsg/libclamunrar/unrarppm.h clamav-0.92.1~dfsg2/libclamunrar/unrarppm.h
--- clamav-0.92.1~dfsg/libclamunrar/unrarppm.h	2007-11-20 07:27:58.000000000 -0500
+++ clamav-0.92.1~dfsg2/libclamunrar/unrarppm.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,103 +0,0 @@
-/*
- * Extract RAR archives
- *
- * Copyright (C) 2005-2006 trog@uncon.org
- *
- * This code is based on the work of Alexander L. Roshal (C)
- *
- * The unRAR sources may be used in any software to handle RAR
- * archives without limitations free of charge, but cannot be used
- * to re-create the RAR compression algorithm, which is proprietary.
- * Distribution of modified unRAR sources in separate form or as a
- * part of other software is permitted, provided that it is clearly
- * stated in the documentation and source comments that the code may
- * not be used to develop a RAR (WinRAR) compatible archiver.
- *
- */
-
-
-#ifndef UNRAR_PPM_H
-#define UNRAR_PPM_H 1
-
-#define N1 4
-#define N2 4
-#define N3 4
-#define N4 26
-#define N_INDEXES 38
-
-typedef struct rar_mem_blk_tag
-{
-	uint16_t stamp, nu;
-	struct rar_mem_blk_tag *next, *prev;
-} rar_mem_blk_t;
-
-struct rar_node
-{
-	struct rar_node *next;
-};
-
-typedef struct sub_allocator_tag
-{
-	long sub_allocator_size;
-	int16_t indx2units[N_INDEXES], units2indx[128], glue_count;
-	uint8_t *heap_start, *lo_unit, *hi_unit;
-	struct rar_node free_list[N_INDEXES];
-	
-	uint8_t *ptext, *units_start, *heap_end, *fake_units_start;
-} sub_allocator_t;
-
-typedef struct range_coder_tag
-{
-	unsigned int low, code, range;
-	unsigned int low_count, high_count, scale;
-}range_coder_t;
-
-struct ppm_context;
-
-struct see2_context_tag
-{
-	uint16_t summ;
-	uint8_t shift, count;
-};
-
-struct state_tag
-{
-	uint8_t symbol;
-	uint8_t freq;
-	struct ppm_context *successor;
-};
-
-struct freq_data_tag
-{
-	uint16_t summ_freq;
-	struct state_tag *stats;
-};
-
-struct ppm_context {
-	uint16_t num_stats;
-	union {
-		struct freq_data_tag u;
-		struct state_tag one_state;
-	} con_ut;
-	struct ppm_context *suffix;
-};
-
-typedef struct ppm_data_tag
-{
-	sub_allocator_t sub_alloc;
-	range_coder_t coder;
-	int num_masked, init_esc, order_fall, max_order, run_length, init_rl;
-	struct ppm_context *min_context, *max_context;
-	struct state_tag *found_state;
-	uint8_t char_mask[256], ns2indx[256], ns2bsindx[256], hb2flag[256];
-	uint8_t esc_count, prev_success, hi_bits_flag;
-	struct see2_context_tag see2cont[25][16], dummy_sse2cont;
-	uint16_t bin_summ[128][64];
-} ppm_data_t;
-
-int ppm_decode_init(ppm_data_t *ppm_data, int fd, struct unpack_data_tag *unpack_data, int *EscChar);
-int ppm_decode_char(ppm_data_t *ppm_data, int fd, struct unpack_data_tag *unpack_data);
-void ppm_constructor(ppm_data_t *ppm_data);
-void ppm_destructor(ppm_data_t *ppm_data);
-
-#endif
diff -ruN clamav-0.92.1~dfsg/libclamunrar/unrarvm.c clamav-0.92.1~dfsg2/libclamunrar/unrarvm.c
--- clamav-0.92.1~dfsg/libclamunrar/unrarvm.c	2008-02-04 12:23:00.000000000 -0500
+++ clamav-0.92.1~dfsg2/libclamunrar/unrarvm.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,1180 +0,0 @@
-/*
- *  Extract RAR archives
- *
- *  Copyright (C) 2005-2006 trog@uncon.org
- *
- *  This code is based on the work of Alexander L. Roshal (C)
- *
- *  The unRAR sources may be used in any software to handle RAR
- *  archives without limitations free of charge, but cannot be used
- *  to re-create the RAR compression algorithm, which is proprietary.
- *  Distribution of modified unRAR sources in separate form or as a
- *  part of other software is permitted, provided that it is clearly
- *  stated in the documentation and source comments that the code may
- *  not be used to develop a RAR (WinRAR) compatible archiver.
- */
-
-#if HAVE_CONFIG_H
-#include "clamav-config.h"
-#endif
-
-#include <string.h>
-
-#include "libclamunrar/unrar.h"
-#include "libclamunrar/unrarvm.h"
-#include "libclamunrar/unrarcmd.h"
-
-#ifdef RAR_HIGH_DEBUG
-#define rar_dbgmsg printf
-#else
-static void rar_dbgmsg(){};
-#endif
-
-#define VMCF_OP0             0
-#define VMCF_OP1             1
-#define VMCF_OP2             2
-#define VMCF_OPMASK          3
-#define VMCF_BYTEMODE        4
-#define VMCF_JUMP            8
-#define VMCF_PROC           16
-#define VMCF_USEFLAGS       32
-#define VMCF_CHFLAGS        64
-
-static uint8_t vm_cmdflags[]=
-{
-  /* VM_MOV   */ VMCF_OP2 | VMCF_BYTEMODE                                ,
-  /* VM_CMP   */ VMCF_OP2 | VMCF_BYTEMODE | VMCF_CHFLAGS                 ,
-  /* VM_ADD   */ VMCF_OP2 | VMCF_BYTEMODE | VMCF_CHFLAGS                 ,
-  /* VM_SUB   */ VMCF_OP2 | VMCF_BYTEMODE | VMCF_CHFLAGS                 ,
-  /* VM_JZ    */ VMCF_OP1 | VMCF_JUMP | VMCF_USEFLAGS                    ,
-  /* VM_JNZ   */ VMCF_OP1 | VMCF_JUMP | VMCF_USEFLAGS                    ,
-  /* VM_INC   */ VMCF_OP1 | VMCF_BYTEMODE | VMCF_CHFLAGS                 ,
-  /* VM_DEC   */ VMCF_OP1 | VMCF_BYTEMODE | VMCF_CHFLAGS                 ,
-  /* VM_JMP   */ VMCF_OP1 | VMCF_JUMP                                    ,
-  /* VM_XOR   */ VMCF_OP2 | VMCF_BYTEMODE | VMCF_CHFLAGS                 ,
-  /* VM_AND   */ VMCF_OP2 | VMCF_BYTEMODE | VMCF_CHFLAGS                 ,
-  /* VM_OR    */ VMCF_OP2 | VMCF_BYTEMODE | VMCF_CHFLAGS                 ,
-  /* VM_TEST  */ VMCF_OP2 | VMCF_BYTEMODE | VMCF_CHFLAGS                 ,
-  /* VM_JS    */ VMCF_OP1 | VMCF_JUMP | VMCF_USEFLAGS                    ,
-  /* VM_JNS   */ VMCF_OP1 | VMCF_JUMP | VMCF_USEFLAGS                    ,
-  /* VM_JB    */ VMCF_OP1 | VMCF_JUMP | VMCF_USEFLAGS                    ,
-  /* VM_JBE   */ VMCF_OP1 | VMCF_JUMP | VMCF_USEFLAGS                    ,
-  /* VM_JA    */ VMCF_OP1 | VMCF_JUMP | VMCF_USEFLAGS                    ,
-  /* VM_JAE   */ VMCF_OP1 | VMCF_JUMP | VMCF_USEFLAGS                    ,
-  /* VM_PUSH  */ VMCF_OP1                                                ,
-  /* VM_POP   */ VMCF_OP1                                                ,
-  /* VM_CALL  */ VMCF_OP1 | VMCF_PROC                                    ,
-  /* VM_RET   */ VMCF_OP0 | VMCF_PROC                                    ,
-  /* VM_NOT   */ VMCF_OP1 | VMCF_BYTEMODE                                ,
-  /* VM_SHL   */ VMCF_OP2 | VMCF_BYTEMODE | VMCF_CHFLAGS                 ,
-  /* VM_SHR   */ VMCF_OP2 | VMCF_BYTEMODE | VMCF_CHFLAGS                 ,
-  /* VM_SAR   */ VMCF_OP2 | VMCF_BYTEMODE | VMCF_CHFLAGS                 ,
-  /* VM_NEG   */ VMCF_OP1 | VMCF_BYTEMODE | VMCF_CHFLAGS                 ,
-  /* VM_PUSHA */ VMCF_OP0                                                ,
-  /* VM_POPA  */ VMCF_OP0                                                ,
-  /* VM_PUSHF */ VMCF_OP0 | VMCF_USEFLAGS                                ,
-  /* VM_POPF  */ VMCF_OP0 | VMCF_CHFLAGS                                 ,
-  /* VM_MOVZX */ VMCF_OP2                                                ,
-  /* VM_MOVSX */ VMCF_OP2                                                ,
-  /* VM_XCHG  */ VMCF_OP2 | VMCF_BYTEMODE                                ,
-  /* VM_MUL   */ VMCF_OP2 | VMCF_BYTEMODE                                ,
-  /* VM_DIV   */ VMCF_OP2 | VMCF_BYTEMODE                                ,
-  /* VM_ADC   */ VMCF_OP2 | VMCF_BYTEMODE | VMCF_USEFLAGS | VMCF_CHFLAGS ,
-  /* VM_SBB   */ VMCF_OP2 | VMCF_BYTEMODE | VMCF_USEFLAGS | VMCF_CHFLAGS ,
-  /* VM_PRINT */ VMCF_OP0
-};
-
-#define UINT32(x)  (sizeof(uint32_t)==4 ? (uint32_t)(x):((x)&0xffffffff))
-
-static unsigned int rarvm_get_value(int byte_mode, unsigned int *addr)
-{
-	if (byte_mode) {
-		return *addr;
-	} else {
-#if WORDS_BIGENDIAN == 0
-		return UINT32(*addr);
-#else
-                unsigned char *B = (unsigned char *)addr;
-                return UINT32((uint8_t)B[0]|((uint8_t)B[1]<<8)|((uint8_t)B[2]<<16)|((uint8_t)B[3]<<24));
-#endif
-	}
-}
-
-#if WORDS_BIGENDIAN == 0
-#define GET_VALUE(byte_mode,addr) ((byte_mode) ? (*(unsigned char *)(addr)) : UINT32((*(unsigned int *)(addr))))
-#else
-#define GET_VALUE(byte_mode,addr) rarvm_get_value(byte_mode, (unsigned int *)addr)
-#endif
-
-void rarvm_set_value(int byte_mode, unsigned int *addr, unsigned int value)
-{
-	if (byte_mode) {
-		*(unsigned char *)addr=value;
-	} else {
-#if WORDS_BIGENDIAN == 0
-		*(uint32_t *)addr = value;
-#else
-		((unsigned char *)addr)[0]=(unsigned char)value;
-		((unsigned char *)addr)[1]=(unsigned char)(value>>8);
-		((unsigned char *)addr)[2]=(unsigned char)(value>>16);
-		((unsigned char *)addr)[3]=(unsigned char)(value>>24);
-#endif
-	}
-}
-
-		
-#if WORDS_BIGENDIAN == 0
-#define SET_VALUE(byte_mode,addr,value) ((byte_mode) ? (*(unsigned char *)(addr)=(value)):(*(uint32_t *)(addr)=((uint32_t)(value))))
-#else
-#define SET_VALUE(byte_mode,addr,value) rarvm_set_value(byte_mode, (unsigned int *)addr, value);
-#endif
-
-const uint32_t crc_tab[256]={
-	0x0,        0x77073096, 0xee0e612c, 0x990951ba, 0x76dc419,  0x706af48f, 0xe963a535, 0x9e6495a3,
-	0xedb8832,  0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x9b64c2b,  0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
-	0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
-	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
-	0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
-	0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
-	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
-	0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
-	0x76dc4190, 0x1db7106,  0x98d220bc, 0xefd5102a, 0x71b18589, 0x6b6b51f,  0x9fbfe4a5, 0xe8b8d433,
-	0x7807c9a2, 0xf00f934,  0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x86d3d2d,  0x91646c97, 0xe6635c01,
-	0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
-	0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
-	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
-	0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
-	0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
-	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
-	0xedb88320, 0x9abfb3b6, 0x3b6e20c,  0x74b1d29a, 0xead54739, 0x9dd277af, 0x4db2615,  0x73dc1683,
-	0xe3630b12, 0x94643b84, 0xd6d6a3e,  0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0xa00ae27,  0x7d079eb1,
-	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
-	0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
-	0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
-	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
-	0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
-	0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
-	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x26d930a,  0x9c0906a9, 0xeb0e363f, 0x72076785, 0x5005713,
-	0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0xcb61b38,  0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0xbdbdf21,
-	0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
-	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
-	0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
-	0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
-	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
-	0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
-};
-
-uint32_t rar_crc(uint32_t start_crc, void *addr, uint32_t size)
-{
-	unsigned char *data;
-	int i;
-
-	data = addr;
-#if WORDS_BIGENDIAN == 0
-	while (size > 0 && ((int)data & 7))
-	{
-		start_crc = crc_tab[(unsigned char)(start_crc^data[0])]^(start_crc>>8);
-		size--;
-		data++;
-	}
-	while (size >= 8)
-	{
-		start_crc ^= *(uint32_t *) data;
-		start_crc = crc_tab[(unsigned char)start_crc] ^ (start_crc>>8);
-		start_crc = crc_tab[(unsigned char)start_crc] ^ (start_crc>>8);
-		start_crc = crc_tab[(unsigned char)start_crc] ^ (start_crc>>8);
-		start_crc = crc_tab[(unsigned char)start_crc] ^ (start_crc>>8);
-		start_crc ^= *(uint32_t *)(data+4);
-		start_crc = crc_tab[(unsigned char)start_crc] ^ (start_crc>>8);
-		start_crc = crc_tab[(unsigned char)start_crc] ^ (start_crc>>8);
-		start_crc = crc_tab[(unsigned char)start_crc] ^ (start_crc>>8);
-		start_crc = crc_tab[(unsigned char)start_crc] ^ (start_crc>>8);
-		data += 8;
-		size -= 8;
-	}
-#endif
-	for (i=0 ; i < size ; i++) {
-		start_crc = crc_tab[(unsigned char)(start_crc^data[i])]^(start_crc >> 8);
-	}
-	return start_crc;
-}
-
-int rarvm_init(rarvm_data_t *rarvm_data)
-{
-	rarvm_data->mem = (uint8_t *) rar_malloc(RARVM_MEMSIZE+4);
-	if (!rarvm_data->mem) {
-		return FALSE;
-	}
-	return TRUE;
-}
-
-void rarvm_free(rarvm_data_t *rarvm_data)
-{
-	if (rarvm_data && rarvm_data->mem) {
-		free(rarvm_data->mem);
-		rarvm_data->mem = NULL;
-	}
-}
-
-void rarvm_addbits(rarvm_input_t *rarvm_input, int bits)
-{
-	bits += rarvm_input->in_bit;
-	rarvm_input->in_addr += bits >> 3;
-	rarvm_input->in_bit = bits & 7;
-}
-
-unsigned int rarvm_getbits(rarvm_input_t *rarvm_input)
-{
-	unsigned int bit_field;
-
-	bit_field = (unsigned int) rarvm_input->in_buf[rarvm_input->in_addr] << 16;
-	bit_field |= (unsigned int) rarvm_input->in_buf[rarvm_input->in_addr+1] << 8;
-	bit_field |= (unsigned int) rarvm_input->in_buf[rarvm_input->in_addr+2];
-	bit_field >>= (8-rarvm_input->in_bit);
-
-	return (bit_field & 0xffff);
-}
-
-unsigned int rarvm_read_data(rarvm_input_t *rarvm_input)
-{
-	unsigned int data;
-	
-	data = rarvm_getbits(rarvm_input);
-	rar_dbgmsg("rarvm_read_data getbits=%u\n", data);
-	switch (data & 0xc000) {
-	case 0:
-		rarvm_addbits(rarvm_input,6);
-		rar_dbgmsg("rarvm_read_data=%u\n", ((data>>10)&0x0f));
-		return ((data>>10)&0x0f);
-	case 0x4000:
-		if ((data & 0x3c00) == 0) {
-			data = 0xffffff00 | ((data>>2) & 0xff);
-			rarvm_addbits(rarvm_input,14);
-		} else {
-			data = (data >> 6) &0xff;
-			rarvm_addbits(rarvm_input,10);
-		}
-		rar_dbgmsg("rarvm_read_data=%u\n", data);
-		return data;
-	case 0x8000:
-		rarvm_addbits(rarvm_input,2);
-		data = rarvm_getbits(rarvm_input);
-		rarvm_addbits(rarvm_input,16);
-		rar_dbgmsg("rarvm_read_data=%u\n", data);
-		return data;
-	default:
-		rarvm_addbits(rarvm_input,2);
-		data = (rarvm_getbits(rarvm_input) << 16);
-		rarvm_addbits(rarvm_input,16);
-		data |= rarvm_getbits(rarvm_input);
-		rarvm_addbits(rarvm_input,16);
-		rar_dbgmsg("rarvm_read_data=%u\n", data);
-		return data;
-	}
-}
-
-static rarvm_standard_filters_t is_standard_filter(unsigned char *code, int code_size)
-{
-	uint32_t code_crc;
-	int i;
-
-	struct standard_filter_signature
-	{
-		int length;
-		uint32_t crc;
-		rarvm_standard_filters_t type;
-	} std_filt_list[] = {
-		{53,  0xad576887, VMSF_E8},
-		{57,  0x3cd7e57e, VMSF_E8E9},
-		{120, 0x3769893f, VMSF_ITANIUM},
-		{29,  0x0e06077d, VMSF_DELTA},
-		{149, 0x1c2c5dc8, VMSF_RGB},
- 		{216, 0xbc85e701, VMSF_AUDIO},
-		{40,  0x46b9c560, VMSF_UPCASE}
-	};
-	
-	code_crc = rar_crc(0xffffffff, code, code_size)^0xffffffff;
-	rar_dbgmsg("code_crc=%u\n", code_crc);
-	for (i=0 ; i<sizeof(std_filt_list)/sizeof(std_filt_list[0]) ; i++) {
-		if (std_filt_list[i].crc == code_crc && std_filt_list[i].length == code_size) {
-			return std_filt_list[i].type;
-		}
-	}
-	return VMSF_NONE;
-}
-
-void rarvm_set_memory(rarvm_data_t *rarvm_data, unsigned int pos, uint8_t *data, unsigned int data_size)
-{
-	if (pos<RARVM_MEMSIZE && data!=rarvm_data->mem+pos) {
-		memmove(rarvm_data->mem+pos, data, MIN(data_size, RARVM_MEMSIZE-pos));
-	}
-}
-
-static unsigned int *rarvm_get_operand(rarvm_data_t *rarvm_data,
-				struct rarvm_prepared_operand *cmd_op)
-{
-	if (cmd_op->type == VM_OPREGMEM) {
-		return ((unsigned int *)&rarvm_data->mem[(*cmd_op->addr+cmd_op->base) & RARVM_MEMMASK]);
-	} else {
-		return cmd_op->addr;
-	}
-}
-
-static unsigned int filter_itanium_getbits(unsigned char *data, int bit_pos, int bit_count)
-{
-	int in_addr=bit_pos/8;
-	int in_bit=bit_pos&7;
-	unsigned int bit_field=(unsigned int)data[in_addr++];
-	bit_field|=(unsigned int)data[in_addr++] << 8;
-	bit_field|=(unsigned int)data[in_addr++] << 16;
-	bit_field|=(unsigned int)data[in_addr] << 24;
-	bit_field >>= in_bit;
-	return(bit_field & (0xffffffff>>(32-bit_count)));
-}
-
-static void filter_itanium_setbits(unsigned char *data, unsigned int bit_field, int bit_pos, int bit_count)
-{
-	int i, in_addr=bit_pos/8;
-	int in_bit=bit_pos&7;
-	unsigned int and_mask=0xffffffff>>(32-bit_count);
-	and_mask=~(and_mask<<in_bit);
-
-	bit_field<<=in_bit;
-
-	for (i=0 ; i<4 ; i++) {
-		data[in_addr+i]&=and_mask;
-		data[in_addr+i]|=bit_field;
-		and_mask=(and_mask>>8)|0xff000000;
-		bit_field>>=8;
-	}
-}
-
-static void execute_standard_filter(rarvm_data_t *rarvm_data, rarvm_standard_filters_t filter_type)
-{
-	unsigned char *data, cmp_byte2, cur_byte, *src_data, *dest_data;
-	int i, j, data_size, channels, src_pos, dest_pos, border, width, PosR;
-	int op_type, cur_channel, byte_count, start_pos, pa, pb, pc;
-	unsigned int file_offset, cur_pos, predicted;
-	int32_t offset, addr;
-	const int file_size=0x1000000;
-
-	switch(filter_type) {
-	case VMSF_E8:
-	case VMSF_E8E9:
-		data=rarvm_data->mem;
-		data_size = rarvm_data->R[4];
-		file_offset = rarvm_data->R[6];
-
-		if ((data_size >= VM_GLOBALMEMADDR) || (data_size < 4)) {
-			break;
-		}
-
-		cmp_byte2 = filter_type==VMSF_E8E9 ? 0xe9:0xe8;
-		for (cur_pos = 0 ; cur_pos < data_size-4 ; ) {
-			cur_byte = *(data++);
-			cur_pos++;
-			if (cur_byte==0xe8 || cur_byte==cmp_byte2) {
-				offset = cur_pos+file_offset;
-				addr = GET_VALUE(FALSE, data);
-				if (addr < 0) {
-					if (addr+offset >=0 ) {
-						SET_VALUE(FALSE, data, addr+file_size);
-					}
-				} else {
-					if (addr<file_size) {
-						SET_VALUE(FALSE, data, addr-offset);
-					}
-				}
-				data += 4;
-				cur_pos += 4;
-			}
-		}
-		break;
-	case VMSF_ITANIUM:
-		data=rarvm_data->mem;
-		data_size = rarvm_data->R[4];
-		file_offset = rarvm_data->R[6];
-		
-		if ((data_size >= VM_GLOBALMEMADDR) || (data_size < 21)) {
-			break;
-		}
-		
-		cur_pos = 0;
-		
-		file_offset>>=4;
-		
-		while (cur_pos < data_size-21) {
-			int Byte = (data[0] & 0x1f) - 0x10;
-			if (Byte >= 0) {
-				static unsigned char masks[16]={4,4,6,6,0,0,7,7,4,4,0,0,4,4,0,0};
-				unsigned char cmd_mask = masks[Byte];
-				
-				if (cmd_mask != 0) {
-					for (i=0 ; i <= 2 ; i++) {
-						if (cmd_mask & (1<<i)) {
-							start_pos = i*41+5;
-							op_type = filter_itanium_getbits(data,
-									start_pos+37, 4);
-							if (op_type == 5) {
-								offset = filter_itanium_getbits(data,
-										start_pos+13, 20);
-								filter_itanium_setbits(data,
-									(offset-file_offset)
-									&0xfffff,start_pos+13,20);
-							}
-						}
-					}
-				}
-			}
-			data += 16;
-			cur_pos += 16;
-			file_offset++;
-		}
-		break;
-	case VMSF_DELTA:
-		data_size = rarvm_data->R[4];
-		channels = rarvm_data->R[0];
-		src_pos = 0;
-		border = data_size*2;
-		
-		SET_VALUE(FALSE, &rarvm_data->mem[VM_GLOBALMEMADDR+0x20], data_size);
-		if (data_size >= VM_GLOBALMEMADDR/2) {
-			break;
-		}
-		for (cur_channel=0 ; cur_channel < channels ; cur_channel++) {
-			unsigned char prev_byte = 0;
-			for (dest_pos=data_size+cur_channel ; dest_pos<border ; dest_pos+=channels) {
-				rarvm_data->mem[dest_pos] = (prev_byte -= rarvm_data->mem[src_pos++]);
-			}
-		}
-		break;
-	case VMSF_RGB: {
-		const int channels=3;
-		data_size = rarvm_data->R[4];
-		width = rarvm_data->R[0] - 3;
-		PosR = rarvm_data->R[1];
-		src_data = rarvm_data->mem;
-		dest_data = src_data + data_size;
-		
-		SET_VALUE(FALSE, &rarvm_data->mem[VM_GLOBALMEMADDR+0x20], data_size);
-		if (data_size >= VM_GLOBALMEMADDR/2) {
-			break;
-		}
-		for (cur_channel=0 ; cur_channel < channels; cur_channel++) {
-			unsigned int prev_byte = 0;
-			for (i=cur_channel ; i<data_size ; i+=channels) {
-				int upper_pos=i-width;
-				if (upper_pos >= 3) {
-					unsigned char *upper_data = dest_data+upper_pos;
-					unsigned int upper_byte = *upper_data;
-					unsigned int upper_left_byte = *(upper_data-3);
-					predicted = prev_byte+upper_byte-upper_left_byte;
-					pa = abs((int)(predicted-prev_byte));
-					pb = abs((int)(predicted-upper_byte));
-					pc = abs((int)(predicted-upper_left_byte));
-					if (pa <= pb && pa <= pc) {
-						predicted = prev_byte;
-					} else {
-						if (pb <= pc) {
-							predicted = upper_byte;
-						} else {
-							predicted = upper_left_byte;
-						}
-					}
-				} else {
-					predicted = prev_byte;
-				}
-				dest_data[i] = prev_byte = (unsigned char)(predicted-*(src_data++));
-			}
-		}
-		for (i=PosR,border=data_size-2 ; i < border ; i+=3) {
-			unsigned char g=dest_data[i+1];
-			dest_data[i] += g;
-			dest_data[i+2] += g;
-		}
-		break;
-	}
-	case VMSF_AUDIO: {
-		int channels=rarvm_data->R[0];
-		data_size = rarvm_data->R[4];
-		src_data = rarvm_data->mem;
-		dest_data = src_data + data_size;
-		
-		SET_VALUE(FALSE, &rarvm_data->mem[VM_GLOBALMEMADDR+0x20], data_size);
-		if (data_size >= VM_GLOBALMEMADDR/2) {
-			break;
-		}
-		for (cur_channel=0 ; cur_channel < channels ; cur_channel++) {
-			unsigned int prev_byte = 0, prev_delta=0, Dif[7];
-			int D, D1=0, D2=0, D3=0, K1=0, K2=0, K3=0;
-			
-			memset(Dif, 0, sizeof(Dif));
-			
-			for (i=cur_channel, byte_count=0 ; i<data_size ; i+=channels, byte_count++) {
-				D3=D2;
-				D2 = prev_delta-D1;
-				D1 = prev_delta;
-				
-				predicted = 8*prev_byte+K1*D1+K2*D2+K3*D3;
-				predicted = (predicted>>3) & 0xff;
-				
-				cur_byte = *(src_data++);
-				
-				predicted -= cur_byte;
-				dest_data[i] = predicted;
-				prev_delta = (signed char)(predicted-prev_byte);
-				prev_byte = predicted;
-				
-				D=((signed char)cur_byte) << 3;
-				
-				Dif[0] += abs(D);
-				Dif[1] += abs(D-D1);
-				Dif[2] += abs(D+D1);
-				Dif[3] += abs(D-D2);
-				Dif[4] += abs(D+D2);
-				Dif[5] += abs(D-D3);
-				Dif[6] += abs(D+D3);
-				
-				if ((byte_count & 0x1f) == 0) {
-					unsigned int min_dif=Dif[0], num_min_dif=0;
-					Dif[0]=0;
-					for (j=1 ; j<sizeof(Dif)/sizeof(Dif[0]) ; j++) {
-						if (Dif[j] < min_dif) {
-							min_dif = Dif[j];
-							num_min_dif = j;
-						}
-						Dif[j]=0;
-					}
-					switch(num_min_dif) {
-					case 1: if (K1>=-16) K1--; break;
-					case 2: if (K1 < 16) K1++; break;
-					case 3: if (K2>=-16) K2--; break;
-					case 4: if (K2 < 16) K2++; break;
-					case 5: if (K3>=-16) K3--; break;
-					case 6: if (K3 < 16) K3++; break;
-					}
-				}
-			}
-		}
-		break;
-	}
-	case VMSF_UPCASE:
-		data_size = rarvm_data->R[4];
-		src_pos = 0;
-		dest_pos = data_size;
-		if (data_size >= VM_GLOBALMEMADDR/2) {
-			break;
-		}
-		while (src_pos < data_size) {
-			cur_byte = rarvm_data->mem[src_pos++];
-			if (cur_byte==2 && (cur_byte=rarvm_data->mem[src_pos++]) != 2) {
-				cur_byte -= 32;
-			}
-			rarvm_data->mem[dest_pos++]=cur_byte;
-		}
-		SET_VALUE(FALSE, &rarvm_data->mem[VM_GLOBALMEMADDR+0x1c], dest_pos-data_size);
-		SET_VALUE(FALSE, &rarvm_data->mem[VM_GLOBALMEMADDR+0x20], data_size);
-		break;
-	}
-}
-				
-#define SET_IP(IP)                      \
-  if ((IP)>=code_size)                   \
-    return TRUE;                       \
-  if (--max_ops<=0)                  \
-    return FALSE;                      \
-  cmd=prepared_code+(IP);
-
-static int rarvm_execute_code(rarvm_data_t *rarvm_data,
-		struct rarvm_prepared_command *prepared_code, int code_size)
-{
-	int max_ops=25000000, i, SP;
-	struct rarvm_prepared_command *cmd;
-	unsigned int value1, value2, result, divider, FC, *op1, *op2;
-	const int reg_count=sizeof(rarvm_data->R)/sizeof(rarvm_data->R[0]);
-	
-	rar_dbgmsg("in rarvm_execute_code\n");
-	cmd = prepared_code;
-	while (1) {
-		if (cmd > (prepared_code + code_size)) {
-			rar_dbgmsg("RAR: code overrun detected\n");
-			return FALSE;
-		}
-		if (cmd < prepared_code) {
-			rar_dbgmsg("RAR: code underrun detected\n");
-                        return FALSE;
-                }
-		op1 = rarvm_get_operand(rarvm_data, &cmd->op1);
-		op2 = rarvm_get_operand(rarvm_data, &cmd->op2);
-		rar_dbgmsg("op(%d) op_code: %d, op1=%u, op2=%u\n", 25000000-max_ops,
-					cmd->op_code, op1, op2);
-		switch(cmd->op_code) {
-		case VM_MOV:
-			SET_VALUE(cmd->byte_mode, op1, GET_VALUE(cmd->byte_mode, op2));
-			break;
-		case VM_MOVB:
-			SET_VALUE(TRUE, op1, GET_VALUE(TRUE, op2));
-			break;
-		case VM_MOVD:
-			SET_VALUE(FALSE, op1, GET_VALUE(FALSE, op2));
-			break;
-		case VM_CMP:
-			value1 = GET_VALUE(cmd->byte_mode, op1);
-			result = UINT32(value1 - GET_VALUE(cmd->byte_mode, op2));
-			rarvm_data->Flags = result==0 ? VM_FZ : (result>value1)|(result&VM_FS);
-			break;
-		case VM_CMPB:
-			value1 = GET_VALUE(TRUE, op1);
-			result = UINT32(value1 - GET_VALUE(TRUE, op2));
-			rarvm_data->Flags = result==0 ? VM_FZ : (result>value1)|(result&VM_FS);
-			break;
-		case VM_CMPD:
-			value1 = GET_VALUE(FALSE, op1);
-			result = UINT32(value1 - GET_VALUE(FALSE, op2));
-			rarvm_data->Flags = result==0 ? VM_FZ : (result>value1)|(result&VM_FS);
-			break;
-		case VM_ADD:
-			value1 = GET_VALUE(cmd->byte_mode, op1);
-			result = UINT32(value1 + GET_VALUE(cmd->byte_mode, op2));
-			rarvm_data->Flags = result==0 ? VM_FZ : (result<value1)|(result&VM_FS);
-			SET_VALUE(cmd->byte_mode, op1, result);
-			break;
-		case VM_ADDB:
-			SET_VALUE(TRUE, op1, GET_VALUE(TRUE, op1)+GET_VALUE(TRUE, op2));
-			break;
-		case VM_ADDD:
-			SET_VALUE(FALSE, op1, GET_VALUE(FALSE, op1)+GET_VALUE(FALSE, op2));
-			break;
-		case VM_SUB:
-			value1 = GET_VALUE(cmd->byte_mode, op1);
-			result = UINT32(value1 - GET_VALUE(cmd->byte_mode, op2));
-			rarvm_data->Flags = result==0 ? VM_FZ : (result>value1)|(result&VM_FS);
-			SET_VALUE(cmd->byte_mode, op1, result);
-			break;
-		case VM_SUBB:
-			SET_VALUE(TRUE, op1, GET_VALUE(TRUE, op1)-GET_VALUE(TRUE, op2));
-			break;
-		case VM_SUBD:
-			SET_VALUE(FALSE, op1, GET_VALUE(FALSE, op1)-GET_VALUE(FALSE, op2));
-			break;
-		case VM_JZ:
-			if ((rarvm_data->Flags & VM_FZ) != 0) {
-				SET_IP(GET_VALUE(FALSE, op1));
-				continue;
-			}
-			break;
-		case VM_JNZ:
-			if ((rarvm_data->Flags & VM_FZ) == 0) {
-				SET_IP(GET_VALUE(FALSE, op1));
-				continue;
-			}
-			break;
-		case VM_INC:
-			result = UINT32(GET_VALUE(cmd->byte_mode, op1)+1);
-			SET_VALUE(cmd->byte_mode, op1, result);
-			rarvm_data->Flags = result==0 ? VM_FZ : result&VM_FS;
-			break;
-		case VM_INCB:
-			SET_VALUE(TRUE, op1, GET_VALUE(TRUE, op1)+1);
-			break;
-		case VM_INCD:
-			SET_VALUE(FALSE, op1, GET_VALUE(FALSE, op1)+1);
-			break;
-		case VM_DEC:
-			result = UINT32(GET_VALUE(cmd->byte_mode, op1)-1);
-			SET_VALUE(cmd->byte_mode, op1, result);
-			rarvm_data->Flags = result==0 ? VM_FZ : result&VM_FS;
-			break;
-		case VM_DECB:
-			SET_VALUE(TRUE, op1, GET_VALUE(TRUE, op1)-1);
-			break;
-		case VM_DECD:
-			SET_VALUE(FALSE, op1, GET_VALUE(FALSE, op1)-1);
-			break;
-		case VM_JMP:
-			SET_IP(GET_VALUE(FALSE, op1));
-			continue;
-		case VM_XOR:
-			result = UINT32(GET_VALUE(cmd->byte_mode, op1)^GET_VALUE(cmd->byte_mode, op2));
-			rarvm_data->Flags = result==0 ? VM_FZ : result&VM_FS;
-			SET_VALUE(cmd->byte_mode, op1, result);
-			break;
-		case VM_AND:
-			result = UINT32(GET_VALUE(cmd->byte_mode, op1)&GET_VALUE(cmd->byte_mode, op2));
-			rarvm_data->Flags = result==0 ? VM_FZ : result&VM_FS;
-			SET_VALUE(cmd->byte_mode, op1, result);
-			break;
-		case VM_OR:
-			result = UINT32(GET_VALUE(cmd->byte_mode, op1)|GET_VALUE(cmd->byte_mode, op2));
-			rarvm_data->Flags = result==0 ? VM_FZ : result&VM_FS;
-			SET_VALUE(cmd->byte_mode, op1, result);
-			break;
-		case VM_TEST:
-			result = UINT32(GET_VALUE(cmd->byte_mode, op1)&GET_VALUE(cmd->byte_mode, op2));
-			rarvm_data->Flags = result==0 ? VM_FZ : result&VM_FS;
-			break;
-		case VM_JS:
-			if ((rarvm_data->Flags & VM_FS) != 0) {
-				SET_IP(GET_VALUE(FALSE, op1));
-				continue;
-			}
-			break;
-		case VM_JNS:
-			if ((rarvm_data->Flags & VM_FS) == 0) {
-				SET_IP(GET_VALUE(FALSE, op1));
-				continue;
-			}
-			break;
-		case VM_JB:
-			if ((rarvm_data->Flags & VM_FC) != 0) {
-				SET_IP(GET_VALUE(FALSE, op1));
-				continue;
-			}
-			break;
-		case VM_JBE:
-			if ((rarvm_data->Flags & (VM_FC|VM_FZ)) != 0) {
-				SET_IP(GET_VALUE(FALSE, op1));
-				continue;
-			}
-			break;
-		case VM_JA:
-			if ((rarvm_data->Flags & (VM_FC|VM_FZ)) == 0) {
-				SET_IP(GET_VALUE(FALSE, op1));
-				continue;
-			}
-			break;
-		case VM_JAE:
-			if ((rarvm_data->Flags & VM_FC) == 0) {
-				SET_IP(GET_VALUE(FALSE, op1));
-				continue;
-			}
-			break;
-		case VM_PUSH:
-			rarvm_data->R[7] -= 4;
-			SET_VALUE(FALSE, (unsigned int *)&rarvm_data->mem[rarvm_data->R[7] &
-				RARVM_MEMMASK],	GET_VALUE(FALSE, op1));
-			break;
-		case VM_POP:
-			SET_VALUE(FALSE, op1, GET_VALUE(FALSE,
-				(unsigned int *)&rarvm_data->mem[rarvm_data->R[7] & RARVM_MEMMASK]));
-			rarvm_data->R[7] += 4;
-			break;
-		case VM_CALL:
-			rarvm_data->R[7] -= 4;
-			SET_VALUE(FALSE, (unsigned int *)&rarvm_data->mem[rarvm_data->R[7] &
-					RARVM_MEMMASK], cmd-prepared_code+1);
-			SET_IP(GET_VALUE(FALSE, op1));
-			continue;
-		case VM_NOT:
-			SET_VALUE(cmd->byte_mode, op1, ~GET_VALUE(cmd->byte_mode, op1));
-			break;
-		case VM_SHL:
-			value1 = GET_VALUE(cmd->byte_mode, op1);
-			value2 = GET_VALUE(cmd->byte_mode, op1);
-			result = UINT32(value1 << value2);
-			rarvm_data->Flags = (result==0 ? VM_FZ : (result&VM_FS))|
-				((value1 << (value2-1))&0x80000000 ? VM_FC:0);
-			SET_VALUE(cmd->byte_mode, op1, result);
-			break;
-		case VM_SHR:
-			value1 = GET_VALUE(cmd->byte_mode, op1);
-			value2 = GET_VALUE(cmd->byte_mode, op1);
-			result = UINT32(value1 >> value2);
-			rarvm_data->Flags = (result==0 ? VM_FZ : (result&VM_FS))|
-				((value1 >> (value2-1)) & VM_FC);
-			SET_VALUE(cmd->byte_mode, op1, result);
-			break;
-		case VM_SAR:
-			value1 = GET_VALUE(cmd->byte_mode, op1);
-			value2 = GET_VALUE(cmd->byte_mode, op1);
-			result = UINT32(((int)value1) >> value2);
-			rarvm_data->Flags = (result==0 ? VM_FZ : (result&VM_FS))|
-				((value1 >> (value2-1)) & VM_FC);
-			SET_VALUE(cmd->byte_mode, op1, result);
-			break;
-		case VM_NEG:
-			result = UINT32(-GET_VALUE(cmd->byte_mode, op1));
-			rarvm_data->Flags = result==0 ? VM_FZ:VM_FC|(result&VM_FS);
-			SET_VALUE(cmd->byte_mode, op1, result);
-			break;
-		case VM_NEGB:
-			SET_VALUE(TRUE, op1, -GET_VALUE(TRUE, op1));
-			break;
-		case VM_NEGD:
-			SET_VALUE(FALSE, op1, -GET_VALUE(FALSE, op1));
-			break;
-		case VM_PUSHA:
-			for (i=0, SP=rarvm_data->R[7]-4 ; i<reg_count ; i++, SP-=4) {
-				SET_VALUE(FALSE,
-					(unsigned int *)&rarvm_data->mem[SP & RARVM_MEMMASK],
-					rarvm_data->R[i]);
-			}
-			rarvm_data->R[7] -= reg_count*4;
-			break;
-		case VM_POPA:
-			for (i=0,SP=rarvm_data->R[7] ; i<reg_count ; i++, SP+=4) {
-				rarvm_data->R[7-i] = GET_VALUE(FALSE,
-					(unsigned int *)&rarvm_data->mem[SP & RARVM_MEMMASK]);
-			}
-			break;
-		case VM_PUSHF:
-			rarvm_data->R[7] -= 4;
-			SET_VALUE(FALSE,
-				(unsigned int *)&rarvm_data->mem[rarvm_data->R[7] & RARVM_MEMMASK],
-				rarvm_data->Flags);
-			break;
-		case VM_POPF:
-			rarvm_data->Flags = GET_VALUE(FALSE,
-				(unsigned int *)&rarvm_data->mem[rarvm_data->R[7] & RARVM_MEMMASK]);
-			rarvm_data->R[7] += 4;
-			break;
-		case VM_MOVZX:
-			SET_VALUE(FALSE, op1, GET_VALUE(TRUE, op2));
-			break;
-		case VM_MOVSX:
-			SET_VALUE(FALSE, op1, (signed char)GET_VALUE(TRUE, op2));
-			break;
-		case VM_XCHG:
-			value1 = GET_VALUE(cmd->byte_mode, op1);
-			SET_VALUE(cmd->byte_mode, op1, GET_VALUE(cmd->byte_mode, op2));
-			SET_VALUE(cmd->byte_mode, op2, value1);
-			break;
-		case VM_MUL:
-			result = GET_VALUE(cmd->byte_mode, op1) * GET_VALUE(cmd->byte_mode, op2);
-			SET_VALUE(cmd->byte_mode, op1, result);
-			break;
-		case VM_DIV:
-			divider = GET_VALUE(cmd->byte_mode, op2);
-			if (divider != 0) {
-				result = GET_VALUE(cmd->byte_mode, op1) / divider;
-				SET_VALUE(cmd->byte_mode, op1, result);
-			}
-			break;
-		case VM_ADC:
-			value1 = GET_VALUE(cmd->byte_mode, op1);
-			FC = (rarvm_data->Flags & VM_FC);
-			result = UINT32(value1+GET_VALUE(cmd->byte_mode, op2)+FC);
-			rarvm_data->Flags = result==0 ? VM_FZ:(result<value1 ||
-				(result==value1 && FC))|(result&VM_FS);
-			SET_VALUE(cmd->byte_mode, op1, result);
-			break;
-		case VM_SBB:
-			value1 = GET_VALUE(cmd->byte_mode, op1);
-			FC = (rarvm_data->Flags & VM_FC);
-			result = UINT32(value1-GET_VALUE(cmd->byte_mode, op2)-FC);
-			rarvm_data->Flags = result==0 ? VM_FZ:(result>value1 ||
-				(result==value1 && FC))|(result&VM_FS);
-			SET_VALUE(cmd->byte_mode, op1, result);
-			break;
-		case VM_RET:
-			if (rarvm_data->R[7] >= RARVM_MEMSIZE) {
-				return TRUE;
-			}
-			SET_IP(GET_VALUE(FALSE, (unsigned int *)&rarvm_data->mem[rarvm_data->R[7] &
-				RARVM_MEMMASK]));
-			rarvm_data->R[7] += 4;
-			continue;
-		case VM_STANDARD:
-			execute_standard_filter(rarvm_data,
-					(rarvm_standard_filters_t)cmd->op1.data);
-			break;
-		case VM_PRINT:
-			/* DEBUG */
-			break;
-		}
-		cmd++;
-		--max_ops;
-	}
-}
-
-int rarvm_execute(rarvm_data_t *rarvm_data, struct rarvm_prepared_program *prg)
-{
-	unsigned int global_size, static_size, new_pos, new_size, data_size;
-	struct rarvm_prepared_command *prepared_code;
-	
-	rar_dbgmsg("in rarvm_execute\n");
-	memcpy(rarvm_data->R, prg->init_r, sizeof(prg->init_r));
-	global_size = MIN(prg->global_size, VM_GLOBALMEMSIZE);
-	if (global_size) {
-		memcpy(rarvm_data->mem+VM_GLOBALMEMADDR, &prg->global_data[0], global_size);
-	}
-	static_size = MIN(prg->static_size, VM_GLOBALMEMSIZE-global_size);
-	if (static_size) {
-		memcpy(rarvm_data->mem+VM_GLOBALMEMADDR+global_size,
-				&prg->static_data[0], static_size);
-	}
-	
-	rarvm_data->R[7] = RARVM_MEMSIZE;
-	rarvm_data->Flags = 0;
-	
-	prepared_code=prg->alt_cmd ? prg->alt_cmd : &prg->cmd.array[0];
-	if(!prepared_code) {
-	    rar_dbgmsg("unrar: rarvm_execute: prepared_code == NULL\n");
-	    return FALSE;
-	}
-	if (!rarvm_execute_code(rarvm_data, prepared_code, prg->cmd_count)) {
-		prepared_code[0].op_code = VM_RET;
-	}
-	new_pos = GET_VALUE(FALSE, &rarvm_data->mem[VM_GLOBALMEMADDR+0x20])&RARVM_MEMMASK;
-	new_size = GET_VALUE(FALSE, &rarvm_data->mem[VM_GLOBALMEMADDR+0x1c])&RARVM_MEMMASK;
-	if (new_pos+new_size >= RARVM_MEMSIZE) {
-		new_pos = new_size = 0;
-	}
-	prg->filtered_data = rarvm_data->mem + new_pos;
-	prg->filtered_data_size = new_size;
-	
-	if (prg->global_data) {
-		free(prg->global_data);
-		prg->global_data = NULL;
-		prg->global_size = 0;
-	}
-	data_size = MIN(GET_VALUE(FALSE,
-		(unsigned int *)&rarvm_data->mem[VM_GLOBALMEMADDR+0x30]),VM_GLOBALMEMSIZE);
-	if (data_size != 0) {
-		prg->global_size += data_size+VM_FIXEDGLOBALSIZE;
-		prg->global_data = rar_realloc2(prg->global_data, prg->global_size);
-		if(!prg->global_data) {
-		    rar_dbgmsg("unrar: rarvm_execute: rar_realloc2 failed for prg->global_data\n");
-		    return FALSE;
-		}
-		memcpy(prg->global_data, &rarvm_data->mem[VM_GLOBALMEMADDR],
-				data_size+VM_FIXEDGLOBALSIZE);
-	}
-
-	return TRUE;
-}
-
-void rarvm_decode_arg(rarvm_data_t *rarvm_data, rarvm_input_t *rarvm_input,
-		struct rarvm_prepared_operand *op, int byte_mode)
-{
-	uint16_t data;
-	
-	data = rarvm_getbits(rarvm_input);
-	if (data & 0x8000) {
-		op->type = VM_OPREG;
-		op->data = (data >> 12) & 7;
-		op->addr = &rarvm_data->R[op->data];
-		rarvm_addbits(rarvm_input,4);
-	} else if ((data & 0xc000) == 0) {
-		op->type = VM_OPINT;
-		if (byte_mode) {
-			op->data = (data>>6) & 0xff;
-			rarvm_addbits(rarvm_input,10);
-		} else {
-			rarvm_addbits(rarvm_input,2);
-			op->data = rarvm_read_data(rarvm_input);
-		}
-	} else {
-		op->type = VM_OPREGMEM;
-		if ((data & 0x2000) == 0) {
-			op->data = (data >> 10) & 7;
-			op->addr = &rarvm_data->R[op->data];
-			op->base = 0;
-			rarvm_addbits(rarvm_input,6);
-		} else {
-			if ((data & 0x1000) == 0) {
-				op->data = (data >> 9) & 7;
-				op->addr = &rarvm_data->R[op->data];
-				rarvm_addbits(rarvm_input,7);
-			} else {
-				op->data = 0;
-				rarvm_addbits(rarvm_input,4);
-			}
-			op->base = rarvm_read_data(rarvm_input);
-		}
-	}
-}
-
-void rarvm_optimize(struct rarvm_prepared_program *prg)
-{
-	struct rarvm_prepared_command *code, *cmd;
-	int code_size, i, flags_required, j, flags;
-	
-	code = prg->cmd.array;
-	code_size = prg->cmd_count;
-	
-	for (i=0 ; i < code_size ; i++) {
-		cmd = &code[i];
-		switch(cmd->op_code) {
-			case VM_MOV:
-				cmd->op_code = cmd->byte_mode ? VM_MOVB:VM_MOVD;
-				continue;
-			case VM_CMP:
-				cmd->op_code = cmd->byte_mode ? VM_CMPB:VM_CMPD;
-				continue;
-		}
-		if ((vm_cmdflags[cmd->op_code] & VMCF_CHFLAGS) == 0) {
-			continue;
-		}
-		flags_required = FALSE;
-		for (j=i+1 ; j < code_size ; j++) {
-			flags = vm_cmdflags[code[j].op_code];
-			if (flags & (VMCF_JUMP|VMCF_PROC|VMCF_USEFLAGS)) {
-				flags_required=TRUE;
-				break;
-			}
-			if (flags & VMCF_CHFLAGS) {
-				break;
-			}
-		}
-		if (flags_required) {
-			continue;
-		}
-		switch(cmd->op_code) {
-			case VM_ADD:
-				cmd->op_code = cmd->byte_mode ? VM_ADDB:VM_ADDD;
-				continue;
-			case VM_SUB:
-				cmd->op_code = cmd->byte_mode ? VM_SUBB:VM_SUBD;
-				continue;
-			case VM_INC:
-				cmd->op_code = cmd->byte_mode ? VM_INCB:VM_INCD;
-				continue;
-			case VM_DEC:
-				cmd->op_code = cmd->byte_mode ? VM_DECB:VM_DECD;
-				continue;
-			case VM_NEG:
-				cmd->op_code = cmd->byte_mode ? VM_NEGB:VM_NEGD;
-				continue;
-		}
-	}
-}
-
-int rarvm_prepare(rarvm_data_t *rarvm_data, rarvm_input_t *rarvm_input, unsigned char *code,
-		int code_size, struct rarvm_prepared_program *prg)
-{
-	unsigned char xor_sum;
-	int i, op_num, distance;
-	rarvm_standard_filters_t filter_type;
-	struct rarvm_prepared_command *cur_cmd;
-	uint32_t data_flag, data;
- 	struct rarvm_prepared_command *cmd;
- 	
- 	rar_dbgmsg("in rarvm_prepare code_size=%d\n", code_size);
-	rarvm_input->in_addr = rarvm_input->in_bit = 0;
-	memcpy(rarvm_input->in_buf, code, MIN(code_size, 0x8000));
-	xor_sum = 0;
-	for (i=1 ; i<code_size; i++) {
-		rar_dbgmsg("code[%d]=%d\n", i, code[i]);
-		xor_sum ^= code[i];
-	}
-	rar_dbgmsg("xor_sum=%d\n", xor_sum);
-	rarvm_addbits(rarvm_input,8);
-	
-	prg->cmd_count = 0;
-	if (xor_sum == code[0]) {
-		filter_type = is_standard_filter(code, code_size);
-		rar_dbgmsg("filter_type=%d\n", filter_type);
-		if (filter_type != VMSF_NONE) {
-			rar_cmd_array_add(&prg->cmd, 1);
-			cur_cmd = &prg->cmd.array[prg->cmd_count++];
-			cur_cmd->op_code = VM_STANDARD;
-			cur_cmd->op1.data = filter_type;
-			cur_cmd->op1.addr = &cur_cmd->op1.data;
-			cur_cmd->op2.addr = &cur_cmd->op2.data;
-			cur_cmd->op1.type = cur_cmd->op2.type = VM_OPNONE;
-			code_size = 0;
-		}
-
-		data_flag = rarvm_getbits(rarvm_input);
-		rar_dbgmsg("data_flag=%u\n", data_flag);
-		rarvm_addbits(rarvm_input, 1);
-		if (data_flag & 0x8000) {
-			int data_size = rarvm_read_data(rarvm_input)+1;
-			rar_dbgmsg("data_size=%d\n", data_size);
-			prg->static_data = rar_malloc(data_size);
-			if(!prg->static_data) {
-			    rar_dbgmsg("unrar: rarvm_prepare: rar_malloc failed for prg->static_data\n");
-			    return FALSE;
-			}
-			for (i=0 ; rarvm_input->in_addr < code_size && i < data_size ; i++) {
-				prg->static_size++;
-				prg->static_data = rar_realloc2(prg->static_data, prg->static_size);
-				if(!prg->static_data) {
-				    rar_dbgmsg("unrar: rarvm_prepare: rar_realloc2 failed for prg->static_data\n");
-				    return FALSE;
-				}
-				prg->static_data[i] = rarvm_getbits(rarvm_input) >> 8;
-				rarvm_addbits(rarvm_input, 8);
-			}
-		}
-		while (rarvm_input->in_addr < code_size) {
-			rar_cmd_array_add(&prg->cmd, 1);
-			cur_cmd = &prg->cmd.array[prg->cmd_count];
-			data = rarvm_getbits(rarvm_input);
-			rar_dbgmsg("data: %u\n", data);
-			if ((data & 0x8000) == 0) {
-				cur_cmd->op_code = (rarvm_commands_t) (data>>12);
-				rarvm_addbits(rarvm_input, 4);
-			} else {
-				cur_cmd->op_code = (rarvm_commands_t) ((data>>10)-24);
-				rarvm_addbits(rarvm_input, 6);
-			}
-			if (vm_cmdflags[cur_cmd->op_code] & VMCF_BYTEMODE) {
-				cur_cmd->byte_mode = rarvm_getbits(rarvm_input) >> 15;
-				rarvm_addbits(rarvm_input, 1);
-			} else {
-				cur_cmd->byte_mode = 0;
-			}
-			cur_cmd->op1.type = cur_cmd->op2.type = VM_OPNONE;
-			op_num = (vm_cmdflags[cur_cmd->op_code] & VMCF_OPMASK);
-			rar_dbgmsg("op_num: %d\n", op_num);
-			cur_cmd->op1.addr = cur_cmd->op2.addr = NULL;
-			if (op_num > 0) {
-				rarvm_decode_arg(rarvm_data, rarvm_input,
-					&cur_cmd->op1, cur_cmd->byte_mode);
-				if (op_num == 2) {
-					rarvm_decode_arg(rarvm_data, rarvm_input,
-							&cur_cmd->op2, cur_cmd->byte_mode);
-				} else {
-					if (cur_cmd->op1.type == VM_OPINT &&
-							(vm_cmdflags[cur_cmd->op_code] &
-							(VMCF_JUMP|VMCF_PROC))) {
-						distance = cur_cmd->op1.data;
-						rar_dbgmsg("distance = %d\n", distance);
-						if (distance >= 256) {
-							distance -= 256;
-						} else {
-							if (distance >=136) {
-								distance -= 264;
-							} else {
-								if (distance >= 16) {
-									distance -= 8;
-								} else if (distance >= 8) {
-									distance -= 16;
-								}
-							}
-							distance += prg->cmd_count;
-						}
-						rar_dbgmsg("distance = %d\n", distance);
-						cur_cmd->op1.data = distance;
-					}
-				}
-			}
-			prg->cmd_count++;
-		}
-	}
-	rar_cmd_array_add(&prg->cmd,1);
-	cur_cmd = &prg->cmd.array[prg->cmd_count++];
-	cur_cmd->op_code = VM_RET;
-	cur_cmd->op1.addr = &cur_cmd->op1.data;
-	cur_cmd->op2.addr = &cur_cmd->op2.data;
-	cur_cmd->op1.type = cur_cmd->op2.type = VM_OPNONE;
-	
-	for (i=0 ; i < prg->cmd_count ; i++) {
-		cmd = &prg->cmd.array[i];
-		rar_dbgmsg("op_code[%d]=%d\n", i, cmd->op_code);
-		if (cmd->op1.addr == NULL) {
-			cmd->op1.addr = &cmd->op1.data;
-		}
-		if (cmd->op2.addr == NULL) {
-			cmd->op2.addr = &cmd->op2.data;
-		}
-	}
-
-	if (code_size!=0) {
-		rarvm_optimize(prg);
-	}
-
-	return TRUE;
-}
diff -ruN clamav-0.92.1~dfsg/libclamunrar/unrarvm.h clamav-0.92.1~dfsg2/libclamunrar/unrarvm.h
--- clamav-0.92.1~dfsg/libclamunrar/unrarvm.h	2007-11-21 08:54:56.000000000 -0500
+++ clamav-0.92.1~dfsg2/libclamunrar/unrarvm.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,115 +0,0 @@
-/*
- * Extract RAR archives
- *
- * Copyright (C) 2005-2006 trog@uncon.org
- *
- * This code is based on the work of Alexander L. Roshal (C)
- *
- * The unRAR sources may be used in any software to handle RAR
- * archives without limitations free of charge, but cannot be used
- * to re-create the RAR compression algorithm, which is proprietary.
- * Distribution of modified unRAR sources in separate form or as a
- * part of other software is permitted, provided that it is clearly
- * stated in the documentation and source comments that the code may
- * not be used to develop a RAR (WinRAR) compatible archiver.
- *
- */
-
-
-#ifndef _RAR_VM_
-#define _RAR_VM_
-
-#include "libclamunrar/unrarcmd.h"
-
-#define FALSE (0)
-#define TRUE (1)
-#ifndef MIN
-#define MIN(a,b) ((a < b) ? a : b)
-#endif
-
-#define RARVM_MEMSIZE	0x40000
-#define RARVM_MEMMASK	(RARVM_MEMSIZE-1)
-
-#define VM_GLOBALMEMADDR            0x3C000
-#define VM_GLOBALMEMSIZE             0x2000
-#define VM_FIXEDGLOBALSIZE               64
-
-typedef enum rarvm_commands
-{
-  VM_MOV,  VM_CMP,  VM_ADD,  VM_SUB,  VM_JZ,   VM_JNZ,  VM_INC,  VM_DEC,
-  VM_JMP,  VM_XOR,  VM_AND,  VM_OR,   VM_TEST, VM_JS,   VM_JNS,  VM_JB,
-  VM_JBE,  VM_JA,   VM_JAE,  VM_PUSH, VM_POP,  VM_CALL, VM_RET,  VM_NOT,
-  VM_SHL,  VM_SHR,  VM_SAR,  VM_NEG,  VM_PUSHA,VM_POPA, VM_PUSHF,VM_POPF,
-  VM_MOVZX,VM_MOVSX,VM_XCHG, VM_MUL,  VM_DIV,  VM_ADC,  VM_SBB,  VM_PRINT,
-  VM_MOVB, VM_MOVD, VM_CMPB, VM_CMPD, VM_ADDB, VM_ADDD, VM_SUBB, VM_SUBD,
-  VM_INCB, VM_INCD, VM_DECB, VM_DECD, VM_NEGB, VM_NEGD, VM_STANDARD
-} rarvm_commands_t;
-
-typedef enum rarvm_standard_filters {
-  VMSF_NONE, VMSF_E8, VMSF_E8E9, VMSF_ITANIUM, VMSF_RGB, VMSF_AUDIO,
-  VMSF_DELTA, VMSF_UPCASE
-} rarvm_standard_filters_t;
-
-enum VM_Flags {
-	VM_FC=1,
-	VM_FZ=2,
-	VM_FS=0x80000000
-};
-
-enum rarvm_op_type {
-	VM_OPREG,
-	VM_OPINT,
-	VM_OPREGMEM,
-	VM_OPNONE
-};
-
-struct rarvm_prepared_operand {
-	enum rarvm_op_type type;
-	unsigned int data;
-	unsigned int base;
-	unsigned int *addr;
-};
-
-struct rarvm_prepared_command {
-	rarvm_commands_t op_code;
-	int byte_mode;
-	struct rarvm_prepared_operand op1, op2;
-};
-
-struct rarvm_prepared_program {
-	rar_cmd_array_t cmd;
-	struct rarvm_prepared_command *alt_cmd;
-	int cmd_count;
-	unsigned char *global_data;
-	unsigned char *static_data;
-	long global_size, static_size;
-	unsigned int init_r[7];
-	uint8_t *filtered_data;
-	unsigned int filtered_data_size;
-};
-
-typedef struct rarvm_input_tag {
-	unsigned char *in_buf;
-	int buf_size;
-	int in_addr;
-	int in_bit;
-} rarvm_input_t;
-
-typedef struct rarvm_data_tag {
-	uint8_t *mem;
-	unsigned int R[8];
-	unsigned int Flags;
-} rarvm_data_t;
-
-unsigned int rarvm_getbits(rarvm_input_t *rarvm_input);
-void rarvm_addbits(rarvm_input_t *rarvm_input, int bits);
-int rarvm_init(rarvm_data_t *rarvm_data);
-void rarvm_free(rarvm_data_t *rarvm_data);
-int rarvm_prepare(rarvm_data_t *rarvm_data, rarvm_input_t *rarvm_input, unsigned char *code,
-		int code_size, struct rarvm_prepared_program *prg);
-void rarvm_set_memory(rarvm_data_t *rarvm_data, unsigned int pos, uint8_t *data, unsigned int data_size);
-int rarvm_execute(rarvm_data_t *rarvm_data, struct rarvm_prepared_program *prg);
-void rarvm_set_value(int byte_mode, unsigned int *addr, unsigned int value);
-unsigned int rarvm_read_data(rarvm_input_t *rarvm_input);
-uint32_t rar_crc(uint32_t start_crc, void *addr, uint32_t size);
-#endif
