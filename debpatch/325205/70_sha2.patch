diff -Nru coreutils-5.97.orig/AUTHORS coreutils-5.97/AUTHORS
--- coreutils-5.97.orig/AUTHORS	2004-11-04 00:10:50.000000000 +0100
+++ coreutils-5.97/AUTHORS	2006-07-31 13:51:41.000000000 +0200
@@ -39,7 +39,7 @@
 ln: Mike Parker, David MacKenzie
 logname: FIXME: unknown
 ls: Richard Stallman, David MacKenzie
-md5sum: Ulrich Drepper, Scott Miller
+md5sum: Ulrich Drepper, Scott Miller, David Madore
 mkdir: David MacKenzie
 mkfifo: David MacKenzie
 mknod: David MacKenzie
@@ -60,7 +60,11 @@
 rm: Paul Rubin, David MacKenzie, Richard Stallman, Jim Meyering
 rmdir: David MacKenzie
 seq: Ulrich Drepper
-sha1sum: Ulrich Drepper, Scott Miller
+sha1sum: Ulrich Drepper, Scott Miller, David Madore
+sha224sum: Ulrich Drepper, Scott Miller, David Madore
+sha256sum: Ulrich Drepper, Scott Miller, David Madore
+sha384sum: Ulrich Drepper, Scott Miller, David Madore
+sha512sum: Ulrich Drepper, Scott Miller, David Madore
 shred: Colin Plumb
 sleep: Jim Meyering, Paul Eggert
 sort: Mike Haertel, Paul Eggert
diff -Nru coreutils-5.97.orig/README coreutils-5.97/README
--- coreutils-5.97.orig/README	2006-07-31 14:16:25.000000000 +0200
+++ coreutils-5.97/README	2006-07-31 13:51:41.000000000 +0200
@@ -11,8 +11,9 @@
   df dir dircolors dirname du echo env expand expr factor false fmt fold
   ginstall groups head hostid hostname id join kill link ln logname ls
   md5sum mkdir mkfifo mknod mv nice nl nohup od paste pathchk pinky pr
-  printenv printf ptx pwd readlink rm rmdir runcon seq sha1sum shred sleep sort
-  split stat stty su sum sync tac tail tee test touch tr true tsort tty
+  printenv printf ptx pwd readlink rm rmdir runcon seq sha1sum
+  sha224sum sha256sum sha384sum sha512sum shred sleep sort split stat
+  stty su sum sync tac tail tee test touch tr true tsort tty
   uname unexpand uniq unlink uptime users vdir wc who whoami yes
 
 See the file NEWS for a list of major changes in the current release.
diff -Nru coreutils-5.97.orig/config/compile coreutils-5.97/config/compile
--- coreutils-5.97.orig/config/compile	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-5.97/config/compile	2006-07-31 13:51:41.000000000 +0200
@@ -0,0 +1,136 @@
+#! /bin/sh
+# Wrapper for compilers which do not understand `-c -o'.
+
+scriptversion=2003-11-09.00
+
+# Copyright (C) 1999, 2000, 2003 Free Software Foundation, Inc.
+# Written by Tom Tromey <tromey@cygnus.com>.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# This file is maintained in Automake, please report
+# bugs to <bug-automake@gnu.org> or send patches to
+# <automake-patches@gnu.org>.
+
+case $1 in
+  '')
+     echo "$0: No command.  Try \`$0 --help' for more information." 1>&2
+     exit 1;
+     ;;
+  -h | --h*)
+    cat <<\EOF
+Usage: compile [--help] [--version] PROGRAM [ARGS]
+
+Wrapper for compilers which do not understand `-c -o'.
+Remove `-o dest.o' from ARGS, run PROGRAM with the remaining
+arguments, and rename the output as expected.
+
+If you are trying to build a whole package this is not the
+right script to run: please start by reading the file `INSTALL'.
+
+Report bugs to <bug-automake@gnu.org>.
+EOF
+    exit 0
+    ;;
+  -v | --v*)
+    echo "compile $scriptversion"
+    exit 0
+    ;;
+esac
+
+
+prog=$1
+shift
+
+ofile=
+cfile=
+args=
+while test $# -gt 0; do
+  case "$1" in
+    -o)
+      # configure might choose to run compile as `compile cc -o foo foo.c'.
+      # So we do something ugly here.
+      ofile=$2
+      shift
+      case "$ofile" in
+	*.o | *.obj)
+	  ;;
+	*)
+	  args="$args -o $ofile"
+	  ofile=
+	  ;;
+      esac
+       ;;
+    *.c)
+      cfile=$1
+      args="$args $1"
+      ;;
+    *)
+      args="$args $1"
+      ;;
+  esac
+  shift
+done
+
+if test -z "$ofile" || test -z "$cfile"; then
+  # If no `-o' option was seen then we might have been invoked from a
+  # pattern rule where we don't need one.  That is ok -- this is a
+  # normal compilation that the losing compiler can handle.  If no
+  # `.c' file was seen then we are probably linking.  That is also
+  # ok.
+  exec "$prog" $args
+fi
+
+# Name of file we expect compiler to create.
+cofile=`echo $cfile | sed -e 's|^.*/||' -e 's/\.c$/.o/'`
+
+# Create the lock directory.
+# Note: use `[/.-]' here to ensure that we don't use the same name
+# that we are using for the .o file.  Also, base the name on the expected
+# object file name, since that is what matters with a parallel build.
+lockdir=`echo $cofile | sed -e 's|[/.-]|_|g'`.d
+while true; do
+  if mkdir $lockdir > /dev/null 2>&1; then
+    break
+  fi
+  sleep 1
+done
+# FIXME: race condition here if user kills between mkdir and trap.
+trap "rmdir $lockdir; exit 1" 1 2 15
+
+# Run the compile.
+"$prog" $args
+status=$?
+
+if test -f "$cofile"; then
+  mv "$cofile" "$ofile"
+fi
+
+rmdir $lockdir
+exit $status
+
+# Local Variables:
+# mode: shell-script
+# sh-indentation: 2
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-end: "$"
+# End:
diff -Nru coreutils-5.97.orig/configure.ac coreutils-5.97/configure.ac
--- coreutils-5.97.orig/configure.ac	2006-07-31 14:16:25.000000000 +0200
+++ coreutils-5.97/configure.ac	2006-07-31 13:51:41.000000000 +0200
@@ -299,6 +299,10 @@
   tests/rmdir/Makefile
   tests/seq/Makefile
   tests/sha1sum/Makefile
+  tests/sha224sum/Makefile
+  tests/sha256sum/Makefile
+  tests/sha384sum/Makefile
+  tests/sha512sum/Makefile
   tests/shred/Makefile
   tests/sort/Makefile
   tests/stty/Makefile
diff -Nru coreutils-5.97.orig/lib/sha256.c coreutils-5.97/lib/sha256.c
--- coreutils-5.97.orig/lib/sha256.c	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-5.97/lib/sha256.c	2006-07-31 14:00:56.000000000 +0200
@@ -0,0 +1,552 @@
+/* sha256.c - Functions to compute SHA256 and SHA224 message digest of files or
+   memory blocks according to the NIST specification FIPS-180-2.
+
+   Copyright (C) 2000, 2001, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2, or (at your option) any
+   later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* Written by David Madore, considerably copypasting from
+   Scott G. Miller's sha1.c
+*/
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include "sha256.h"
+
+#include <stddef.h>
+#include <string.h>
+
+#if USE_UNLOCKED_IO
+# include "unlocked-io.h"
+#endif
+
+/* SWAP does an endian swap on architectures that are little-endian,
+   as SHA256 needs some data in a big-endian form.  */
+
+#ifdef WORDS_BIGENDIAN
+# define SWAP(n) (n)
+#else
+# define SWAP(n) \
+    (((n) << 24) | (((n) & 0xff00) << 8) | (((n) >> 8) & 0xff00) | ((n) >> 24))
+#endif
+
+#define BLOCKSIZE 4096
+#if BLOCKSIZE % 64 != 0
+# error "invalid BLOCKSIZE"
+#endif
+
+/* This array contains the bytes used to pad the buffer to the next
+   64-byte boundary.   */
+static const unsigned char fillbuf[64] = { 0x80, 0 /* , 0, 0, ...  */ };
+
+
+/*
+  Takes a pointer to a 256 bit block of data (eight 32 bit ints) and
+  intializes it to the start constants of the SHA256 algorithm.  This
+  must be called before using hash in the call to sha256_hash
+*/
+void
+sha256_init_ctx (struct sha256_ctx *ctx)
+{
+  ctx->state[0] = 0x6a09e667UL;
+  ctx->state[1] = 0xbb67ae85UL;
+  ctx->state[2] = 0x3c6ef372UL;
+  ctx->state[3] = 0xa54ff53aUL;
+  ctx->state[4] = 0x510e527fUL;
+  ctx->state[5] = 0x9b05688cUL;
+  ctx->state[6] = 0x1f83d9abUL;
+  ctx->state[7] = 0x5be0cd19UL;
+
+  ctx->total[0] = ctx->total[1] = 0;
+  ctx->buflen = 0;
+}
+
+void
+sha224_init_ctx (struct sha256_ctx *ctx)
+{
+  ctx->state[0] = 0xc1059ed8UL;
+  ctx->state[1] = 0x367cd507UL;
+  ctx->state[2] = 0x3070dd17UL;
+  ctx->state[3] = 0xf70e5939UL;
+  ctx->state[4] = 0xffc00b31UL;
+  ctx->state[5] = 0x68581511UL;
+  ctx->state[6] = 0x64f98fa7UL;
+  ctx->state[7] = 0xbefa4fa4UL;
+
+  ctx->total[0] = ctx->total[1] = 0;
+  ctx->buflen = 0;
+}
+
+/* Put result from CTX in first 32 bytes following RESBUF.  The result
+   must be in little endian byte order.
+
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 32 bits value.  */
+void *
+sha256_read_ctx (const struct sha256_ctx *ctx, void *resbuf)
+{
+  int i;
+
+  for ( i=0 ; i<8 ; i++ )
+    ((md5_uint32 *) resbuf)[i] = SWAP (ctx->state[i]);
+
+  return resbuf;
+}
+
+void *
+sha224_read_ctx (const struct sha256_ctx *ctx, void *resbuf)
+{
+  int i;
+
+  for ( i=0 ; i<7 ; i++ )
+    ((md5_uint32 *) resbuf)[i] = SWAP (ctx->state[i]);
+
+  return resbuf;
+}
+
+/* Process the remaining bytes in the internal buffer and the usual
+   prolog according to the standard and write the result to RESBUF.
+
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 32 bits value.  */
+static void
+sha256_conclude_ctx (struct sha256_ctx *ctx)
+{
+  /* Take yet unprocessed bytes into account.  */
+  md5_uint32 bytes = ctx->buflen;
+  size_t pad;
+
+  /* Now count remaining bytes.  */
+  ctx->total[0] += bytes;
+  if (ctx->total[0] < bytes)
+    ++ctx->total[1];
+
+  pad = bytes >= 56 ? 64 + 56 - bytes : 56 - bytes;
+  memcpy (&ctx->buffer[bytes], fillbuf, pad);
+
+  /* Put the 64-bit file length in *bits* at the end of the buffer.  */
+  *(md5_uint32 *) &ctx->buffer[bytes + pad + 4] = SWAP (ctx->total[0] << 3);
+  *(md5_uint32 *) &ctx->buffer[bytes + pad] = SWAP ((ctx->total[1] << 3) |
+						    (ctx->total[0] >> 29));
+
+  /* Process last bytes.  */
+  sha256_process_block (ctx->buffer, bytes + pad + 8, ctx);
+}
+
+void *
+sha256_finish_ctx (struct sha256_ctx *ctx, void *resbuf)
+{
+  sha256_conclude_ctx (ctx);
+  return sha256_read_ctx (ctx, resbuf);
+}
+
+void *
+sha224_finish_ctx (struct sha256_ctx *ctx, void *resbuf)
+{
+  sha256_conclude_ctx (ctx);
+  return sha224_read_ctx (ctx, resbuf);
+}
+
+/* Compute SHA256 message digest for bytes read from STREAM.  The
+   resulting message digest number will be written into the 32 bytes
+   beginning at RESBLOCK.  */
+int
+sha256_stream (FILE *stream, void *resblock)
+{
+  struct sha256_ctx ctx;
+  char buffer[BLOCKSIZE + 72];
+  size_t sum;
+
+  /* Initialize the computation context.  */
+  sha256_init_ctx (&ctx);
+
+  /* Iterate over full file contents.  */
+  while (1)
+    {
+      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the
+	 computation function processes the whole buffer so that with the
+	 next round of the loop another block can be read.  */
+      size_t n;
+      sum = 0;
+
+      /* Read block.  Take care for partial reads.  */
+      while (1)
+	{
+	  n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);
+
+	  sum += n;
+
+	  if (sum == BLOCKSIZE)
+	    break;
+
+	  if (n == 0)
+	    {
+	      /* Check for the error flag IFF N == 0, so that we don't
+		 exit the loop after a partial read due to e.g., EAGAIN
+		 or EWOULDBLOCK.  */
+	      if (ferror (stream))
+		return 1;
+	      goto process_partial_block;
+	    }
+
+	  /* We've read at least one byte, so ignore errors.  But always
+	     check for EOF, since feof may be true even though N > 0.
+	     Otherwise, we could end up calling fread after EOF.  */
+	  if (feof (stream))
+	    goto process_partial_block;
+	}
+
+      /* Process buffer with BLOCKSIZE bytes.  Note that
+			BLOCKSIZE % 64 == 0
+       */
+      sha256_process_block (buffer, BLOCKSIZE, &ctx);
+    }
+
+ process_partial_block:;
+
+  /* Process any remaining bytes.  */
+  if (sum > 0)
+    sha256_process_bytes (buffer, sum, &ctx);
+
+  /* Construct result in desired memory.  */
+  sha256_finish_ctx (&ctx, resblock);
+  return 0;
+}
+
+/* FIXME: Avoid code duplication */
+int
+sha224_stream (FILE *stream, void *resblock)
+{
+  struct sha256_ctx ctx;
+  char buffer[BLOCKSIZE + 72];
+  size_t sum;
+
+  /* Initialize the computation context.  */
+  sha224_init_ctx (&ctx);
+
+  /* Iterate over full file contents.  */
+  while (1)
+    {
+      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the
+	 computation function processes the whole buffer so that with the
+	 next round of the loop another block can be read.  */
+      size_t n;
+      sum = 0;
+
+      /* Read block.  Take care for partial reads.  */
+      while (1)
+	{
+	  n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);
+
+	  sum += n;
+
+	  if (sum == BLOCKSIZE)
+	    break;
+
+	  if (n == 0)
+	    {
+	      /* Check for the error flag IFF N == 0, so that we don't
+		 exit the loop after a partial read due to e.g., EAGAIN
+		 or EWOULDBLOCK.  */
+	      if (ferror (stream))
+		return 1;
+	      goto process_partial_block;
+	    }
+
+	  /* We've read at least one byte, so ignore errors.  But always
+	     check for EOF, since feof may be true even though N > 0.
+	     Otherwise, we could end up calling fread after EOF.  */
+	  if (feof (stream))
+	    goto process_partial_block;
+	}
+
+      /* Process buffer with BLOCKSIZE bytes.  Note that
+			BLOCKSIZE % 64 == 0
+       */
+      sha256_process_block (buffer, BLOCKSIZE, &ctx);
+    }
+
+ process_partial_block:;
+
+  /* Process any remaining bytes.  */
+  if (sum > 0)
+    sha256_process_bytes (buffer, sum, &ctx);
+
+  /* Construct result in desired memory.  */
+  sha224_finish_ctx (&ctx, resblock);
+  return 0;
+}
+
+/* Compute SHA512 message digest for LEN bytes beginning at BUFFER.  The
+   result is always in little endian byte order, so that a byte-wise
+   output yields to the wanted ASCII representation of the message
+   digest.  */
+void *
+sha256_buffer (const char *buffer, size_t len, void *resblock)
+{
+  struct sha256_ctx ctx;
+
+  /* Initialize the computation context.  */
+  sha256_init_ctx (&ctx);
+
+  /* Process whole buffer but last len % 64 bytes.  */
+  sha256_process_bytes (buffer, len, &ctx);
+
+  /* Put result in desired memory area.  */
+  return sha256_finish_ctx (&ctx, resblock);
+}
+
+void *
+sha224_buffer (const char *buffer, size_t len, void *resblock)
+{
+  struct sha256_ctx ctx;
+
+  /* Initialize the computation context.  */
+  sha224_init_ctx (&ctx);
+
+  /* Process whole buffer but last len % 64 bytes.  */
+  sha256_process_bytes (buffer, len, &ctx);
+
+  /* Put result in desired memory area.  */
+  return sha224_finish_ctx (&ctx, resblock);
+}
+
+void
+sha256_process_bytes (const void *buffer, size_t len, struct sha256_ctx *ctx)
+{
+  /* When we already have some bits in our internal buffer concatenate
+     both inputs first.  */
+  if (ctx->buflen != 0)
+    {
+      size_t left_over = ctx->buflen;
+      size_t add = 128 - left_over > len ? len : 128 - left_over;
+
+      memcpy (&ctx->buffer[left_over], buffer, add);
+      ctx->buflen += add;
+
+      if (ctx->buflen > 64)
+	{
+	  sha256_process_block (ctx->buffer, ctx->buflen & ~63, ctx);
+
+	  ctx->buflen &= 63;
+	  /* The regions in the following copy operation cannot overlap.  */
+	  memcpy (ctx->buffer, &ctx->buffer[(left_over + add) & ~63],
+		  ctx->buflen);
+	}
+
+      buffer = (const char *) buffer + add;
+      len -= add;
+    }
+
+  /* Process available complete blocks.  */
+  if (len >= 64)
+    {
+#if !_STRING_ARCH_unaligned
+# define alignof(type) offsetof (struct { char c; type x; }, x)
+# define UNALIGNED_P(p) (((size_t) p) % alignof (md5_uint32) != 0)
+      if (UNALIGNED_P (buffer))
+	while (len > 64)
+	  {
+	    sha256_process_block (memcpy (ctx->buffer, buffer, 64), 64, ctx);
+	    buffer = (const char *) buffer + 64;
+	    len -= 64;
+	  }
+      else
+#endif
+	{
+	  sha256_process_block (buffer, len & ~63, ctx);
+	  buffer = (const char *) buffer + (len & ~63);
+	  len &= 63;
+	}
+    }
+
+  /* Move remaining bytes in internal buffer.  */
+  if (len > 0)
+    {
+      size_t left_over = ctx->buflen;
+
+      memcpy (&ctx->buffer[left_over], buffer, len);
+      left_over += len;
+      if (left_over >= 64)
+	{
+	  sha256_process_block (ctx->buffer, 64, ctx);
+	  left_over -= 64;
+	  memcpy (ctx->buffer, &ctx->buffer[64], left_over);
+	}
+      ctx->buflen = left_over;
+    }
+}
+
+/* --- Code below is the primary difference between md5.c and sha256.c --- */
+
+/* SHA256 round constants */
+#define K(I) sha256_round_constants[I]
+static const md5_uint32 sha256_round_constants[64] = {
+  0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL,
+  0x3956c25bUL, 0x59f111f1UL, 0x923f82a4UL, 0xab1c5ed5UL,
+  0xd807aa98UL, 0x12835b01UL, 0x243185beUL, 0x550c7dc3UL,
+  0x72be5d74UL, 0x80deb1feUL, 0x9bdc06a7UL, 0xc19bf174UL,
+  0xe49b69c1UL, 0xefbe4786UL, 0x0fc19dc6UL, 0x240ca1ccUL,
+  0x2de92c6fUL, 0x4a7484aaUL, 0x5cb0a9dcUL, 0x76f988daUL,
+  0x983e5152UL, 0xa831c66dUL, 0xb00327c8UL, 0xbf597fc7UL,
+  0xc6e00bf3UL, 0xd5a79147UL, 0x06ca6351UL, 0x14292967UL,
+  0x27b70a85UL, 0x2e1b2138UL, 0x4d2c6dfcUL, 0x53380d13UL,
+  0x650a7354UL, 0x766a0abbUL, 0x81c2c92eUL, 0x92722c85UL,
+  0xa2bfe8a1UL, 0xa81a664bUL, 0xc24b8b70UL, 0xc76c51a3UL,
+  0xd192e819UL, 0xd6990624UL, 0xf40e3585UL, 0x106aa070UL,
+  0x19a4c116UL, 0x1e376c08UL, 0x2748774cUL, 0x34b0bcb5UL,
+  0x391c0cb3UL, 0x4ed8aa4aUL, 0x5b9cca4fUL, 0x682e6ff3UL,
+  0x748f82eeUL, 0x78a5636fUL, 0x84c87814UL, 0x8cc70208UL,
+  0x90befffaUL, 0xa4506cebUL, 0xbef9a3f7UL, 0xc67178f2UL,
+};
+
+/* Round functions.  */
+#define F2(A,B,C) ( ( A & B ) | ( C & ( A | B ) ) )
+#define F1(E,F,G) ( G ^ ( E & ( F ^ G ) ) )
+
+/* Process LEN bytes of BUFFER, accumulating context into CTX.
+   It is assumed that LEN % 64 == 0.
+   Most of this code comes from GnuPG's cipher/sha1.c.  */
+
+void
+sha256_process_block (const void *buffer, size_t len, struct sha256_ctx *ctx)
+{
+  const md5_uint32 *words = buffer;
+  size_t nwords = len / sizeof (md5_uint32);
+  const md5_uint32 *endp = words + nwords;
+  md5_uint32 x[16];
+  md5_uint32 a = ctx->state[0];
+  md5_uint32 b = ctx->state[1];
+  md5_uint32 c = ctx->state[2];
+  md5_uint32 d = ctx->state[3];
+  md5_uint32 e = ctx->state[4];
+  md5_uint32 f = ctx->state[5];
+  md5_uint32 g = ctx->state[6];
+  md5_uint32 h = ctx->state[7];
+
+  /* First increment the byte count.  FIPS PUB 180-2 specifies the possible
+     length of the file up to 2^64 bits.  Here we only compute the
+     number of bytes.  Do a double word increment.  */
+  ctx->total[0] += len;
+  if (ctx->total[0] < len)
+    ++ctx->total[1];
+
+#define rol(x, n) (((x) << (n)) | ((x) >> (32 - (n))))
+
+#define S0(x) (rol(x,25)^rol(x,14)^(x>>3))
+#define S1(x) (rol(x,15)^rol(x,13)^(x>>10))
+#define SS0(x) (rol(x,30)^rol(x,19)^rol(x,10))
+#define SS1(x) (rol(x,26)^rol(x,21)^rol(x,7))
+
+#define M(I) ( tm =   S1(x[(I-2)&0x0f]) + x[(I-7)&0x0f] \
+		    + S0(x[(I-15)&0x0f]) + x[I&0x0f]    \
+	       , x[I&0x0f] = tm )
+
+#define R(A,B,C,D,E,F,G,H,K,M)  do { t0 = SS0(A) + F2(A,B,C); \
+                                     t1 = H + SS1(E)  \
+                                      + F1(E,F,G)     \
+				      + K	      \
+				      + M;	      \
+				     D += t1;  H = t0 + t1; \
+			       } while(0)
+
+  while (words < endp)
+    {
+      md5_uint32 tm;
+      md5_uint32 t0, t1;
+      int t;
+      for (t = 0; t < 16; t++)
+	{
+	  x[t] = SWAP (*words);
+	  words++;
+	}
+
+      R( a, b, c, d, e, f, g, h, K( 0), x[ 0] );
+      R( h, a, b, c, d, e, f, g, K( 1), x[ 1] );
+      R( g, h, a, b, c, d, e, f, K( 2), x[ 2] );
+      R( f, g, h, a, b, c, d, e, K( 3), x[ 3] );
+      R( e, f, g, h, a, b, c, d, K( 4), x[ 4] );
+      R( d, e, f, g, h, a, b, c, K( 5), x[ 5] );
+      R( c, d, e, f, g, h, a, b, K( 6), x[ 6] );
+      R( b, c, d, e, f, g, h, a, K( 7), x[ 7] );
+      R( a, b, c, d, e, f, g, h, K( 8), x[ 8] );
+      R( h, a, b, c, d, e, f, g, K( 9), x[ 9] );
+      R( g, h, a, b, c, d, e, f, K(10), x[10] );
+      R( f, g, h, a, b, c, d, e, K(11), x[11] );
+      R( e, f, g, h, a, b, c, d, K(12), x[12] );
+      R( d, e, f, g, h, a, b, c, K(13), x[13] );
+      R( c, d, e, f, g, h, a, b, K(14), x[14] );
+      R( b, c, d, e, f, g, h, a, K(15), x[15] );
+      R( a, b, c, d, e, f, g, h, K(16), M(16) );
+      R( h, a, b, c, d, e, f, g, K(17), M(17) );
+      R( g, h, a, b, c, d, e, f, K(18), M(18) );
+      R( f, g, h, a, b, c, d, e, K(19), M(19) );
+      R( e, f, g, h, a, b, c, d, K(20), M(20) );
+      R( d, e, f, g, h, a, b, c, K(21), M(21) );
+      R( c, d, e, f, g, h, a, b, K(22), M(22) );
+      R( b, c, d, e, f, g, h, a, K(23), M(23) );
+      R( a, b, c, d, e, f, g, h, K(24), M(24) );
+      R( h, a, b, c, d, e, f, g, K(25), M(25) );
+      R( g, h, a, b, c, d, e, f, K(26), M(26) );
+      R( f, g, h, a, b, c, d, e, K(27), M(27) );
+      R( e, f, g, h, a, b, c, d, K(28), M(28) );
+      R( d, e, f, g, h, a, b, c, K(29), M(29) );
+      R( c, d, e, f, g, h, a, b, K(30), M(30) );
+      R( b, c, d, e, f, g, h, a, K(31), M(31) );
+      R( a, b, c, d, e, f, g, h, K(32), M(32) );
+      R( h, a, b, c, d, e, f, g, K(33), M(33) );
+      R( g, h, a, b, c, d, e, f, K(34), M(34) );
+      R( f, g, h, a, b, c, d, e, K(35), M(35) );
+      R( e, f, g, h, a, b, c, d, K(36), M(36) );
+      R( d, e, f, g, h, a, b, c, K(37), M(37) );
+      R( c, d, e, f, g, h, a, b, K(38), M(38) );
+      R( b, c, d, e, f, g, h, a, K(39), M(39) );
+      R( a, b, c, d, e, f, g, h, K(40), M(40) );
+      R( h, a, b, c, d, e, f, g, K(41), M(41) );
+      R( g, h, a, b, c, d, e, f, K(42), M(42) );
+      R( f, g, h, a, b, c, d, e, K(43), M(43) );
+      R( e, f, g, h, a, b, c, d, K(44), M(44) );
+      R( d, e, f, g, h, a, b, c, K(45), M(45) );
+      R( c, d, e, f, g, h, a, b, K(46), M(46) );
+      R( b, c, d, e, f, g, h, a, K(47), M(47) );
+      R( a, b, c, d, e, f, g, h, K(48), M(48) );
+      R( h, a, b, c, d, e, f, g, K(49), M(49) );
+      R( g, h, a, b, c, d, e, f, K(50), M(50) );
+      R( f, g, h, a, b, c, d, e, K(51), M(51) );
+      R( e, f, g, h, a, b, c, d, K(52), M(52) );
+      R( d, e, f, g, h, a, b, c, K(53), M(53) );
+      R( c, d, e, f, g, h, a, b, K(54), M(54) );
+      R( b, c, d, e, f, g, h, a, K(55), M(55) );
+      R( a, b, c, d, e, f, g, h, K(56), M(56) );
+      R( h, a, b, c, d, e, f, g, K(57), M(57) );
+      R( g, h, a, b, c, d, e, f, K(58), M(58) );
+      R( f, g, h, a, b, c, d, e, K(59), M(59) );
+      R( e, f, g, h, a, b, c, d, K(60), M(60) );
+      R( d, e, f, g, h, a, b, c, K(61), M(61) );
+      R( c, d, e, f, g, h, a, b, K(62), M(62) );
+      R( b, c, d, e, f, g, h, a, K(63), M(63) );
+
+      a = ctx->state[0] += a;
+      b = ctx->state[1] += b;
+      c = ctx->state[2] += c;
+      d = ctx->state[3] += d;
+      e = ctx->state[4] += e;
+      f = ctx->state[5] += f;
+      g = ctx->state[6] += g;
+      h = ctx->state[7] += h;
+    }
+}
diff -Nru coreutils-5.97.orig/lib/sha256.h coreutils-5.97/lib/sha256.h
--- coreutils-5.97.orig/lib/sha256.h	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-5.97/lib/sha256.h	2006-07-31 14:14:36.000000000 +0200
@@ -0,0 +1,88 @@
+/* Declarations of functions and data types used for SHA256 and SHA224 sum
+   library functions.
+   Copyright (C) 2000, 2001, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2, or (at your option) any
+   later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef SHA256_H
+# define SHA256_H 1
+
+# include <stdio.h>
+# include "md5.h"
+
+/* Structure to save state of computation between the single steps.  */
+struct sha256_ctx
+{
+  md5_uint32 state[8];
+
+  md5_uint32 total[2];
+  md5_uint32 buflen;
+  char buffer[128];
+};
+
+
+/* Initialize structure containing state of computation. */
+extern void sha256_init_ctx (struct sha256_ctx *ctx);
+extern void sha224_init_ctx (struct sha256_ctx *ctx);
+
+/* Starting with the result of former calls of this function (or the
+   initialization function update the context for the next LEN bytes
+   starting at BUFFER.
+   It is necessary that LEN is a multiple of 64!!! */
+extern void sha256_process_block (const void *buffer, size_t len,
+				  struct sha256_ctx *ctx);
+
+/* Starting with the result of former calls of this function (or the
+   initialization function update the context for the next LEN bytes
+   starting at BUFFER.
+   It is NOT required that LEN is a multiple of 64.  */
+extern void sha256_process_bytes (const void *buffer, size_t len,
+				  struct sha256_ctx *ctx);
+
+/* Process the remaining bytes in the buffer and put result from CTX
+   in first 32 (28) bytes following RESBUF.  The result is always in little
+   endian byte order, so that a byte-wise output yields to the wanted
+   ASCII representation of the message digest.
+
+   IMPORTANT: On some systems it is required that RESBUF be correctly
+   aligned for a 32 bits value.  */
+extern void *sha256_finish_ctx (struct sha256_ctx *ctx, void *resbuf);
+extern void *sha224_finish_ctx (struct sha256_ctx *ctx, void *resbuf);
+
+
+/* Put result from CTX in first 32 (28) bytes following RESBUF.  The result is
+   always in little endian byte order, so that a byte-wise output yields
+   to the wanted ASCII representation of the message digest.
+
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 32 bits value.  */
+extern void *sha256_read_ctx (const struct sha256_ctx *ctx, void *resbuf);
+extern void *sha224_read_ctx (const struct sha256_ctx *ctx, void *resbuf);
+
+
+/* Compute SHA256 (SHA224) message digest for bytes read from STREAM.  The
+   resulting message digest number will be written into the 32 (28) bytes
+   beginning at RESBLOCK.  */
+extern int sha256_stream (FILE *stream, void *resblock);
+extern int sha224_stream (FILE *stream, void *resblock);
+
+/* Compute SHA256 (SHA224) message digest for LEN bytes beginning at BUFFER.  The
+   result is always in little endian byte order, so that a byte-wise
+   output yields to the wanted ASCII representation of the message
+   digest.  */
+extern void *sha256_buffer (const char *buffer, size_t len, void *resblock);
+extern void *sha224_buffer (const char *buffer, size_t len, void *resblock);
+
+#endif
diff -Nru coreutils-5.97.orig/lib/sha512.c coreutils-5.97/lib/sha512.c
--- coreutils-5.97.orig/lib/sha512.c	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-5.97/lib/sha512.c	2006-07-31 14:05:31.000000000 +0200
@@ -0,0 +1,564 @@
+/* sha512.c - Functions to compute SHA512 and SHA384 message digest of files or
+   memory blocks according to the NIST specification FIPS-180-2.
+
+   Copyright (C) 2000, 2001, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2, or (at your option) any
+   later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* Written by David Madore, considerably copypasting from
+   Scott G. Miller's sha1.c
+*/
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include "sha512.h"
+
+#include <stddef.h>
+#include <string.h>
+
+#if USE_UNLOCKED_IO
+# include "unlocked-io.h"
+#endif
+
+/* SWAP does an endian swap on architectures that are little-endian,
+   as SHA512 needs some data in a big-endian form.  */
+
+#ifdef WORDS_BIGENDIAN
+# define SWAP(n) (n)
+#else
+# define SWAP(n) \
+    (((n) << 56) | (((n) & 0xff00) << 40) | (((n) & 0xff0000UL) << 24) \
+  | (((n) & 0xff000000UL) << 8) | (((n) >> 8) & 0xff000000UL) \
+  | (((n) >> 24) & 0xff0000UL) | (((n) >> 40) & 0xff00UL) | ((n) >> 56))
+#endif
+
+#define BLOCKSIZE 4096
+#if BLOCKSIZE % 128 != 0
+# error "invalid BLOCKSIZE"
+#endif
+
+/* This array contains the bytes used to pad the buffer to the next
+   64-byte boundary.  */
+static const unsigned char fillbuf[128] = { 0x80, 0 /* , 0, 0, ...  */ };
+
+
+/*
+  Takes a pointer to a 512 bit block of data (eight 64 bit ints) and
+  intializes it to the start constants of the SHA512 algorithm.  This
+  must be called before using hash in the call to sha512_hash
+*/
+void
+sha512_init_ctx (struct sha512_ctx *ctx)
+{
+  ctx->state[0] = 0x6a09e667f3bcc908ULL;
+  ctx->state[1] = 0xbb67ae8584caa73bULL;
+  ctx->state[2] = 0x3c6ef372fe94f82bULL;
+  ctx->state[3] = 0xa54ff53a5f1d36f1ULL;
+  ctx->state[4] = 0x510e527fade682d1ULL;
+  ctx->state[5] = 0x9b05688c2b3e6c1fULL;
+  ctx->state[6] = 0x1f83d9abfb41bd6bULL;
+  ctx->state[7] = 0x5be0cd19137e2179ULL;
+
+  ctx->total[0] = ctx->total[1] = 0;
+  ctx->buflen = 0;
+}
+
+void
+sha384_init_ctx (struct sha512_ctx *ctx)
+{
+  ctx->state[0] = 0xcbbb9d5dc1059ed8ULL;
+  ctx->state[1] = 0x629a292a367cd507ULL;
+  ctx->state[2] = 0x9159015a3070dd17ULL;
+  ctx->state[3] = 0x152fecd8f70e5939ULL;
+  ctx->state[4] = 0x67332667ffc00b31ULL;
+  ctx->state[5] = 0x8eb44a8768581511ULL;
+  ctx->state[6] = 0xdb0c2e0d64f98fa7ULL;
+  ctx->state[7] = 0x47b5481dbefa4fa4ULL;
+
+  ctx->total[0] = ctx->total[1] = 0;
+  ctx->buflen = 0;
+}
+
+/* Put result from CTX in first 64 bytes following RESBUF.  The result
+   must be in little endian byte order.
+
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 64 bits value.  */
+void *
+sha512_read_ctx (const struct sha512_ctx *ctx, void *resbuf)
+{
+  int i;
+
+  for ( i=0 ; i<8 ; i++ )
+    ((sha512_uint64 *) resbuf)[i] = SWAP (ctx->state[i]);
+
+  return resbuf;
+}
+
+void *
+sha384_read_ctx (const struct sha512_ctx *ctx, void *resbuf)
+{
+  int i;
+
+  for ( i=0 ; i<6 ; i++ )
+    ((sha512_uint64 *) resbuf)[i] = SWAP (ctx->state[i]);
+
+  return resbuf;
+}
+
+/* Process the remaining bytes in the internal buffer and the usual
+   prolog according to the standard and write the result to RESBUF.
+
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 64 bits value.  */
+static void
+sha512_conclude_ctx (struct sha512_ctx *ctx)
+{
+  /* Take yet unprocessed bytes into account.  */
+  sha512_uint64 bytes = ctx->buflen;
+  size_t pad;
+
+  /* Now count remaining bytes.  */
+  ctx->total[0] += bytes;
+  if (ctx->total[0] < bytes)
+    ++ctx->total[1];
+
+  pad = bytes >= 112 ? 128 + 112 - bytes : 112 - bytes;
+  memcpy (&ctx->buffer[bytes], fillbuf, pad);
+
+  /* Put the 64-bit file length in *bits* at the end of the buffer.  */
+  *(sha512_uint64 *) &ctx->buffer[bytes + pad + 8] = SWAP (ctx->total[0] << 3);
+  *(sha512_uint64 *) &ctx->buffer[bytes + pad] = SWAP ((ctx->total[1] << 3) |
+						    (ctx->total[0] >> 61));
+
+  /* Process last bytes.  */
+  sha512_process_block (ctx->buffer, bytes + pad + 16, ctx);
+}
+
+void *
+sha512_finish_ctx (struct sha512_ctx *ctx, void *resbuf)
+{
+  sha512_conclude_ctx (ctx);
+  return sha512_read_ctx (ctx, resbuf);
+}
+
+void *
+sha384_finish_ctx (struct sha512_ctx *ctx, void *resbuf)
+{
+  sha512_conclude_ctx (ctx);
+  return sha384_read_ctx (ctx, resbuf);
+}
+
+/* Compute SHA512 message digest for bytes read from STREAM.  The
+   resulting message digest number will be written into the 64 bytes
+   beginning at RESBLOCK.  */
+int
+sha512_stream (FILE *stream, void *resblock)
+{
+  struct sha512_ctx ctx;
+  char buffer[BLOCKSIZE + 72];
+  size_t sum;
+
+  /* Initialize the computation context.  */
+  sha512_init_ctx (&ctx);
+
+  /* Iterate over full file contents.  */
+  while (1)
+    {
+      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the
+	 computation function processes the whole buffer so that with the
+	 next round of the loop another block can be read.  */
+      size_t n;
+      sum = 0;
+
+      /* Read block.  Take care for partial reads.  */
+      while (1)
+	{
+	  n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);
+
+	  sum += n;
+
+	  if (sum == BLOCKSIZE)
+	    break;
+
+	  if (n == 0)
+	    {
+	      /* Check for the error flag IFF N == 0, so that we don't
+		 exit the loop after a partial read due to e.g., EAGAIN
+		 or EWOULDBLOCK.  */
+	      if (ferror (stream))
+		return 1;
+	      goto process_partial_block;
+	    }
+
+	  /* We've read at least one byte, so ignore errors.  But always
+	     check for EOF, since feof may be true even though N > 0.
+	     Otherwise, we could end up calling fread after EOF.  */
+	  if (feof (stream))
+	    goto process_partial_block;
+	}
+
+      /* Process buffer with BLOCKSIZE bytes.  Note that
+			BLOCKSIZE % 128 == 0
+       */
+      sha512_process_block (buffer, BLOCKSIZE, &ctx);
+    }
+
+ process_partial_block:;
+
+  /* Process any remaining bytes.  */
+  if (sum > 0)
+    sha512_process_bytes (buffer, sum, &ctx);
+
+  /* Construct result in desired memory.  */
+  sha512_finish_ctx (&ctx, resblock);
+  return 0;
+}
+
+/* FIXME: Avoid code duplication */
+int
+sha384_stream (FILE *stream, void *resblock)
+{
+  struct sha512_ctx ctx;
+  char buffer[BLOCKSIZE + 72];
+  size_t sum;
+
+  /* Initialize the computation context.  */
+  sha384_init_ctx (&ctx);
+
+  /* Iterate over full file contents.  */
+  while (1)
+    {
+      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the
+	 computation function processes the whole buffer so that with the
+	 next round of the loop another block can be read.  */
+      size_t n;
+      sum = 0;
+
+      /* Read block.  Take care for partial reads.  */
+      while (1)
+	{
+	  n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);
+
+	  sum += n;
+
+	  if (sum == BLOCKSIZE)
+	    break;
+
+	  if (n == 0)
+	    {
+	      /* Check for the error flag IFF N == 0, so that we don't
+		 exit the loop after a partial read due to e.g., EAGAIN
+		 or EWOULDBLOCK.  */
+	      if (ferror (stream))
+		return 1;
+	      goto process_partial_block;
+	    }
+
+	  /* We've read at least one byte, so ignore errors.  But always
+	     check for EOF, since feof may be true even though N > 0.
+	     Otherwise, we could end up calling fread after EOF.  */
+	  if (feof (stream))
+	    goto process_partial_block;
+	}
+
+      /* Process buffer with BLOCKSIZE bytes.  Note that
+			BLOCKSIZE % 128 == 0
+       */
+      sha512_process_block (buffer, BLOCKSIZE, &ctx);
+    }
+
+ process_partial_block:;
+
+  /* Process any remaining bytes.  */
+  if (sum > 0)
+    sha512_process_bytes (buffer, sum, &ctx);
+
+  /* Construct result in desired memory.  */
+  sha384_finish_ctx (&ctx, resblock);
+  return 0;
+}
+
+/* Compute SHA512 message digest for LEN bytes beginning at BUFFER.  The
+   result is always in little endian byte order, so that a byte-wise
+   output yields to the wanted ASCII representation of the message
+   digest.  */
+void *
+sha512_buffer (const char *buffer, size_t len, void *resblock)
+{
+  struct sha512_ctx ctx;
+
+  /* Initialize the computation context.  */
+  sha512_init_ctx (&ctx);
+
+  /* Process whole buffer but last len % 128 bytes.  */
+  sha512_process_bytes (buffer, len, &ctx);
+
+  /* Put result in desired memory area.  */
+  return sha512_finish_ctx (&ctx, resblock);
+}
+
+void *
+sha384_buffer (const char *buffer, size_t len, void *resblock)
+{
+  struct sha512_ctx ctx;
+
+  /* Initialize the computation context.  */
+  sha384_init_ctx (&ctx);
+
+  /* Process whole buffer but last len % 128 bytes.  */
+  sha512_process_bytes (buffer, len, &ctx);
+
+  /* Put result in desired memory area.  */
+  return sha384_finish_ctx (&ctx, resblock);
+}
+
+void
+sha512_process_bytes (const void *buffer, size_t len, struct sha512_ctx *ctx)
+{
+  /* When we already have some bits in our internal buffer concatenate
+     both inputs first.  */
+  if (ctx->buflen != 0)
+    {
+      size_t left_over = ctx->buflen;
+      size_t add = 256 - left_over > len ? len : 256 - left_over;
+
+      memcpy (&ctx->buffer[left_over], buffer, add);
+      ctx->buflen += add;
+
+      if (ctx->buflen > 128)
+	{
+	  sha512_process_block (ctx->buffer, ctx->buflen & ~63, ctx);
+
+	  ctx->buflen &= 127;
+	  /* The regions in the following copy operation cannot overlap.  */
+	  memcpy (ctx->buffer, &ctx->buffer[(left_over + add) & ~127],
+		  ctx->buflen);
+	}
+
+      buffer = (const char *) buffer + add;
+      len -= add;
+    }
+
+  /* Process available complete blocks.  */
+  if (len >= 128)
+    {
+#if !_STRING_ARCH_unaligned
+# define alignof(type) offsetof (struct { char c; type x; }, x)
+# define UNALIGNED_P(p) (((size_t) p) % alignof (sha512_uint64) != 0)
+      if (UNALIGNED_P (buffer))
+	while (len > 128)
+	  {
+	    sha512_process_block (memcpy (ctx->buffer, buffer, 128), 128, ctx);
+	    buffer = (const char *) buffer + 128;
+	    len -= 128;
+	  }
+      else
+#endif
+	{
+	  sha512_process_block (buffer, len & ~127, ctx);
+	  buffer = (const char *) buffer + (len & ~127);
+	  len &= 127;
+	}
+    }
+
+  /* Move remaining bytes in internal buffer.  */
+  if (len > 0)
+    {
+      size_t left_over = ctx->buflen;
+
+      memcpy (&ctx->buffer[left_over], buffer, len);
+      left_over += len;
+      if (left_over >= 128)
+	{
+	  sha512_process_block (ctx->buffer, 128, ctx);
+	  left_over -= 128;
+	  memcpy (ctx->buffer, &ctx->buffer[128], left_over);
+	}
+      ctx->buflen = left_over;
+    }
+}
+
+/* --- Code below is the primary difference between md5.c and sha512.c --- */
+
+/* SHA512 round constants */
+#define K(I) sha512_round_constants[I]
+static const sha512_uint64 sha512_round_constants[80] = {
+ 0x428a2f98d728ae22ULL, 0x7137449123ef65cdULL, 0xb5c0fbcfec4d3b2fULL, 0xe9b5dba58189dbbcULL, 0x3956c25bf348b538ULL, 0x59f111f1b605d019ULL, 0x923f82a4af194f9bULL, 0xab1c5ed5da6d8118ULL,
+ 0xd807aa98a3030242ULL, 0x12835b0145706fbeULL, 0x243185be4ee4b28cULL, 0x550c7dc3d5ffb4e2ULL, 0x72be5d74f27b896fULL, 0x80deb1fe3b1696b1ULL, 0x9bdc06a725c71235ULL, 0xc19bf174cf692694ULL,
+ 0xe49b69c19ef14ad2ULL, 0xefbe4786384f25e3ULL, 0x0fc19dc68b8cd5b5ULL, 0x240ca1cc77ac9c65ULL, 0x2de92c6f592b0275ULL, 0x4a7484aa6ea6e483ULL, 0x5cb0a9dcbd41fbd4ULL, 0x76f988da831153b5ULL,
+ 0x983e5152ee66dfabULL, 0xa831c66d2db43210ULL, 0xb00327c898fb213fULL, 0xbf597fc7beef0ee4ULL, 0xc6e00bf33da88fc2ULL, 0xd5a79147930aa725ULL, 0x06ca6351e003826fULL, 0x142929670a0e6e70ULL,
+ 0x27b70a8546d22ffcULL, 0x2e1b21385c26c926ULL, 0x4d2c6dfc5ac42aedULL, 0x53380d139d95b3dfULL, 0x650a73548baf63deULL, 0x766a0abb3c77b2a8ULL, 0x81c2c92e47edaee6ULL, 0x92722c851482353bULL,
+ 0xa2bfe8a14cf10364ULL, 0xa81a664bbc423001ULL, 0xc24b8b70d0f89791ULL, 0xc76c51a30654be30ULL, 0xd192e819d6ef5218ULL, 0xd69906245565a910ULL, 0xf40e35855771202aULL, 0x106aa07032bbd1b8ULL,
+ 0x19a4c116b8d2d0c8ULL, 0x1e376c085141ab53ULL, 0x2748774cdf8eeb99ULL, 0x34b0bcb5e19b48a8ULL, 0x391c0cb3c5c95a63ULL, 0x4ed8aa4ae3418acbULL, 0x5b9cca4f7763e373ULL, 0x682e6ff3d6b2b8a3ULL,
+ 0x748f82ee5defb2fcULL, 0x78a5636f43172f60ULL, 0x84c87814a1f0ab72ULL, 0x8cc702081a6439ecULL, 0x90befffa23631e28ULL, 0xa4506cebde82bde9ULL, 0xbef9a3f7b2c67915ULL, 0xc67178f2e372532bULL,
+ 0xca273eceea26619cULL, 0xd186b8c721c0c207ULL, 0xeada7dd6cde0eb1eULL, 0xf57d4f7fee6ed178ULL, 0x06f067aa72176fbaULL, 0x0a637dc5a2c898a6ULL, 0x113f9804bef90daeULL, 0x1b710b35131c471bULL,
+ 0x28db77f523047d84ULL, 0x32caab7b40c72493ULL, 0x3c9ebe0a15c9bebcULL, 0x431d67c49c100d4cULL, 0x4cc5d4becb3e42b6ULL, 0x597f299cfc657e2aULL, 0x5fcb6fab3ad6faecULL, 0x6c44198c4a475817ULL,
+};
+
+/* Round functions.  */
+#define F2(A,B,C) ( ( A & B ) | ( C & ( A | B ) ) )
+#define F1(E,F,G) ( G ^ ( E & ( F ^ G ) ) )
+
+/* Process LEN bytes of BUFFER, accumulating context into CTX.
+   It is assumed that LEN % 128 == 0.
+   Most of this code comes from GnuPG's cipher/sha1.c.  */
+
+void
+sha512_process_block (const void *buffer, size_t len, struct sha512_ctx *ctx)
+{
+  const sha512_uint64 *words = buffer;
+  size_t nwords = len / sizeof (sha512_uint64);
+  const sha512_uint64 *endp = words + nwords;
+  sha512_uint64 x[16];
+  sha512_uint64 a = ctx->state[0];
+  sha512_uint64 b = ctx->state[1];
+  sha512_uint64 c = ctx->state[2];
+  sha512_uint64 d = ctx->state[3];
+  sha512_uint64 e = ctx->state[4];
+  sha512_uint64 f = ctx->state[5];
+  sha512_uint64 g = ctx->state[6];
+  sha512_uint64 h = ctx->state[7];
+
+  /* First increment the byte count.  FIPS PUB 180-2 specifies the possible
+     length of the file up to 2^128 bits.  Here we only compute the
+     number of bytes.  Do a double word increment.  */
+  ctx->total[0] += len;
+  if (ctx->total[0] < len)
+    ++ctx->total[1];
+
+#define rol64(x,n) ( ((x) << (n)) | ((x) >> (64-(n))) )
+
+#define S0(x) (rol64(x,63)^rol64(x,56)^(x>>7))
+#define S1(x) (rol64(x,45)^rol64(x,3)^(x>>6))
+#define SS0(x) (rol64(x,36)^rol64(x,30)^rol64(x,25))
+#define SS1(x) (rol64(x,50)^rol64(x,46)^rol64(x,23))
+
+#define M(I) ( tm =   S1(x[(I-2)&0x0f]) + x[(I-7)&0x0f] \
+		    + S0(x[(I-15)&0x0f]) + x[I&0x0f]    \
+	       , x[I&0x0f] = tm )
+
+#define R(A,B,C,D,E,F,G,H,K,M)  do { t0 = SS0(A) + F2(A,B,C); \
+                                     t1 = H + SS1(E)  \
+                                      + F1(E,F,G)     \
+				      + K	      \
+				      + M;	      \
+				     D += t1;  H = t0 + t1; \
+			       } while(0)
+
+  while (words < endp)
+    {
+      sha512_uint64 tm;
+      sha512_uint64 t0, t1;
+      int t;
+      for (t = 0; t < 16; t++)
+	{
+	  x[t] = SWAP (*words);
+	  words++;
+	}
+
+      R( a, b, c, d, e, f, g, h, K( 0), x[ 0] );
+      R( h, a, b, c, d, e, f, g, K( 1), x[ 1] );
+      R( g, h, a, b, c, d, e, f, K( 2), x[ 2] );
+      R( f, g, h, a, b, c, d, e, K( 3), x[ 3] );
+      R( e, f, g, h, a, b, c, d, K( 4), x[ 4] );
+      R( d, e, f, g, h, a, b, c, K( 5), x[ 5] );
+      R( c, d, e, f, g, h, a, b, K( 6), x[ 6] );
+      R( b, c, d, e, f, g, h, a, K( 7), x[ 7] );
+      R( a, b, c, d, e, f, g, h, K( 8), x[ 8] );
+      R( h, a, b, c, d, e, f, g, K( 9), x[ 9] );
+      R( g, h, a, b, c, d, e, f, K(10), x[10] );
+      R( f, g, h, a, b, c, d, e, K(11), x[11] );
+      R( e, f, g, h, a, b, c, d, K(12), x[12] );
+      R( d, e, f, g, h, a, b, c, K(13), x[13] );
+      R( c, d, e, f, g, h, a, b, K(14), x[14] );
+      R( b, c, d, e, f, g, h, a, K(15), x[15] );
+      R( a, b, c, d, e, f, g, h, K(16), M(16) );
+      R( h, a, b, c, d, e, f, g, K(17), M(17) );
+      R( g, h, a, b, c, d, e, f, K(18), M(18) );
+      R( f, g, h, a, b, c, d, e, K(19), M(19) );
+      R( e, f, g, h, a, b, c, d, K(20), M(20) );
+      R( d, e, f, g, h, a, b, c, K(21), M(21) );
+      R( c, d, e, f, g, h, a, b, K(22), M(22) );
+      R( b, c, d, e, f, g, h, a, K(23), M(23) );
+      R( a, b, c, d, e, f, g, h, K(24), M(24) );
+      R( h, a, b, c, d, e, f, g, K(25), M(25) );
+      R( g, h, a, b, c, d, e, f, K(26), M(26) );
+      R( f, g, h, a, b, c, d, e, K(27), M(27) );
+      R( e, f, g, h, a, b, c, d, K(28), M(28) );
+      R( d, e, f, g, h, a, b, c, K(29), M(29) );
+      R( c, d, e, f, g, h, a, b, K(30), M(30) );
+      R( b, c, d, e, f, g, h, a, K(31), M(31) );
+      R( a, b, c, d, e, f, g, h, K(32), M(32) );
+      R( h, a, b, c, d, e, f, g, K(33), M(33) );
+      R( g, h, a, b, c, d, e, f, K(34), M(34) );
+      R( f, g, h, a, b, c, d, e, K(35), M(35) );
+      R( e, f, g, h, a, b, c, d, K(36), M(36) );
+      R( d, e, f, g, h, a, b, c, K(37), M(37) );
+      R( c, d, e, f, g, h, a, b, K(38), M(38) );
+      R( b, c, d, e, f, g, h, a, K(39), M(39) );
+      R( a, b, c, d, e, f, g, h, K(40), M(40) );
+      R( h, a, b, c, d, e, f, g, K(41), M(41) );
+      R( g, h, a, b, c, d, e, f, K(42), M(42) );
+      R( f, g, h, a, b, c, d, e, K(43), M(43) );
+      R( e, f, g, h, a, b, c, d, K(44), M(44) );
+      R( d, e, f, g, h, a, b, c, K(45), M(45) );
+      R( c, d, e, f, g, h, a, b, K(46), M(46) );
+      R( b, c, d, e, f, g, h, a, K(47), M(47) );
+      R( a, b, c, d, e, f, g, h, K(48), M(48) );
+      R( h, a, b, c, d, e, f, g, K(49), M(49) );
+      R( g, h, a, b, c, d, e, f, K(50), M(50) );
+      R( f, g, h, a, b, c, d, e, K(51), M(51) );
+      R( e, f, g, h, a, b, c, d, K(52), M(52) );
+      R( d, e, f, g, h, a, b, c, K(53), M(53) );
+      R( c, d, e, f, g, h, a, b, K(54), M(54) );
+      R( b, c, d, e, f, g, h, a, K(55), M(55) );
+      R( a, b, c, d, e, f, g, h, K(56), M(56) );
+      R( h, a, b, c, d, e, f, g, K(57), M(57) );
+      R( g, h, a, b, c, d, e, f, K(58), M(58) );
+      R( f, g, h, a, b, c, d, e, K(59), M(59) );
+      R( e, f, g, h, a, b, c, d, K(60), M(60) );
+      R( d, e, f, g, h, a, b, c, K(61), M(61) );
+      R( c, d, e, f, g, h, a, b, K(62), M(62) );
+      R( b, c, d, e, f, g, h, a, K(63), M(63) );
+      R( a, b, c, d, e, f, g, h, K(64), M(64) );
+      R( h, a, b, c, d, e, f, g, K(65), M(65) );
+      R( g, h, a, b, c, d, e, f, K(66), M(66) );
+      R( f, g, h, a, b, c, d, e, K(67), M(67) );
+      R( e, f, g, h, a, b, c, d, K(68), M(68) );
+      R( d, e, f, g, h, a, b, c, K(69), M(69) );
+      R( c, d, e, f, g, h, a, b, K(70), M(70) );
+      R( b, c, d, e, f, g, h, a, K(71), M(71) );
+      R( a, b, c, d, e, f, g, h, K(72), M(72) );
+      R( h, a, b, c, d, e, f, g, K(73), M(73) );
+      R( g, h, a, b, c, d, e, f, K(74), M(74) );
+      R( f, g, h, a, b, c, d, e, K(75), M(75) );
+      R( e, f, g, h, a, b, c, d, K(76), M(76) );
+      R( d, e, f, g, h, a, b, c, K(77), M(77) );
+      R( c, d, e, f, g, h, a, b, K(78), M(78) );
+      R( b, c, d, e, f, g, h, a, K(79), M(79) );
+
+      a = ctx->state[0] += a;
+      b = ctx->state[1] += b;
+      c = ctx->state[2] += c;
+      d = ctx->state[3] += d;
+      e = ctx->state[4] += e;
+      f = ctx->state[5] += f;
+      g = ctx->state[6] += g;
+      h = ctx->state[7] += h;
+    }
+}
diff -Nru coreutils-5.97.orig/lib/sha512.h coreutils-5.97/lib/sha512.h
--- coreutils-5.97.orig/lib/sha512.h	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-5.97/lib/sha512.h	2006-07-31 14:15:02.000000000 +0200
@@ -0,0 +1,91 @@
+/* Declarations of functions and data types used for SHA512 and SHA384 sum
+   library functions.
+   Copyright (C) 2000, 2001, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2, or (at your option) any
+   later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef SHA512_H
+# define SHA512_H 1
+
+# include <stdio.h>
+# include <stdint.h>
+
+typedef uint64_t sha512_uint64;
+
+
+/* Structure to save state of computation between the single steps.  */
+struct sha512_ctx
+{
+  sha512_uint64 state[8];
+
+  sha512_uint64 total[2];
+  sha512_uint64 buflen;
+  char buffer[256];
+};
+
+
+/* Initialize structure containing state of computation. */
+extern void sha512_init_ctx (struct sha512_ctx *ctx);
+extern void sha384_init_ctx (struct sha512_ctx *ctx);
+
+/* Starting with the result of former calls of this function (or the
+   initialization function update the context for the next LEN bytes
+   starting at BUFFER.
+   It is necessary that LEN is a multiple of 128!!! */
+extern void sha512_process_block (const void *buffer, size_t len,
+				  struct sha512_ctx *ctx);
+
+/* Starting with the result of former calls of this function (or the
+   initialization function update the context for the next LEN bytes
+   starting at BUFFER.
+   It is NOT required that LEN is a multiple of 128.  */
+extern void sha512_process_bytes (const void *buffer, size_t len,
+				  struct sha512_ctx *ctx);
+
+/* Process the remaining bytes in the buffer and put result from CTX
+   in first 64 (48) bytes following RESBUF.  The result is always in little
+   endian byte order, so that a byte-wise output yields to the wanted
+   ASCII representation of the message digest.
+
+   IMPORTANT: On some systems it is required that RESBUF be correctly
+   aligned for a 64 bits value.  */
+extern void *sha512_finish_ctx (struct sha512_ctx *ctx, void *resbuf);
+extern void *sha384_finish_ctx (struct sha512_ctx *ctx, void *resbuf);
+
+
+/* Put result from CTX in first 64 (48) bytes following RESBUF.  The result is
+   always in little endian byte order, so that a byte-wise output yields
+   to the wanted ASCII representation of the message digest.
+
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 32 bits value.  */
+extern void *sha512_read_ctx (const struct sha512_ctx *ctx, void *resbuf);
+extern void *sha384_read_ctx (const struct sha512_ctx *ctx, void *resbuf);
+
+
+/* Compute SHA512 (SHA384) message digest for bytes read from STREAM.  The
+   resulting message digest number will be written into the 64 (48) bytes
+   beginning at RESBLOCK.  */
+extern int sha512_stream (FILE *stream, void *resblock);
+extern int sha384_stream (FILE *stream, void *resblock);
+
+/* Compute SHA512 (SHA384) message digest for LEN bytes beginning at BUFFER.  The
+   result is always in little endian byte order, so that a byte-wise
+   output yields to the wanted ASCII representation of the message
+   digest.  */
+extern void *sha512_buffer (const char *buffer, size_t len, void *resblock);
+extern void *sha384_buffer (const char *buffer, size_t len, void *resblock);
+
+#endif
diff -Nru coreutils-5.97.orig/m4/prereq.m4 coreutils-5.97/m4/prereq.m4
--- coreutils-5.97.orig/m4/prereq.m4	2005-09-22 09:00:24.000000000 +0200
+++ coreutils-5.97/m4/prereq.m4	2006-07-31 13:51:41.000000000 +0200
@@ -134,6 +134,8 @@
   AC_REQUIRE([gl_SAVE_CWD])
   AC_REQUIRE([gl_SETTIME])
   AC_REQUIRE([gl_SHA1])
+  AC_REQUIRE([gl_SHA256])
+  AC_REQUIRE([gl_SHA512])
   AC_REQUIRE([gl_STAT_MACROS])
   AC_REQUIRE([gl_STAT_TIME])
   AC_REQUIRE([gl_STDIO_SAFER])
diff -Nru coreutils-5.97.orig/m4/sha256.m4 coreutils-5.97/m4/sha256.m4
--- coreutils-5.97.orig/m4/sha256.m4	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-5.97/m4/sha256.m4	2006-07-31 13:51:41.000000000 +0200
@@ -0,0 +1,15 @@
+# sha256.m4 serial 1
+dnl Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_SHA256],
+[
+  AC_LIBSOURCES([sha256.c, sha256.h])
+  AC_LIBOBJ([sha256])
+
+  dnl Prerequisites of lib/sha256.c.
+  AC_REQUIRE([AC_C_BIGENDIAN])
+  :
+])
diff -Nru coreutils-5.97.orig/m4/sha512.m4 coreutils-5.97/m4/sha512.m4
--- coreutils-5.97.orig/m4/sha512.m4	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-5.97/m4/sha512.m4	2006-07-31 13:51:41.000000000 +0200
@@ -0,0 +1,15 @@
+# sha512.m4 serial 1
+dnl Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_SHA512],
+[
+  AC_LIBSOURCES([sha512.c, sha512.h])
+  AC_LIBOBJ([sha512])
+
+  dnl Prerequisites of lib/sha512.c.
+  AC_REQUIRE([AC_C_BIGENDIAN])
+  :
+])
diff -Nru coreutils-5.97.orig/man/Makefile.am coreutils-5.97/man/Makefile.am
--- coreutils-5.97.orig/man/Makefile.am	2006-07-31 14:16:25.000000000 +0200
+++ coreutils-5.97/man/Makefile.am	2006-07-31 13:51:41.000000000 +0200
@@ -7,7 +7,8 @@
   link.1 ln.1 logname.1 \
   ls.1 md5sum.1 mkdir.1 mkfifo.1 mknod.1 mv.1 nice.1 nl.1 nohup.1 od.1 \
   paste.1 pathchk.1 pinky.1 pr.1 printenv.1 printf.1 ptx.1 pwd.1 readlink.1 \
-  rm.1 rmdir.1 seq.1 sha1sum.1 shred.1 sleep.1 sort.1 split.1 stat.1 stty.1 \
+  rm.1 rmdir.1 seq.1 sha1sum.1 sha224sum.1 sha256sum.1 sha384sum.1 sha512sum.1 \
+  shred.1 sleep.1 sort.1 split.1 stat.1 stty.1 \
   su.1 sum.1 sync.1 tac.1 tail.1 tee.1 test.1 touch.1 tr.1 true.1 tsort.1 \
   tty.1 uname.1 unexpand.1 uniq.1 unlink.1 uptime.1 users.1 vdir.1 wc.1 \
   who.1 whoami.1 yes.1 chcon.1 runcon.1
@@ -83,6 +84,10 @@
 rmdir.1:	$(common_dep)	$(srcdir)/rmdir.x	../src/rmdir.c
 seq.1:		$(common_dep)	$(srcdir)/seq.x		../src/seq.c
 sha1sum.1:	$(common_dep)	$(srcdir)/sha1sum.x	../src/md5sum.c
+sha224sum.1:	$(common_dep)	$(srcdir)/sha224sum.x	../src/md5sum.c
+sha256sum.1:	$(common_dep)	$(srcdir)/sha256sum.x	../src/md5sum.c
+sha384sum.1:	$(common_dep)	$(srcdir)/sha384sum.x	../src/md5sum.c
+sha512sum.1:	$(common_dep)	$(srcdir)/sha512sum.x	../src/md5sum.c
 shred.1:	$(common_dep)	$(srcdir)/shred.x	../src/shred.c
 sleep.1:	$(common_dep)	$(srcdir)/sleep.x	../src/sleep.c
 sort.1:		$(common_dep)	$(srcdir)/sort.x	../src/sort.c
diff -Nru coreutils-5.97.orig/man/sha224sum.x coreutils-5.97/man/sha224sum.x
--- coreutils-5.97.orig/man/sha224sum.x	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-5.97/man/sha224sum.x	2006-07-31 13:51:41.000000000 +0200
@@ -0,0 +1,4 @@
+[NAME]
+sha224sum \- compute and check SHA224 message digest
+[DESCRIPTION]
+.\" Add any additional description here
diff -Nru coreutils-5.97.orig/man/sha256sum.x coreutils-5.97/man/sha256sum.x
--- coreutils-5.97.orig/man/sha256sum.x	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-5.97/man/sha256sum.x	2006-07-31 13:51:41.000000000 +0200
@@ -0,0 +1,4 @@
+[NAME]
+sha256sum \- compute and check SHA256 message digest
+[DESCRIPTION]
+.\" Add any additional description here
diff -Nru coreutils-5.97.orig/man/sha384sum.x coreutils-5.97/man/sha384sum.x
--- coreutils-5.97.orig/man/sha384sum.x	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-5.97/man/sha384sum.x	2006-07-31 13:51:41.000000000 +0200
@@ -0,0 +1,4 @@
+[NAME]
+sha384sum \- compute and check SHA384 message digest
+[DESCRIPTION]
+.\" Add any additional description here
diff -Nru coreutils-5.97.orig/man/sha512sum.x coreutils-5.97/man/sha512sum.x
--- coreutils-5.97.orig/man/sha512sum.x	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-5.97/man/sha512sum.x	2006-07-31 13:51:41.000000000 +0200
@@ -0,0 +1,4 @@
+[NAME]
+sha512sum \- compute and check SHA512 message digest
+[DESCRIPTION]
+.\" Add any additional description here
diff -Nru coreutils-5.97.orig/src/Makefile.am coreutils-5.97/src/Makefile.am
--- coreutils-5.97.orig/src/Makefile.am	2006-07-31 14:16:25.000000000 +0200
+++ coreutils-5.97/src/Makefile.am	2006-07-31 13:51:41.000000000 +0200
@@ -24,7 +24,8 @@
   ginstall link ln dir vdir ls mkdir \
   mkfifo mknod mv nohup readlink rm rmdir shred stat sync touch unlink \
   cat cksum comm csplit cut expand fmt fold head join md5sum \
-  nl od paste pr ptx sha1sum sort split sum tac tail tr tsort unexpand uniq wc \
+  nl od paste pr ptx sha1sum sha224sum sha256sum sha384sum sha512sum \
+  sort split sum tac tail tr tsort unexpand uniq wc \
   basename date dirname echo env expr factor false \
   hostname id kill logname pathchk printenv printf pwd seq sleep tee \
   test true tty whoami yes \
@@ -33,7 +34,7 @@
 noinst_PROGRAMS = setuidgid
 
 noinst_HEADERS = \
-  system.h checksum.h copy.h cp-hash.h ls.h dircolors.h remove.h \
+  system.h copy.h cp-hash.h ls.h dircolors.h remove.h \
   chown-core.h fs.h \
   wheel.h wheel-size.h
 EXTRA_DIST = dcgen dircolors.hin tac-pipe.c \
@@ -176,8 +177,18 @@
 mv_SOURCES = mv.c copy.c cp-hash.c remove.c
 rm_SOURCES = rm.c remove.c
 
-md5sum_SOURCES = md5sum.c md5.c
-sha1sum_SOURCES = md5sum.c sha1sum.c
+md5sum_SOURCES = md5sum.c
+md5sum_CPPFLAGS = -DHASH_ALGO_MD5=1 $(AM_CPPFLAGS)
+sha1sum_SOURCES = md5sum.c
+sha1sum_CPPFLAGS = -DHASH_ALGO_SHA1=1 $(AM_CPPFLAGS)
+sha224sum_SOURCES = md5sum.c
+sha224sum_CPPFLAGS = -DHASH_ALGO_SHA224=1 $(AM_CPPFLAGS)
+sha256sum_SOURCES = md5sum.c
+sha256sum_CPPFLAGS = -DHASH_ALGO_SHA256=1 $(AM_CPPFLAGS)
+sha384sum_SOURCES = md5sum.c
+sha384sum_CPPFLAGS = -DHASH_ALGO_SHA384=1 $(AM_CPPFLAGS)
+sha512sum_SOURCES = md5sum.c
+sha512sum_CPPFLAGS = -DHASH_ALGO_SHA512=1 $(AM_CPPFLAGS)
 
 editpl = sed -e 's,@''PERL''@,$(PERL),g'
 
diff -Nru coreutils-5.97.orig/src/checksum.h coreutils-5.97/src/checksum.h
--- coreutils-5.97.orig/src/checksum.h	2004-09-22 22:11:10.000000000 +0200
+++ coreutils-5.97/src/checksum.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,7 +0,0 @@
-enum
-{
-  ALG_MD5 = 1,
-  ALG_SHA1
-};
-
-extern int algorithm;
diff -Nru coreutils-5.97.orig/src/md5.c coreutils-5.97/src/md5.c
--- coreutils-5.97.orig/src/md5.c	2004-07-30 02:54:02.000000000 +0200
+++ coreutils-5.97/src/md5.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-#include "checksum.h"
-int algorithm = ALG_MD5;
diff -Nru coreutils-5.97.orig/src/md5sum.c coreutils-5.97/src/md5sum.c
--- coreutils-5.97.orig/src/md5sum.c	2005-10-27 18:22:14.000000000 +0200
+++ coreutils-5.97/src/md5sum.c	2006-07-31 13:51:41.000000000 +0200
@@ -1,4 +1,4 @@
-/* Compute MD5 or SHA1 checksum of files or strings
+/* Compute MD5, SHA1, SHA224, SHA256, SHA384 and SHA512 checksum of files or strings
    Copyright (C) 1995-2005 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
@@ -24,34 +24,79 @@
 
 #include "system.h"
 
+#if HASH_ALGO_MD5
 #include "md5.h"
+#endif
+#if HASH_ALGO_SHA1
 #include "sha1.h"
-#include "checksum.h"
+#endif
+#if HASH_ALGO_SHA256 || HASH_ALGO_SHA224
+#include "sha256.h"
+#endif
+#if HASH_ALGO_SHA512 || HASH_ALGO_SHA384
+#include "sha512.h"
+#endif
 #include "getline.h"
 #include "error.h"
 #include "quote.h"
 #include "stdio--.h"
 
 /* The official name of this program (e.g., no `g' prefix).  */
-#define PROGRAM_NAME (algorithm == ALG_MD5 ? "md5sum" : "sha1sum")
+#if HASH_ALGO_MD5
+# define PROGRAM_NAME "md5sum"
+# define DIGEST_TYPE_STRING "MD5"
+# define DIGEST_STREAM md5_stream
+# define DIGEST_BUFFER md5_buffer
+# define DIGEST_BITS 128
+# define DIGEST_SOURCE "RFC 1321"
+#elif HASH_ALGO_SHA1
+# define PROGRAM_NAME "sha1sum"
+# define DIGEST_TYPE_STRING "SHA1"
+# define DIGEST_STREAM sha1_stream
+# define DIGEST_BUFFER sha1_buffer
+# define DIGEST_BITS 160
+# define DIGEST_SOURCE "FIPS-180-1"
+#elif HASH_ALGO_SHA256
+# define PROGRAM_NAME "sha256sum"
+# define DIGEST_TYPE_STRING "SHA256"
+# define DIGEST_STREAM sha256_stream
+# define DIGEST_BUFFER sha256_buffer
+# define DIGEST_BITS 256
+# define DIGEST_SOURCE "FIPS-180-2"
+#elif HASH_ALGO_SHA224
+# define PROGRAM_NAME "sha224sum"
+# define DIGEST_TYPE_STRING "SHA224"
+# define DIGEST_STREAM sha224_stream
+# define DIGEST_BUFFER sha224_buffer
+# define DIGEST_BITS 224
+# define DIGEST_SOURCE "RFC 3874"
+#elif HASH_ALGO_SHA512
+# define PROGRAM_NAME "sha512sum"
+# define DIGEST_TYPE_STRING "SHA512"
+# define DIGEST_STREAM sha512_stream
+# define DIGEST_BUFFER sha512_buffer
+# define DIGEST_BITS 512
+# define DIGEST_SOURCE "FIPS-180-2"
+#elif HASH_ALGO_SHA384
+# define PROGRAM_NAME "sha384sum"
+# define DIGEST_TYPE_STRING "SHA384"
+# define DIGEST_STREAM sha384_stream
+# define DIGEST_BUFFER sha384_buffer
+# define DIGEST_BITS 384
+# define DIGEST_SOURCE "FIPS-180-2"
+#else
+#error "Can't decide which hash algorithm to compile."
+#endif
 
-#define AUTHORS "Ulrich Drepper", "Scott Miller"
+#define DIGEST_HEX_BYTES (DIGEST_BITS / 4)
+#define DIGEST_BIN_BYTES (DIGEST_BITS / 8)
 
-
-#define DIGEST_TYPE_STRING(Alg) ((Alg) == ALG_MD5 ? "MD5" : "SHA1")
-#define DIGEST_STREAM(Alg) ((Alg) == ALG_MD5 ? md5_stream : sha1_stream)
-
-#define DIGEST_BITS(Alg) ((Alg) == ALG_MD5 ? 128 : 160)
-#define DIGEST_HEX_BYTES(Alg) (DIGEST_BITS (Alg) / 4)
-#define DIGEST_BIN_BYTES(Alg) (DIGEST_BITS (Alg) / 8)
-
-#define MAX_DIGEST_BIN_BYTES MAX (DIGEST_BIN_BYTES (ALG_MD5), \
-				  DIGEST_BIN_BYTES (ALG_SHA1))
+#define AUTHORS "Ulrich Drepper", "Scott Miller", "David Madore"
 
 /* The minimum length of a valid digest line.  This length does
    not include any newline character at the end of a line.  */
-#define MIN_DIGEST_LINE_LENGTH(Alg) \
-  (DIGEST_HEX_BYTES (Alg) /* length of hexadecimal message digest */ \
+#define MIN_DIGEST_LINE_LENGTH \
+  (DIGEST_HEX_BYTES /* length of hexadecimal message digest */ \
    + 2 /* blank and binary indicator */ \
    + 1 /* minimum filename length */ )
 
@@ -72,9 +117,6 @@
    improperly formatted checksum line.  */
 static bool warn = false;
 
-/* Declared and set via one of the wrapper .c files.  */
-/* int algorithm = ALG_UNSPECIFIED; */
-
 /* The name this program was run with.  */
 char *program_name;
 
@@ -112,8 +154,8 @@
 \n\
 "),
 	      program_name,
-	      DIGEST_TYPE_STRING (algorithm),
-	      DIGEST_BITS (algorithm));
+	      DIGEST_TYPE_STRING,
+	      DIGEST_BITS);
       if (O_BINARY)
 	fputs (_("\
   -b, --binary            read in binary mode (default unless reading tty stdin)\n\
@@ -124,7 +166,7 @@
 "), stdout);
       printf (_("\
   -c, --check             read %s sums from the FILEs and check them\n"),
-	      DIGEST_TYPE_STRING (algorithm));
+	      DIGEST_TYPE_STRING);
       if (O_BINARY)
 	fputs (_("\
   -t, --text              read in text mode (default if reading tty stdin)\n\
@@ -148,7 +190,7 @@
 should be a former output of this program.  The default mode is to print\n\
 a line with checksum, a character indicating type (`*' for binary, ` ' for\n\
 text), and name for each FILE.\n"),
-	      (algorithm == ALG_MD5 ? "RFC 1321" : "FIPS-180-1"));
+	      DIGEST_SOURCE);
       printf (_("\nReport bugs to <%s>.\n"), PACKAGE_BUGREPORT);
     }
 
@@ -211,8 +253,8 @@
     ++i;
 
   /* Check for BSD-style checksum line. */
-  algo_name_len = strlen (DIGEST_TYPE_STRING (algorithm));
-  if (strncmp (s + i, DIGEST_TYPE_STRING (algorithm), algo_name_len) == 0)
+  algo_name_len = strlen (DIGEST_TYPE_STRING);
+  if (strncmp (s + i, DIGEST_TYPE_STRING, algo_name_len) == 0)
     {
       if (strncmp (s + i + algo_name_len, " (", 2) == 0)
 	{
@@ -326,8 +368,7 @@
    Return true if successful.  */
 
 static bool
-digest_file (const char *filename, int *binary, unsigned char *bin_result,
-	     int (*digest_stream) (FILE *, void *))
+digest_file (const char *filename, int *binary, unsigned char *bin_result)
 {
   FILE *fp;
   int err;
@@ -355,7 +396,7 @@
 	}
     }
 
-  err = (*digest_stream) (fp, bin_result);
+  err = DIGEST_STREAM (fp, bin_result);
   if (err)
     {
       error (0, errno, "%s", filename);
@@ -374,13 +415,13 @@
 }
 
 static bool
-digest_check (const char *checkfile_name, int (*digest_stream) (FILE *, void *))
+digest_check (const char *checkfile_name)
 {
   FILE *checkfile_stream;
   uintmax_t n_properly_formatted_lines = 0;
   uintmax_t n_mismatched_checksums = 0;
   uintmax_t n_open_or_read_failures = 0;
-  unsigned char bin_buffer[MAX_DIGEST_BIN_BYTES];
+  unsigned char bin_buffer[DIGEST_BIN_BYTES];
   uintmax_t line_number;
   char *line;
   size_t line_chars_allocated;
@@ -439,7 +480,7 @@
 		     _("%s: %" PRIuMAX
 		       ": improperly formatted %s checksum line"),
 		     checkfile_name, line_number,
-		     DIGEST_TYPE_STRING (algorithm));
+		     DIGEST_TYPE_STRING);
 	    }
 	}
       else
@@ -452,7 +493,7 @@
 
 	  ++n_properly_formatted_lines;
 
-	  ok = digest_file (filename, &binary, bin_buffer, digest_stream);
+	  ok = digest_file (filename, &binary, bin_buffer);
 
 	  if (!ok)
 	    {
@@ -509,7 +550,7 @@
     {
       /* Warn if no tests are found.  */
       error (0, 0, _("%s: no properly formatted %s checksum lines found"),
-	     checkfile_name, DIGEST_TYPE_STRING (algorithm));
+	     checkfile_name, DIGEST_TYPE_STRING);
     }
   else
     {
@@ -547,7 +588,7 @@
 int
 main (int argc, char **argv)
 {
-  unsigned char bin_buffer[MAX_DIGEST_BIN_BYTES];
+  unsigned char bin_buffer[DIGEST_BIN_BYTES];
   bool do_check = false;
   int opt;
   bool ok = true;
@@ -588,8 +629,8 @@
 	usage (EXIT_FAILURE);
       }
 
-  min_digest_line_length = MIN_DIGEST_LINE_LENGTH (algorithm);
-  digest_hex_bytes = DIGEST_HEX_BYTES (algorithm);
+  min_digest_line_length = MIN_DIGEST_LINE_LENGTH;
+  digest_hex_bytes = DIGEST_HEX_BYTES;
 
   if (0 <= binary && do_check)
     {
@@ -623,13 +664,12 @@
       char *file = argv[optind];
 
       if (do_check)
-	ok &= digest_check (file, DIGEST_STREAM (algorithm));
+	ok &= digest_check (file);
       else
 	{
 	  int file_is_binary = binary;
 
-	  if (! digest_file (file, &file_is_binary, bin_buffer,
-			     DIGEST_STREAM (algorithm)))
+	  if (! digest_file (file, &file_is_binary, bin_buffer))
 	    ok = false;
 	  else
 	    {
diff -Nru coreutils-5.97.orig/src/sha1sum.c coreutils-5.97/src/sha1sum.c
--- coreutils-5.97.orig/src/sha1sum.c	2004-07-30 02:54:20.000000000 +0200
+++ coreutils-5.97/src/sha1sum.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-#include "checksum.h"
-int algorithm = ALG_SHA1;
diff -Nru coreutils-5.97.orig/tests/Makefile.am coreutils-5.97/tests/Makefile.am
--- coreutils-5.97.orig/tests/Makefile.am	2005-08-13 19:34:11.000000000 +0200
+++ coreutils-5.97/tests/Makefile.am	2006-07-31 13:51:41.000000000 +0200
@@ -21,7 +21,8 @@
 SUBDIRS = \
   basename chgrp chmod chown cp cut dd dircolors du expr factor \
   fmt head install join ln ls ls-2 md5sum misc mkdir mv od pr readlink \
-  rm rmdir seq sha1sum shred sort stty sum tac tail tail-2 tee test \
+  rm rmdir seq sha1sum sha224sum sha256sum sha384sum sha512sum \
+  shred sort stty sum tac tail tail-2 tee test \
   touch tr tsort unexpand uniq wc
 
 .PHONY: check-root
diff -Nru coreutils-5.97.orig/tests/sha224sum/Makefile.am coreutils-5.97/tests/sha224sum/Makefile.am
--- coreutils-5.97.orig/tests/sha224sum/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-5.97/tests/sha224sum/Makefile.am	2006-07-31 13:51:41.000000000 +0200
@@ -0,0 +1,12 @@
+## Process this file with automake to produce Makefile.in -*-Makefile-*-.
+
+EXTRA_DIST = $(TESTS)
+
+TESTS_ENVIRONMENT = \
+  top_srcdir=$(top_srcdir) \
+  srcdir=$(srcdir) \
+  PERL="$(PERL)" \
+  PATH="`pwd`/../../src$(PATH_SEPARATOR)$$PATH" \
+  PROG=sha224sum
+
+TESTS = basic-1
diff -Nru coreutils-5.97.orig/tests/sha224sum/basic-1 coreutils-5.97/tests/sha224sum/basic-1
--- coreutils-5.97.orig/tests/sha224sum/basic-1	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-5.97/tests/sha224sum/basic-1	2006-07-31 13:51:41.000000000 +0200
@@ -0,0 +1,43 @@
+#!/bin/sh
+
+: ${PERL=perl}
+: ${srcdir=.}
+
+$PERL -e 1 > /dev/null 2>&1 || {
+  echo 1>&2 "$0: configure didn't find a usable version of Perl," \
+    "so can't run this test"
+  exit 77
+}
+
+exec $PERL -w -I$srcdir/.. -MCoreutils -- - <<\EOF
+require 5.003;
+use strict;
+
+(my $program_name = $0) =~ s|.*/||;
+
+# Turn off localisation of executable's ouput.
+@ENV{qw(LANGUAGE LANG LC_ALL)} = ('C') x 3;
+
+my @Tests =
+    (
+     ['s3', {IN=> {f=> 'abc'}},
+			{OUT=>"23097d223405d8228642a477bda255b32aadbce4bda0b3f7e36c9da7  f\n"}],
+     ['s4',
+      {IN=> {f=> 'abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq'}},
+			{OUT=>"75388b16512776cc5dba5da1fd890150b0c6455cb4f58b1952522525  f\n"}],
+    );
+
+# Insert the `--text' argument for each test.
+my $t;
+foreach $t (@Tests)
+  {
+    splice @$t, 1, 0, '--text' unless @$t[1] =~ /--check/;
+  }
+
+my $save_temps = $ENV{DEBUG};
+my $verbose = $ENV{VERBOSE};
+
+my $prog = $ENV{PROG} || die "$0: \$PROG not specified in environment\n";
+my $fail = run_tests ($program_name, $prog, \@Tests, $save_temps, $verbose);
+exit $fail;
+EOF
diff -Nru coreutils-5.97.orig/tests/sha256sum/Makefile.am coreutils-5.97/tests/sha256sum/Makefile.am
--- coreutils-5.97.orig/tests/sha256sum/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-5.97/tests/sha256sum/Makefile.am	2006-07-31 13:51:41.000000000 +0200
@@ -0,0 +1,12 @@
+## Process this file with automake to produce Makefile.in -*-Makefile-*-.
+
+EXTRA_DIST = $(TESTS)
+
+TESTS_ENVIRONMENT = \
+  top_srcdir=$(top_srcdir) \
+  srcdir=$(srcdir) \
+  PERL="$(PERL)" \
+  PATH="`pwd`/../../src$(PATH_SEPARATOR)$$PATH" \
+  PROG=sha256sum
+
+TESTS = basic-1
diff -Nru coreutils-5.97.orig/tests/sha256sum/basic-1 coreutils-5.97/tests/sha256sum/basic-1
--- coreutils-5.97.orig/tests/sha256sum/basic-1	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-5.97/tests/sha256sum/basic-1	2006-07-31 13:51:41.000000000 +0200
@@ -0,0 +1,49 @@
+#!/bin/sh
+
+: ${PERL=perl}
+: ${srcdir=.}
+
+$PERL -e 1 > /dev/null 2>&1 || {
+  echo 1>&2 "$0: configure didn't find a usable version of Perl," \
+    "so can't run this test"
+  exit 77
+}
+
+exec $PERL -w -I$srcdir/.. -MCoreutils -- - <<\EOF
+require 5.003;
+use strict;
+
+(my $program_name = $0) =~ s|.*/||;
+
+# Turn off localisation of executable's ouput.
+@ENV{qw(LANGUAGE LANG LC_ALL)} = ('C') x 3;
+
+my $sha_degenerate = "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
+
+my @Tests =
+    (
+     ['s1', {IN=> {f=> ''}},
+			{OUT=>"$sha_degenerate  f\n"}],
+     ['s2', {IN=> {f=> 'a'}},
+			{OUT=>"ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb  f\n"}],
+     ['s3', {IN=> {f=> 'abc'}},
+			{OUT=>"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad  f\n"}],
+     ['s4',
+      {IN=> {f=> 'abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq'}},
+			{OUT=>"248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1  f\n"}],
+    );
+
+# Insert the `--text' argument for each test.
+my $t;
+foreach $t (@Tests)
+  {
+    splice @$t, 1, 0, '--text' unless @$t[1] =~ /--check/;
+  }
+
+my $save_temps = $ENV{DEBUG};
+my $verbose = $ENV{VERBOSE};
+
+my $prog = $ENV{PROG} || die "$0: \$PROG not specified in environment\n";
+my $fail = run_tests ($program_name, $prog, \@Tests, $save_temps, $verbose);
+exit $fail;
+EOF
diff -Nru coreutils-5.97.orig/tests/sha384sum/Makefile.am coreutils-5.97/tests/sha384sum/Makefile.am
--- coreutils-5.97.orig/tests/sha384sum/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-5.97/tests/sha384sum/Makefile.am	2006-07-31 13:51:41.000000000 +0200
@@ -0,0 +1,12 @@
+## Process this file with automake to produce Makefile.in -*-Makefile-*-.
+
+EXTRA_DIST = $(TESTS)
+
+TESTS_ENVIRONMENT = \
+  top_srcdir=$(top_srcdir) \
+  srcdir=$(srcdir) \
+  PERL="$(PERL)" \
+  PATH="`pwd`/../../src$(PATH_SEPARATOR)$$PATH" \
+  PROG=sha384sum
+
+TESTS = basic-1
diff -Nru coreutils-5.97.orig/tests/sha384sum/basic-1 coreutils-5.97/tests/sha384sum/basic-1
--- coreutils-5.97.orig/tests/sha384sum/basic-1	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-5.97/tests/sha384sum/basic-1	2006-07-31 13:51:41.000000000 +0200
@@ -0,0 +1,49 @@
+#!/bin/sh
+
+: ${PERL=perl}
+: ${srcdir=.}
+
+$PERL -e 1 > /dev/null 2>&1 || {
+  echo 1>&2 "$0: configure didn't find a usable version of Perl," \
+    "so can't run this test"
+  exit 77
+}
+
+exec $PERL -w -I$srcdir/.. -MCoreutils -- - <<\EOF
+require 5.003;
+use strict;
+
+(my $program_name = $0) =~ s|.*/||;
+
+# Turn off localisation of executable's ouput.
+@ENV{qw(LANGUAGE LANG LC_ALL)} = ('C') x 3;
+
+my $sha_degenerate = "38b060a751ac96384cd9327eb1b1e36a21fdb71114be07434c0cc7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b";
+
+my @Tests =
+    (
+     ['s1', {IN=> {f=> ''}},
+			{OUT=>"$sha_degenerate  f\n"}],
+     ['s2', {IN=> {f=> 'a'}},
+			{OUT=>"54a59b9f22b0b80880d8427e548b7c23abd873486e1f035dce9cd697e85175033caa88e6d57bc35efae0b5afd3145f31  f\n"}],
+     ['s3', {IN=> {f=> 'abc'}},
+			{OUT=>"cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed8086072ba1e7cc2358baeca134c825a7  f\n"}],
+     ['s4',
+      {IN=> {f=> 'abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu'}},
+			{OUT=>"09330c33f71147e83d192fc782cd1b4753111b173b3b05d22fa08086e3b0f712fcc7c71a557e2db966c3e9fa91746039  f\n"}],
+    );
+
+# Insert the `--text' argument for each test.
+my $t;
+foreach $t (@Tests)
+  {
+    splice @$t, 1, 0, '--text' unless @$t[1] =~ /--check/;
+  }
+
+my $save_temps = $ENV{DEBUG};
+my $verbose = $ENV{VERBOSE};
+
+my $prog = $ENV{PROG} || die "$0: \$PROG not specified in environment\n";
+my $fail = run_tests ($program_name, $prog, \@Tests, $save_temps, $verbose);
+exit $fail;
+EOF
diff -Nru coreutils-5.97.orig/tests/sha512sum/Makefile.am coreutils-5.97/tests/sha512sum/Makefile.am
--- coreutils-5.97.orig/tests/sha512sum/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-5.97/tests/sha512sum/Makefile.am	2006-07-31 13:51:41.000000000 +0200
@@ -0,0 +1,12 @@
+## Process this file with automake to produce Makefile.in -*-Makefile-*-.
+
+EXTRA_DIST = $(TESTS)
+
+TESTS_ENVIRONMENT = \
+  top_srcdir=$(top_srcdir) \
+  srcdir=$(srcdir) \
+  PERL="$(PERL)" \
+  PATH="`pwd`/../../src$(PATH_SEPARATOR)$$PATH" \
+  PROG=sha512sum
+
+TESTS = basic-1
diff -Nru coreutils-5.97.orig/tests/sha512sum/basic-1 coreutils-5.97/tests/sha512sum/basic-1
--- coreutils-5.97.orig/tests/sha512sum/basic-1	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-5.97/tests/sha512sum/basic-1	2006-07-31 13:51:41.000000000 +0200
@@ -0,0 +1,49 @@
+#!/bin/sh
+
+: ${PERL=perl}
+: ${srcdir=.}
+
+$PERL -e 1 > /dev/null 2>&1 || {
+  echo 1>&2 "$0: configure didn't find a usable version of Perl," \
+    "so can't run this test"
+  exit 77
+}
+
+exec $PERL -w -I$srcdir/.. -MCoreutils -- - <<\EOF
+require 5.003;
+use strict;
+
+(my $program_name = $0) =~ s|.*/||;
+
+# Turn off localisation of executable's ouput.
+@ENV{qw(LANGUAGE LANG LC_ALL)} = ('C') x 3;
+
+my $sha_degenerate = "cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e";
+
+my @Tests =
+    (
+     ['s1', {IN=> {f=> ''}},
+			{OUT=>"$sha_degenerate  f\n"}],
+     ['s2', {IN=> {f=> 'a'}},
+			{OUT=>"1f40fc92da241694750979ee6cf582f2d5d7d28e18335de05abc54d0560e0f5302860c652bf08d560252aa5e74210546f369fbbbce8c12cfc7957b2652fe9a75  f\n"}],
+     ['s3', {IN=> {f=> 'abc'}},
+			{OUT=>"ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f  f\n"}],
+     ['s4',
+      {IN=> {f=> 'abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu'}},
+			{OUT=>"8e959b75dae313da8cf4f72814fc143f8f7779c6eb9f7fa17299aeadb6889018501d289e4900f7e4331b99dec4b5433ac7d329eeb6dd26545e96e55b874be909  f\n"}],
+    );
+
+# Insert the `--text' argument for each test.
+my $t;
+foreach $t (@Tests)
+  {
+    splice @$t, 1, 0, '--text' unless @$t[1] =~ /--check/;
+  }
+
+my $save_temps = $ENV{DEBUG};
+my $verbose = $ENV{VERBOSE};
+
+my $prog = $ENV{PROG} || die "$0: \$PROG not specified in environment\n";
+my $fail = run_tests ($program_name, $prog, \@Tests, $save_temps, $verbose);
+exit $fail;
+EOF
