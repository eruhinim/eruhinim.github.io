Description: This patch updates the cc-mode to upsream VCS 
 This patch pulls in the latest version of the cc-mode available 
 from upstream as of 2014/09/25. The patch fixes problems with the 
 auto-indention being clobbered after an include statement with angled
 brackets is addeed. 
Origin: upstream, http://sourceforge.net/p/cc-mode/cc-mode/ci/default/tree/
Forwarded: not-needed
Last-Update: 2014-09-25

--- emacs24-24.3+1.orig/lisp/progmodes/cc-align.el
+++ emacs24-24.3+1/lisp/progmodes/cc-align.el
@@ -1,32 +1,34 @@
 ;;; cc-align.el --- custom indentation functions for CC Mode
 
-;; Copyright (C) 1985, 1987, 1992-2013 Free Software Foundation, Inc.
+;; Copyright (C) 1985, 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+;;   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+;;   2010, 2011   Free Software Foundation, Inc.
 
 ;; Authors:    2004- Alan Mackenzie
-;;             1998- Martin Stjernholm
-;;             1992-1999 Barry A. Warsaw
-;;             1987 Dave Detlefs
-;;             1987 Stewart Clamen
-;;             1985 Richard M. Stallman
+;;	       1998- Martin Stjernholm
+;;	       1992-1999 Barry A. Warsaw
+;;	       1987 Dave Detlefs and Stewart Clamen
+;;	       1985 Richard M. Stallman
 ;; Maintainer: bug-cc-mode@gnu.org
 ;; Created:    22-Apr-1997 (split from cc-mode.el)
-;; Keywords:   c languages
-;; Package:    cc-mode
+;; Version:    See cc-mode.el
+;; Keywords:   c languages oop
 
 ;; This file is part of GNU Emacs.
 
-;; GNU Emacs is free software: you can redistribute it and/or modify
+;; GNU Emacs is free software; you can redistribute it and/or modify
 ;; it under the terms of the GNU General Public License as published by
-;; the Free Software Foundation, either version 3 of the License, or
-;; (at your option) any later version.
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
 
 ;; GNU Emacs is distributed in the hope that it will be useful,
 ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
 ;; GNU General Public License for more details.
 
 ;; You should have received a copy of the GNU General Public License
-;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
+;; along with this program; see the file COPYING.  If not, see
+;; <http://www.gnu.org/licenses/>.
 
 ;;; Commentary:
 
@@ -53,25 +55,25 @@
 (defun c-lineup-topmost-intro-cont (langelem)
   "Line up declaration continuation lines zero or one indentation step.
 For lines in the \"header\" of a definition, zero is used.  For other
-lines, `c-basic-offset' is added to the indentation.  E.g.:
+lines, `c-basic-offset' is added to the indentation.  E.g:
 
 int
-neg (int i)           <- c-lineup-topmost-intro-cont
+neg (int i)	      <- c-lineup-topmost-intro-cont
 {
     return -i;
 }
 
 struct
-larch                 <- c-lineup-topmost-intro-cont
+larch		      <- c-lineup-topmost-intro-cont
 {
     double height;
 }
-    the_larch,        <- c-lineup-topmost-intro-cont
+    the_larch,	      <- c-lineup-topmost-intro-cont
     another_larch;    <- c-lineup-topmost-intro-cont
 <--> c-basic-offset
 
 struct larch
-the_larch,            <- c-lineup-topmost-intro-cont
+the_larch,	      <- c-lineup-topmost-intro-cont
     another_larch;    <- c-lineup-topmost-intro-cont
 
 \(This function is mainly provided to mimic the behavior of CC Mode
@@ -101,8 +103,8 @@ Here is an example:
 DEFUN (\"forward-char\", Fforward_char, Sforward_char, 0, 1, \"p\",
        doc: /* Move point right N characters (left if N is negative).
 On reaching end of buffer, stop and signal error.  */)
-     (n)                      <- c-lineup-gnu-DEFUN-into-cont
-     Lisp_Object n;           <- c-lineup-gnu-DEFUN-into-cont
+     (n)		      <- c-lineup-gnu-DEFUN-into-cont
+     Lisp_Object n;	      <- c-lineup-gnu-DEFUN-into-cont
 
 Works with: topmost-intro-cont."
   (save-excursion
@@ -119,7 +121,7 @@ Works with: topmost-intro-cont."
 
   (or
    ;; Check if the syntactic context contains any of the symbols for
-   ;; in-expression constructs.  This can both save the work that we
+   ;; in-expression constructs.	 This can both save the work that we
    ;; have to do below, and it also detect the brace list constructs
    ;; that `c-looking-at-inexpr-block' currently misses (they are
    ;; recognized by `c-inside-bracelist-p' instead).
@@ -165,10 +167,10 @@ Works with: topmost-intro-cont."
 As a special case, if the indented line is inside a brace block
 construct, the indentation is `c-basic-offset' only.  This is intended
 as a \"DWIM\" measure in cases like macros that contains statement
-blocks, e.g.:
+blocks, e.g:
 
 A_VERY_LONG_MACRO_NAME ({
-        some (code, with + long, lines * in[it]);
+	some (code, with + long, lines * in[it]);
     });
 <--> c-basic-offset
 
@@ -184,7 +186,7 @@ Works with: arglist-cont-nonempty, argli
       (if (c-block-in-arglist-dwim (c-langelem-2nd-pos c-syntactic-element))
 	  c-basic-offset		; DWIM case.
 
-	;; Normal case.  Indent to the token after the arglist open paren.
+	;; Normal case.	 Indent to the token after the arglist open paren.
 	(goto-char (c-langelem-2nd-pos c-syntactic-element))
 	(if (and c-special-brace-lists
 		 (c-looking-at-special-brace-list))
@@ -204,7 +206,7 @@ Works with: arglist-cont-nonempty, argli
   "Line up a continued argument.
 
 foo (xyz, aaa + bbb + ccc
-          + ddd + eee + fff);    <- c-lineup-argcont
+	  + ddd + eee + fff);	 <- c-lineup-argcont
 
 Only continuation lines like this are touched, nil is returned on lines
 which are the start of an argument.
@@ -286,7 +288,7 @@ the open paren.
 
 As a special case, if a brace block construct starts at the same line
 as the open parenthesis of the argument list, the indentation is
-`c-basic-offset' only.  See `c-lineup-arglist' for further discussion
+`c-basic-offset' only.	See `c-lineup-arglist' for further discussion
 of this \"DWIM\" measure.
 
 Works with: Almost all symbols, but are typically most useful on
@@ -316,8 +318,8 @@ Return nil on lines that don't start wit
 cases to other line-up functions.  Example:
 
 if (  x < 10
-   || at_limit (x,       <- c-lineup-arglist-operators
-                list)    <- c-lineup-arglist-operators returns nil
+   || at_limit (x,	 <- c-lineup-arglist-operators
+		list)	 <- c-lineup-arglist-operators returns nil
    )
 
 Since this function doesn't do anything for lines without an infix
@@ -327,7 +329,7 @@ suggestion to get a consistent style):
 
 \(c-set-offset 'arglist-cont '(c-lineup-arglist-operators 0))
 \(c-set-offset 'arglist-cont-nonempty '(c-lineup-arglist-operators
-                                        c-lineup-arglist))
+					c-lineup-arglist))
 \(c-set-offset 'arglist-close '(c-lineup-arglist-close-under-paren))
 
 Works with: arglist-cont, arglist-cont-nonempty."
@@ -339,12 +341,12 @@ Works with: arglist-cont, arglist-cont-n
 
 (defun c-lineup-close-paren (langelem)
   "Line up the closing paren under its corresponding open paren if the
-open paren is followed by code.  If the open paren ends its line, no
-indentation is added.  E.g.:
+open paren is followed by code.	 If the open paren ends its line, no
+indentation is added.  E.g:
 
-main (int,              main (
-      char **               int, char **
-     )           <->    )                 <- c-lineup-close-paren
+main (int,		main (
+      char **		    int, char **
+     )		 <->	)		  <- c-lineup-close-paren
 
 As a special case, if a brace block construct starts at the same line
 as the open parenthesis of the argument list, the indentation is
@@ -394,19 +396,19 @@ Works with: stream-op."
 
 (defun c-lineup-multi-inher (langelem)
   "Line up the classes in C++ multiple inheritance clauses and member
-initializers under each other.  E.g.:
+initializers under each other.	E.g:
 
-class Foo:                Foo::Foo (int a, int b):
-    public Cyphr,             Cyphr (a),
-    public Bar       <->      Bar (b)               <- c-lineup-multi-inher
-
-class Foo                 Foo::Foo (int a, int b)
-    : public Cyphr,           : Cyphr (a),
-      public Bar     <->        Bar (b)             <- c-lineup-multi-inher
-
-class Foo                 Foo::Foo (int a, int b)
-    : public Cyphr            : Cyphr (a)
-    , public Bar     <->      , Bar (b)             <- c-lineup-multi-inher
+class Foo:		  Foo::Foo (int a, int b):
+    public Cyphr,	      Cyphr (a),
+    public Bar	     <->      Bar (b)		    <- c-lineup-multi-inher
+
+class Foo		  Foo::Foo (int a, int b)
+    : public Cyphr,	      : Cyphr (a),
+      public Bar     <->	Bar (b)		    <- c-lineup-multi-inher
+
+class Foo		  Foo::Foo (int a, int b)
+    : public Cyphr	      : Cyphr (a)
+    , public Bar     <->      , Bar (b)		    <- c-lineup-multi-inher
 
 Works with: inher-cont, member-init-cont."
   (save-excursion
@@ -439,11 +441,11 @@ Works with: inher-cont, member-init-cont
 If class names follow on the same line as the implements/extends
 keyword, they are lined up under each other.  Otherwise, they are
 indented by adding `c-basic-offset' to the column of the keyword.
-E.g.:
+E.g:
 
-class Foo             class Foo
-    extends               extends Cyphr,
-        Bar    <->                Bar     <- c-lineup-java-inher
+class Foo	      class Foo
+    extends		  extends Cyphr,
+	Bar    <->		  Bar	  <- c-lineup-java-inher
     <--> c-basic-offset
 
 Works with: inher-cont."
@@ -461,11 +463,11 @@ If exception names follow on the same li
 they are lined up under each other.  Otherwise, they are indented by
 adding `c-basic-offset' to the column of the throws keyword.  The
 throws keyword itself is also indented by `c-basic-offset' from the
-function declaration start if it doesn't hang.  E.g.:
+function declaration start if it doesn't hang.	E.g:
 
-int foo()           int foo() throws Cyphr,
-    throws     <->                   Bar,    <- c-lineup-java-throws
-        Bar    <->                   Vlod    <- c-lineup-java-throws
+int foo()	    int foo() throws Cyphr,
+    throws     <->		     Bar,    <- c-lineup-java-throws
+	Bar    <->		     Vlod    <- c-lineup-java-throws
 <--><--> c-basic-offset
 
 Works with: func-decl-cont."
@@ -485,12 +487,12 @@ Works with: func-decl-cont."
 
 (defun c-indent-one-line-block (langelem)
   "Indent a one line block `c-basic-offset' extra.
-E.g.:
+E.g:
 
-if (n > 0)                 if (n > 0)
-    {m+=n; n=0;}    <->    {               <- c-indent-one-line-block
-<--> c-basic-offset            m+=n; n=0;
-                           }
+if (n > 0)		   if (n > 0)
+    {m+=n; n=0;}    <->	   {		   <- c-indent-one-line-block
+<--> c-basic-offset	       m+=n; n=0;
+			   }
 
 The block may use any kind of parenthesis character.  nil is returned
 if the line doesn't start with a one line block, which makes the
@@ -508,14 +510,14 @@ Work with: Almost all syntactic symbols,
 
 (defun c-indent-multi-line-block (langelem)
   "Indent a multi line block `c-basic-offset' extra.
-E.g.:
+E.g:
 
-int *foo[] = {           int *foo[] = {
-    NULL,                    NULL,
-    {17},         <->            {       <- c-indent-multi-line-block
-                                 17
-                                 }
-                             <--> c-basic-offset
+int *foo[] = {		 int *foo[] = {
+    NULL,		     NULL,
+    {17},	  <->		 {	 <- c-indent-multi-line-block
+				 17
+				 }
+			     <--> c-basic-offset
 
 The block may use any kind of parenthesis character.  nil is returned
 if the line doesn't start with a multi line block, which makes the
@@ -534,11 +536,11 @@ Work with: Almost all syntactic symbols,
 (defun c-lineup-C-comments (langelem)
   "Line up C block comment continuation lines.
 Various heuristics are used to handle many of the common comment
-styles.  Some examples:
+styles.	 Some examples:
 
-/*          /**         /*         /* text      /*          /**
- * text      * text       text        text      ** text      ** text
- */          */         */         */           */           */
+/*	    /**		/*	   /* text	/*	    /**
+ * text	     * text	  text	      text	** text	     ** text
+ */	     */		*/	   */		*/	     */
 
 /*********************************************************************
  * text
@@ -587,7 +589,7 @@ Works with: The `c' syntactic symbol."
 		      1)))))
       (if (and (> starterlen 10) (zerop prefixlen))
 	  ;; The comment has a long starter and the line doesn't have
-	  ;; a nonempty comment prefix.  Treat it as free form text
+	  ;; a nonempty comment prefix.	 Treat it as free form text
 	  ;; and don't change the indentation.
 	  (vector (current-column))
 	;; Go back to the previous non-blank line, if any.
@@ -609,9 +611,9 @@ Works with: The `c' syntactic symbol."
 		  ;; comment-start-skip should match everything (i.e.
 		  ;; typically whitespace) that leads up to the text.
 		  ;;(if (looking-at "\\([ \t]+\\).+$")
-		  ;;    ;; Align with the text that hangs after the
-		  ;;    ;; comment starter.
-		  ;;    (goto-char (match-end 1)))
+		  ;;	;; Align with the text that hangs after the
+		  ;;	;; comment starter.
+		  ;;	(goto-char (match-end 1)))
 		  (vector (current-column)))
 	      ;; How long is the comment starter?  if greater than the
 	      ;; length of the comment prefix, align left.  if less
@@ -623,7 +625,7 @@ Works with: The `c' syntactic symbol."
 		    (vector (1+ (current-column))))
 		(goto-char (+ (c-langelem-pos langelem) starterlen 1))
 		(vector (- (current-column) prefixlen))))
-	  ;; We didn't start on the first non-blank continuation line.  If the
+	  ;; We didn't start on the first non-blank continuation line.	If the
 	  ;; previous line has a nonempty comment prefix, align with it.
 	  ;; Otherwise, align with the previous nonempty line, but align the
 	  ;; comment ender with the starter.
@@ -670,7 +672,7 @@ Works with: comment-intro."
 (defun c-lineup-knr-region-comment (langelem)
   "Line up a comment in the \"K&R region\" with the declaration.
 That is the region between the function or class header and the
-beginning of the block.  E.g.:
+beginning of the block.	 E.g:
 
 int main()
 /* This is the main function. */  <- c-lineup-knr-region-comment
@@ -693,11 +695,11 @@ Works with: comment-intro."
 
 (defun c-lineup-runin-statements (langelem)
   "Line up statements when the first statement is on the same line as
-the block opening brace.  E.g.:
+the block opening brace.  E.g:
 
 int main()
 { puts (\"Hello world!\");
-  return 0;                 <- c-lineup-runin-statements
+  return 0;		    <- c-lineup-runin-statements
 }
 
 If there is no statement after the opening brace to align with, nil is
@@ -715,8 +717,8 @@ Works with: The `statement' syntactic sy
 
 (defun c-lineup-assignments (langelem)
   "Line up the current line after the assignment operator on the first
-line in the statement.  If there isn't any, return nil to allow
-stacking with other line-up functions.  If the current line contains
+line in the statement.	If there isn't any, return nil to allow
+stacking with other line-up functions.	If the current line contains
 an assignment operator too, try to align it with the first one.
 
 Works with: topmost-intro-cont, statement-cont, arglist-cont,
@@ -737,10 +739,10 @@ arglist-cont-nonempty."
 	      (setq startpos (c-langelem-pos langelem)))))
 
       (setq startpos (c-langelem-pos langelem)
-	    endpos (point))
+	    endpos (c-point 'bol))
 
       ;; Find a syntactically relevant and unnested "=" token on the
-      ;; current line.  equalp is in that case set to the number of
+      ;; current line.	equalp is in that case set to the number of
       ;; columns to left shift the current line to align it with the
       ;; goal column.
       (save-excursion
@@ -794,11 +796,11 @@ arglist-cont-nonempty."
   "Line up \"cascaded calls\" under each other.
 If the line begins with \"->\" or \".\" and the preceding line ends
 with one or more function calls preceded by the same token, then the
-arrow is lined up with the first of those tokens.  E.g.:
+arrow is lined up with the first of those tokens.  E.g:
 
 result = proc->add(17)->add(18)
-             ->add(19) +           <- c-lineup-cascaded-calls
-  offset;                          <- c-lineup-cascaded-calls (inactive)
+	     ->add(19) +	   <- c-lineup-cascaded-calls
+  offset;			   <- c-lineup-cascaded-calls (inactive)
 
 In any other situation nil is returned to allow use in list
 expressions.
@@ -839,10 +841,10 @@ arglist-cont-nonempty."
 (defun c-lineup-string-cont (langelem)
   "Line up a continued string under the one it continues.
 A continued string in this sense is where a string literal follows
-directly after another one.  E.g.:
+directly after another one.  E.g:
 
 result = prefix + \"A message \"
-                  \"string.\";      <- c-lineup-string-cont
+		  \"string.\";	    <- c-lineup-string-cont
 
 In other situations, returns nil, to allow stacking with other
 line-up functions.
@@ -892,10 +894,10 @@ Works with: objc-method-call-cont."
 			(- c-basic-offset)
 		      0)))
 	   (open-bracket-pos (c-langelem-pos langelem))
-           (open-bracket-col (progn
+	   (open-bracket-col (progn
 			       (goto-char open-bracket-pos)
 			       (current-column)))
-           (target-col (progn
+	   (target-col (progn
 			 (forward-char)
 			 (c-forward-sexp)
 			 (skip-chars-forward " \t")
@@ -921,8 +923,8 @@ Works with: objc-method-call-cont."
 				 ; no complete argument to indent yet
 				 (throw 'no-idea nil))))
 
-	     (extra (save-excursion
-                      ; indent parameter to argument if needed
+	     (extra (save-excursion 
+		      ; indent parameter to argument if needed
 		      (back-to-indentation)
 		      (c-backward-syntactic-ws (c-langelem-pos langelem))
 		      (if (eq ?: (char-before))
@@ -939,7 +941,7 @@ Works with: objc-method-call-cont."
 			    (- (current-column) open-bracket-col
 			       method-arg-len extra)
 			  ; previous arg has no param
-  			  c-objc-method-arg-unfinished-offset))))
+			  c-objc-method-arg-unfinished-offset))))
 
 	(if (>= arg-ralign-colon-ofs c-objc-method-arg-min-delta-to-bracket)
 	    (+ arg-ralign-colon-ofs extra)
@@ -1023,13 +1025,13 @@ Works with: inlambda, inexpr-statement,
 (defun c-lineup-whitesmith-in-block (langelem)
   "Line up lines inside a block in Whitesmith style.
 It's done in a way that works both when the opening brace hangs and
-when it doesn't.  E.g.:
+when it doesn't.  E.g:
 
 something
-    {                something {
-    foo;     <->         foo;     <- c-lineup-whitesmith-in-block
-    }                    }
-                     <--> c-basic-offset
+    {		     something {
+    foo;     <->	 foo;	  <- c-lineup-whitesmith-in-block
+    }			 }
+		     <--> c-basic-offset
 
 In the first case the indentation is kept unchanged, in the
 second `c-basic-offset' is added.
@@ -1039,6 +1041,7 @@ brace-list-close, brace-list-intro, stat
 arglist-intro, arglist-cont-nonempty, arglist-close, and all in*
 symbols, e.g. inclass and inextern-lang."
   (save-excursion
+    (beginning-of-line)
     (if (and (c-go-up-list-backward)
 	     (= (point) (c-point 'boi)))
 	nil
@@ -1051,12 +1054,12 @@ inside blocks, this function is necessar
 correct Whitesmith style indentation.  Consider the following
 examples:
 
-                    int foo()
-                        {
-int foo()                   {
-    {                       a;
-    a;                      }
-    x;       <->        x;        <- c-lineup-after-whitesmith-blocks
+		    int foo()
+			{
+int foo()		    {
+    {			    a;
+    a;			    }
+    x;	     <->	x;	  <- c-lineup-after-whitesmith-blocks
 
 The fact that the line with \"x\" is preceded by a Whitesmith style
 indented block in one case and not the other should not affect its
@@ -1066,7 +1069,7 @@ would in the rightmost case be indented
 `statement' was set simply to zero.
 
 This lineup function corrects for this situation by detecting if the
-anchor position is at an open paren character.  In that case, it
+anchor position is at an open paren character.	In that case, it
 instead indents relative to the surrounding block just like
 `c-lineup-whitesmith-in-block'.
 
@@ -1085,17 +1088,17 @@ arglist-cont."
 
 (defun c-lineup-cpp-define (langelem)
   "Line up macro continuation lines according to the indentation of
-the construct preceding the macro.  E.g.:
+the construct preceding the macro.  E.g:
 
 v beg of preceding constr      v beg of preceding constr
-                             int dribble() {
-const char msg[] =             if (!running)
-  \"Some text.\";	         error(\"Not running!\");
-
-#define X(A, B)  \           #define X(A, B)    \
-do {             \    <->      do {             \    <- c-lineup-cpp-define
-  printf (A, B); \               printf (A, B); \
-} while (0)                    } while (0)
+			     int dribble() {
+const char msg[] =	       if (!running)
+  \"Some text.\";		 error(\"Not running!\");
+
+#define X(A, B)	 \	     #define X(A, B)	\
+do {		 \    <->      do {		\    <- c-lineup-cpp-define
+  printf (A, B); \		 printf (A, B); \
+} while (0)		       } while (0)
 
 If `c-syntactic-indentation-in-macros' is non-nil, the function
 returns the relative indentation to the macro start line to allow
@@ -1103,14 +1106,14 @@ accumulation with other offsets.  E.g. i
 cpp-define-intro is combined with the statement-block-intro that comes
 from the \"do {\" that hangs on the \"#define\" line:
 
-                             int dribble() {
-const char msg[] =             if (!running)
-  \"Some text.\";	         error(\"Not running!\");
-
-#define X(A, B) do { \       #define X(A, B) do { \
-  printf (A, B);     \  <->      printf (A, B);   \  <- c-lineup-cpp-define
-  this->refs++;      \           this->refs++;    \
-} while (0)             <->    } while (0)           <- c-lineup-cpp-define
+			     int dribble() {
+const char msg[] =	       if (!running)
+  \"Some text.\";		 error(\"Not running!\");
+
+#define X(A, B) do { \	     #define X(A, B) do { \
+  printf (A, B);     \	<->	 printf (A, B);	  \  <- c-lineup-cpp-define
+  this->refs++;	     \		 this->refs++;	  \
+} while (0)		<->    } while (0)	     <- c-lineup-cpp-define
 
 The relative indentation returned by `c-lineup-cpp-define' is zero and
 two, respectively, in these two examples.  They are then added to the
@@ -1170,17 +1173,17 @@ Works with: cpp-define-intro."
   "Line up a gcc asm register under one on a previous line.
 
     asm (\"foo %1, %0\\n\"
-         \"bar %0, %1\"
-         : \"=r\" (w),
-           \"=r\" (x)
-         :  \"0\" (y),
-            \"1\" (z));
+	 \"bar %0, %1\"
+	 : \"=r\" (w),
+	   \"=r\" (x)
+	 :  \"0\" (y),
+	    \"1\" (z));
 
 The \"x\" line is aligned to the text after the \":\" on the \"w\" line, and
 similarly \"z\" under \"y\".
 
 This is done only in an \"asm\" or \"__asm__\" block, and only to
-those lines mentioned.  Anywhere else nil is returned.  The usual
+those lines mentioned.	Anywhere else nil is returned.	The usual
 arrangement is to have this routine as an extra feature at the start
 of arglist line-ups, e.g.
 
@@ -1191,6 +1194,7 @@ Works with: arglist-cont, arglist-cont-n
   (let ((orig-pos (point))
 	alignto)
     (save-excursion
+      (beginning-of-line)
       (and
        c-opt-asm-stmt-key
 
@@ -1227,6 +1231,18 @@ Works with: Any syntactic symbol."
     (back-to-indentation)
     (vector (current-column))))
 
+(defun c-lineup-respect-col-0 (langelem)
+  "If the current line starts at column 0, return [0].	Otherwise return nil.
+
+This can be used for comments (in conjunction with, say,
+`c-lineup-comment'), to keep comments already at column 0
+anchored there, but reindent other comments."
+  (save-excursion
+    (back-to-indentation)
+    (if (eq (current-column) 0)
+	[0]
+      nil)))
+
 
 (defun c-snug-do-while (syntax pos)
   "Dynamically calculate brace hanginess for do-while statements.
@@ -1248,7 +1264,7 @@ ACTION associated with `block-close' syn
 
 (defun c-snug-1line-defun-close (syntax pos)
   "Determine the brace hanginess for an AWK defun-close.
-If the action/function being closed is a one-liner, keep it so.  Otherwise put
+If the action/function being closed is a one-liner, keep it so.	 Otherwise put
 the closing brace on its own line."
   (save-excursion
     (goto-char pos)
@@ -1280,11 +1296,11 @@ indentation amount."
   "Controls newline insertion after semicolons in parenthesis lists.
 If a comma was inserted, no determination is made.  If a semicolon was
 inserted inside a parenthesis list, no newline is added otherwise a
-newline is added.  In either case, checking is stopped.  This supports
+newline is added.  In either case, checking is stopped.	 This supports
 exactly the old newline insertion behavior."
   ;; newline only after semicolon, but only if that semicolon is not
   ;; inside a parenthesis list (e.g. a for loop statement)
-  (if (not (eq last-command-event ?\;))
+  (if (not (eq (c-last-command-char) ?\;))
       nil				; continue checking
     (if (condition-case nil
 	    (save-excursion
@@ -1301,9 +1317,9 @@ If a comma was inserted, no determinatio
 inserted, and the following line is not blank, no newline is inserted.
 Otherwise, no determination is made."
   (save-excursion
-    (if (and (= last-command-event ?\;)
+    (if (and (= (c-last-command-char) ?\;)
 	     ;;(/= (point-max)
-	     ;;    (save-excursion (skip-syntax-forward " ") (point))
+	     ;;	   (save-excursion (skip-syntax-forward " ") (point))
 	     (zerop (forward-line 1))
 	     (bolp)			; forward-line has funny behavior at eob.
 	     (not (looking-at "^[ \t]*$")))
@@ -1317,18 +1333,19 @@ If a comma was inserted, no determinatio
 suppressed in one-liners, if the line is an in-class inline function.
 For other semicolon contexts, no determination is made."
   (let ((syntax (c-guess-basic-syntax))
-        (bol (save-excursion
-               (if (c-safe (up-list -1) t)
-                   (c-point 'bol)
-                 -1))))
-    (if (and (eq last-command-event ?\;)
-             (eq (car (car syntax)) 'inclass)
-             (eq (car (car (cdr syntax))) 'topmost-intro)
-             (= (c-point 'bol) bol))
-        'stop
+	(bol (save-excursion
+	       (if (c-safe (up-list -1) t)
+		   (c-point 'bol)
+		 -1))))
+    (if (and (eq (c-last-command-char) ?\;)
+	     (eq (car (car syntax)) 'inclass)
+	     (eq (car (car (cdr syntax))) 'topmost-intro)
+	     (= (c-point 'bol) bol))
+	'stop
       nil)))
 
 
 (cc-provide 'cc-align)
 
+;;; arch-tag: 4d71ed28-bf51-4509-a148-f39669669a2e
 ;;; cc-align.el ends here
--- emacs24-24.3+1.orig/lisp/progmodes/cc-awk.el
+++ emacs24-24.3+1/lisp/progmodes/cc-awk.el
@@ -1,38 +1,38 @@
 ;;; cc-awk.el --- AWK specific code within cc-mode.
 
-;; Copyright (C) 1988, 1994, 1996, 2000-2013 Free Software Foundation,
-;; Inc.
+;; Copyright (C) 1988, 1994, 1996, 2000, 2001, 2002, 2003, 2004, 2005,
+;;   2006, 2007, 2008, 2009, 2010, 2011  Free Software Foundation, Inc.
 
 ;; Author: Alan Mackenzie <acm@muc.de> (originally based on awk-mode.el)
 ;; Maintainer: FSF
 ;; Keywords: AWK, cc-mode, unix, languages
-;; Package: cc-mode
 
 ;; This file is part of GNU Emacs.
 
-;; GNU Emacs is free software: you can redistribute it and/or modify
+;; GNU Emacs is free software; you can redistribute it and/or modify
 ;; it under the terms of the GNU General Public License as published by
-;; the Free Software Foundation, either version 3 of the License, or
-;; (at your option) any later version.
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
 
 ;; GNU Emacs is distributed in the hope that it will be useful,
 ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
 ;; GNU General Public License for more details.
 
 ;; You should have received a copy of the GNU General Public License
-;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
+;; along with this program; see the file COPYING.  If not, see
+;; <http://www.gnu.org/licenses/>.
 
 ;;; Commentary:
 
 ;; This file contains (most of) the adaptations to cc-mode required for the
 ;; integration of AWK Mode.
-;; It is organized thusly, the sections being separated by page breaks:
+;; It is organised thusly, the sections being separated by page breaks:
 ;;   1. The AWK Mode syntax table.
-;;   2. Regular expressions for analyzing AWK code.
+;;   2. Regular expressions for analysing AWK code.
 ;;   3. Indentation calculation stuff ("c-awk-NL-prop text-property").
 ;;   4. Syntax-table property/font-locking stuff, including the
-;;      font-lock-keywords setting.
+;;	font-lock-keywords setting.
 ;;   5. The AWK Mode before/after-change-functions.
 ;;   6. AWK Mode specific versions of commands like beginning-of-defun.
 ;; The AWK Mode keymap, abbreviation table, and the mode function itself are
@@ -65,14 +65,14 @@
 (defvar awk-mode-syntax-table
   (let ((st (make-syntax-table)))
     (modify-syntax-entry ?\\ "\\" st)
-    (modify-syntax-entry ?\n ">   " st)
-    (modify-syntax-entry ?\r ">   " st)
-    (modify-syntax-entry ?\f ">   " st)
-    (modify-syntax-entry ?\# "<   " st)
-    ;; / can delimit regexes or be a division operator.  By default we assume
+    (modify-syntax-entry ?\n ">	  " st)
+    (modify-syntax-entry ?\r ">	  " st)
+    (modify-syntax-entry ?\f ">	  " st)
+    (modify-syntax-entry ?\# "<	  " st)
+    ;; / can delimit regexes or be a division operator.	 By default we assume
     ;; that it is a division sign, and fix the regexp operator cases with
     ;; `font-lock-syntactic-keywords'.
-    (modify-syntax-entry ?/ "." st)     ; ACM 2002/4/27.
+    (modify-syntax-entry ?/ "." st)	; ACM 2002/4/27.  
     (modify-syntax-entry ?* "." st)
     (modify-syntax-entry ?+ "." st)
     (modify-syntax-entry ?- "." st)
@@ -114,7 +114,7 @@
 ;; awk-font-lock-keywords.
 ;; (defconst c-awk-escaped-nls*-with-space*
 ;;   (concat "\\(" c-awk-escaped-nls* "\\|" "[ \t]+" "\\)*"))
-;; The above RE was very slow.  It's runtime was doubling with each additional
+;; The above RE was very slow.	It's runtime was doubling with each additional
 ;; space :-(  Reformulate it as below:
 (eval-and-compile
   (defconst c-awk-escaped-nls*-with-space*
@@ -127,22 +127,29 @@
 ;; escaped EOL.
 
 ;; REGEXPS FOR "HARMLESS" STRINGS/LINES.
-(defconst c-awk-harmless-char-re "[^_#/\"\\\\\n\r]")
-;;   Matches any character but a _, #, /, ", \, or newline.  N.B. _" starts a
-;; localization string in gawk 3.1
 (defconst c-awk-harmless-_ "_\\([^\"]\\|\\'\\)")
 ;;   Matches an underline NOT followed by ".
+(defconst c-awk-harmless-char-re "[^_#/\"{}();\\\\\n\r]")
+;;   Matches any character not significant in the state machine applying
+;; syntax-table properties to "s and /s.
 (defconst c-awk-harmless-string*-re
   (concat "\\(" c-awk-harmless-char-re "\\|" c-awk-esc-pair-re "\\|" c-awk-harmless-_ "\\)*"))
-;;   Matches a (possibly empty) sequence of chars without unescaped /, ", \,
-;; #, or newlines.
+;;   Matches a (possibly empty) sequence of characters insignificant in the
+;; state machine applying syntax-table properties to "s and /s.
 (defconst c-awk-harmless-string*-here-re
   (concat "\\=" c-awk-harmless-string*-re))
-;; Matches the (possibly empty) sequence of chars without unescaped /, ", \,
-;; at point.
+;; Matches the (possibly empty) sequence of "insignificant" chars at point.
+
+(defconst c-awk-harmless-line-char-re "[^_#/\"\\\\\n\r]")
+;;   Matches any character but a _, #, /, ", \, or newline.  N.B. _" starts a
+;; localisation string in gawk 3.1
+(defconst c-awk-harmless-line-string*-re
+  (concat "\\(" c-awk-harmless-line-char-re "\\|" c-awk-esc-pair-re "\\|" c-awk-harmless-_ "\\)*"))
+;;   Matches a (possibly empty) sequence of chars without unescaped /, ", \,
+;; #, or newlines.
 (defconst c-awk-harmless-line-re
-  (concat c-awk-harmless-string*-re
-          "\\(" c-awk-comment-without-nl "\\)?" c-awk-nl-or-eob))
+  (concat c-awk-harmless-line-string*-re
+	  "\\(" c-awk-comment-without-nl "\\)?" c-awk-nl-or-eob))
 ;;   Matches (the tail of) an AWK \"logical\" line not containing an unescaped
 ;; " or /.  "logical" means "possibly containing escaped newlines".  A comment
 ;; is matched as part of the line even if it contains a " or a /.  The End of
@@ -161,10 +168,11 @@
 (defconst c-awk-string-without-end-here-re
   (concat "\\=_?\"" c-awk-string-innards-re))
 ;;   Matches an AWK string at point up to, but not including, any terminator.
-;; A gawk 3.1+ string may look like _"localizable string".
-(defconst c-awk-one-line-possibly-open-string-re
-  (concat "\"\\(" c-awk-string-ch-re "\\|" c-awk-non-eol-esc-pair-re "\\)*"
-	  "\\(\"\\|\\\\?$\\|\\'\\)"))
+;; A gawk 3.1+ string may look like _"localisable string".
+(defconst c-awk-possibly-open-string-re
+  (concat "\"\\(" c-awk-string-ch-re "\\|" c-awk-esc-pair-re "\\)*"
+	  "\\(\"\\|$\\|\\'\\)"))
+
 
 ;; REGEXPS FOR AWK REGEXPS.
 (defconst c-awk-regexp-normal-re "[^[/\\\n\r]")
@@ -181,29 +189,18 @@
   ;; Matches a character class spec (e.g. [:alpha:]).
 (defconst c-awk-regexp-char-list-re
   (concat "\\[" c-awk-escaped-newlines*-re "^?" c-awk-escaped-newlines*-re "]?"
-          "\\(" c-awk-esc-pair-re "\\|" c-awk-regexp-char-class-re
+	  "\\(" c-awk-esc-pair-re "\\|" c-awk-regexp-char-class-re
 	  "\\|" "[^]\n\r]" "\\)*" "\\(]\\|$\\)"))
 ;;   Matches a regexp char list, up to (but not including) EOL if the ] is
 ;;   missing.
-(defconst c-awk-regexp-one-line-possibly-open-char-list-re
-  (concat "\\[\\]?\\(" c-awk-non-eol-esc-pair-re "\\|" "[^]\n\r]" "\\)*"
-	  "\\(]\\|\\\\?$\\|\\'\\)"))
-;;   Matches the head (or all) of a regexp char class, up to (but not
-;;   including) the first EOL.
 (defconst c-awk-regexp-innards-re
   (concat "\\(" c-awk-esc-pair-re "\\|" c-awk-regexp-char-list-re
-          "\\|" c-awk-regexp-normal-re "\\)*"))
+	  "\\|" c-awk-regexp-normal-re "\\)*"))
 ;;   Matches the inside of an AWK regexp (i.e. without the enclosing /s)
 (defconst c-awk-regexp-without-end-re
   (concat "/" c-awk-regexp-innards-re))
-;; Matches an AWK regexp up to, but not including, any terminating /.
-(defconst c-awk-one-line-possibly-open-regexp-re
-  (concat "/\\(" c-awk-non-eol-esc-pair-re
-	  "\\|" c-awk-regexp-one-line-possibly-open-char-list-re
-	  "\\|" c-awk-regexp-normal-re "\\)*"
-	  "\\(/\\|\\\\?$\\|\\'\\)"))
-;; Matches as much of the head of an AWK regexp which fits on one line,
-;; possibly all of it.
+;; Matches an AWK regexp up to, but not including, any terminating /. 
+
 
 ;; REGEXPS used for scanning an AWK buffer in order to decide IF A '/' IS A
 ;; REGEXP OPENER OR A DIVISION SIGN.  By "state" in the following is meant
@@ -211,11 +208,11 @@
 ;; division sign.
 (defconst c-awk-neutral-re
 ;  "\\([{}@` \t]\\|\\+\\+\\|--\\|\\\\.\\)+") ; changed, 2003/6/7
-  "\\([{}@` \t]\\|\\+\\+\\|--\\|\\\\.\\)")
+  "\\([}@` \t]\\|\\+\\+\\|--\\|\\\\\\(.\\|[\n\r]\\)\\)")
 ;;   A "neutral" char(pair).  Doesn't change the "state" of a subsequent /.
-;; This is space/tab, braces, an auto-increment/decrement operator or an
+;; This is space/tab, close brace, an auto-increment/decrement operator or an
 ;; escaped character.  Or one of the (invalid) characters @ or `.  But NOT an
-;; end of line (even if escaped).
+;; end of line (unless escaped).
 (defconst c-awk-neutrals*-re
   (concat "\\(" c-awk-neutral-re "\\)*"))
 ;;   A (possibly empty) string of neutral characters (or character pairs).
@@ -227,37 +224,56 @@
   (concat c-awk-var-num-ket-re c-awk-neutrals*-re "/"))
 ;;   Will match a piece of AWK buffer ending in / which is a division sign, in
 ;; a context where an immediate / would be a regexp bracket.  It follows a
-;; variable or number (with optional intervening "neutral" characters).  This
+;; variable or number (with optional intervening "neutral" characters).	 This
 ;; will only work when there won't be a preceding " or / before the sought /
 ;; to foul things up.
 (defconst c-awk-non-arith-op-bra-re
-  "[[\(&=:!><,?;'~|]")
-;;   Matches an opening BRAcket, round or square, or any operator character
+  "[[\({&=:!><,?;'~|]")
+;;   Matches an opening BRAcket (of any sort), or any operator character
 ;; apart from +,-,/,*,%.  For the purpose at hand (detecting a / which is a
 ;; regexp bracket) these arith ops are unnecessary and a pain, because of "++"
 ;; and "--".
 (defconst c-awk-regexp-sign-re
   (concat c-awk-non-arith-op-bra-re c-awk-neutrals*-re "/"))
 ;;   Will match a piece of AWK buffer ending in / which is an opening regexp
-;; bracket, in a context where an immediate / would be a division sign.  This
+;; bracket, in a context where an immediate / would be a division sign.	 This
 ;; will only work when there won't be a preceding " or / before the sought /
 ;; to foul things up.
+(defconst c-awk-pre-exp-alphanum-kwd-re
+  (concat "\\(^\\|\\=\\|[^_\n\r]\\)\\<"
+	  (regexp-opt '("print" "return" "case") t)
+	  "\\>\\([^_\n\r]\\|$\\)"))
+;;   Matches all AWK keywords which can precede expressions (including
+;; /regexp/).
+(defconst c-awk-kwd-regexp-sign-re
+  (concat c-awk-pre-exp-alphanum-kwd-re c-awk-escaped-nls*-with-space* "/"))
+;;   Matches a piece of AWK buffer ending in <kwd> /, where <kwd> is a keyword
+;; which can precede an expression.
 
 ;; REGEXPS USED FOR FINDING THE POSITION OF A "virtual semicolon"
 (defconst c-awk-_-harmless-nonws-char-re "[^#/\"\\\\\n\r \t]")
-;; NEW VERSION!  (which will be restricted to the current line)
-(defconst c-awk-one-line-non-syn-ws*-re
-  (concat "\\([ \t]*"
-              "\\(" c-awk-_-harmless-nonws-char-re "\\|"
-	            c-awk-non-eol-esc-pair-re "\\|"
-		    c-awk-one-line-possibly-open-string-re "\\|"
-		    c-awk-one-line-possibly-open-regexp-re
-	      "\\)"
-          "\\)*"))
+(defconst c-awk-non-/-syn-ws*-re
+  (concat
+   "\\(" c-awk-escaped-nls*-with-space*
+         "\\(" c-awk-_-harmless-nonws-char-re "\\|"
+               c-awk-non-eol-esc-pair-re "\\|"
+	       c-awk-possibly-open-string-re
+         "\\)"
+   "\\)*"))
+(defconst c-awk-space*-/-re (concat c-awk-escaped-nls*-with-space* "/"))
+;; Matches optional whitespace followed by "/".
+(defconst c-awk-space*-regexp-/-re
+  (concat c-awk-escaped-nls*-with-space* "\\s\""))
+;; Matches optional whitespace followed by a "/" with string syntax (a matched
+;; regexp delimiter).
+(defconst c-awk-space*-unclosed-regexp-/-re
+  (concat c-awk-escaped-nls*-with-space* "\\s\|"))
+;; Matches optional whitespace followed by a "/" with string fence syntax (an
+;; unmatched regexp delimiter).
 
 
 ;; ACM, 2002/5/29:
-;;
+;; 
 ;; The next section of code is about determining whether or not an AWK
 ;; statement is complete or not.  We use this to indent the following line.
 ;; The determination is pretty straightforward in C, where a statement ends
@@ -270,7 +286,7 @@
 ;;
 ;; To avoid continually repeating this expensive analysis, we "cache" its
 ;; result in a text-property, c-awk-NL-prop, whose value for a line is set on
-;; the EOL (if any) which terminates that line.  Should the property be
+;; the EOL (if any) which terminates that line.	 Should the property be
 ;; required for the very last line (which has no EOL), it is calculated as
 ;; required but not cached.  The c-awk-NL-prop property should be thought of
 ;; as only really valid immediately after a buffer change, not a permanently
@@ -289,10 +305,10 @@
 ;;     line.
 ;; '{' There is an unfinished statement on this (or a previous) line which
 ;;     doesn't require \s to continue onto another line, e.g. the line ends
-;;     with {, or the && operator, or "if (condition)".  Note that even if the
+;;     with {, or the && operator, or "if (condition)".	 Note that even if the
 ;;     newline is redundantly escaped, it remains a '{' line.
 ;; '\' There is an escaped newline at the end of this line and this '\' is
-;;     essential to the syntax of the program.  (i.e. if it had been a
+;;     essential to the syntax of the program.	(i.e. if it had been a
 ;;     frivolous \, it would have been ignored and the line been given one of
 ;;     the other property values.)
 ;; '$' A non-empty statement is terminated on the line by an EOL (a "virtual
@@ -323,12 +339,12 @@
    (save-excursion
      (let ((par-pos (c-safe (scan-lists (point) -1 0))))
        (when par-pos
-         (goto-char par-pos)            ; back over "(...)"
-         (c-backward-token-1)           ; BOB isn't a problem.
-         (or (looking-at "\\(if\\|for\\)\\>\\([^_]\\|$\\)")
-             (and (looking-at "while\\>\\([^_]\\|$\\)") ; Ensure this isn't a do-while.
-                  (not (eq (c-beginning-of-statement-1 do-lim)
-                           'beginning)))))))))
+	 (goto-char par-pos)		; back over "(...)"
+	 (c-backward-token-1)		; BOB isn't a problem.
+	 (or (looking-at "\\(if\\|for\\)\\>\\([^_]\\|$\\)")
+	     (and (looking-at "while\\>\\([^_]\\|$\\)") ; Ensure this isn't a do-while.
+		  (not (eq (c-beginning-of-statement-1 do-lim)
+			   'beginning)))))))))
 
 (defun c-awk-after-function-decl-param-list ()
   ;; Are we just after the ) in "function foo (bar)" ?
@@ -336,13 +352,13 @@
   ;; This function might do hidden buffer changes.
   (and (eq (char-before) ?\))
        (save-excursion
-         (let ((par-pos (c-safe (scan-lists (point) -1 0))))
-           (when par-pos
-             (goto-char par-pos)        ; back over "(...)"
-             (c-backward-token-1)       ; BOB isn't a problem
-             (and (looking-at "[_a-zA-Z][_a-zA-Z0-9]*\\>")
-                  (progn (c-backward-token-1)
-                         (looking-at "func\\(tion\\)?\\>"))))))))
+	 (let ((par-pos (c-safe (scan-lists (point) -1 0))))
+	   (when par-pos
+	     (goto-char par-pos)	; back over "(...)"
+	     (c-backward-token-1)	; BOB isn't a problem
+	     (and (looking-at "[_a-zA-Z][_a-zA-Z0-9]*\\>")
+		  (progn (c-backward-token-1)
+			 (looking-at "func\\(tion\\)?\\>"))))))))
 
 ;; 2002/11/8:  FIXME!  Check c-backward-token-1/2 for success (0 return code).
 (defun c-awk-after-continue-token ()
@@ -351,9 +367,9 @@
 ;;
 ;; This function might do hidden buffer changes.
   (save-excursion
-    (c-backward-token-1)              ; FIXME 2002/10/27.  What if this fails?
+    (c-backward-token-1)	      ; FIXME 2002/10/27.  What if this fails?
     (if (and (looking-at "[&|]") (not (bobp)))
-        (backward-char)) ; c-backward-token-1 doesn't do this :-(
+	(backward-char)) ; c-backward-token-1 doesn't do this :-(
     (looking-at "[,{?:]\\|&&\\|||\\|do\\>\\|else\\>")))
 
 (defun c-awk-after-rbrace-or-statement-semicolon ()
@@ -365,12 +381,12 @@
       (and
        (eq (char-before) ?\;)
        (save-excursion
-         (let ((par-pos (c-safe (scan-lists (point) -1 1))))
-           (when par-pos
-             (goto-char par-pos) ; go back to containing (
-             (not (and (looking-at "(")
-                       (c-backward-token-1) ; BOB isn't a problem
-                       (looking-at "for\\>")))))))))
+	 (let ((par-pos (c-safe (scan-lists (point) -1 1))))
+	   (when par-pos
+	     (goto-char par-pos) ; go back to containing (
+	     (not (and (looking-at "(")
+		       (c-backward-token-1) ; BOB isn't a problem
+		       (looking-at "for\\>")))))))))
 
 (defun c-awk-back-to-contentful-text-or-NL-prop ()
   ;;  Move back to just after the first found of either (i) an EOL which has
@@ -383,56 +399,56 @@
   ;;  Kludge: If c-backward-syntactic-ws gets stuck at a BOL, it is likely
   ;;  that the previous line contains an unterminated string (without \).  In
   ;;  this case, assume that the previous line's c-awk-NL-prop is a $.
-  ;;
-  ;;  POINT MUST BE AT THE START OF A LINE when calling this function.  This
+  ;; 
+  ;;  POINT MUST BE AT THE START OF A LINE when calling this function.	This
   ;;  is to ensure that the various backward-comment functions will work
   ;;  properly.
   ;;
   ;; This function might do hidden buffer changes.
   (let ((nl-prop nil)
-        bol-pos bsws-pos) ; starting pos for a backward-syntactic-ws call.
+	bol-pos bsws-pos) ; starting pos for a backward-syntactic-ws call.
     (while ;; We are at a BOL here.  Go back one line each iteration.
-        (and
-         (not (bobp))
-         (not (setq nl-prop (c-get-char-property (1- (point)) 'c-awk-NL-prop)))
-         (progn (setq bol-pos (c-point 'bopl))
-                (setq bsws-pos (point))
-                ;; N.B. the following function will not go back past an EOL if
-                ;; there is an open string (without \) on the previous line.
-                ;; If we find such, set the c-awk-NL-prop on it, too
-                ;; (2004/3/29).
-                (c-backward-syntactic-ws bol-pos)
-                (or (/= (point) bsws-pos)
-                    (progn (setq nl-prop ?\$)
+	(and
+	 (not (bobp))
+	 (not (setq nl-prop (c-get-char-property (1- (point)) 'c-awk-NL-prop)))
+	 (progn (setq bol-pos (c-point 'bopl))
+		(setq bsws-pos (point))
+		;; N.B. the following function will not go back past an EOL if
+		;; there is an open string (without \) on the previous line.
+		;; If we find such, set the c-awk-NL-prop on it, too
+		;; (2004/3/29).
+		(c-backward-syntactic-ws bol-pos)
+		(or (/= (point) bsws-pos)
+		    (progn (setq nl-prop ?\$)
 			   (c-put-char-property (1- (point)) 'c-awk-NL-prop nl-prop)
-                           nil)))
-         ;; If we had a backslash at EOL, c-backward-syntactic-ws will
-         ;; have gone backwards over it.  Check the backslash was "real".
-         (progn
-           (if (looking-at "[ \t]*\\\\+$")
-               (if (progn
-                     (end-of-line)
-                     (search-backward-regexp
-                      "\\(^\\|[^\\]\\)\\(\\\\\\\\\\)*\\\\$" ; ODD number of \s at EOL  :-)
-                      bol-pos t))
-                   (progn (end-of-line)   ; escaped EOL.
-                          (backward-char)
-                          (c-backward-syntactic-ws bol-pos))
-                 (end-of-line)))          ; The \ at eol is a fake.
-           (bolp))))
+			   nil)))
+	 ;; If we had a backslash at EOL, c-backward-syntactic-ws will
+	 ;; have gone backwards over it.  Check the backslash was "real".
+	 (progn
+	   (if (looking-at "[ \t]*\\\\+$")
+	       (if (progn
+		     (end-of-line)
+		     (search-backward-regexp
+		      "\\(^\\|[^\\]\\)\\(\\\\\\\\\\)*\\\\$" ; ODD number of \s at EOL  :-)
+		      bol-pos t))
+		   (progn (end-of-line)	  ; escaped EOL.
+			  (backward-char)
+			  (c-backward-syntactic-ws bol-pos))
+		 (end-of-line)))	  ; The \ at eol is a fake.
+	   (bolp))))
     nl-prop))
 
 (defun c-awk-calculate-NL-prop-prev-line (&optional do-lim)
   ;; Calculate and set the value of the c-awk-NL-prop on the immediately
   ;; preceding EOL.  This may also involve doing the same for several
   ;; preceding EOLs.
-  ;;
+  ;; 
   ;; NOTE that if the property was already set, we return it without
   ;; recalculation.  (This is by accident rather than design.)
-  ;;
+  ;; 
   ;; Return the property which got set (or was already set) on the previous
   ;; line.  Return nil if we hit BOB.
-  ;;
+  ;; 
   ;; See c-awk-after-if-for-while-condition-p for a description of DO-LIM.
   ;;
   ;; This function might do hidden buffer changes.
@@ -440,42 +456,42 @@
     (save-match-data
       (beginning-of-line)
       (let* ((pos (point))
-             (nl-prop (c-awk-back-to-contentful-text-or-NL-prop)))
-        ;; We are either (1) at a BOL (with nl-prop containing the previous
-        ;; line's c-awk-NL-prop) or (2) after contentful text on a line.  At
-        ;; the BOB counts as case (1), so we test next for bolp rather than
-        ;; non-nil nl-prop.
-        (when (not (bolp))
-          (setq nl-prop
-                (cond
-                 ;; Incomplete statement which doesn't require escaped EOL?
-                 ((or (c-awk-after-if-for-while-condition-p do-lim)
-                      (c-awk-after-function-decl-param-list)
-                      (c-awk-after-continue-token))
-                  ?\{)
-                 ;; Escaped EOL (where there's also something to continue)?
-                 ((and (looking-at "[ \t]*\\\\$")
-                       (not (c-awk-after-rbrace-or-statement-semicolon)))
-                  ?\\)
+	     (nl-prop (c-awk-back-to-contentful-text-or-NL-prop)))
+	;; We are either (1) at a BOL (with nl-prop containing the previous
+	;; line's c-awk-NL-prop) or (2) after contentful text on a line.  At
+	;; the BOB counts as case (1), so we test next for bolp rather than
+	;; non-nil nl-prop.
+	(when (not (bolp))
+	  (setq nl-prop
+		(cond
+		 ;; Incomplete statement which doesn't require escaped EOL?
+		 ((or (c-awk-after-if-for-while-condition-p do-lim)
+		      (c-awk-after-function-decl-param-list)
+		      (c-awk-after-continue-token))
+		  ?\{)
+		 ;; Escaped EOL (where there's also something to continue)?
+		 ((and (looking-at "[ \t]*\\\\$")
+		       (not (c-awk-after-rbrace-or-statement-semicolon)))
+		  ?\\)
 		 ;; A statement was completed on this line.  How?
 		 ((memq (char-before) '(?\; ?\}))  ?\})	; Real ; or }
-                 (t ?\$)))            ; A virtual semicolon.
-          (end-of-line)
-          (c-put-char-property (point) 'c-awk-NL-prop nl-prop)
-          (forward-line))
-
-        ;; We are now at a (possibly empty) sequence of content-free lines.
-        ;; Set c-awk-NL-prop on each of these lines's EOL.
-        (while (< (point) pos)         ; one content-free line each iteration.
-          (cond              ; recalculate nl-prop from previous line's value.
-           ((memq nl-prop '(?\} ?\$ nil)) (setq nl-prop ?\#))
-           ((eq nl-prop ?\\)
-            (if (not (looking-at "[ \t]*\\\\$")) (setq nl-prop ?\$)))
-           ;; ?\# (empty line) and ?\{ (open stmt) don't change.
-           )
-          (forward-line)
-          (c-put-char-property (1- (point)) 'c-awk-NL-prop nl-prop))
-        nl-prop))))
+		 (t ?\$)))	      ; A virtual semicolon.
+	  (end-of-line)
+	  (c-put-char-property (point) 'c-awk-NL-prop nl-prop)
+	  (forward-line))
+
+	;; We are now at a (possibly empty) sequence of content-free lines.
+	;; Set c-awk-NL-prop on each of these lines's EOL.
+	(while (< (point) pos)	       ; one content-free line each iteration.
+	  (cond		     ; recalculate nl-prop from previous line's value.
+	   ((memq nl-prop '(?\} ?\$ nil)) (setq nl-prop ?\#))
+	   ((eq nl-prop ?\\)
+	    (if (not (looking-at "[ \t]*\\\\$")) (setq nl-prop ?\$)))
+	   ;; ?\# (empty line) and ?\{ (open stmt) don't change.
+	   )
+	  (forward-line)
+	  (c-put-char-property (1- (point)) 'c-awk-NL-prop nl-prop))
+	nl-prop))))
 
 (defun c-awk-get-NL-prop-prev-line (&optional do-lim)
   ;; Get the c-awk-NL-prop text-property from the previous line, calculating
@@ -486,25 +502,25 @@
   (if (bobp)
       nil
     (or (c-get-char-property (c-point 'eopl) 'c-awk-NL-prop)
-        (c-awk-calculate-NL-prop-prev-line do-lim))))
+	(c-awk-calculate-NL-prop-prev-line do-lim))))
 
 (defun c-awk-get-NL-prop-cur-line (&optional do-lim)
   ;; Get the c-awk-NL-prop text-property from the current line, calculating it
   ;; if necessary. (As a special case, the property doesn't get set on an
   ;; empty line at EOB (there's no position to set the property on), but the
   ;; function returns the property value an EOL would have got.)
-  ;;
+  ;; 
   ;; See c-awk-after-if-for-while-condition-p for a description of DO-LIM.
   ;;
   ;; This function might do hidden buffer changes.
   (save-excursion
     (let ((extra-nl nil))
-      (end-of-line)                ; Necessary for the following test to work.
-      (when (= (forward-line) 1)        ; if we were on the last line....
-        (insert-char ?\n 1) ; ...artificial eol is needed for comment detection.
-        (setq extra-nl t))
+      (end-of-line)		   ; Necessary for the following test to work.
+      (when (= (forward-line) 1)	; if we were on the last line....
+	(insert-char ?\n 1) ; ...artificial eol is needed for comment detection.
+	(setq extra-nl t))
       (prog1 (c-awk-get-NL-prop-prev-line do-lim)
-        (if extra-nl (delete-char -1))))))
+	(if extra-nl (delete-char -1))))))
 
 (defsubst c-awk-prev-line-incomplete-p (&optional do-lim)
   ;; Is there an incomplete statement at the end of the previous line?
@@ -520,22 +536,48 @@
   ;; This function might do hidden buffer changes.
   (memq (c-awk-get-NL-prop-cur-line do-lim) '(?\\ ?\{)))
 
-;; NOTES ON "VIRTUAL SEMICOLONS"
-;;
-;; A "virtual semicolon" is what terminates a statement when there is no ;
-;; or } to do the job.  Like point, it is considered to lie _between_ two
-;; characters.  As from mid-March 2004, it is considered to lie just after
-;; the last non-syntactic-whitespace character on the line; (previously, it
-;; was considered an attribute of the EOL on the line).  A real semicolon
-;; never counts as a virtual one.
+;;;; NOTES ON "VIRTUAL SEMICOLONS"
+;;;;
+;;;; A "virtual semicolon" is what terminates a statement when there is no ;
+;;;; or } to do the job.  Like point, it is considered to lie _between_ two
+;;;; characters.  As from mid-March 2004, it is considered to lie just after
+;;;; the last non-syntactic-whitespace character on the line; (previously, it
+;;;; was considered an attribute of the EOL on the line).  A real semicolon
+;;;; never counts as a virtual one.
 
 (defun c-awk-at-vsemi-p (&optional pos)
   ;; Is there a virtual semicolon at POS (or POINT)?
   (save-excursion
-    (let (nl-prop
-	  (pos-or-point (progn (if pos (goto-char pos)) (point))))
-      (forward-line 0)
-      (search-forward-regexp c-awk-one-line-non-syn-ws*-re)
+    (let* (nl-prop
+	   (pos-or-point (progn (if pos (goto-char pos)) (point)))
+	   (bol (c-point 'bol)) (eol (c-point 'eol)))
+      (c-awk-beginning-of-logical-line)
+      ;; Next `while' goes round one logical line (ending in, e.g. "\\") per
+      ;; iteration.  Such a line is rare, and can only be an open string
+      ;; ending in an escaped \.
+      (while
+	  (progn
+	    ;; Next `while' goes over a division sign or /regexp/ per iteration.
+	    (while
+		(and
+		 (< (point) eol)
+		 (progn
+		   (search-forward-regexp c-awk-non-/-syn-ws*-re eol)
+		   (looking-at c-awk-space*-/-re)))
+	      (cond
+	       ((looking-at c-awk-space*-regexp-/-re) ; /regexp/
+		(forward-sexp))
+	       ((looking-at c-awk-space*-unclosed-regexp-/-re) ; Unclosed /regexp
+		(condition-case nil
+		    (progn
+		      (forward-sexp)
+		      (backward-char))	; Move to end of (logical) line.
+		  (error (end-of-line)))) ; Happens at EOB.
+	       (t 			; division sign
+		(c-forward-syntactic-ws)
+		(forward-char))))
+	    (< (point) bol))
+	(forward-line))
       (and (eq (point) pos-or-point)
 	   (progn
 	     (while (and (eq (setq nl-prop (c-awk-get-NL-prop-cur-line)) ?\\)
@@ -546,7 +588,7 @@
 (defun c-awk-vsemi-status-unknown-p ()
   ;; Are we unsure whether there is a virtual semicolon on the current line?
   ;; DO NOT under any circumstances attempt to calculate this; that would
-  ;; defeat the (admittedly kludgy) purpose of this function, which is to
+  ;; defeat the (admittedly kludgey) purpose of this function, which is to
   ;; prevent an infinite recursion in c-beginning-of-statement-1 when point
   ;; starts at a `while' token.
   (not (c-get-char-property (c-point 'eol) 'c-awk-NL-prop)))
@@ -567,23 +609,23 @@
   ;; this, a new newline inserted after an old newline (e.g. by C-j) would
   ;; inherit any c-awk-NL-prop from the old newline.  This would be a Bad
   ;; Thing.  This function's action is required by c-put-char-property.
-  (if (and (boundp 'text-property-default-nonsticky) ; doesn't exist in XEmacs
-           (not (assoc 'c-awk-NL-prop text-property-default-nonsticky)))
+  (if (and (boundp 'text-property-default-nonsticky) ; doesn't exist in Xemacs
+	   (not (assoc 'c-awk-NL-prop text-property-default-nonsticky)))
       (setq text-property-default-nonsticky
-            (cons '(c-awk-NL-prop . t) text-property-default-nonsticky))))
+	    (cons '(c-awk-NL-prop . t) text-property-default-nonsticky))))
 
 ;; The following is purely a diagnostic command, to be commented out of the
 ;; final release.  ACM, 2002/6/1
 ;; (defun NL-props ()
 ;;   (interactive)
 ;;   (let (pl-prop cl-prop)
-;;     (message "Prev-line: %s  Cur-line: %s"
-;;              (if (setq pl-prop (c-get-char-property (c-point 'eopl) 'c-awk-NL-prop))
-;;                  (char-to-string pl-prop)
-;;                "nil")
-;;              (if (setq cl-prop (c-get-char-property (c-point 'eol) 'c-awk-NL-prop))
-;;                  (char-to-string cl-prop)
-;;                "nil"))))
+;;     (message "Prev-line: %s	Cur-line: %s"
+;;		(if (setq pl-prop (c-get-char-property (c-point 'eopl) 'c-awk-NL-prop))
+;;		    (char-to-string pl-prop)
+;;		  "nil")
+;;		(if (setq cl-prop (c-get-char-property (c-point 'eol) 'c-awk-NL-prop))
+;;		    (char-to-string cl-prop)
+;;		  "nil"))))
 ;(define-key awk-mode-map [?\C-c ?\r] 'NL-props) ; commented out, 2002/8/31
 ;for now.  In the byte compiled version, this causes things to crash because
 ;awk-mode-map isn't yet defined.  :-(
@@ -605,14 +647,14 @@
 ;;
 ;; This requires the region processed by the current font-lock after-change
 ;; function to have access to the start of the string/regexp, which may be
-;; several lines back.  The elisp "advice" feature is used on these functions
+;; several lines back.	The elisp "advice" feature is used on these functions
 ;; to allow this.
 
 (defun c-awk-beginning-of-logical-line (&optional pos)
 ;; Go back to the start of the (apparent) current line (or the start of the
 ;; line containing POS), returning the buffer position of that point.  I.e.,
 ;; go back to the last line which doesn't have an escaped EOL before it.
-;;
+;; 
 ;; This is guaranteed to be "safe" for syntactic analysis, i.e. outwith any
 ;; comment, string or regexp.  IT MAY WELL BE that this function should not be
 ;; executed on a narrowed buffer.
@@ -621,13 +663,13 @@
   (if pos (goto-char pos))
   (forward-line 0)
   (while (and (> (point) (point-min))
-              (eq (char-before (1- (point))) ?\\))
+	      (eq (char-before (1- (point))) ?\\))
     (forward-line -1))
   (point))
 
 (defun c-awk-beyond-logical-line (&optional pos)
 ;; Return the position just beyond the (apparent) current logical line, or the
-;; one containing POS.  This is usually the beginning of the next line which
+;; one containing POS.	This is usually the beginning of the next line which
 ;; doesn't follow an escaped EOL.  At EOB, this will be EOB.
 ;;
 ;; Point is unchanged.
@@ -654,7 +696,7 @@
 (defun c-awk-set-string-regexp-syntax-table-properties (beg end)
 ;; BEG and END bracket a (possibly unterminated) string or regexp.  The
 ;; opening delimiter is after BEG, and the closing delimiter, IF ANY, is AFTER
-;; END.  Set the appropriate syntax-table properties on the delimiters and
+;; END.	 Set the appropriate syntax-table properties on the delimiters and
 ;; contents of this string/regex.
 ;;
 ;; "String" here can also mean a gawk 3.1 "localizable" string which starts
@@ -668,21 +710,21 @@
   (if (eq (char-after beg) ?_) (setq beg (1+ beg)))
 
   ;; First put the properties on the delimiters.
-  (cond ((eq end (point-max))           ; string/regexp terminated by EOB
-         (c-put-char-property beg 'syntax-table '(15))) ; (15) = "string fence"
-        ((/= (char-after beg) (char-after end)) ; missing end delimiter
-         (c-put-char-property beg 'syntax-table '(15))
-         (c-put-char-property end 'syntax-table '(15)))
-        ((eq (char-after beg) ?/)       ; Properly bracketed regexp
-         (c-put-char-property beg 'syntax-table '(7)) ; (7) = "string"
-         (c-put-char-property end 'syntax-table '(7)))
-        (t))                       ; Properly bracketed string: Nothing to do.
+  (cond ((eq end (point-max))		; string/regexp terminated by EOB
+	 (c-put-char-property beg 'syntax-table '(15))) ; (15) = "string fence"
+	((/= (char-after beg) (char-after end)) ; missing end delimiter
+	 (c-put-char-property beg 'syntax-table '(15))
+	 (c-put-char-property end 'syntax-table '(15)))
+	((eq (char-after beg) ?/)	; Properly bracketed regexp
+	 (c-put-char-property beg 'syntax-table '(7)) ; (7) = "string"
+	 (c-put-char-property end 'syntax-table '(7)))
+	(t))			   ; Properly bracketed string: Nothing to do.
   ;; Now change the properties of any escaped "s in the string to punctuation.
   (save-excursion
     (goto-char (1+ beg))
     (or (eobp)
-        (while (search-forward "\"" end t)
-          (c-put-char-property (1- (point)) 'syntax-table '(1))))))
+	(while (search-forward "\"" end t)
+	  (c-put-char-property (1- (point)) 'syntax-table '(1))))))
 
 (defun c-awk-syntax-tablify-string ()
   ;; Point is at the opening " or _" of a string.  Set the syntax-table
@@ -696,12 +738,12 @@
   (c-awk-set-string-regexp-syntax-table-properties
    (match-beginning 0) (match-end 0))
   (cond ((looking-at "\"")
-         (forward-char)
-         t)                             ; In AWK, ("15" / 5) gives 3 ;-)
-        ((looking-at "[\n\r]")          ; Unterminated string with EOL.
-         (forward-char)
-         nil)                           ; / on next line would start a regexp
-        (t nil)))                       ; Unterminated string at EOB
+	 (forward-char)
+	 t)				; In AWK, ("15" / 5) gives 3 ;-)
+	((looking-at "[\n\r]")		; Unterminated string with EOL.
+	 (forward-char)
+	 nil)				; / on next line would start a regexp
+	(t nil)))			; Unterminated string at EOB
 
 (defun c-awk-syntax-tablify-/ (anchor anchor-state-/div)
   ;; Point is at a /.  Determine whether this is a division sign or a regexp
@@ -711,7 +753,7 @@
   ;;
   ;; ANCHOR-STATE-/DIV identifies whether a / at ANCHOR would have been a
   ;; division sign (value t) or a regexp opener (value nil).  The idea is that
-  ;; we analyze the line from ANCHOR up till point to determine what the / at
+  ;; we analyse the line from ANCHOR up till point to determine what the / at
   ;; point is.
   ;;
   ;; The result is what ANCHOR-STATE-/DIV (see above) is where point is left.
@@ -719,11 +761,12 @@
   ;; This function does hidden buffer changes.
   (let ((/point (point)))
     (goto-char anchor)
-    ;; Analyze the line to find out what the / is.
+    ;; Analyse the line to find out what the / is.
     (if (if anchor-state-/div
-            (not (search-forward-regexp c-awk-regexp-sign-re (1+ /point) t))
-          (search-forward-regexp c-awk-div-sign-re (1+ /point) t))
-        ;; A division sign.
+	    (not (search-forward-regexp c-awk-regexp-sign-re (1+ /point) t))
+	  (and (not (search-forward-regexp c-awk-kwd-regexp-sign-re (1+ /point) t))
+	       (search-forward-regexp c-awk-div-sign-re (1+ /point) t)))
+	;; A division sign.
 	(progn (goto-char (1+ /point)) nil)
       ;; A regexp opener
       ;; Jump over the regexp innards, setting the match data.
@@ -731,13 +774,13 @@
       (search-forward-regexp c-awk-regexp-without-end-re)
       (c-awk-set-string-regexp-syntax-table-properties
        (match-beginning 0) (match-end 0))
-      (cond ((looking-at "/")           ; Terminating /
-             (forward-char)
-             t)
-            ((looking-at "[\n\r]")      ; Incomplete regexp terminated by EOL
-             (forward-char)
-             nil)                  ; / on next line would start another regexp
-            (t nil)))))                 ; Unterminated regexp at EOB
+      (cond ((looking-at "/")		; Terminating /
+	     (forward-char)
+	     t)
+	    ((looking-at "[\n\r]")	; Incomplete regexp terminated by EOL
+	     (forward-char)
+	     nil)		   ; / on next line would start another regexp
+	    (t nil)))))			; Unterminated regexp at EOB
 
 (defun c-awk-set-syntax-table-properties (lim)
 ;;     Scan the buffer text between point and LIM, setting (and clearing) the
@@ -747,7 +790,7 @@
 ;; font-lock-syntactic-keywords, and it always returns NIL (to inhibit
 ;; repeated calls from font-lock: See elisp info page "Search-based
 ;; Fontification").  It also gets called, with a bit of glue, from
-;; after-change-functions when font-lock isn't active.  Point is left
+;; after-change-functions when font-lock isn't active.	Point is left
 ;; "undefined" after this function exits.  THE BUFFER SHOULD HAVE BEEN
 ;; WIDENED, AND ANY PRECIOUS MATCH-DATA SAVED BEFORE CALLING THIS ROUTINE.
 ;;
@@ -759,29 +802,37 @@
 ;;    "generic string delimiter" on both the opening " or / and the end of the
 ;;    line where the closing delimiter is missing.
 ;; (iii) "s inside strings/regexps (these will all be escaped "s).  They are
-;;   given the property "punctuation".  This will later allow other routines
+;;   given the property "punctuation".	This will later allow other routines
 ;;   to use the regexp "\\S\"*" to skip over the string innards.
 ;; (iv) Inside a comment, all syntax-table properties are cleared.
 ;;
 ;; This function does hidden buffer changes.
   (let (anchor
 	(anchor-state-/div nil)) ; t means a following / would be a div sign.
-    (c-awk-beginning-of-logical-line) ; ACM 2002/7/21.  This is probably redundant.
+    (c-awk-beginning-of-logical-line) ; ACM 2002/7/21.	This is probably redundant.
     (c-clear-char-properties (point) lim 'syntax-table)
     ;; Once round the next loop for each string, regexp, or div sign
     (while (progn
-             ;; Skip any "harmless" lines before the next tricky one.
-             (if (search-forward-regexp c-awk-harmless-lines+-here-re nil t)
-                 (setq anchor-state-/div nil))
-             (< (point) lim))
+	     ;; Skip any "harmless" lines before the next tricky one.
+	     (if (search-forward-regexp c-awk-harmless-lines+-here-re nil t)
+		 (setq anchor-state-/div nil))
+	     (< (point) lim))
       (setq anchor (point))
       (search-forward-regexp c-awk-harmless-string*-here-re nil t)
-      ;; We are now looking at either a " or a /.
-      ;; Do our thing on the string, regexp or division sign.
+      ;; We are now looking at either a " or a / or a brace/paren/semicolon.
+      ;; Do our thing on the string, regexp or divsion sign or update our state.
       (setq anchor-state-/div
-            (if (looking-at "_?\"")
-                (c-awk-syntax-tablify-string)
-              (c-awk-syntax-tablify-/ anchor anchor-state-/div))))
+	    (cond
+	     ((looking-at "_?\"")
+	      (c-awk-syntax-tablify-string))
+	     ((eq (char-after) ?/)
+	      (c-awk-syntax-tablify-/ anchor anchor-state-/div))
+	     ((memq (char-after) '(?{ ?} ?\( ?\;))
+	      (forward-char)
+	      nil)
+	     (t 			; ?\)
+	      (forward-char)
+	      t))))
     nil))
 
 ;; ACM, 2002/07/21: Thoughts: We need an AWK Mode after-change function to set
@@ -824,14 +875,14 @@
 ;; Don't overlook the possibility of the buffer change being the "recapturing"
 ;; of a previously escaped newline.
 
-;; ACM 2008-02-05:
+;; ACM 2008-02-05: 
 (defun c-awk-extend-and-syntax-tablify-region (beg end old-len)
   ;; Expand the region (BEG END) as needed to (c-new-BEG c-new-END) then put
   ;; `syntax-table' properties on this region.
   ;;
   ;; This function is called from an after-change function, BEG END and
   ;; OLD-LEN being the standard parameters.
-  ;;
+  ;; 
   ;; Point is undefined both before and after this function call, the buffer
   ;; has been widened, and match-data saved.  The return value is ignored.
   ;;
@@ -848,8 +899,8 @@
 
 ;; Awk regexps written with help from Peter Galbraith
 ;; <galbraith@mixing.qc.dfo.ca>.
-;; Take GNU Emacs's 'words out of the following regexp-opts.  They don't work
-;; in XEmacs 21.4.4.  acm 2002/9/19.
+;; Take GNU Emacs's 'words out of the following regexp-opts.  They dont work
+;; in Xemacs 21.4.4.  acm 2002/9/19.
 (defconst awk-font-lock-keywords
   (eval-when-compile
     (list
@@ -870,7 +921,7 @@
      ;; Special file names.  (acm, 2002/7/22)
      ;; The following regexp was created by first evaluating this in GNU Emacs 21.1:
      ;; (regexp-opt '("/dev/stdin" "/dev/stdout" "/dev/stderr" "/dev/fd/n" "/dev/pid"
-     ;;                 "/dev/ppid" "/dev/pgrpid" "/dev/user") 'words)
+     ;;			"/dev/ppid" "/dev/pgrpid" "/dev/user") 'words)
      ;; , removing the "?:" from each "\\(?:" (for backward compatibility with older Emacsen)
      ;; , replacing the "n" in "dev/fd/n" with "[0-9]+"
      ;; , removing the unwanted \\< at the beginning, and finally filling out the
@@ -884,7 +935,7 @@ std\\(err\\|in\\|out\\)\\|user\\)\\)\\>\
        (8 font-lock-variable-name-face t t))
      ;; Do the same (almost) with
      ;; (regexp-opt '("/inet/tcp/lport/rhost/rport" "/inet/udp/lport/rhost/rport"
-     ;;                 "/inet/raw/lport/rhost/rport") 'words)
+     ;;			"/inet/raw/lport/rhost/rport") 'words)
      ;; This cannot be combined with the above pattern, because the match number
      ;; for the (optional) closing \" would then exceed 9.
      '("\\(\"/inet/\\(\\(raw\\|\\(tc\\|ud\\)p\\)/lport/rhost/rport\\)\\)\\>\
@@ -929,7 +980,7 @@ std\\(err\\|in\\|out\\)\\|user\\)\\)\\>\
      ;; Space after \ in what looks like an escaped newline.  2002/5/31
      '("\\\\\\s +$" 0 font-lock-warning-face t)
 
-     ;; Unbalanced string (") or regexp (/) delimiters.  2002/02/16.
+     ;; Unbalanced string (") or regexp (/) delimiters.	 2002/02/16.
      '("\\s|" 0 font-lock-warning-face t nil)
      ;; gawk 3.1 localizable strings ( _"translate me!").  2002/5/21
      '("\\(_\\)\\s|" 1 font-lock-warning-face)
@@ -940,7 +991,7 @@ std\\(err\\|in\\|out\\)\\|user\\)\\)\\>\
 ;; ACM 2002/9/29.  Movement functions, e.g. for C-M-a and C-M-e
 
 ;; The following three regexps differ from those earlier on in cc-awk.el in
-;; that they assume the syntax-table properties have been set.  They are thus
+;; that they assume the syntax-table properties have been set.	They are thus
 ;; not useful for code which sets these properties.
 (defconst c-awk-terminated-regexp-or-string-here-re "\\=\\s\"\\S\"*\\s\"")
 ;; Matches a terminated string/regexp.
@@ -954,8 +1005,8 @@ std\\(err\\|in\\|out\\)\\|user\\)\\)\\>\
 
 (defun c-awk-at-statement-end-p ()
   ;; Point is not inside a comment or string.  Is it AT the end of a
-  ;; statement?  This means immediately after the last non-ws character of the
-  ;; statement.  The caller is responsible for widening the buffer, if
+  ;; statement?	 This means immediately after the last non-ws character of the
+  ;; statement.	 The caller is responsible for widening the buffer, if
   ;; appropriate.
   (and (not (bobp))
        (save-excursion
@@ -968,9 +1019,9 @@ std\\(err\\|in\\|out\\)\\|user\\)\\)\\>\
 			     "[#\n\r]"))))))))
 
 (defun c-awk-beginning-of-defun (&optional arg)
-  "Move backward to the beginning of an AWK \"defun\".  With ARG, do it that
+  "Move backward to the beginning of an AWK \"defun\".	With ARG, do it that
 many times.  Negative arg -N means move forward to Nth following beginning of
-defun.  Returns t unless search stops due to beginning or end of buffer.
+defun.	Returns t unless search stops due to beginning or end of buffer.
 
 By a \"defun\" is meant either a pattern-action pair or a function.  The start
 of a defun is recognized as code starting at column zero which is neither a
@@ -978,31 +1029,31 @@ closing brace nor a comment nor a contin
 in some other modes, having an opening brace at column 0 is neither necessary
 nor helpful.
 
-Note that this function might do hidden buffer changes.  See the
+Note that this function might do hidden buffer changes.	 See the
 comment at the start of cc-engine.el for more info."
   (interactive "p")
   (or arg (setq arg 1))
   (save-match-data
-    (c-save-buffer-state                ; ensures the buffer is writable.
+    (c-save-buffer-state		; ensures the buffer is writable.
      nil
-     (let ((found t))     ; Has the most recent regexp search found b-of-defun?
+     (let ((found t))	  ; Has the most recent regexp search found b-of-defun?
        (if (>= arg 0)
-           ;; Go back one defun each time round the following loop. (For +ve arg)
-           (while (and found (> arg 0) (not (eq (point) (point-min))))
-             ;; Go back one "candidate" each time round the next loop until one
-             ;; is genuinely a beginning-of-defun.
-             (while (and (setq found (search-backward-regexp
-                                      "^[^#} \t\n\r]" (point-min) 'stop-at-limit))
-                         (not (memq (c-awk-get-NL-prop-prev-line) '(?\$ ?\} ?\#)))))
-             (setq arg (1- arg)))
-         ;; The same for a -ve arg.
-         (if (not (eq (point) (point-max))) (forward-char 1))
-         (while (and found (< arg 0) (not (eq (point) (point-max)))) ; The same for -ve arg.
-           (while (and (setq found (search-forward-regexp
-                                    "^[^#} \t\n\r]" (point-max) 'stop-at-limit))
-                       (not (memq (c-awk-get-NL-prop-prev-line) '(?\$ ?\} ?\#)))))
-           (setq arg (1+ arg)))
-         (if found (goto-char (match-beginning 0))))
+	   ;; Go back one defun each time round the following loop. (For +ve arg)
+	   (while (and found (> arg 0) (not (eq (point) (point-min))))
+	     ;; Go back one "candidate" each time round the next loop until one
+	     ;; is genuinely a beginning-of-defun.
+	     (while (and (setq found (search-backward-regexp
+				      "^[^#} \t\n\r]" (point-min) 'stop-at-limit))
+			 (not (memq (c-awk-get-NL-prop-prev-line) '(?\$ ?\} ?\#)))))
+	     (setq arg (1- arg)))
+	 ;; The same for a -ve arg.
+	 (if (not (eq (point) (point-max))) (forward-char 1))
+	 (while (and found (< arg 0) (not (eq (point) (point-max)))) ; The same for -ve arg.
+	   (while (and (setq found (search-forward-regexp
+				    "^[^#} \t\n\r]" (point-max) 'stop-at-limit))
+		       (not (memq (c-awk-get-NL-prop-prev-line) '(?\$ ?\} ?\#)))))
+	   (setq arg (1+ arg)))
+	 (if found (goto-char (match-beginning 0))))
        (eq arg 0)))))
 
 (defun c-awk-forward-awk-pattern ()
@@ -1015,18 +1066,18 @@ comment at the start of cc-engine.el for
   ;; This function might do hidden buffer changes.
   (while
       (progn
-        (search-forward-regexp c-awk-harmless-pattern-characters*)
-        (if (looking-at "#") (end-of-line))
-        (cond
-         ((eobp) nil)
-         ((looking-at "[{;]") nil)  ; We've finished!
-         ((eolp)
-          (if (c-awk-cur-line-incomplete-p)
-              (forward-line)            ; returns non-nil
-            nil))
-         ((search-forward-regexp c-awk-terminated-regexp-or-string-here-re nil t))
-         ((search-forward-regexp c-awk-unterminated-regexp-or-string-here-re nil t))
-         ((looking-at "/") (forward-char) t))))) ; division sign.
+	(search-forward-regexp c-awk-harmless-pattern-characters*)
+	(if (looking-at "#") (end-of-line))
+	(cond
+	 ((eobp) nil)
+	 ((looking-at "[{;]") nil)  ; We've finished!
+	 ((eolp)
+	  (if (c-awk-cur-line-incomplete-p)
+	      (forward-line)		; returns non-nil
+	    nil))
+	 ((search-forward-regexp c-awk-terminated-regexp-or-string-here-re nil t))
+	 ((search-forward-regexp c-awk-unterminated-regexp-or-string-here-re nil t))
+	 ((looking-at "/") (forward-char) t))))) ; division sign.
 
 (defun c-awk-end-of-defun1 ()
   ;; point is at the start of a "defun".  Move to its end.  Return end position.
@@ -1056,7 +1107,7 @@ An end of a defun occurs right after the
 opening brace at its start, or immediately after the AWK pattern when there is
 no explicit action; see function `c-awk-beginning-of-defun'.
 
-Note that this function might do hidden buffer changes.  See the
+Note that this function might do hidden buffer changes.	 See the
 comment at the start of cc-engine.el for more info."
   (interactive "p")
   (or arg (setq arg 1))
@@ -1067,33 +1118,34 @@ comment at the start of cc-engine.el for
        ;; Strategy: (For +ve ARG): If we're not already at a beginning-of-defun,
        ;; move backwards to one.
        ;; Repeat [(i) move forward to end-of-current-defun (see below);
-       ;;         (ii) If this isn't it, move forward to beginning-of-defun].
+       ;;	  (ii) If this isn't it, move forward to beginning-of-defun].
        ;; We start counting ARG only when step (i) has passed the original point.
        (when (> arg 0)
-         ;; Try to move back to a beginning-of-defun, if not already at one.
-         (if (not (c-awk-beginning-of-defun-p))
-             (when (not (c-awk-beginning-of-defun 1)) ; No bo-defun before point.
-               (goto-char start-point)
-               (c-awk-beginning-of-defun -1))) ; if this fails, we're at EOB, tough!
-         ;; Now count forward, one defun at a time
-         (while (and (not (eobp))
-                     (c-awk-end-of-defun1)
-                     (if (> (point) start-point) (setq arg (1- arg)) t)
-                     (> arg 0)
-                     (c-awk-beginning-of-defun -1))))
+	 ;; Try to move back to a beginning-of-defun, if not already at one.
+	 (if (not (c-awk-beginning-of-defun-p))
+	     (when (not (c-awk-beginning-of-defun 1)) ; No bo-defun before point.
+	       (goto-char start-point)
+	       (c-awk-beginning-of-defun -1))) ; if this fails, we're at EOB, tough!
+	 ;; Now count forward, one defun at a time
+	 (while (and (not (eobp))
+		     (c-awk-end-of-defun1)
+		     (if (> (point) start-point) (setq arg (1- arg)) t)
+		     (> arg 0)
+		     (c-awk-beginning-of-defun -1))))
 
        (when (< arg 0)
-         (setq end-point start-point)
-         (while (and (not (bobp))
-                     (c-awk-beginning-of-defun 1)
-                     (if (< (setq end-point (if (bobp) (point)
-                                              (save-excursion (c-awk-end-of-defun1))))
-                            start-point)
-                         (setq arg (1+ arg)) t)
-                     (< arg 0)))
-         (goto-char (min start-point end-point)))))))
+	 (setq end-point start-point)
+	 (while (and (not (bobp))
+		     (c-awk-beginning-of-defun 1)
+		     (if (< (setq end-point (if (bobp) (point)
+					      (save-excursion (c-awk-end-of-defun1))))
+			    start-point)
+			 (setq arg (1+ arg)) t)
+		     (< arg 0)))
+	 (goto-char (min start-point end-point)))))))
 
 
 (cc-provide 'cc-awk)			; Changed from 'awk-mode, ACM 2002/5/21
 
+;;; arch-tag: c4836289-3aa4-4a59-9934-9ccc2bacccf3
 ;;; awk-mode.el ends here
--- emacs24-24.3+1.orig/lisp/progmodes/cc-bytecomp.el
+++ emacs24-24.3+1/lisp/progmodes/cc-bytecomp.el
@@ -1,19 +1,20 @@
 ;;; cc-bytecomp.el --- compile time setup for proper compilation
 
-;; Copyright (C) 2000-2013 Free Software Foundation, Inc.
+;; Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
+;;   2008, 2009, 2010, 2011  Free Software Foundation, Inc.
 
 ;; Author:     Martin Stjernholm
 ;; Maintainer: bug-cc-mode@gnu.org
 ;; Created:    15-Jul-2000
-;; Keywords:   c languages
-;; Package:    cc-mode
+;; Version:    See cc-mode.el
+;; Keywords:   c languages oop
 
 ;; This file is part of GNU Emacs.
 
-;; GNU Emacs is free software: you can redistribute it and/or modify
+;; GNU Emacs is free software; you can redistribute it and/or modify
 ;; it under the terms of the GNU General Public License as published by
-;; the Free Software Foundation, either version 3 of the License, or
-;; (at your option) any later version.
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
 
 ;; GNU Emacs is distributed in the hope that it will be useful,
 ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -21,7 +22,8 @@
 ;; GNU General Public License for more details.
 
 ;; You should have received a copy of the GNU General Public License
-;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
+;; along with this program; see the file COPYING.  If not, see
+;; <http://www.gnu.org/licenses/>.
 
 ;;; Commentary:
 
@@ -78,6 +80,15 @@
 (defvar cc-bytecomp-original-functions nil)
 (defvar cc-bytecomp-original-properties nil)
 (defvar cc-bytecomp-loaded-files nil)
+(defvar cc-bytecomp-push-vars nil
+  "A stack ((VAR GLOBAL-VAL SETQD-VAL) ...)")
+
+(setq cc-bytecomp-unbound-variables nil)
+(setq cc-bytecomp-original-functions nil)
+(setq cc-bytecomp-original-properties nil)
+(setq cc-bytecomp-loaded-files nil)
+(setq cc-bytecomp-push-vars nil)
+
 (defvar cc-bytecomp-environment-set nil)
 
 (defmacro cc-bytecomp-debug-msg (&rest args)
@@ -131,6 +142,15 @@ perhaps a `cc-bytecomp-restore-environme
 	     "cc-bytecomp-setup-environment: Bound property %s for %s to %s"
 	     prop sym tempdef))
 	  (setq p (cdr p)))
+	(setq p (reverse cc-bytecomp-push-vars))
+	(while p
+	  (let ((var (caar p))
+		(setqd-val (cadr (cdar p))))
+	    (set var setqd-val)
+	    (cc-bytecomp-debug-msg
+	     "cc-bytecomp-setup-environment: Set variable %s to %s"
+	     var setqd-val))
+	  (setq p (cdr p)))
 	(setq cc-bytecomp-environment-set t)
 	(cc-bytecomp-debug-msg
 	 "cc-bytecomp-setup-environment: Done"))))
@@ -196,6 +216,18 @@ perhaps a `cc-bytecomp-restore-environme
 	       "cc-bytecomp-restore-environment: Not restoring property %s for %s"
 	       prop sym)))
 	  (setq p (cdr p)))
+	(setq p cc-bytecomp-push-vars)
+	(while p
+	  (let ((var (caar p))
+		(global-val (cadr (car p)))
+		)
+	    (if (eq global-val 'cc-bytecomp-unbound)
+		(makunbound var)
+	      (set var global-val))
+	    (cc-bytecomp-debug-msg
+	     "cc-bytecomp-restore-environment: Restored variable %s to %s"
+	     var global-val))
+	  (setq p (cdr p)))
 	(setq cc-bytecomp-environment-set nil)
 	(cc-bytecomp-debug-msg
 	 "cc-bytecomp-restore-environment: Done"))))
@@ -338,6 +370,30 @@ at compile time, e.g. for macros and inl
 	     (cc-bytecomp-debug-msg
 	      "cc-bytecomp-defun: Covered function %s" ',fun))))))
 
+(put 'cc-bytecomp-defmacro 'lisp-indent-function 'defun)
+(defmacro cc-bytecomp-defmacro (fun &rest temp-macro)
+  "Bind the symbol as a macro during compilation (and evaluation) of the
+file.  Don't use outside `eval-when-compile'."
+  `(let ((orig-fun (assq ',fun cc-bytecomp-original-functions)))
+     (if (not orig-fun)
+	 (setq orig-fun
+	       (list ',fun
+		     nil
+		     (if (fboundp ',fun)
+			 (progn
+			   (cc-bytecomp-debug-msg
+			    "cc-bytecomp-defmacro: Saving %s" ',fun)
+			   (symbol-function ',fun))
+		       (cc-bytecomp-debug-msg
+			"cc-bytecomp-defmacro: Saving %s as unbound" ',fun)
+		       'unbound))
+	       cc-bytecomp-original-functions
+	       (cons orig-fun cc-bytecomp-original-functions)))
+     (defmacro ,fun ,@temp-macro)
+     (cc-bytecomp-debug-msg
+      "cc-bytecomp-defmacro: Bound macro %s" ',fun)
+     (setcar (cdr orig-fun) (symbol-function ',fun))))
+
 (defmacro cc-bytecomp-put (symbol propname value)
   "Set a property on a symbol during compilation (and evaluation) of
 the file.  Don't use outside `eval-when-compile'."
@@ -356,6 +412,26 @@ the file.  Don't use outside `eval-when-
       "cc-bytecomp-put: Bound property %s for %s to %s"
       ,propname ,symbol ,value)))
 
+(defmacro cc-bytecomp-push (symbol value)
+  "Set SYMBOL to VALUE during compilation (and evaluation) of the file.
+Don't use within `eval-when-compile'."
+  `(eval-when-compile
+     (cc-bytecomp-debug-msg
+      "cc-bytecomp-push: symbol is %s, value is %s"
+      ',symbol ,value)
+     (setq cc-bytecomp-set-vars
+	   (cons (list ',symbol
+		       (if (boundp ',symbol)
+			   ,symbol
+			 'cc-bytecomp-unbound)
+		       ,value)
+		 cc-bytecomp-push-vars))
+     (cc-bytecomp-debug-msg
+      "cc-bytecomp-push: set %s to %s" ',symbol ,value)
+     (set ',symbol ,value)
+     (cc-bytecomp-debug-msg
+      "cc-bytecomp-push: cc-bytecomp-push-vars is %s" cc-bytecomp-push-vars)))
+
 (defmacro cc-bytecomp-obsolete-var (symbol)
   "Suppress warnings that the given symbol is an obsolete variable.
 Don't use within `eval-when-compile'."
@@ -369,19 +445,24 @@ Don't use within `eval-when-compile'."
 (defun cc-bytecomp-ignore-obsolete (form)
   ;; Wraps a call to `byte-compile-obsolete' that suppresses the warning.
   (let ((byte-compile-warnings byte-compile-warnings))
-    (byte-compile-disable-warning 'obsolete)
-    (byte-compile-obsolete form)))
+    (if (fboundp 'byte-compile-disable-warning) ; Emacs 23+
+	(byte-compile-disable-warning 'obsolete)
+      (delq 'obsolete (append byte-compile-warnings nil)))
+    (if (fboundp 'byte-compile-obsolete) ; purely to suppress a warnin.
+	(byte-compile-obsolete form))))
 
 (defmacro cc-bytecomp-obsolete-fun (symbol)
   "Suppress warnings that the given symbol is an obsolete function.
 Don't use within `eval-when-compile'."
   `(eval-when-compile
-     (if (eq (get ',symbol 'byte-compile) 'byte-compile-obsolete)
-	 (cc-bytecomp-put ',symbol 'byte-compile
-			  'cc-bytecomp-ignore-obsolete)
-       ;; This avoids a superfluous compiler warning
-       ;; about calling `get' for effect.
-       t)))
+     ,(if (fboundp 'byte-compile-obsolete)
+	  `(if (eq (get ',symbol 'byte-compile) 'byte-compile-obsolete)
+	       (cc-bytecomp-put ',symbol 'byte-compile
+				'cc-bytecomp-ignore-obsolete)
+	     ;; This avoids a superfluous compiler warning
+	     ;; about calling `get' for effect.
+	     t)
+	`(cc-bytecomp-push byte-compile-not-obsolete-funcs '(,symbol)))))
 
 (defmacro cc-bytecomp-boundp (symbol)
   "Return non-nil if the given symbol is bound as a variable outside
@@ -409,4 +490,5 @@ exclude any functions that have been bou
 
 (provide 'cc-bytecomp)
 
+;;; arch-tag: 2d71b3ad-57b0-4b13-abd3-ab836e08f975
 ;;; cc-bytecomp.el ends here
--- emacs24-24.3+1.orig/lisp/progmodes/cc-cmds.el
+++ emacs24-24.3+1/lisp/progmodes/cc-cmds.el
@@ -1,32 +1,34 @@
 ;;; cc-cmds.el --- user level commands for CC Mode
 
-;; Copyright (C) 1985, 1987, 1992-2013 Free Software Foundation, Inc.
+;; Copyright (C) 1985, 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+;;   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+;;   2010, 2011   Free Software Foundation, Inc.
 
 ;; Authors:    2003- Alan Mackenzie
-;;             1998- Martin Stjernholm
-;;             1992-1999 Barry A. Warsaw
-;;             1987 Dave Detlefs
-;;             1987 Stewart Clamen
-;;             1985 Richard M. Stallman
+;;	       1998- Martin Stjernholm
+;;	       1992-1999 Barry A. Warsaw
+;;	       1987 Dave Detlefs and Stewart Clamen
+;;	       1985 Richard M. Stallman
 ;; Maintainer: bug-cc-mode@gnu.org
 ;; Created:    22-Apr-1997 (split from cc-mode.el)
-;; Keywords:   c languages
-;; Package:    cc-mode
+;; Version:    See cc-mode.el
+;; Keywords:   c languages oop
 
 ;; This file is part of GNU Emacs.
 
-;; GNU Emacs is free software: you can redistribute it and/or modify
+;; GNU Emacs is free software; you can redistribute it and/or modify
 ;; it under the terms of the GNU General Public License as published by
-;; the Free Software Foundation, either version 3 of the License, or
-;; (at your option) any later version.
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
 
 ;; GNU Emacs is distributed in the hope that it will be useful,
 ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
 ;; GNU General Public License for more details.
 
 ;; You should have received a copy of the GNU General Public License
-;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
+;; along with this program; see the file COPYING.  If not, see
+;; <http://www.gnu.org/licenses/>.
 
 ;;; Commentary:
 
@@ -48,6 +50,8 @@
 (cc-bytecomp-defun delete-forward-p)	; XEmacs
 (cc-bytecomp-defvar filladapt-mode)	; c-fill-paragraph contains a kludge
 					; which looks at this.
+(cc-bytecomp-defun c-forward-subword)
+(cc-bytecomp-defun c-backward-subword)
 
 ;; Indentation / Display syntax functions
 (defvar c-fix-backslashes t)
@@ -57,10 +61,10 @@
 if `c-syntactic-indentation' is non-nil.  Optional SYNTAX is the
 syntactic information for the current line.  Be silent about syntactic
 errors if the optional argument QUIET is non-nil, even if
-`c-report-syntactic-errors' is non-nil.  Normally the position of
+`c-report-syntactic-errors' is non-nil.	 Normally the position of
 point is used to decide where the old indentation is on a lines that
 is otherwise empty \(ignoring any line continuation backslash), but
-that's not done if IGNORE-POINT-POS is non-nil.  Returns the amount of
+that's not done if IGNORE-POINT-POS is non-nil.	 Returns the amount of
 indentation change \(in columns)."
 
   (let ((line-cont-backslash (save-excursion
@@ -143,7 +147,7 @@ and takes care to set the indentation be
   (let ((c-macro-start (c-query-macro-start))
 	;; Avoid calling c-backslash-region from c-indent-line if it's
 	;; called during the newline call, which can happen due to
-	;; c-electric-continued-statement, for example.  We also don't
+	;; c-electric-continued-statement, for example.	 We also don't
 	;; want any backslash alignment from indent-according-to-mode.
 	(c-fix-backslashes nil)
 	has-backslash insert-backslash
@@ -186,7 +190,7 @@ and takes care to set the indentation be
       (let ((c-syntactic-context (c-save-buffer-state nil
 				   (c-guess-basic-syntax))))
 	;; We temporarily insert another line break, so that the
-	;; lineup functions will see the line as empty.  That makes
+	;; lineup functions will see the line as empty.	 That makes
 	;; e.g. c-lineup-cpp-define more intuitive since it then
 	;; proceeds to the preceding line in this case.
 	(insert ?\n)
@@ -199,7 +203,7 @@ and takes care to set the indentation be
 	  (goto-char (- (point-max) start))
 	  (delete-char -1)))
       (when has-backslash
-	;; Must align the backslash again after reindentation.  The
+	;; Must align the backslash again after reindentation.	The
 	;; c-backslash-region call above can't be optimized to ignore
 	;; this line, since it then won't align correctly with the
 	;; lines below if the first line in the macro is broken.
@@ -259,19 +263,17 @@ With universal argument, inserts the ana
 			 "a" "")
 		     (if c-hungry-delete-key "h" "")
 		     (if (and
-			  ;; subword might not be loaded.
-			  (boundp 'subword-mode)
-			  (symbol-value 'subword-mode))
+			  ;; cc-subword might not be loaded.
+			  (boundp 'c-subword-mode)
+			  (symbol-value 'c-subword-mode))
 			 "w"
 		       "")))
-        ;; FIXME: Derived modes might want to use something else
-        ;; than a string for `mode-name'.
 	(bare-mode-name (if (string-match "\\(^[^/]*\\)/" mode-name)
-			    (match-string 1 mode-name)
+			    (substring mode-name (match-beginning 1) (match-end 1))
 			  mode-name)))
 ;;     (setq c-submode-indicators
-;; 	  (if (> (length fmt) 1)
-;; 	      fmt))
+;;	  (if (> (length fmt) 1)
+;;	      fmt))
     (setq mode-name
 	  (if (> (length fmt) 1)
 	      (concat bare-mode-name fmt)
@@ -291,7 +293,7 @@ context keys, when applicable.
 When it's turned off, the electric keys don't reindent, the indentation
 functions indents every new line to the same level as the previous
 nonempty line, and \\[c-indent-command] adjusts the indentation in steps
-specified by `c-basic-offset'.  The indentation style has no effect in
+specified by `c-basic-offset'.	The indentation style has no effect in
 this mode, nor any of the indentation associated variables,
 e.g. `c-special-indent-hook'.
 
@@ -310,7 +312,7 @@ left out.
 Turning on auto-newline automatically enables electric indentation.
 
 When the auto-newline feature is enabled (indicated by \"/la\" on the
-mode line after the mode name) newlines are automatically inserted
+modeline after the mode name) newlines are automatically inserted
 after special characters such as brace, comma, semi-colon, and colon."
   (interactive "P")
   (setq c-auto-newline
@@ -320,7 +322,7 @@ after special characters such as brace,
   (c-keep-region-active))
 
 (defalias 'c-toggle-auto-state 'c-toggle-auto-newline)
-(make-obsolete 'c-toggle-auto-state 'c-toggle-auto-newline "22.1")
+(make-obsolete 'c-toggle-auto-state 'c-toggle-auto-newline nil)
 
 (defun c-toggle-hungry-state (&optional arg)
   "Toggle hungry-delete-key feature.
@@ -329,7 +331,7 @@ positive, turns it off when negative, an
 left out.
 
 When the hungry-delete-key feature is enabled (indicated by \"/h\" on
-the mode line after the mode name) the delete key gobbles all preceding
+the modeline after the mode name) the delete key gobbles all preceding
 whitespace in one fell swoop."
   (interactive "P")
   (setq c-hungry-delete-key (c-calculate-state arg c-hungry-delete-key))
@@ -475,7 +477,7 @@ inside a literal or a macro, nothing spe
 	  (bolp (bolp)))
       (beginning-of-line)
       (delete-horizontal-space)
-      (insert last-command-event)
+      (insert (c-last-command-char))
       (and (not bolp)
 	   (goto-char (- (point-max) pos)))
       )))
@@ -524,7 +526,7 @@ inside a literal or a macro, nothing spe
 	;; This is the list of brace syntactic symbols that can hang.
 	;; If any new ones are added to c-offsets-alist, they should be
 	;; added here as well.
-	;;
+	;; 
 	;; The order of this list is important; if SYNTAX has several
 	;; elements, the element that "wins" is the earliest in SYMS.
 	'(arglist-cont-nonempty		; e.g. an array literal.
@@ -540,7 +542,7 @@ inside a literal or a macro, nothing spe
 		     composition-open composition-close
 		     inexpr-class-open inexpr-class-close
 		     ;; `statement-cont' is here for the case with a brace
-		     ;; list opener inside a statement.  C.f. CASE B.2 in
+		     ;; list opener inside a statement.	 C.f. CASE B.2 in
 		     ;; `c-guess-continued-construct'.
 		     statement-cont))
        ;; shut this up too
@@ -645,7 +647,7 @@ inside a literal or a macro, nothing spe
 	      (insert-char ?\} 1)	; reinsert the `}' before the comment.
 	      (setq cmnt-gap (- cmnt-col (current-column)))
 	      (when (zerop cmnt-gap)
-		(insert-char ?\  1)	; Put a space before a bare comment.
+		(insert-char ?\	 1)	; Put a space before a bare comment.
 		(setq cmnt-gap 1)))
 
 	    (or (null c-max-one-liner-length)
@@ -737,7 +739,7 @@ settings of `c-cleanup-list' are done."
 	      ;; `}': clean up empty defun braces
 	      (when (c-save-buffer-state ()
 		      (and (memq 'empty-defun-braces c-cleanup-list)
-			   (eq last-command-event ?\})
+			   (eq (c-last-command-char) ?\})
 			   (c-intersect-lists '(defun-close class-close inline-close)
 					      syntax)
 			   (progn
@@ -753,14 +755,14 @@ settings of `c-cleanup-list' are done."
 	      ;; `}': compact to a one-liner defun?
 	      (save-match-data
 		(when
-		    (and (eq last-command-event ?\})
+		    (and (eq (c-last-command-char) ?\})
 			 (memq 'one-liner-defun c-cleanup-list)
 			 (c-intersect-lists '(defun-close) syntax)
 			 (c-try-one-liner))
 		  (setq here (- (point-max) pos))))
 
 	      ;; `{': clean up brace-else-brace and brace-elseif-brace
-	      (when (eq last-command-event ?\{)
+	      (when (eq (c-last-command-char) ?\{)
 		(cond
 		 ((and (memq 'brace-else-brace c-cleanup-list)
 		       (re-search-backward
@@ -814,7 +816,7 @@ settings of `c-cleanup-list' are done."
 	    ))))
 
     ;; blink the paren
-    (and (eq last-command-event ?\})
+    (and (eq (c-last-command-char) ?\})
 	 (not executing-kbd-macro)
 	 old-blink-paren
 	 (save-excursion
@@ -851,7 +853,7 @@ is inhibited."
     (when (and (not arg)
 	       (eq literal 'c)
 	       (memq 'comment-close-slash c-cleanup-list)
-	       (eq last-command-event ?/)
+	       (eq (c-last-command-char) ?/)
 	       (looking-at (concat "[ \t]*\\("
 				   (regexp-quote comment-end) "\\)?$"))
 	; (eq c-block-comment-ender "*/") ; C-style comments ALWAYS end in */
@@ -867,7 +869,7 @@ is inhibited."
     (setq indentp (and (not arg)
 		       c-syntactic-indentation
 		       c-electric-flag
-		       (eq last-command-event ?/)
+		       (eq (c-last-command-char) ?/)
 		       (eq (char-before) (if literal ?* ?/))))
     (self-insert-command (prefix-numeric-value arg))
     (if indentp
@@ -935,16 +937,23 @@ settings of `c-cleanup-list'."
 	;; do all cleanups and newline insertions if c-auto-newline is on.
 	(if (or (not c-auto-newline)
 		(not (looking-at "[ \t]*\\\\?$")))
-	    (if c-syntactic-indentation
-		(c-indent-line))
+	    (when c-syntactic-indentation
+		(let ((syntax (c-guess-basic-syntax)))
+		  (c-indent-line syntax)
+		  ;; Guard against the C hacker inserting a statement before a
+		  ;; non-compound statement in an if/while/for.
+		  (if (eq (caar syntax) 'substatement)
+		      (save-excursion
+			(if (eq 0 (forward-line))
+			    (c-indent-line))))))
 	  ;; clean ups: list-close-comma or defun-close-semi
 	  (let ((pos (- (point-max) (point))))
 	    (if (c-save-buffer-state ()
 		  (and (or (and
-			    (eq last-command-event ?,)
+			    (eq (c-last-command-char) ?,)
 			    (memq 'list-close-comma c-cleanup-list))
 			   (and
-			    (eq last-command-event ?\;)
+			    (eq (c-last-command-char) ?\;)
 			    (memq 'defun-close-semi c-cleanup-list)))
 		       (progn
 			 (forward-char -1)
@@ -1045,7 +1054,7 @@ reindented unless `c-syntactic-indentati
 		  (setcar (car elem) 'label))
 	      (setq elem (cdr elem)))
 	    ;; some language elements can only be determined by checking
-	    ;; the following line.  Let's first look for ones that can be
+	    ;; the following line.  Lets first look for ones that can be
 	    ;; found when looking on the line with the colon
 	    (setq newlines
 		  (and c-auto-newline
@@ -1089,7 +1098,7 @@ numeric argument is supplied, or the poi
 
   (interactive "*P")
   (let ((c-echo-syntactic-information-p nil)
-	final-pos close-paren-inserted found-delim case-fold-search)
+	final-pos found-delim case-fold-search)
 
     (self-insert-command (prefix-numeric-value arg))
     (setq final-pos (point))
@@ -1101,7 +1110,7 @@ numeric argument is supplied, or the poi
     ;; Indent the line if appropriate.
     (when (and c-electric-flag c-syntactic-indentation c-recognize-<>-arglists)
       (setq found-delim
-	    (if (eq last-command-event ?<)
+	    (if (eq (c-last-command-char) ?<)
 		;; If a <, basically see if it's got "template" before it .....
 		(or (and (progn
 			   (backward-char)
@@ -1195,7 +1204,7 @@ newline cleanups are done if appropriate
 	    ;; clean up brace-elseif-brace
 	    (when
 		(and (memq 'brace-elseif-brace c-cleanup-list)
-		     (eq last-command-event ?\()
+		     (eq (c-last-command-char) ?\()
 		     (re-search-backward
 		      (concat "}"
 			      "\\([ \t\n]\\|\\\\\n\\)*"
@@ -1213,7 +1222,7 @@ newline cleanups are done if appropriate
 	    ;; clean up brace-catch-brace
 	    (when
 		(and (memq 'brace-catch-brace c-cleanup-list)
-		     (eq last-command-event ?\()
+		     (eq (c-last-command-char) ?\()
 		     (re-search-backward
 		      (concat "}"
 			      "\\([ \t\n]\\|\\\\\n\\)*"
@@ -1234,16 +1243,16 @@ newline cleanups are done if appropriate
 
 	     ;; space-before-funcall clean-up?
 	     ((and (memq 'space-before-funcall c-cleanup-list)
-		   (eq last-command-event ?\()
+		   (eq (c-last-command-char) ?\()
 		   (save-excursion
 		     (backward-char)
 		     (skip-chars-backward " \t")
 		     (setq beg (point))
 		     (and (c-save-buffer-state () (c-on-identifier))
-                          ;; Don't add a space into #define FOO()....
-                          (not (and (c-beginning-of-macro)
-                                    (c-forward-over-cpp-define-id)
-                                    (eq (point) beg))))))
+			  ;; Don't add a space into #define FOO()....
+			  (not (and (c-beginning-of-macro)
+				    (c-forward-over-cpp-define-id)
+				    (eq (point) beg))))))
 	      (save-excursion
 		(delete-region beg end)
 		(goto-char beg)
@@ -1252,7 +1261,7 @@ newline cleanups are done if appropriate
 	     ;; compact-empty-funcall clean-up?
 		  ((c-save-buffer-state ()
 		     (and (memq 'compact-empty-funcall c-cleanup-list)
-			  (eq last-command-event ?\))
+			  (eq (c-last-command-char) ?\))
 			  (save-excursion
 			    (c-safe (backward-char 2))
 			    (when (looking-at "()")
@@ -1281,7 +1290,7 @@ keyword on the line, the keyword is not
     (when (c-save-buffer-state ()
 	    (and c-electric-flag
 		 c-syntactic-indentation
-		 (not (eq last-command-event ?_))
+		 (not (eq (c-last-command-char) ?_))
 		 (= (save-excursion
 		      (skip-syntax-backward "w")
 		      (point))
@@ -1298,24 +1307,20 @@ keyword on the line, the keyword is not
 	(delete-char -2)))))
 
 
-
-(declare-function subword-forward "subword" (&optional arg))
-(declare-function subword-backward "subword" (&optional arg))
-
 ;; "nomenclature" functions + c-scope-operator.
 (defun c-forward-into-nomenclature (&optional arg)
   "Compatibility alias for `c-forward-subword'."
   (interactive "p")
-  (require 'subword)
-  (subword-forward arg))
-(make-obsolete 'c-forward-into-nomenclature 'subword-forward "23.2")
+  (require 'cc-subword)
+  (c-forward-subword arg))
+(make-obsolete 'c-forward-into-nomenclature 'c-forward-subword nil)
 
 (defun c-backward-into-nomenclature (&optional arg)
   "Compatibility alias for `c-backward-subword'."
   (interactive "p")
-  (require 'subword)
-  (subword-backward arg))
-(make-obsolete 'c-backward-into-nomenclature 'subword-backward "23.2")
+  (require 'cc-subword)
+  (c-backward-subword arg))
+(make-obsolete 'c-backward-into-nomenclature 'c-backward-subword nil)
 
 (defun c-scope-operator ()
   "Insert a double colon scope operator at point.
@@ -1364,19 +1369,19 @@ No indentation or other \"electric\" beh
   ;; Determine where we are with respect to functions (or other brace
   ;; constructs, included in the term "function" in the rest of this comment).
   ;; Point is assumed to be outside any macro or literal.
-  ;; This is used by c-\(beginning\|end\)-of-defun.
+  ;; This is used by c-\(begining\|end\)-of-defun.
   ;;
   ;; Return one of these symbols:
-  ;; at-header       : we're at the start of a function's header.
-  ;; in-header       : we're inside a function's header, this extending right
-  ;;                   up to the brace.  This bit includes any k&r declarations.
-  ;; in-block        : we're inside a function's brace block.
-  ;; in-trailer      : we're in the area between the "}" and ";" of something
-  ;;                  like "struct foo {...} bar, baz;".
+  ;; at-header	     : we're at the start of a function's header.
+  ;; in-header	     : we're inside a function's header, this extending right
+  ;;		       up to the brace.	 This bit includes any k&r declarations.
+  ;; in-block	     : we're inside a function's brace block.
+  ;; in-trailer	     : we're in the area between the "}" and ";" of something
+  ;;		      like "struct foo {...} bar, baz;".
   ;; at-function-end : we're just after the closing brace (or semicolon) that
-  ;;                   terminates the function.
-  ;; outwith-function: we're not at or in any function.  Being inside a
-  ;;                   non-brace construct also counts as 'outwith-function'.
+  ;;		       terminates the function.
+  ;; outwith-function: we're not at or in any function.	 Being inside a
+  ;;		       non-brace construct also counts as 'outwith-function'.
   ;;
   ;; This function might do hidden buffer changes.
   (save-excursion
@@ -1407,20 +1412,22 @@ No indentation or other \"electric\" beh
 	;; Kluge so that c-beginning-of-decl-1 won't go back if we're already
 	;; at a declaration.
 	(if (or (and (eolp) (not (eobp))) ; EOL is matched by "\\s>"
-		(not (looking-at
-"\\([;#]\\|\\'\\|\\s(\\|\\s)\\|\\s\"\\|\\s\\\\|\\s$\\|\\s<\\|\\s>\\|\\s!\\)")))
+		(not (c-looking-at-non-alphnumspace)))
 	    (forward-char))
 	(setq kluge-start (point))
 	(setq decl-result
 	      (car (c-beginning-of-decl-1
 		    ;; NOTE: If we're in a K&R region, this might be the start
 		    ;; of a parameter declaration, not the actual function.
+		    ;; It might also leave us at a label or "label" like
+		    ;; "private:".
 		    (and least-enclosing ; LIMIT for c-b-of-decl-1
 			 (c-safe-position least-enclosing paren-state)))))
 
 	;; Has the declaration we've gone back to got braces?
-	(setq brace-decl-p
-	      (save-excursion
+	(or (eq decl-result 'label)
+	    (setq brace-decl-p
+		  (save-excursion
 		    (and (c-syntactic-re-search-forward "[;{]" nil t t)
 			 (or (eq (char-before) ?\{)
 			     (and c-recognize-knr-p
@@ -1428,10 +1435,11 @@ No indentation or other \"electric\" beh
 				  ;; ';' in a K&R argdecl.  In
 				  ;; that case the declaration
 				  ;; should contain a block.
-				  (c-in-knr-argdecl))))))
+				  (c-in-knr-argdecl)))))))
 
 	(cond
-	 ((= (point) kluge-start)	; might be BOB or unbalanced parens.
+	 ((or (eq decl-result 'label)	; e.g. "private:" or invalid syntax.
+	      (= (point) kluge-start))	; might be BOB or unbalanced parens.
 	  'outwith-function)
 	 ((eq decl-result 'same)
 	  (if brace-decl-p
@@ -1567,7 +1575,7 @@ Every top level declaration that contain
 considered to be a defun.
 
 With a positive argument, move backward that many defuns.  A negative
-argument -N means move forward to the Nth following beginning.  Return
+argument -N means move forward to the Nth following beginning.	Return
 t unless search stops due to beginning or end of buffer.
 
 Unlike the built-in `beginning-of-defun' this tries to be smarter
@@ -1577,11 +1585,6 @@ defun."
   (interactive "p")
   (or arg (setq arg 1))
 
-  (or (not (eq this-command 'c-beginning-of-defun))
-      (eq last-command 'c-beginning-of-defun)
-      (and transient-mark-mode mark-active)
-      (push-mark))
-
   (c-save-buffer-state
       (beginning-of-defun-function end-of-defun-function
        (start (point))
@@ -1647,7 +1650,7 @@ defun."
 	(= arg 0)))))
 
 (defun c-forward-to-nth-EOF-} (n where)
-  ;; Skip to the closing brace of the Nth function after point.  If
+  ;; Skip to the closing brace of the Nth function after point.	 If
   ;; point is inside a function, this counts as the first.  Point must be
   ;; outside any comment/string or macro.
   ;;
@@ -1683,7 +1686,7 @@ defun."
   ;; Each time round the loop, go forward to a "}" at the outermost level.
   (while (and (> n 0) (not (eobp)))
 					;(c-parse-state)	; This call speeds up the following one by a factor
-					; of ~6.  Hmmm.  2006/4/5.
+					; of ~6.  Hmmm.	 2006/4/5.
     (when (c-syntactic-re-search-forward "{" nil 'eob)
       (backward-char)
       (forward-sexp))
@@ -1701,11 +1704,6 @@ the open-parenthesis that starts a defun
   (interactive "p")
   (or arg (setq arg 1))
 
-  (or (not (eq this-command 'c-end-of-defun))
-      (eq last-command 'c-end-of-defun)
-      (and transient-mark-mode mark-active)
-      (push-mark))
-
   (c-save-buffer-state
       (beginning-of-defun-function end-of-defun-function
        (start (point))
@@ -1747,7 +1745,7 @@ the open-parenthesis that starts a defun
 
       ;; Do we need to move forward from the brace to the semicolon?
       (when (eq arg 0)
-	(if (c-in-function-trailer-p) ; after "}" of struct/enum, etc.
+	(if (c-in-function-trailer-p)	; after "}" of struct/enum, etc.
 	    (c-syntactic-re-search-forward ";"))
 
 	(setq pos (point))
@@ -1807,9 +1805,9 @@ with a brace block."
 	      (looking-at c-symbol-key))
 	    (match-string-no-properties 0))
 
-	   ((looking-at "DEFUN\\_>")
+	   ((looking-at "DEFUN\\s-*(") ;"DEFUN\\_>") think of XEmacs!
 	    ;; DEFUN ("file-name-directory", Ffile_name_directory, Sfile_name_directory, ...) ==> Ffile_name_directory
-	    ;; DEFUN(POSIX::STREAM-LOCK, stream lockp &key BLOCK SHARED START LENGTH) ==> POSIX::STREAM-LOCK
+	    ;; DEFUN(POSIX::STREAM-LOCK, stream lockp &key BLOCK SHARED START LENGTH) ==> POSIX::STREAM-LOCK	  
 	    (down-list 1)
 	    (c-forward-syntactic-ws)
 	    (when (eq (char-after) ?\")
@@ -1819,27 +1817,9 @@ with a brace block."
 	     (point)
 	     (progn
 	       (c-forward-token-2)
-	       (when (looking-at ":")  ; CLISP: DEFUN(PACKAGE:LISP-SYMBOL,...)
-		 (skip-chars-forward "^,"))
 	       (c-backward-syntactic-ws)
 	       (point))))
-
-	   ((looking-at "DEF[a-zA-Z0-9_]* *( *\\([^, ]*\\) *,")
-	    ;; DEFCHECKER(sysconf_arg,prefix=_SC,default=, ...) ==> sysconf_arg
-	    ;; DEFFLAGSET(syslog_opt_flags,LOG_PID ...) ==> syslog_opt_flags
-	    (match-string-no-properties 1))
-
-	   ;; Objc selectors.
-	   ((assq 'objc-method-intro (c-guess-basic-syntax))
-	    (let ((bound (save-excursion (c-end-of-statement) (point)))
-		  (kw-re (concat "\\(?:" c-symbol-key "\\)?:"))
-		  (stretches))
-	      (when (c-syntactic-re-search-forward c-symbol-key bound t t t)
-		(push (match-string-no-properties 0) stretches)
-		(while (c-syntactic-re-search-forward kw-re bound t t t)
-		  (push (match-string-no-properties 0) stretches)))
-	      (apply 'concat (nreverse stretches))))
-
+		
 	   (t
 	    ;; Normal function or initializer.
 	    (when (c-syntactic-re-search-forward "[{(]" nil t)
@@ -1856,7 +1836,7 @@ with a brace block."
   ;; Return a cons of the beginning and end positions of the current
   ;; top level declaration or macro.  If point is not inside any then
   ;; nil is returned, unless NEAR is non-nil in which case the closest
-  ;; following one is chosen instead (if there is any).  The end
+  ;; following one is chosen instead (if there is any).	 The end
   ;; position is at the next line, providing there is one before the
   ;; declaration.
   ;;
@@ -1867,104 +1847,104 @@ with a brace block."
 	(c-narrow-to-most-enclosing-decl-block t)  ; e.g. class, namespace
 	(or (save-restriction
 	      (c-narrow-to-most-enclosing-decl-block nil)
-
-    ;; Note: Some code duplication in `c-beginning-of-defun' and
-    ;; `c-end-of-defun'.
-    (catch 'exit
-      (let ((start (point))
-	    (paren-state (c-parse-state))
-	    lim pos end-pos)
-	(unless (c-safe
-		  (goto-char (c-least-enclosing-brace paren-state))
+      
+	      ;; Note: Some code duplication in `c-beginning-of-defun' and
+	      ;; `c-end-of-defun'.
+	      (catch 'exit
+		(let ((start (point))
+		      (paren-state (c-parse-state))
+		      lim pos end-pos)
+		  (unless (c-safe
+			    (goto-char (c-least-enclosing-brace paren-state))
 			    ;; If we moved to the outermost enclosing paren
 			    ;; then we can use c-safe-position to set the
 			    ;; limit. Can't do that otherwise since the
 			    ;; earlier paren pair on paren-state might very
 			    ;; well be part of the declaration we should go
 			    ;; to.
-		  (setq lim (c-safe-position (point) paren-state))
-		  t)
-	  ;; At top level.  Make sure we aren't inside a literal.
-	  (setq pos (c-literal-limits
-		     (c-safe-position (point) paren-state)))
-	  (if pos (goto-char (car pos))))
-
-	(when (c-beginning-of-macro)
-	  (throw 'exit
-		 (cons (point)
-		       (save-excursion
-			 (c-end-of-macro)
-			 (forward-line 1)
-			 (point)))))
-
-	(setq pos (point))
-	(when (or (eq (car (c-beginning-of-decl-1 lim)) 'previous)
-		  (= pos (point)))
-	  ;; We moved back over the previous defun.  Skip to the next
-	  ;; one.  Not using c-forward-syntactic-ws here since we
-	  ;; should not skip a macro.  We can also be directly after
-	  ;; the block in a `c-opt-block-decls-with-vars-key'
-	  ;; declaration, but then we won't move significantly far
-	  ;; here.
-	  (goto-char pos)
-	  (c-forward-comments)
-
-	  (when (and near (c-beginning-of-macro))
-	    (throw 'exit
-		   (cons (point)
-			 (save-excursion
-			   (c-end-of-macro)
-			   (forward-line 1)
-			   (point))))))
-
-	(if (eobp) (throw 'exit nil))
-
-	;; Check if `c-beginning-of-decl-1' put us after the block in a
-	;; declaration that doesn't end there.  We're searching back and
-	;; forth over the block here, which can be expensive.
-	(setq pos (point))
-	(if (and c-opt-block-decls-with-vars-key
-		 (progn
-		   (c-backward-syntactic-ws)
-		   (eq (char-before) ?}))
-		 (eq (car (c-beginning-of-decl-1))
-		     'previous)
-		 (save-excursion
-		   (c-end-of-decl-1)
-		   (and (> (point) pos)
-			(setq end-pos (point)))))
-	    nil
-	  (goto-char pos))
-
-	(if (and (not near) (> (point) start))
-	    nil
+			    (setq lim (c-safe-position (point) paren-state))
+			    t)
+		    ;; At top level.  Make sure we aren't inside a literal.
+		    (setq pos (c-literal-limits
+			       (c-safe-position (point) paren-state)))
+		    (if pos (goto-char (car pos))))
+
+		  (when (c-beginning-of-macro)
+		    (throw 'exit
+			   (cons (point)
+				 (save-excursion
+				   (c-end-of-macro)
+				   (forward-line 1)
+				   (point)))))
 
-	  ;; Try to be line oriented; position the limits at the
-	  ;; closest preceding boi, and after the next newline, that
-	  ;; isn't inside a comment, but if we hit a neighboring
-	  ;; declaration then we instead use the exact declaration
-	  ;; limit in that direction.
-	  (cons (progn
 		  (setq pos (point))
-		  (while (and (/= (point) (c-point 'boi))
-			      (c-backward-single-comment)))
-		  (if (/= (point) (c-point 'boi))
-		      pos
-		    (point)))
-		(progn
-		  (if end-pos
-		      (goto-char end-pos)
-		    (c-end-of-decl-1))
+		  (when (or (eq (car (c-beginning-of-decl-1 lim)) 'previous)
+			    (= pos (point)))
+		    ;; We moved back over the previous defun.  Skip to the next
+		    ;; one.  Not using c-forward-syntactic-ws here since we
+		    ;; should not skip a macro.  We can also be directly after
+		    ;; the block in a `c-opt-block-decls-with-vars-key'
+		    ;; declaration, but then we won't move significantly far
+		    ;; here.
+		    (goto-char pos)
+		    (c-forward-comments)
+
+		    (when (and near (c-beginning-of-macro))
+		      (throw 'exit
+			     (cons (point)
+				   (save-excursion
+				     (c-end-of-macro)
+				     (forward-line 1)
+				     (point))))))
+
+		  (if (eobp) (throw 'exit nil))
+
+		  ;; Check if `c-beginning-of-decl-1' put us after the block in a
+		  ;; declaration that doesn't end there.	We're searching back and
+		  ;; forth over the block here, which can be expensive.
 		  (setq pos (point))
-		  (while (and (not (bolp))
-			      (not (looking-at "\\s *$"))
-			      (c-forward-single-comment)))
-		  (cond ((bolp)
-			 (point))
-			((looking-at "\\s *$")
-			 (forward-line 1)
-			 (point))
-			(t
+		  (if (and c-opt-block-decls-with-vars-key
+			   (progn
+			     (c-backward-syntactic-ws)
+			     (eq (char-before) ?}))
+			   (eq (car (c-beginning-of-decl-1))
+			       'previous)
+			   (save-excursion
+			     (c-end-of-decl-1)
+			     (and (> (point) pos)
+				  (setq end-pos (point)))))
+		      nil
+		    (goto-char pos))
+
+		  (if (and (not near) (> (point) start))
+		      nil
+
+		    ;; Try to be line oriented; position the limits at the
+		    ;; closest preceding boi, and after the next newline, that
+		    ;; isn't inside a comment, but if we hit a neighboring
+		    ;; declaration then we instead use the exact declaration
+		    ;; limit in that direction.
+		    (cons (progn
+			    (setq pos (point))
+			    (while (and (/= (point) (c-point 'boi))
+					(c-backward-single-comment)))
+			    (if (/= (point) (c-point 'boi))
+				pos
+			      (point)))
+			  (progn
+			    (if end-pos
+				(goto-char end-pos)
+			      (c-end-of-decl-1))
+			    (setq pos (point))
+			    (while (and (not (bolp))
+					(not (looking-at "\\s *$"))
+					(c-forward-single-comment)))
+			    (cond ((bolp)
+				   (point))
+				  ((looking-at "\\s *$")
+				   (forward-line 1)
+				   (point))
+				  (t
 				   pos))))))))
 	    (and (not near)
 		 (goto-char (point-min))
@@ -1978,11 +1958,13 @@ If point is not inside any then the clos
 chosen.  Each successive call of this command extends the marked
 region by one function.
 
-A mark is left where the command started, unless the region is already active
-\(in Transient Mark mode).
+A mark is left where the command started.
 
 As opposed to \\[c-beginning-of-defun] and \\[c-end-of-defun], this
 function does not require the declaration to contain a brace block."
+  ;; Middle sentence of doc-string was: A mark is left where the command
+  ;; started, unless the region is already active \(in Transient Mark mode).
+  ;; FIXME!!!  for transient-mark/zemacs sometime.  (2012-03-08.)
   (interactive)
 
   (let (decl-limits case-fold-search)
@@ -2000,7 +1982,9 @@ function does not require the declaratio
 		   (eq last-command 'c-mark-function)))
 	     (push-mark-p (and (eq this-command 'c-mark-function)
 			       (not extend-region-p)
-			       (not (and transient-mark-mode mark-active)))))
+			       ;; (not (and transient-mark-mode mark-active))
+			       ;; FIXME!!!, sometime (2012-03-08.)
+			       )))
 	(if push-mark-p (push-mark (point)))
 	(if extend-region-p
 	    (progn
@@ -2027,7 +2011,7 @@ function does not require the declaratio
 
 ;; Movement by statements.
 (defun c-in-comment-line-prefix-p ()
-  ;; Point is within a comment.  Is it also within a comment-prefix?
+  ;; Point is within a comment.	 Is it also within a comment-prefix?
   ;; Space at BOL which precedes a comment-prefix counts as part of it.
   ;;
   ;; This function might do hidden buffer changes.
@@ -2044,8 +2028,8 @@ function does not require the declaratio
   ;; follows:
   ;;
   ;; A c-style block comment has its opening "/*" and its closing "*/" (if
-  ;; present) removed.  A c++-style line comment retains its opening "//" but
-  ;; has any final NL removed.  If POINT is currently outwith these innards,
+  ;; present) removed.	A c++-style line comment retains its opening "//" but
+  ;; has any final NL removed.	If POINT is currently outwith these innards,
   ;; move it to the appropriate boundary.
   ;;
   ;; This narrowing simplifies the sentence movement functions, since it
@@ -2089,7 +2073,7 @@ function does not require the declaratio
 	(c-narrow-to-comment-innards range) ; This may move point back.
 	(let* ((here (point))
 	       last
-	       (here-filler	   ; matches WS and comment-prefixes at point.
+	       (here-filler	   ; matches WS and comment-prefices at point.
 		(concat "\\=\\(^[ \t]*\\(" c-current-comment-prefix "\\)"
 			"\\|[ \t\n\r\f]\\)*"))
 	       (prefix-at-bol-here ; matches WS and prefix at BOL, just before point
@@ -2109,7 +2093,7 @@ function does not require the declaratio
 
 	  ;; Now seek successively earlier sentence ends between PAR-BEG and
 	  ;; HERE, until the "start of sentence" following it is earlier than
-	  ;; HERE, or we hit PAR-BEG.  Beware of comment prefixes!
+	  ;; HERE, or we hit PAR-BEG.  Beware of comment prefices!
 	  (while (and (re-search-backward (c-sentence-end) par-beg 'limit)
 		      (setq last (point))
 		      (goto-char (match-end 0))	; tentative beginning of sentence
@@ -2139,7 +2123,7 @@ function does not require the declaratio
   ;; and return T.
   ;;
   ;; The EOS is just after the non-WS part of the next match of the regexp
-  ;; sentence-end.  Typically, this is just after one of [.!?].  If there is
+  ;; sentence-end.  Typically, this is just after one of [.!?].	 If there is
   ;; no sentence-end match following point, any WS before the end of the
   ;; comment will count as EOS, providing we're not already in it.
   ;;
@@ -2150,7 +2134,7 @@ function does not require the declaratio
   ;; This function might do hidden buffer changes.
   (save-match-data
     (let ((start-point (point))
-	  ;; (lit-type (c-literal-type range))  ; Commented out, 2005/11/23, ACM
+	  ;; (lit-type (c-literal-type range))	; Commented out, 2005/11/23, ACM
 	  )
       (save-restriction
 	(c-narrow-to-comment-innards range) ; This might move point forwards.
@@ -2216,7 +2200,7 @@ function does not require the declaratio
 	   (end (1- (cdr range)))
 	   (here-filler		   ; matches WS and escaped newlines at point.
 	    "\\=\\([ \t\n\r\f]\\|\\\\[\n\r]\\)*")
-	   ;; Enhance paragraph-start and paragraph-separate also to recognize
+	   ;; Enhance paragraph-start and paragraph-separate also to recognise
 	   ;; blank lines terminated by escaped EOLs.  IT MAY WELL BE that
 	   ;; these values should be customizable user options, or something.
 	   (paragraph-start c-string-par-start)
@@ -2242,7 +2226,7 @@ function does not require the declaratio
 		  (or (> (point) end)
 		      (progn
 			(re-search-forward
-			 here-filler end t) ; always succeeds.  Use end rather
+			 here-filler end t) ; always succeeds.	Use end rather
 					; than here, in case point starts
 					; beyond the closing quote.
 			(>= (point) here))))
@@ -2260,7 +2244,7 @@ function does not require the declaratio
   ;; and return T.
   ;;
   ;; The EOS is just after the non-WS part of the next match of the regexp
-  ;; sentence-end.  Typically, this is just after one of [.!?].  If there is
+  ;; sentence-end.  Typically, this is just after one of [.!?].	 If there is
   ;; no sentence-end match following point, any WS before the end of the
   ;; string will count as EOS, providing we're not already in it.
   ;;
@@ -2272,7 +2256,7 @@ function does not require the declaratio
   (save-match-data
     (let* ((here (point))
 	   last
-	   ;; Enhance paragraph-start and paragraph-separate to recognize
+	   ;; Enhance paragraph-start and paragraph-separate to recognise
 	   ;; blank lines terminated by escaped EOLs.
 	   (paragraph-start c-string-par-start)
 	   (paragraph-separate c-string-par-separate)
@@ -2354,7 +2338,7 @@ function does not require the declaratio
 
 (defun c-after-statement-terminator-p () ; Should we pass in LIM here?
   ;; Does point immediately follow a statement "terminator"?  A virtual
-  ;; semicolon is regarded here as such.  So is an opening brace ;-)
+  ;; semicolon is regarded here as such.  So is a an opening brace ;-)
   ;;
   ;; This function might do hidden buffer changes.
   (or (save-excursion
@@ -2366,7 +2350,7 @@ function does not require the declaratio
       (c-at-vsemi-p)
       ;; The following (for macros) is not strict about exactly where we are
       ;; wrt white space at the end of the macro.  Doesn't seem to matter too
-      ;; much.  ACM 2004/3/29.
+      ;; much.	ACM 2004/3/29.
       (let (eom)
 	(save-excursion
 	  (if (c-beginning-of-macro)
@@ -2380,24 +2364,24 @@ function does not require the declaratio
 (defun c-back-over-illiterals (macro-start)
   ;; Move backwards over code which isn't a literal (i.e. comment or string),
   ;; stopping before reaching BOB or a literal or the boundary of a
-  ;; preprocessor statement or the "beginning of a statement".  MACRO-START is
+  ;; preprocessor statement or the "beginning of a statement".	MACRO-START is
   ;; the position of the '#' beginning the current preprocessor directive, or
   ;; NIL if we're not in such.
   ;;
   ;; Return a cons (A.B), where
   ;;   A is NIL if we moved back to a BOS (and know it), T otherwise (we
-  ;;     didn't move, or we hit a literal, or we're not sure about BOS).
+  ;;	 didn't move, or we hit a literal, or we're not sure about BOS).
   ;;   B is MACRO-BOUNDARY if we are about to cross the boundary out of or
-  ;;     into a macro, otherwise LITERAL if we've hit a literal, otherwise NIL
+  ;;	 into a macro, otherwise LITERAL if we've hit a literal, otherwise NIL
   ;;
   ;;   The total collection of returned values is as follows:
-  ;;     (nil . nil): Found a BOS whilst remaining inside the illiterals.
-  ;;     (t . literal): No BOS found: only a comment/string.  We _might_ be at
-  ;;                    a BOS - the caller must check this.
-  ;;     (nil . macro-boundary): only happens with non-nil macro-start.  We've
-  ;;                             moved and reached the opening # of the macro.
-  ;;     (t . macro-boundary): Every other circumstance in which we're at a
-  ;;                           macro-boundary.  We might be at a BOS.
+  ;;	 (nil . nil): Found a BOS whilst remaining inside the illiterals.
+  ;;	 (t . literal): No BOS found: only a comment/string.  We _might_ be at
+  ;;			a BOS - the caller must check this.
+  ;;	 (nil . macro-boundary): only happens with non-nil macro-start.	 We've
+  ;;				 moved and reached the opening # of the macro.
+  ;;	 (t . macro-boundary): Every other circumstance in which we're at a
+  ;;			       macro-boundary.	We might be at a BOS.
   ;;
   ;; Point is left either at the beginning-of-statement, or at the last non-ws
   ;; code before encountering the literal/BOB or macro-boundary.
@@ -2407,8 +2391,8 @@ function does not require the declaratio
   ;; or between two distinct preprocessor commands.
   ;;
   ;; Stop before `{' and after `;', `{', `}' and `};' when not followed by `}'
-  ;; or `)', but on the other side of the syntactic ws.  Move by sexps and
-  ;; move into parens.  Also stop before `#' when it's at boi on a line.
+  ;; or `)', but on the other side of the syntactic ws.	 Move by sexps and
+  ;; move into parens.	Also stop before `#' when it's at boi on a line.
   ;;
   ;; This function might do hidden buffer changes.
   (save-match-data
@@ -2468,7 +2452,7 @@ function does not require the declaratio
 	   ;; BOS.  (N.B. I don't think (eq (point) here) can ever be true
 	   ;; here.  FIXME!!! ACM 2004/3/29)
 	   ((and macro-start (eq (point) macro-start))
- 	    (throw 'done (cons (eq (point) here) 'macro-boundary)))
+	    (throw 'done (cons (eq (point) here) 'macro-boundary)))
 
 	   ;; Stop at token just after "}" or ";".
 	   ((looking-at "[;}]")
@@ -2493,22 +2477,22 @@ function does not require the declaratio
 (defun c-forward-over-illiterals (macro-end allow-early-stop)
   ;; Move forwards over code, stopping before reaching EOB or a literal
   ;; (i.e. a comment/string) or the boundary of a preprocessor statement or
-  ;; the "end of a statement".  MACRO-END is the position of the EOL/EOB which
+  ;; the "end of a statement".	MACRO-END is the position of the EOL/EOB which
   ;; terminates the current preprocessor directive, or NIL if we're not in
   ;; such.
   ;;
   ;; ALLOW-EARLY-STOP is non-nil if it is permissible to return without moving
-  ;; forward at all, should we encounter a `{'.  This is an ugly kludge, but
-  ;; seems unavoidable.  Depending on the context this function is called
+  ;; forward at all, should we encounter a `{'.	 This is an ugly kludge, but
+  ;; seems unavoidable.	 Depending on the context this function is called
   ;; from, we _sometimes_ need to stop there.  Currently (2004/4/3),
   ;; ALLOW-EARLY-STOP is applied only to open braces, not to virtual
   ;; semicolons, or anything else.
   ;;
   ;; Return a cons (A.B), where
   ;;   A is NIL if we moved forward to an EOS, or stay at one (when
-  ;;     ALLOW-EARLY-STOP is set), T otherwise (we hit a literal).
+  ;;	 ALLOW-EARLY-STOP is set), T otherwise (we hit a literal).
   ;;   B is 'MACRO-BOUNDARY if we are about to cross the boundary out of or
-  ;;     into a macro, otherwise 'LITERAL if we've hit a literal, otherwise NIL
+  ;;	 into a macro, otherwise 'LITERAL if we've hit a literal, otherwise NIL
   ;;
   ;; Point is left either after the end-of-statement, or at the last non-ws
   ;; code before encountering the literal, or the # of the preprocessor
@@ -2523,7 +2507,7 @@ function does not require the declaratio
   ;;
   ;; Stop before `{', `}', and `#' when it's at boi on a line, but on the
   ;; other side of the syntactic ws, and after `;', `}' and `};'.  Only
-  ;; stop before `{' if at top level or inside braces, though.  Move by
+  ;; stop before `{' if at top level or inside braces, though.	Move by
   ;; sexps and move into parens.  Also stop at eol of lines with `#' at
   ;; the boi.
   ;;
@@ -2588,13 +2572,12 @@ function does not require the declaratio
 	  (goto-char last)
 	  (throw 'done '(nil . nil)))
 
-	 ;; Stop if we encounter a preprocessor line.  Continue if we
-	 ;; hit a naked #
+	 ;; Stop if we encounter a preprocessor line.  Continue if we hit a naked #
 	 ((and c-opt-cpp-prefix
 	       (not macro-end)
 	       (eq (char-after) ?#)
 	       (= (point) (c-point 'boi)))
-	  (if (= (point) here)          ; Not a macro, therefore naked #.
+	  (if (= (point) here)		; Not a macro, therefore naked #.
 	      (forward-char)
 	    (throw 'done '(t . macro-boundary))))
 
@@ -2640,7 +2623,7 @@ to search for the syntactic context, and
 sentence motion in or near comments and multiline strings.
 
 Note that for use in programs, `c-beginning-of-statement-1' is
-usually better.  It has much better defined semantics than this one,
+usually better.	 It has much better defined semantics than this one,
 which is intended for interactive use, and might therefore change to
 be more \"DWIM:ey\"."
   (interactive (list (prefix-numeric-value current-prefix-arg)
@@ -2701,7 +2684,7 @@ be more \"DWIM:ey\"."
 			  (memq (char-after) '(?\) ?\}))
 			  (and
 			   (car res)
-			   ;; We're at a tentative BOS.  The next form goes
+			   ;; We're at a tentative BOS.	 The next form goes
 			   ;; back over WS looking for an end of previous
 			   ;; statement.
 			   (not (save-excursion
@@ -2710,7 +2693,7 @@ be more \"DWIM:ey\"."
 				    (c-backward-syntactic-ws))
 				  (or (bobp) (c-after-statement-terminator-p)))))))
 		;; Are we about to move backwards into or out of a
-		;; preprocessor command?  If so, locate its beginning.
+		;; preprocessor command?  If so, locate it's beginning.
 		(when (eq (cdr res) 'macro-boundary)
 		  (save-excursion
 		    (beginning-of-line)
@@ -2833,12 +2816,12 @@ sentence motion in or near comments and
    c-electric-lt-gt
    c-electric-colon
    c-electric-paren))
-(put 'c-electric-delete    'delete-selection 'supersede) ; delsel
-(put 'c-electric-delete    'pending-delete   'supersede) ; pending-del
+(put 'c-electric-delete	   'delete-selection 'supersede) ; delsel
+(put 'c-electric-delete	   'pending-delete   'supersede) ; pending-del
 (put 'c-electric-backspace 'delete-selection 'supersede) ; delsel
 (put 'c-electric-backspace 'pending-delete   'supersede) ; pending-del
 (put 'c-electric-delete-forward 'delete-selection 'supersede) ; delsel
-(put 'c-electric-delete-forward 'pending-delete   'supersede) ; pending-del
+(put 'c-electric-delete-forward 'pending-delete	  'supersede) ; pending-del
 
 
 ;; Inserting/indenting comments
@@ -2993,7 +2976,7 @@ A prefix argument acts as a repeat count
 move forward across a preprocessor conditional.
 
 The optional arguments TARGET-DEPTH and WITH-ELSE are historical,
-and have the same meanings as in `c-scan-conditionals'.  If you
+and have the same meanings as in `c-scan-conditionals'.	 If you
 are calling c-forward-conditional from a program, you might want
 to call `c-scan-conditionals' directly instead."
   (interactive "p")
@@ -3008,13 +2991,13 @@ A prefix argument acts as a repeat count
 move backward across a preprocessor conditional.
 
 If there aren't enough conditionals after \(or before) point, an
-error is signaled.
+error is signalled.
 
 \"#elif\" is treated like \"#else\" followed by \"#if\", except that
 the nesting level isn't changed when tracking subconditionals.
 
 The optional arguments TARGET-DEPTH and WITH-ELSE are historical,
-and have the same meanings as in `c-scan-conditionals'.  If you
+and have the same meanings as in `c-scan-conditionals'.	 If you
 are calling c-forward-conditional from a program, you might want
 to call `c-scan-conditionals' directly instead."
   (interactive "p")
@@ -3025,7 +3008,7 @@ to call `c-scan-conditionals' directly i
 (defun c-scan-conditionals (count &optional target-depth with-else)
   "Scan forward across COUNT preprocessor conditionals.
 With a negative argument, scan backward across preprocessor
-conditionals.  Return the end position.  Point is not moved.
+conditionals.  Return the end position.	 Point is not moved.
 
 If there aren't enough preprocessor conditionals, throw an error.
 
@@ -3060,7 +3043,7 @@ are treated as conditional clause limits
 			;; comes at the beginning of a line aside from
 			;; whitespace, search first for a string
 			;; starting with # sign.  Then verify what
-			;; precedes it.  This is faster on account of
+			;; precedes it.	 This is faster on account of
 			;; the fastmap feature of the regexp matcher.
 			(funcall search-function
 				 "#[ \t]*\\(if\\|elif\\|endif\\|else\\)"
@@ -3121,12 +3104,12 @@ are treated as conditional clause limits
 
 If `c-tab-always-indent' is t, always just indent the current line.
 If nil, indent the current line only if point is at the left margin or
-in the line's indentation; otherwise insert some whitespace[*].  If
+in the line's indentation; otherwise insert some whitespace[*].	 If
 other than nil or t, then some whitespace[*] is inserted only within
 literals (comments and strings), but the line is always reindented.
 
 If `c-syntactic-indentation' is t, indentation is done according to
-the syntactic context.  A numeric argument, regardless of its value,
+the syntactic context.	A numeric argument, regardless of its value,
 means indent rigidly all the lines of the expression starting after
 point so that this line becomes properly indented.  The relative
 indentation among the lines of the expression is preserved.
@@ -3330,17 +3313,15 @@ non-nil."
   ;; compiled, e.g. in the menus.
   (c-region-is-active-p))
 
-(defun c-indent-line-or-region (&optional arg region)
-  "Indent active region, current line, or block starting on this line.
-In Transient Mark mode, when the region is active, reindent the region.
-Otherwise, with a prefix argument, rigidly reindent the expression
-starting on the current line.
-Otherwise reindent just the current line."
-  (interactive
-   (list current-prefix-arg (use-region-p)))
-  (if region
+(defun c-indent-line-or-region ()
+  "When the region is active, indent it syntactically.	Otherwise
+indent the current line syntactically."
+  ;; Emacs has a variable called mark-active, XEmacs uses region-active-p
+  (interactive)
+  (if (c-region-is-active-p)
       (c-indent-region (region-beginning) (region-end))
-    (c-indent-command arg)))
+    (c-indent-line)))
+
 
 ;; for progress reporting
 (defvar c-progress-info nil)
@@ -3355,7 +3336,7 @@ Otherwise reindent just the current line
     (message "Indenting region... (this may take a while)"))
    ;; If progress has already been initialized, do nothing. otherwise
    ;; initialize the counter with a vector of:
-   ;;     [start end lastsec context]
+   ;;	  [start end lastsec context]
    (c-progress-info)
    (t (setq c-progress-info (vector start
 				    (save-excursion
@@ -3493,7 +3474,7 @@ command to conveniently insert and align
 		      (setq column (max column bs-col-after-end)))
 		  (goto-char from))
 	      ;; No preceding backslash.  Try to align with one
-	      ;; following the region.  Disregard the backslash at the
+	      ;; following the region.	Disregard the backslash at the
 	      ;; to line since it's likely to be bogus (e.g. when
 	      ;; called from c-newline-and-indent).
 	      (if (numberp bs-col-after-end)
@@ -3642,7 +3623,7 @@ command to conveniently insert and align
 ;; of the text handling to the currently active mode for that
 ;; (e.g. adaptive-fill-mode or filladapt-mode) and do as little as
 ;; possible to make them work correctly wrt the comment and string
-;; separators, one-line paragraphs etc.  Unfortunately, when it comes
+;; separators, one-line paragraphs etc.	 Unfortunately, when it comes
 ;; to it, there's quite a lot of special cases to handle which makes
 ;; the code anything but simple.  The intention is that it will work
 ;; with any well-written text filling package that preserves a fill
@@ -3802,14 +3783,14 @@ command to conveniently insert and align
 		   ;; the prefix really is the empty string.
 		   ;; E.g. this is an unclosed comment:
 		   ;;
-		   ;;     /*
-		   ;;     foo
+		   ;;	  /*
+		   ;;	  foo
 		   ;;
 		   ;; But this is not:
 		   ;;
-		   ;;     /*
-		   ;;       foo
-		   ;;     */
+		   ;;	  /*
+		   ;;	    foo
+		   ;;	  */
 		   ;;
 		   ;; (Looking for the presence of the comment closer
 		   ;; rarely works since it's probably the closer of
@@ -3906,7 +3887,7 @@ command to conveniently insert and align
 	    (or (catch 'found
 		  ;; Search for a line which has text after the prefix
 		  ;; so that we get the proper amount of whitespace
-		  ;; after it.  We start with the current line, then
+		  ;; after it.	We start with the current line, then
 		  ;; search backwards, then forwards.
 
 		  (goto-char prefix-line)
@@ -4027,7 +4008,7 @@ command to conveniently insert and align
 	;; beg and end limit the region to narrow.  end is a marker.
 	beg end
 	;; tmp-pre and tmp-post mark strings that are temporarily
-	;; inserted at the start and end of the region.  tmp-pre is a
+	;; inserted at the start and end of the region.	 tmp-pre is a
 	;; cons of the positions of the prepended string.  tmp-post is
 	;; a marker pointing to the single character of the appended
 	;; string.
@@ -4117,7 +4098,7 @@ command to conveniently insert and align
 			 (eq (char-before (1- end)) ?*)
 			 ;; disallow "/*/"
 			 (> (- (cdr c-lit-limits) (car c-lit-limits)) 3)))
-	      ;; There is a comment ender, and the region includes it.  If
+	      ;; There is a comment ender, and the region includes it.	If
 	      ;; it's on its own line, it stays on its own line.  If it's got
 	      ;; company on the line, it keeps (at least one word of) it.
 	      ;; "=====*/" counts as a comment ender here, but "===== */"
@@ -4133,7 +4114,7 @@ command to conveniently insert and align
 ;		    (or (<= (- (cdr c-lit-limits) 2) (point))
 ; 2010-10-17  Construct removed.
 ;		    (or (< (- (cdr c-lit-limits) 2) (point))
-		    (and
+		    (and 
 		     (search-forward-regexp
 		      (concat "\\=[ \t]*\\(" c-current-comment-prefix "\\)")
 		      (- (cdr c-lit-limits) 2) t)
@@ -4148,8 +4129,8 @@ command to conveniently insert and align
 		;; and the last word either by one or two 'x's (when
 		;; FILL-PARAGRAPH is non-nil), or a row of x's the same width
 		;; as the whitespace (when auto filling), and include it in
-		;; the region.  We'll change them back to whitespace
-		;; afterwards.  The effect of this is to glue the comment
+		;; the region.	We'll change them back to whitespace
+		;; afterwards.	The effect of this is to glue the comment
 		;; ender to the last word in the comment during filling.
 		(let* ((ender-start (save-excursion
 				      (goto-char (cdr c-lit-limits))
@@ -4182,8 +4163,8 @@ command to conveniently insert and align
 						 "\\)[ \t]*\\)"))
 			     (eq ender-start (match-end 0)))
 			;; The comment ender is prefixed by nothing but a
-			;; comment line prefix.  IS THIS POSSIBLE?  (ACM,
-			;; 2006/4/28).  Remove it along with surrounding ws.
+			;; comment line prefix.	 IS THIS POSSIBLE?  (ACM,
+			;; 2006/4/28).	Remove it along with surrounding ws.
 			(setq spaces (- (match-end 1) (match-end 2)))
 		      (goto-char ender-start))
 		    (skip-chars-backward " \t\r\n") ; Surely this can be
@@ -4390,7 +4371,9 @@ Warning: Regexp from `c-comment-prefix-r
 	  (forward-char (- hang-ender-stuck))
 	  (if (or fill-paragraph (not auto-fill-spaces))
 	      (insert-char ?\  hang-ender-stuck t)
-	    (insert auto-fill-spaces))
+	    (insert auto-fill-spaces)
+	    ;; (setq here (- here (- hang-ender-stuck (length auto-fill-spaces))))
+	    )
 	  (delete-char hang-ender-stuck)
 	  (goto-char here))
 	(set-marker tmp-post nil))
@@ -4407,7 +4390,7 @@ details).
 
 If point is inside multiline string literal, fill it.  This currently
 does not respect escaped newlines, except for the special case when it
-is the very first thing in the string.  The intended use for this rule
+is the very first thing in the string.	The intended use for this rule
 is in situations like the following:
 
 char description[] = \"\\
@@ -4454,7 +4437,7 @@ new line is indented according to `c-syn
 
 If a fill prefix is specified, it overrides all the above."
   ;; allow-auto-fill is used from c-context-line-break to allow auto
-  ;; filling to break the line more than once.  Since this function is
+  ;; filling to break the line more than once.	Since this function is
   ;; used from auto-fill itself, that's normally disabled to avoid
   ;; unnecessary recursion.
   (interactive)
@@ -4488,7 +4471,7 @@ If a fill prefix is specified, it overri
 		   (<= (c-point 'bol) (car c-lit-limits)))
 	      ;; The adaptive fill function has generated a prefix, but
 	      ;; we're on the first line in a block comment so it'll be
-	      ;; wrong.  Ignore it to guess a better one below.
+	      ;; wrong.	 Ignore it to guess a better one below.
 	      (setq fill-prefix nil)
 	    (when (and (eq c-lit-type 'c++)
 		       (not (string-match (concat "\\`[ \t]*"
@@ -4539,13 +4522,13 @@ If a fill prefix is specified, it overri
 		 ;; FIXME: This doesn't work well in cases like
 		 ;;
 		 ;; /* Bla bla bla bla bla
-		 ;;         bla bla
+		 ;;	    bla bla
 		 ;;
 		 ;; If point is on the 'B' then the line will be
 		 ;; broken after "Bla b".
 		 ;;
 		 ;; If we have an empty comment, /*   */, the next
-		 ;; lot of code pushes point to the */.  We fix
+		 ;; lot of code pushes point to the */.	 We fix
 		 ;; this by never allowing point to end up to the
 		 ;; right of where it started.
 		 (while (and (< (current-column) (cdr fill))
@@ -4573,7 +4556,7 @@ If a fill prefix is specified, it overri
 		   (insert-and-inherit (car fill))
 		   (if (> (current-column) start-col)
 		       (move-to-column start-col)))) ; can this hit the
-					             ; middle of a TAB?
+						     ; middle of a TAB?
 	     ;; Inside a comment that should be broken.
 	     (let ((comment-start comment-start)
 		   (comment-end comment-end)
@@ -4619,7 +4602,7 @@ If a fill prefix is specified, it overri
 	     (indent-to col))))))
 
 (defalias 'c-comment-line-break-function 'c-indent-new-comment-line)
-(make-obsolete 'c-comment-line-break-function 'c-indent-new-comment-line "21.1")
+(make-obsolete 'c-comment-line-break-function 'c-indent-new-comment-line nil)
 
 ;; advice for indent-new-comment-line for older Emacsen
 (unless (boundp 'comment-line-break-function)
@@ -4643,7 +4626,7 @@ non-empty line instead.
 
 When point is inside the content of a preprocessor directive, a line
 continuation backslash is inserted before the line break and aligned
-appropriately.  The end of the cpp directive doesn't count as inside
+appropriately.	The end of the cpp directive doesn't count as inside
 it.
 
 When point is inside a comment, continue it with the appropriate
@@ -4711,7 +4694,7 @@ inside a preprocessor directive."
 (defun c-context-open-line ()
   "Insert a line break suitable to the context and leave point before it.
 This is the `c-context-line-break' equivalent to `open-line', which is
-normally bound to C-o.  See `c-context-line-break' for the details."
+normally bound to C-o.	See `c-context-line-break' for the details."
   (interactive "*")
   (let ((here (point)))
     (unwind-protect
@@ -4726,4 +4709,5 @@ normally bound to C-o.  See `c-context-l
 
 (cc-provide 'cc-cmds)
 
+;;; arch-tag: bf0611dc-d1f4-449e-9e45-4ec7c6936677
 ;;; cc-cmds.el ends here
--- emacs24-24.3+1.orig/lisp/progmodes/cc-compat.el
+++ emacs24-24.3+1/lisp/progmodes/cc-compat.el
@@ -1,20 +1,22 @@
 ;;; cc-compat.el --- cc-mode compatibility with c-mode.el confusion
 
-;; Copyright (C) 1985, 1987, 1992-2013 Free Software Foundation, Inc.
+;; Copyright (C) 1985, 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+;;   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+;;   2010, 2011   Free Software Foundation, Inc.
 
 ;; Authors:    1998- Martin Stjernholm
 ;;	       1994-1999 Barry A. Warsaw
 ;; Maintainer: bug-cc-mode@gnu.org
 ;; Created:    August 1994, split from cc-mode.el
-;; Keywords:   c languages
-;; Package:    cc-mode
+;; Version:    See cc-mode.el
+;; Keywords:   c languages oop
 
 ;; This file is part of GNU Emacs.
 
-;; GNU Emacs is free software: you can redistribute it and/or modify
+;; GNU Emacs is free software; you can redistribute it and/or modify
 ;; it under the terms of the GNU General Public License as published by
-;; the Free Software Foundation, either version 3 of the License, or
-;; (at your option) any later version.
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
 
 ;; GNU Emacs is distributed in the hope that it will be useful,
 ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -22,7 +24,8 @@
 ;; GNU General Public License for more details.
 
 ;; You should have received a copy of the GNU General Public License
-;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
+;; along with this program; see the file COPYING.  If not, see
+;; <http://www.gnu.org/licenses/>.
 
 ;;; Commentary:
 ;;
@@ -59,8 +62,6 @@
 ;; In case c-mode.el isn't loaded
 (defvar c-indent-level 2
   "*Indentation of C statements with respect to containing block.")
-;;;###autoload(put 'c-indent-level 'safe-local-variable 'integerp)
-
 (defvar c-brace-imaginary-offset 0
   "*Imagined indentation of a C open brace that actually follows a statement.")
 (defvar c-brace-offset 0
@@ -161,4 +162,5 @@ This is in addition to c-continued-state
 
 (cc-provide 'cc-compat)
 
+;;; arch-tag: 564dab2f-e6ad-499c-a4a3-fedec3ecc192
 ;;; cc-compat.el ends here
--- emacs24-24.3+1.orig/lisp/progmodes/cc-defs.el
+++ emacs24-24.3+1/lisp/progmodes/cc-defs.el
@@ -1,32 +1,34 @@
 ;;; cc-defs.el --- compile time definitions for CC Mode
 
-;; Copyright (C) 1985, 1987, 1992-2013 Free Software Foundation, Inc.
+;; Copyright (C) 1985, 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+;;   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+;;   2010, 2011   Free Software Foundation, Inc.
 
 ;; Authors:    2003- Alan Mackenzie
-;;             1998- Martin Stjernholm
-;;             1992-1999 Barry A. Warsaw
-;;             1987 Dave Detlefs
-;;             1987 Stewart Clamen
-;;             1985 Richard M. Stallman
+;;	       1998- Martin Stjernholm
+;;	       1992-1999 Barry A. Warsaw
+;;	       1987 Dave Detlefs and Stewart Clamen
+;;	       1985 Richard M. Stallman
 ;; Maintainer: bug-cc-mode@gnu.org
 ;; Created:    22-Apr-1997 (split from cc-mode.el)
-;; Keywords:   c languages
-;; Package:    cc-mode
+;; Version:    See cc-mode.el
+;; Keywords:   c languages oop
 
 ;; This file is part of GNU Emacs.
 
-;; GNU Emacs is free software: you can redistribute it and/or modify
+;; GNU Emacs is free software; you can redistribute it and/or modify
 ;; it under the terms of the GNU General Public License as published by
-;; the Free Software Foundation, either version 3 of the License, or
-;; (at your option) any later version.
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
 
 ;; GNU Emacs is distributed in the hope that it will be useful,
 ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
 ;; GNU General Public License for more details.
 
 ;; You should have received a copy of the GNU General Public License
-;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
+;; along with this program; see the file COPYING.  If not, see
+;; <http://www.gnu.org/licenses/>.
 
 ;;; Commentary:
 
@@ -43,7 +45,7 @@
 	   load-path)))
     (load "cc-bytecomp" nil t)))
 
-(eval-when-compile (require 'cl)) ; was (cc-external-require 'cl).  ACM 2005/11/29.
+(cc-external-require 'cl)
 (cc-external-require 'regexp-opt)
 
 ;; Silence the compiler.
@@ -68,15 +70,14 @@
 	  (not (fboundp 'push)))
       (cc-load "cc-fix")))
 
-; (eval-after-load "font-lock"  ; 2006-07-09.  font-lock is now preloaded
-;   '
-(if (and (featurep 'xemacs)	; There is now (2005/12) code in GNU Emacs CVS
-				; to make the call to f-l-c-k throw an error.
-	 (not (featurep 'cc-fix)) ; only load the file once.
-	 (let (font-lock-keywords)
-	   (font-lock-compile-keywords '("\\<\\>"))
-	   font-lock-keywords))     ; did the previous call foul this up?
-    (load "cc-fix")) ;)
+(eval-after-load "font-lock"
+  '(if (and (not (featurep 'cc-fix)) ; only load the file once.
+	    (featurep 'xemacs) ; There is now (2005/12) code in GNU Emacs CVS
+			       ; to make the call to f-l-c-k throw an error.
+	    (let (font-lock-keywords)
+	      (font-lock-compile-keywords '("\\<\\>"))
+	      font-lock-keywords))     ; did the previous call foul this up?
+       (load "cc-fix")))
 
 ;; The above takes care of the delayed loading, but this is necessary
 ;; to ensure correct byte compilation.
@@ -90,10 +91,15 @@
 	       font-lock-keywords)))
       (cc-load "cc-fix")))
 
+;; XEmacs 21.4 doesn't have `delete-dups'.
+(eval-and-compile
+  (if (and (not (fboundp 'delete-dups))
+	   (not (featurep 'cc-fix)))
+      (cc-load "cc-fix")))
 
 ;;; Variables also used at compile time.
 
-(defconst c-version "5.32.4"
+(defconst c-version "5.33"
   "CC Mode version number.")
 
 (defconst c-version-sym (intern c-version))
@@ -104,7 +110,7 @@
 Otherwise, this variable is nil.  I.e. this variable is non-nil for
 `c-mode', `c++-mode', `objc-mode', `java-mode', `idl-mode',
 `pike-mode', `awk-mode', and any other non-CC Mode mode that calls
-`c-initialize-cc-mode'.  The value is the mode symbol itself
+`c-initialize-cc-mode'.	 The value is the mode symbol itself
 \(i.e. `c-mode' etc) of the original CC Mode mode, or just t if it's
 not known.")
 (make-variable-buffer-local 'c-buffer-is-cc-mode)
@@ -128,13 +134,13 @@ This variant works around bugs in `eval-
     (if c-inside-eval-when-compile
 	;; XEmacs 21.4.6 has a bug in `eval-when-compile' in that it
 	;; evaluates its body at macro expansion time if it's nested
-	;; inside another `eval-when-compile'.  So we use a dynamically
+	;; inside another `eval-when-compile'.	So we use a dynamically
 	;; bound variable to avoid nesting them.
 	`(progn ,@body)
 
       `(eval-when-compile
 	 ;; In all (X)Emacsen so far, `eval-when-compile' byte compiles
-	 ;; its contents before evaluating it.  That can cause forms to
+	 ;; its contents before evaluating it.	That can cause forms to
 	 ;; be compiled in situations they aren't intended to be
 	 ;; compiled.
 	 ;;
@@ -143,19 +149,19 @@ This variant works around bugs in `eval-
 	 ;; `nthcdr' is a primitive function that's handled specially by
 	 ;; the byte compiler and thus can't be redefined:
 	 ;;
-	 ;;     (defsubst nthcdr (val) val)
+	 ;;	(defsubst nthcdr (val) val)
 	 ;;
 	 ;; `defsubst', like `defmacro', needs to be evaluated at
 	 ;; compile time, so this will produce an error during byte
 	 ;; compilation.
 	 ;;
 	 ;; CC Mode occasionally needs to do things like this for
-	 ;; cross-emacs compatibility.  It therefore uses the following
+	 ;; cross-emacs compatibility.	It therefore uses the following
 	 ;; to conditionally do a `defsubst':
 	 ;;
-	 ;;     (eval-when-compile
-	 ;;       (if (not (fboundp 'foo))
-	 ;;           (defsubst foo ...)))
+	 ;;	(eval-when-compile
+	 ;;	  (if (not (fboundp 'foo))
+	 ;;	      (defsubst foo ...)))
 	 ;;
 	 ;; But `eval-when-compile' byte compiles its contents and
 	 ;; _then_ evaluates it (in all current emacs versions, up to
@@ -181,17 +187,17 @@ This variant works around bugs in `eval-
 The current point is used if POINT isn't specified.  POSITION can be
 one of the following symbols:
 
-`bol'   -- beginning of line
-`eol'   -- end of line
-`bod'   -- beginning of defun
-`eod'   -- end of defun
-`boi'   -- beginning of indentation
-`ionl'  -- indentation of next line
-`iopl'  -- indentation of previous line
-`bonl'  -- beginning of next line
-`eonl'  -- end of next line
-`bopl'  -- beginning of previous line
-`eopl'  -- end of previous line
+`bol'	-- beginning of line
+`eol'	-- end of line
+`bod'	-- beginning of defun
+`eod'	-- end of defun
+`boi'	-- beginning of indentation
+`ionl'	-- indentation of next line
+`iopl'	-- indentation of previous line
+`bonl'	-- beginning of next line
+`eonl'	-- end of next line
+`bopl'	-- beginning of previous line
+`eopl'	-- end of previous line
 `bosws' -- beginning of syntactic whitespace
 `eosws' -- end of syntactic whitespace
 
@@ -331,18 +337,27 @@ to it is returned.  This function does n
 	  (t (error "Unknown buffer position requested: %s" position))))
        (point))))
 
+(defmacro c-next-single-property-change (position prop &optional object limit)
+  ;; See the doc string for either of the defuns expanded to.
+  (if (and c-use-extents
+	   (fboundp 'next-single-char-property-change))
+      ;; XEmacs >= 2005-01-25
+      `(next-single-char-property-change ,position ,prop ,object ,limit)
+    ;; Emacs and earlier XEmacs
+    `(next-single-property-change ,position ,prop ,object ,limit)))
+
 (defmacro c-region-is-active-p ()
   ;; Return t when the region is active.  The determination of region
   ;; activeness is different in both Emacs and XEmacs.
-  (if (cc-bytecomp-boundp 'mark-active)
-      ;; Emacs.
-      'mark-active
-    ;; XEmacs.
-    '(region-active-p)))
+  (if (cc-bytecomp-fboundp 'region-active-p)
+      ;; XEmacs.
+      '(region-active-p)
+    ;; Emacs.
+    'mark-active))
 
 (defmacro c-set-region-active (activate)
   ;; Activate the region if ACTIVE is non-nil, deactivate it
-  ;; otherwise.  Covers the differences between Emacs and XEmacs.
+  ;; otherwise.	 Covers the differences between Emacs and XEmacs.
   (if (cc-bytecomp-fboundp 'zmacs-activate-region)
       ;; XEmacs.
       `(if ,activate
@@ -369,13 +384,20 @@ to it is returned.  This function does n
 (put 'c-safe 'lisp-indent-function 0)
 
 (defmacro c-int-to-char (integer)
-  ;; In Emacs, a character is an integer.  In XEmacs, a character is a
+  ;; In GNU Emacs, a character is an integer.  In XEmacs, a character is a
   ;; type distinct from an integer.  Sometimes we need to convert integers to
   ;; characters.  `c-int-to-char' makes this conversion, if necessary.
   (if (fboundp 'int-to-char)
       `(int-to-char ,integer)
     integer))
 
+(defmacro c-last-command-char ()
+  ;; The last character just typed.  Note that `last-command-event' exists in
+  ;; both Emacs and XEmacs, but with confusingly different meanings.
+  (if (featurep 'xemacs)
+      'last-command-char
+    'last-command-event))
+
 (defmacro c-sentence-end ()
   ;; Get the regular expression `sentence-end'.
   (if (cc-bytecomp-fboundp 'sentence-end)
@@ -405,7 +427,7 @@ properties to be changed, even in a read
 
 This macro should be placed around all calculations which set
 \"insignificant\" text properties in a buffer, even when the buffer is
-known to be writable.  That way, these text properties remain set
+known to be writeable.	That way, these text properties remain set
 even if the user undoes the command which set them.
 
 This macro should ALWAYS be placed around \"temporary\" internal buffer
@@ -473,7 +495,7 @@ various buffer change hooks."
 
   (let ((saved-undo-list (elt saved-state 0)))
     (if (eq buffer-undo-list saved-undo-list)
-	;; No change was done after all.
+	;; No change was done afterall.
 	(setq buffer-undo-list (cdr saved-undo-list))
 
       (if keep
@@ -510,7 +532,7 @@ LIMIT sets an upper limit of the forward
 LIMIT or the end of the buffer is reached inside a comment or
 preprocessor directive, the point will be left there.
 
-Note that this function might do hidden buffer changes.  See the
+Note that this function might do hidden buffer changes.	 See the
 comment at the start of cc-engine.el for more info."
   (if limit
       `(save-restriction
@@ -529,7 +551,7 @@ LIMIT sets a lower limit of the backward
 LIMIT is reached inside a line comment or preprocessor directive then
 the point is moved into it past the whitespace at the end.
 
-Note that this function might do hidden buffer changes.  See the
+Note that this function might do hidden buffer changes.	 See the
 comment at the start of cc-engine.el for more info."
   (if limit
       `(save-restriction
@@ -555,7 +577,7 @@ certain situations."
   `(c-forward-sexp ,(if (numberp count) (- count) `(- ,count))))
 
 (defmacro c-safe-scan-lists (from count depth &optional limit)
-  "Like `scan-lists' but returns nil instead of signaling errors
+  "Like `scan-lists' but returns nil instead of signalling errors
 for unbalanced parens.
 
 A limit for the search may be given.  FROM is assumed to be on the
@@ -582,7 +604,7 @@ right side of it."
 (defmacro c-go-list-forward ()
   "Move backward across one balanced group of parentheses.
 
-Return POINT when we succeed, NIL when we fail.  In the latter case, leave
+Return POINT when we succeed, NIL when we fail.	 In the latter case, leave
 point unmoved."
   `(c-safe (let ((endpos (scan-lists (point) 1 0)))
 	     (goto-char endpos)
@@ -591,7 +613,7 @@ point unmoved."
 (defmacro c-go-list-backward ()
   "Move backward across one balanced group of parentheses.
 
-Return POINT when we succeed, NIL when we fail.  In the latter case, leave
+Return POINT when we succeed, NIL when we fail.	 In the latter case, leave
 point unmoved."
   `(c-safe (let ((endpos (scan-lists (point) -1 0)))
 	     (goto-char endpos)
@@ -659,7 +681,7 @@ be after it."
 
 (defmacro c-go-down-list-forward (&optional pos limit)
   "Move the point to the first position inside the first list sexp after POS,
-or before the point if POS is left out.  Return t if such a position
+or before the point if POS is left out.	 Return t if such a position
 exists, otherwise nil is returned and the point isn't moved.
 
 A limit for the search may be given.  The start position is assumed to
@@ -673,7 +695,7 @@ be before it."
 
 (defmacro c-go-down-list-backward (&optional pos limit)
   "Move the point to the last position inside the last list sexp before POS,
-or before the point if POS is left out.  Return t if such a position
+or before the point if POS is left out.	 Return t if such a position
 exists, otherwise nil is returned and the point isn't moved.
 
 A limit for the search may be given.  The start position is assumed to
@@ -705,7 +727,7 @@ be after it."
 	 ,(when (cc-bytecomp-fboundp 'buffer-syntactic-context-depth)
 	    ;; XEmacs only.  This can improve the performance of
 	    ;; c-parse-state to between 3 and 60 times faster when
-	    ;; braces are hung.  It can also degrade performance by
+	    ;; braces are hung.	 It can also degrade performance by
 	    ;; about as much when braces are not hung.
 	    '(let (beginning-of-defun-function end-of-defun-function
 					       pos)
@@ -760,21 +782,21 @@ be after it."
 ;; non-nil if point (or the optional parameter POS) is at a VS, nil otherwise.
 ;;
 ;; The language specific function might well do extensive analysis of the
-;; source text, and may use a caching scheme to speed up repeated calls.
+;; source text, and may use a cacheing scheme to speed up repeated calls.
 ;;
 ;; The "virtual semicolon" lies just after the last non-ws token on the line.
-;; Like POINT, it is considered to lie between two characters.  For example,
+;; Like POINT, it is considered to lie between two characters.	For example,
 ;; at the place shown in the following AWK source line:
 ;;
-;;          kbyte = 1024             # 1000 if you're not picky
-;;                      ^
-;;                      |
-;;              Virtual Semicolon
+;;	    kbyte = 1024	     # 1000 if you're not picky
+;;			^
+;;			|
+;;		Virtual Semicolon
 ;;
 ;; In addition to `c-at-vsemi-p-fn', a mode may need to supply a function for
 ;; `c-vsemi-status-unknown-p-fn'.  The macro `c-vsemi-status-unknown-p' is a
 ;; rather recondite kludge.  It exists because the function
-;; `c-beginning-of-statement-1' sometimes tests for VSs as an optimization,
+;; `c-beginning-of-statement-1' sometimes tests for VSs as an optimisation,
 ;; but `c-at-vsemi-p' might well need to call `c-beginning-of-statement-1' in
 ;; its calculations, thus potentially leading to infinite recursion.
 ;;
@@ -784,7 +806,7 @@ be after it."
 ;; `c-beginning-of-statement-1'.  `c-vsemi-status-unknown-p' may not itself
 ;; call `c-beginning-of-statement-1'.
 ;;
-;; The macro `c-vsemi-status-unknown-p' will typically check the caching
+;; The macro `c-vsemi-status-unknown-p' will typically check the cacheing
 ;; scheme used by the `c-at-vsemi-p-fn', hence the name - the status is
 ;; "unknown" if there is no cache entry current for the line.
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@@ -818,6 +840,8 @@ be after it."
 (defmacro c-with-syntax-table (table &rest code)
   ;; Temporarily switches to the specified syntax table in a failsafe
   ;; way to execute code.
+  ;; Maintainers' note: If TABLE is `c++-template-syntax-table', DON'T call
+  ;; any forms inside this that call `c-parse-state'.  !!!!
   `(let ((c-with-syntax-table-orig-table (syntax-table)))
      (unwind-protect
 	 (progn
@@ -906,38 +930,44 @@ MODE is either a mode symbol or a list o
 			       (cc-bytecomp-fboundp 'delete-extent)
 			       (cc-bytecomp-fboundp 'map-extents))))
 
+(defconst c-<-as-paren-syntax '(4 . ?>))
+(put 'c-<-as-paren-syntax 'syntax-table c-<-as-paren-syntax)
+
+(defconst c->-as-paren-syntax '(5 . ?<))
+(put 'c->-as-paren-syntax 'syntax-table c->-as-paren-syntax)
+
 ;; `c-put-char-property' is complex enough in XEmacs and Emacs < 21 to
 ;; make it a function.
-(defalias 'c-put-char-property-fun
-  (cc-eval-when-compile
-    (cond (c-use-extents
-	   ;; XEmacs.
-	   (byte-compile
-	    (lambda (pos property value)
-	      (let ((ext (extent-at pos nil property)))
-		(if ext
-		    (set-extent-property ext property value)
-		  (set-extent-properties (make-extent pos (1+ pos))
-					 (cons property
-					       (cons value
-						     '(start-open t
-						       end-open t)))))))))
-
-	  ((not (cc-bytecomp-boundp 'text-property-default-nonsticky))
-	   ;; In Emacs < 21 we have to mess with the `rear-nonsticky' property.
-	   (byte-compile
-	    (lambda (pos property value)
-	      (put-text-property pos (1+ pos) property value)
-	      (let ((prop (get-text-property pos 'rear-nonsticky)))
-		(or (memq property prop)
-		    (put-text-property pos (1+ pos)
-				       'rear-nonsticky
-				       (cons property prop)))))))
-	  ;; This won't be used for anything.
-	  (t 'ignore))))
+(eval-and-compile
+  (defalias 'c-put-char-property-fun
+    (cc-eval-when-compile
+      (cond (c-use-extents
+	     ;; XEmacs.
+	     (byte-compile
+	      (lambda (pos property value)
+		(let ((ext (extent-at pos nil property)))
+		  (if ext
+		      (set-extent-property ext property value)
+		    (set-extent-properties (make-extent pos (1+ pos))
+					   (cons property
+						 (cons value
+						       '(start-open t
+								    end-open t)))))))))
+
+	    ((not (cc-bytecomp-boundp 'text-property-default-nonsticky))
+	     ;; In Emacs < 21 we have to mess with the `rear-nonsticky' property.
+	     (byte-compile
+	      (lambda (pos property value)
+		(put-text-property pos (1+ pos) property value)
+		(let ((prop (get-text-property pos 'rear-nonsticky)))
+		  (or (memq property prop)
+		      (put-text-property pos (1+ pos)
+					 'rear-nonsticky
+					 (cons property prop)))))))))))
 (cc-bytecomp-defun c-put-char-property-fun) ; Make it known below.
 
-(defmacro c-put-char-property (pos property value)
+(eval-and-compile
+  (defmacro c-put-char-property (pos property value)
   ;; Put the given property with the given value on the character at
   ;; POS and make it front and rear nonsticky, or start and end open
   ;; in XEmacs vocabulary.  If the character already has the given
@@ -957,7 +987,27 @@ MODE is either a mode symbol or a list o
     ;; In Emacs 21 we got the `rear-nonsticky' property covered
     ;; by `text-property-default-nonsticky'.
     `(let ((-pos- ,pos))
-       (put-text-property -pos- (1+ -pos-) ',property ,value))))
+       (put-text-property -pos- (1+ -pos-) ',property ,value)))))
+
+(eval-and-compile
+  ;; Constant to decide at compilation time whether to use category
+  ;; properties.  Currently (2010-03) they're available only on GNU Emacs.
+  (defconst c-use-category
+    (let ((buf (generate-new-buffer " test"))
+	  parse-sexp-lookup-properties lookup-syntax-properties)
+      (prog1
+	  (save-excursion
+	    (set-buffer buf)
+	    (setq parse-sexp-lookup-properties t)
+	    (setq lookup-syntax-properties t)
+	    (set-syntax-table (make-syntax-table))
+	    (insert "<()>")
+	    (c-put-char-property (point-min) 'category 'c-<-as-paren-syntax)
+	    (c-put-char-property (+ 3 (point-min)) 'category 'c->-as-paren-syntax)
+	    (goto-char (point-min))
+	    (forward-sexp)
+	    (= (point) (+ 4 (point-min))))
+	(kill-buffer buf)))))
 
 (defmacro c-get-char-property (pos property)
   ;; Get the value of the given property on the character at POS if
@@ -1009,13 +1059,13 @@ MODE is either a mode symbol or a list o
 	 `(c-clear-char-property-fun ,pos ',property))))
 
 (defmacro c-clear-char-properties (from to property)
-  ;; Remove all the occurrences of the given property in the given
+  ;; Remove all the occurences of the given property in the given
   ;; region that has been put with `c-put-char-property'.  PROPERTY is
   ;; assumed to be constant.
   ;;
   ;; Note that this function does not clean up the property from the
   ;; lists of the `rear-nonsticky' properties in the region, if such
-  ;; are used.  Thus it should not be used for common properties like
+  ;; are used.	Thus it should not be used for common properties like
   ;; `syntax-table'.
   ;;
   ;; This macro does hidden buffer changes.
@@ -1039,8 +1089,8 @@ nil; point is then left undefined."
      (while
 	 (and
 	  (< place ,(or limit '(point-max)))
-	  (not (equal (get-text-property place ,property) ,value)))
-       (setq place (next-single-property-change
+	  (not (equal (c-get-char-property place ,property) ,value)))
+       (setq place (c-next-single-property-change
 		    place ,property nil ,(or limit '(point-max)))))
      (when (< place ,(or limit '(point-max)))
        (goto-char place)
@@ -1058,10 +1108,15 @@ point is then left undefined."
      (while
 	 (and
 	  (> place ,(or limit '(point-min)))
-	  (not (equal (get-text-property (1- place) ,property) ,value)))
-       (setq place (previous-single-property-change
+	  (not (equal (c-get-char-property (1- place) ,property) ,value)))
+       (setq place (,(if (and c-use-extents
+			      (fboundp 'previous-single-char-property-change))
+			 ;; XEmacs > 2005-01-25.
+			 'previous-single-char-property-change
+		       ;; Emacs and earlier XEmacs.
+		       'previous-single-property-change)
 		    place ,property nil ,(or limit '(point-min)))))
-     (when (> place ,(or limit '(point-max)))
+     (when (> place ,(or limit '(point-min)))
        (goto-char place)
        (search-backward-regexp ".")	; to set the match-data.
        (point))))
@@ -1070,17 +1125,17 @@ point is then left undefined."
   "Remove all text-properties PROPERTY from the region (FROM, TO)
 which have the value VALUE, as tested by `equal'.  These
 properties are assumed to be over individual characters, having
-been put there by c-put-char-property.  POINT remains unchanged."
+been put there by c-put-char-property.	POINT remains unchanged."
   (let ((place from) end-place)
-    (while			  ; loop round occurrences of (PROPERTY VALUE)
+    (while			  ; loop round occurrances of (PROPERTY VALUE)
 	(progn
 	  (while	   ; loop round changes in PROPERTY till we find VALUE
 	      (and
 	       (< place to)
 	       (not (equal (get-text-property place property) value)))
-	    (setq place (next-single-property-change place property nil to)))
+	    (setq place (c-next-single-property-change place property nil to)))
 	  (< place to))
-      (setq end-place (next-single-property-change place property nil to))
+      (setq end-place (c-next-single-property-change place property nil to))
       (remove-text-properties place end-place (cons property nil))
       ;; Do we have to do anything with stickiness here?
       (setq place end-place))))
@@ -1089,7 +1144,7 @@ been put there by c-put-char-property.
   "Remove all text-properties PROPERTY from the region [FROM, TO)
 which have the value VALUE, as tested by `equal'.  These
 properties are assumed to be over individual characters, having
-been put there by c-put-char-property.  POINT remains unchanged."
+been put there by c-put-char-property.	POINT remains unchanged."
   (if c-use-extents
     ;; XEmacs
       `(let ((-property- ,property))
@@ -1130,35 +1185,35 @@ been put there by c-put-char-property.
 
 
 ;; Make edebug understand the macros.
-;(eval-after-load "edebug" ; 2006-07-09: def-edebug-spec is now in subr.el.
-;  '(progn
-(def-edebug-spec cc-eval-when-compile t)
-(def-edebug-spec c-point t)
-(def-edebug-spec c-set-region-active t)
-(def-edebug-spec c-safe t)
-(def-edebug-spec c-save-buffer-state let*)
-(def-edebug-spec c-tentative-buffer-changes t)
-(def-edebug-spec c-forward-syntactic-ws t)
-(def-edebug-spec c-backward-syntactic-ws t)
-(def-edebug-spec c-forward-sexp t)
-(def-edebug-spec c-backward-sexp t)
-(def-edebug-spec c-up-list-forward t)
-(def-edebug-spec c-up-list-backward t)
-(def-edebug-spec c-down-list-forward t)
-(def-edebug-spec c-down-list-backward t)
-(def-edebug-spec c-add-syntax t)
-(def-edebug-spec c-add-class-syntax t)
-(def-edebug-spec c-benign-error t)
-(def-edebug-spec c-with-syntax-table t)
-(def-edebug-spec c-skip-ws-forward t)
-(def-edebug-spec c-skip-ws-backward t)
-(def-edebug-spec c-major-mode-is t)
-(def-edebug-spec c-put-char-property t)
-(def-edebug-spec c-get-char-property t)
-(def-edebug-spec c-clear-char-property t)
-(def-edebug-spec c-clear-char-properties t)
-(def-edebug-spec c-put-overlay t)
-(def-edebug-spec c-delete-overlay t) ;))
+(eval-after-load "edebug"
+  '(progn
+     (def-edebug-spec cc-eval-when-compile t)
+     (def-edebug-spec c-point t)
+     (def-edebug-spec c-set-region-active t)
+     (def-edebug-spec c-safe t)
+     (def-edebug-spec c-save-buffer-state let*)
+     (def-edebug-spec c-tentative-buffer-changes t)
+     (def-edebug-spec c-forward-syntactic-ws t)
+     (def-edebug-spec c-backward-syntactic-ws t)
+     (def-edebug-spec c-forward-sexp t)
+     (def-edebug-spec c-backward-sexp t)
+     (def-edebug-spec c-up-list-forward t)
+     (def-edebug-spec c-up-list-backward t)
+     (def-edebug-spec c-down-list-forward t)
+     (def-edebug-spec c-down-list-backward t)
+     (def-edebug-spec c-add-syntax t)
+     (def-edebug-spec c-add-class-syntax t)
+     (def-edebug-spec c-benign-error t)
+     (def-edebug-spec c-with-syntax-table t)
+     (def-edebug-spec c-skip-ws-forward t)
+     (def-edebug-spec c-skip-ws-backward t)
+     (def-edebug-spec c-major-mode-is t)
+     (def-edebug-spec c-put-char-property t)
+     (def-edebug-spec c-get-char-property t)
+     (def-edebug-spec c-clear-char-property t)
+     (def-edebug-spec c-clear-char-properties t)
+     (def-edebug-spec c-put-overlay t)
+     (def-edebug-spec c-delete-overlay t)))
 
 
 ;;; Functions.
@@ -1181,42 +1236,43 @@ been put there by c-put-char-property.
     (if (< (point) start)
 	(goto-char (point-max)))))
 
-(defconst c-<-as-paren-syntax '(4 . ?>))
-(put 'c-<-as-paren-syntax 'syntax-table c-<-as-paren-syntax)
-
-(defsubst c-mark-<-as-paren (pos)
+(defmacro c-mark-<-as-paren (pos)
   ;; Mark the "<" character at POS as a template opener using the
-  ;; `syntax-table' property via the `category' property.
+  ;; `syntax-table' property either directly (XEmacs) or via a `category'
+  ;; property (GNU Emacs).
   ;;
-  ;; This function does a hidden buffer change.  Note that we use
-  ;; indirection through the `category' text property.  This allows us to
+  ;; This function does a hidden buffer change.	 Note that we use
+  ;; indirection through the `category' text property.	This allows us to
   ;; toggle the property in all template brackets simultaneously and
   ;; cheaply.  We use this, for instance, in `c-parse-state'.
-  (c-put-char-property pos 'category 'c-<-as-paren-syntax))
+  (if c-use-category
+      `(c-put-char-property ,pos 'category 'c-<-as-paren-syntax)
+    `(c-put-char-property ,pos 'syntax-table c-<-as-paren-syntax)))
+  
 
-(defconst c->-as-paren-syntax '(5 . ?<))
-(put 'c->-as-paren-syntax 'syntax-table c->-as-paren-syntax)
-
-(defsubst c-mark->-as-paren (pos)
+(defmacro c-mark->-as-paren (pos)
   ;; Mark the ">" character at POS as an sexp list closer using the
-  ;; syntax-table property.
+  ;; `syntax-table' property either directly (XEmacs) or via a `category'
+  ;; property (GNU Emacs).
   ;;
-  ;; This function does a hidden buffer change.  Note that we use
-  ;; indirection through the `category' text property.  This allows us to
+  ;; This function does a hidden buffer change.	 Note that we use
+  ;; indirection through the `category' text property.	This allows us to
   ;; toggle the property in all template brackets simultaneously and
   ;; cheaply.  We use this, for instance, in `c-parse-state'.
-  (c-put-char-property pos 'category 'c->-as-paren-syntax))
-
-(defsubst c-unmark-<->-as-paren (pos)
-  ;; Unmark the "<" or "<" character at POS as an sexp list opener using
-  ;; the syntax-table property indirectly through the `category' text
-  ;; property.
+  (if c-use-category
+      `(c-put-char-property ,pos 'category 'c->-as-paren-syntax)
+    `(c-put-char-property ,pos 'syntax-table c->-as-paren-syntax)))
+
+(defmacro c-unmark-<->-as-paren (pos)
+  ;; Unmark the "<" or "<" character at POS as an sexp list opener using the
+  ;; `syntax-table' property either directly or indirectly through a
+  ;; `category' text property.
   ;;
-  ;; This function does a hidden buffer change.  Note that we use
+  ;; This function does a hidden buffer change.  Note that we try to use
   ;; indirection through the `category' text property.  This allows us to
   ;; toggle the property in all template brackets simultaneously and
   ;; cheaply.  We use this, for instance, in `c-parse-state'.
-  (c-clear-char-property pos 'category))
+  `(c-clear-char-property ,pos ,(if c-use-category ''category ''syntax-table)))
 
 (defsubst c-suppress-<->-as-parens ()
   ;; Suppress the syntactic effect of all marked < and > as parens.  Note
@@ -1234,7 +1290,7 @@ been put there by c-put-char-property.
 
 (defmacro c-with-<->-as-parens-suppressed (&rest forms)
   ;; Like progn, except that the paren property is suppressed on all
-  ;; template brackets whilst they are running.  This macro does a hidden
+  ;; template brackets whilst they are running.	 This macro does a hidden
   ;; buffer change.
   `(unwind-protect
        (progn
@@ -1249,7 +1305,7 @@ been put there by c-put-char-property.
 ;; which introduces a CPP construct and every EOL (or EOB, or character
 ;; preceding //, etc.) which terminates it.  We can instantly "comment
 ;; out" all CPP constructs by giving `c-cpp-delimiter' a syntax-table
-;; property '(14) (generic comment delimiter).
+;; propery '(14) (generic comment delimiter).
 (defmacro c-set-cpp-delimiters (beg end)
   ;; This macro does a hidden buffer change.
   `(progn
@@ -1288,10 +1344,130 @@ been put there by c-put-char-property.
   ;; suppressed.
   `(unwind-protect
        (c-save-buffer-state ()
-	 (c-clear-cpp-delimiters ,beg ,end)
+	 (save-restriction
+	   (widen)
+	   (c-clear-cpp-delimiters ,beg ,end))
 	 ,`(c-with-cpps-commented-out ,@forms))
      (c-save-buffer-state ()
-       (c-set-cpp-delimiters ,beg ,end))))
+       (save-restriction
+	 (widen)
+	 (c-set-cpp-delimiters ,beg ,end)))))
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; The following macros are to be used only in `c-parse-state' and its
+;; subroutines.  Their main purpose is to simplify the handling of C++/Java
+;; template delimiters and CPP macros.  In GNU Emacs, this is done slickly by
+;; the judicious use of 'category properties.  These don't exist in XEmacs.
+;; 
+;; Note: in the following macros, there is no special handling for parentheses
+;; inside CPP constructs.  That is because CPPs are always syntactically
+;; balanced, thanks to `c-neutralize-CPP-line' in cc-mode.el.
+(defmacro c-sc-scan-lists-no-category+1+1 (from)
+  ;; Do a (scan-lists FROM 1 1).  Any finishing position which either (i) is
+  ;; determined by and angle bracket; or (ii) is inside a macro whose start
+  ;; isn't POINT-MACRO-START doesn't count as a finishing position.
+  `(let ((here (point))
+	 (pos (scan-lists ,from 1 1)))
+     (while (eq (char-before pos) ?>)
+       (setq pos (scan-lists pos 1 1)))
+     pos))
+
+(defmacro c-sc-scan-lists-no-category+1-1 (from) 
+  ;; Do a (scan-lists FROM 1 -1).  Any finishing position which either (i) is
+  ;; determined by and angle bracket; or (ii) is inside a macro whose start
+  ;; isn't POINT-MACRO-START doesn't count as a finishing position.
+  `(let ((here (point))
+	 (pos (scan-lists ,from 1 -1)))
+     (while (eq (char-before pos) ?<)
+       (setq pos (scan-lists pos 1 1))
+       (setq pos (scan-lists pos 1 -1)))
+     pos))
+
+(defmacro c-sc-scan-lists-no-category-1+1 (from)
+  ;; Do a (scan-lists FROM -1 1).  Any finishing position which either (i) is
+  ;; determined by and angle bracket; or (ii) is inside a macro whose start
+  ;; isn't POINT-MACRO-START doesn't count as a finishing position.
+  `(let ((here (point))
+	 (pos (scan-lists ,from -1 1)))
+     (while (eq (char-after pos) ?<)
+       (setq pos (scan-lists pos -1 1)))
+     pos))
+
+(defmacro c-sc-scan-lists-no-category-1-1 (from)
+  ;; Do a (scan-lists FROM -1 -1).  Any finishing position which either (i) is
+  ;; determined by and angle bracket; or (ii) is inside a macro whose start
+  ;; isn't POINT-MACRO-START doesn't count as a finishing position.
+  `(let ((here (point))
+	 (pos (scan-lists ,from -1 -1)))
+     (while (eq (char-after pos) ?>)
+       (setq pos (scan-lists pos -1 1))
+       (setq pos (scan-lists pos -1 -1)))
+     pos))
+
+(defmacro c-sc-scan-lists (from count depth)
+  (if c-use-category
+      `(scan-lists ,from ,count ,depth)
+    (cond
+     ((and (eq count 1) (eq depth 1))
+      `(c-sc-scan-lists-no-category+1+1 ,from))
+     ((and (eq count 1) (eq depth -1))
+      `(c-sc-scan-lists-no-category+1-1 ,from))
+     ((and (eq count -1) (eq depth 1))
+      `(c-sc-scan-lists-no-category-1+1 ,from))
+     ((and (eq count -1) (eq depth -1))
+      `(c-sc-scan-lists-no-category-1-1 ,from))
+     (t (error "Invalid parameter(s) to c-sc-scan-lists")))))
+	      
+
+(defun c-sc-parse-partial-sexp-no-category (from to targetdepth stopbefore
+						 oldstate)
+  ;; Do a parse-partial-sexp using the supplied arguments, disregarding
+  ;; template/generic delimiters < > and disregarding macros other than the
+  ;; one at POINT-MACRO-START.
+  ;;
+  ;; NOTE that STOPBEFORE must be nil.  TARGETDEPTH should be one less than
+  ;; the depth in OLDSTATE.  This function is thus a SPECIAL PURPOSE variation
+  ;; on parse-partial-sexp, designed for calling from
+  ;; `c-remove-stale-state-cache'.
+  ;;
+  ;; Any finishing position which is determined by an angle bracket delimiter
+  ;; doesn't count as a finishing position.
+  ;;
+  ;; Note there is no special handling of CPP constructs here, since these are
+  ;; always syntactically balanced (thanks to `c-neutralize-CPP-line').
+  (let ((state
+	 (parse-partial-sexp from to targetdepth stopbefore oldstate)))
+    (while
+	(and (< (point) to)
+	     ;; We must have hit targetdepth.
+	     (or (eq (char-before) ?<)
+		 (eq (char-before) ?>)))
+      (setcar state
+	      (if (memq (char-before) '(?> ?\) ?\} ?\]))
+		  (1+ (car state))
+		(1- (car state))))
+      (setq state
+	    (parse-partial-sexp (point) to targetdepth stopbefore oldstate)))
+    state))
+
+(defmacro c-sc-parse-partial-sexp (from to &optional targetdepth stopbefore
+					oldstate)
+  (if c-use-category
+      `(parse-partial-sexp ,from ,to ,targetdepth ,stopbefore ,oldstate)
+    `(c-sc-parse-partial-sexp-no-category ,from ,to ,targetdepth ,stopbefore
+					  ,oldstate)))
+
+
+(defmacro c-looking-at-non-alphnumspace ()
+  "Are we looking at a character which isn't alphanumeric or space?"
+  (if (memq 'gen-comment-delim c-emacs-features)
+      `(looking-at
+"\\([;#]\\|\\'\\|\\s(\\|\\s)\\|\\s\"\\|\\s\\\\|\\s$\\|\\s<\\|\\s>\\|\\s!\\)")
+    `(or (looking-at
+"\\([;#]\\|\\'\\|\\s(\\|\\s)\\|\\s\"\\|\\s\\\\|\\s$\\|\\s<\\|\\s>\\)"
+         (let ((prop (c-get-char-property (point) 'syntax-table)))
+	   (eq prop '(14)))))))		; '(14) is generic comment delimiter.
+
 
 (defsubst c-intersect-lists (list alist)
   ;; return the element of ALIST that matches the first element found
@@ -1357,13 +1533,13 @@ will be nil."
   (and (boundp 'zmacs-region-stays)
        (setq zmacs-region-stays t)))
 
-(put 'c-mode    'c-mode-prefix "c-")
-(put 'c++-mode  'c-mode-prefix "c++-")
+(put 'c-mode	'c-mode-prefix "c-")
+(put 'c++-mode	'c-mode-prefix "c++-")
 (put 'objc-mode 'c-mode-prefix "objc-")
 (put 'java-mode 'c-mode-prefix "java-")
-(put 'idl-mode  'c-mode-prefix "idl-")
+(put 'idl-mode	'c-mode-prefix "idl-")
 (put 'pike-mode 'c-mode-prefix "pike-")
-(put 'awk-mode  'c-mode-prefix "awk-")
+(put 'awk-mode	'c-mode-prefix "awk-")
 
 (defsubst c-mode-symbol (suffix)
   "Prefix the current mode prefix (e.g. \"c-\") to SUFFIX and return
@@ -1408,8 +1584,8 @@ Notably, null elements in LIST are ignor
 
 (defun c-make-keywords-re (adorn list &optional mode)
   "Make a regexp that matches all the strings the list.
-Duplicates and nil elements in the list are removed.  The resulting
-regexp may contain zero or more submatch expressions.
+Duplicates and nil elements in the list are removed.  The
+resulting regexp may contain zero or more submatch expressions.
 
 If ADORN is t there will be at least one submatch and the first
 surrounds the matched alternative, and the regexp will also not match
@@ -1418,7 +1594,7 @@ language variable `c-nonsymbol-key' is u
 
 A value 'appendable for ADORN is like above, but all alternatives in
 the list that end with a word constituent char will have \\> appended
-instead, so that the regexp remains appendable.  Note that this
+instead, so that the regexp remains appendable.	 Note that this
 variant doesn't always guarantee that an identifier prefix isn't
 matched since the symbol constituent '_' is normally considered a
 nonword token by \\>.
@@ -1427,11 +1603,7 @@ The optional MODE specifies the language
 when it's needed.  The default is the current language taken from
 `c-buffer-is-cc-mode'."
 
-  (let (unique)
-    (dolist (elt list)
-      (unless (member elt unique)
-	(push elt unique)))
-    (setq list (delete nil unique)))
+  (setq list (delete nil (delete-duplicates list :test 'string-equal)))
   (if list
       (let (re)
 
@@ -1514,7 +1686,7 @@ when it's needed.  The default is the cu
 (defun c-make-bare-char-alt (chars &optional inverted)
   "Make a character alternative string from the list of characters CHARS.
 The returned string is of the type that can be used with
-`skip-chars-forward' and `skip-chars-backward'.  If INVERTED is
+`skip-chars-forward' and `skip-chars-backward'.	 If INVERTED is
 non-nil, a caret is prepended to invert the set."
   ;; This function ought to be in the elisp core somewhere.
   (let ((str (if inverted "^" "")) char char2)
@@ -1553,7 +1725,7 @@ non-nil, a caret is prepended to invert
 	(setq list (cons 'infodock list)))
 
     ;; XEmacs uses 8-bit modify-syntax-entry flags.
-    ;; Emacs uses a 1-bit flag.  We will have to set up our
+    ;; Emacs uses a 1-bit flag.	 We will have to set up our
     ;; syntax tables differently to handle this.
     (let ((table (copy-syntax-table))
 	  entry)
@@ -1596,11 +1768,15 @@ non-nil, a caret is prepended to invert
 			       (not (end-of-defun))))
 	  (setq list (cons 'argumentative-bod-function list))))
 
+    ;; Record whether the `category' text property works.
+    (if c-use-category (setq list (cons 'category-properties list)))
+
     (let ((buf (generate-new-buffer " test"))
 	  parse-sexp-lookup-properties
 	  parse-sexp-ignore-comments
 	  lookup-syntax-properties)
-      (with-current-buffer buf
+      (save-excursion
+	(set-buffer buf)
 	(set-syntax-table (make-syntax-table))
 
 	;; For some reason we have to set some of these after the
@@ -1625,13 +1801,13 @@ non-nil, a caret is prepended to invert
 		  "support for the `syntax-table' text property "
 		  "is required.")))
 
-	;; Find out if generic comment delimiters work.
+	;; Find out if "\\s!" (generic comment delimiters) work.
 	(c-safe
 	  (modify-syntax-entry ?x "!")
 	  (if (string-match "\\s!" "x")
 	      (setq list (cons 'gen-comment-delim list))))
 
-	;; Find out if generic string delimiters work.
+	;; Find out if "\\s|" (generic string delimiters) work.
 	(c-safe
 	  (modify-syntax-entry ?x "|")
 	  (if (string-match "\\s|" "x")
@@ -1659,7 +1835,7 @@ non-nil, a caret is prepended to invert
 	    (set-syntax-table (make-syntax-table))
 	    (modify-syntax-entry ?\' "\"")
 	    (cond
-	     ;; XEmacs.  Afaik this is currently an Emacs-only
+	     ;; XEmacs.	 Afaik this is currently an Emacs-only
 	     ;; feature, but it's good to be prepared.
 	     ((memq '8-bit list)
 	      (modify-syntax-entry ?/ ". 1456")
@@ -1677,8 +1853,33 @@ non-nil, a caret is prepended to invert
 	(set-buffer-modified-p nil))
       (kill-buffer buf))
 
+    ;; Will the "LOCAL" parameter of `add-hook' work without the hook first
+    ;; being made local by `make-local-hook'?
+    (if (let ((buf1 (generate-new-buffer " test1"))
+	      (buf2 (generate-new-buffer " test2"))
+	      changed)
+	  
+	  (save-excursion		; Needed for XEmacs's byte compiler
+	    (set-buffer buf1)
+	    (add-hook 'after-change-functions
+		      (lambda (beg end old-len) (setq changed t))
+		      nil
+		      t)
+	    (set-buffer buf2)
+	    (insert ?c)
+	    (set-buffer buf1)
+	    (remove-hook 'after-change-functions
+			 (lambda (beg end old-len) (setq changed t))
+			 t)
+	    (kill-buffer buf1)
+	    (kill-buffer buf2)
+	    (not changed)))
+	(setq list (cons 'add-hook-local list)))
+
+
     ;; See if `parse-partial-sexp' returns the eighth element.
-    (if (c-safe (>= (length (save-excursion (parse-partial-sexp (point) (point))))
+    (if (c-safe (>= (length (save-excursion
+			      (parse-partial-sexp (point) (point))))
 		    10))
 	(setq list (cons 'pps-extended-state list))
       (error (concat
@@ -1692,27 +1893,28 @@ There are many flavors of Emacs out ther
 features supporting those needed by CC Mode.  The following values
 might be present:
 
-'8-bit              8 bit syntax entry flags (XEmacs style).
-'1-bit              1 bit syntax entry flags (Emacs style).
-'argumentative-bod-function         beginning-of-defun passes ARG through
-                    to a non-null beginning-of-defun-function.  It is assumed
-		    the end-of-defun does the same thing.
+'8-bit		    8 bit syntax entry flags (XEmacs style).
+'1-bit		    1 bit syntax entry flags (Emacs style).
+'argumentative-bod-function	    beginning-of-defun and end-of-defun pass
+		    ARG through to beginning/end-of-defun-function.
 'syntax-properties  It works to override the syntax for specific characters
 		    in the buffer with the 'syntax-table property.  It's
 		    always set - CC Mode no longer works in emacsen without
 		    this feature.
+'category-properties Syntax routines can add a level of indirection to text
+		    properties using the 'category property.
 'gen-comment-delim  Generic comment delimiters work
 		    (i.e. the syntax class `!').
 'gen-string-delim   Generic string delimiters work
 		    (i.e. the syntax class `|').
 'pps-extended-state `parse-partial-sexp' returns a list with at least 10
 		    elements, i.e. it contains the position of the start of
-		    the last comment or string.  It's always set - CC Mode
-                    no longer works in emacsen without this feature.
+		    the last comment or string.	 It's always set - CC Mode
+		    no longer works in emacsen without this feature.
 'posix-char-classes The regexp engine understands POSIX character classes.
-'col-0-paren        It's possible to turn off the ad-hoc rule that a paren
+'col-0-paren	    It's possible to turn off the ad-hoc rule that a paren
 		    in column zero is the start of a defun.
-'infodock           This is Infodock (based on XEmacs).
+'infodock	    This is Infodock (based on XEmacs).
 
 '8-bit and '1-bit are mutually exclusive.")
 
@@ -1739,7 +1941,7 @@ might be present:
 
 ;; This is used to set various language dependent data in a flexible
 ;; way: Language constants can be built from the values of other
-;; language constants, also those for other languages.  They can also
+;; language constants, also those for other languages.	They can also
 ;; process the values of other language constants uniformly across all
 ;; the languages.  E.g. one language constant can list all the type
 ;; keywords in each language, and another can build a regexp for each
@@ -1796,10 +1998,10 @@ system."
 ;; `c-lang-const'.  It's mostly used at compile time but it's not
 ;; stored in compiled files.
 ;;
-;; The obarray contains all the language constants as symbols.  The
+;; The obarray contains all the language constants as symbols.	The
 ;; value cells hold the evaluated values as alists where each car is
 ;; the mode name symbol and the corresponding cdr is the evaluated
-;; value in that mode.  The property lists hold the source definitions
+;; value in that mode.	The property lists hold the source definitions
 ;; and other miscellaneous data.  The obarray might also contain
 ;; various other symbols, but those don't have any variable bindings.
 
@@ -1818,7 +2020,9 @@ system."
 	       (t
 		;; Being evaluated interactively.
 		(buffer-file-name)))))
-    (and file (file-name-base file))))
+    (and file
+	 (file-name-sans-extension
+	  (file-name-nondirectory file)))))
 
 (defmacro c-lang-defconst-eval-immediately (form)
   "Can be used inside a VAL in `c-lang-defconst' to evaluate FORM
@@ -1828,9 +2032,6 @@ itself is evaluated."
   ;; `cl-macroexpand-all' inside `c-lang-defconst'.
   (eval form))
 
-;; Only used at compile time - suppress "might not be defined at runtime".
-(declare-function cl-macroexpand-all "cl" (form &optional env))
-
 (defmacro c-lang-defconst (name &rest args)
   "Set the language specific values of the language constant NAME.
 The second argument can optionally be a docstring.  The rest of the
@@ -1844,13 +2045,13 @@ If LANG isn't `t' or one of the core lan
 have been declared with `c-add-language'.
 
 Neither NAME, LANG nor VAL are evaluated directly - they should not be
-quoted.  `c-lang-defconst-eval-immediately' can however be used inside
+quoted.	 `c-lang-defconst-eval-immediately' can however be used inside
 VAL to evaluate parts of it directly.
 
 When VAL is evaluated for some language, that language is temporarily
 made current so that `c-lang-const' without an explicit language can
 be used inside VAL to refer to the value of a language constant in the
-same language.  That is particularly useful if LANG is `t'.
+same language.	That is particularly useful if LANG is `t'.
 
 VAL is not evaluated right away but rather when the value is requested
 with `c-lang-const'.  Thus it's possible to use `c-lang-const' inside
@@ -1953,10 +2154,9 @@ constant.  A file is identified by its b
 			       ,@(and pre-files `(',pre-files))))))
 
 (put 'c-lang-defconst 'lisp-indent-function 1)
-;(eval-after-load "edebug" ; 2006-07-09: def-edebug-spec is now in subr.el.
-;  '
-(def-edebug-spec c-lang-defconst
-  (&define name [&optional stringp] [&rest sexp def-form]))
+(eval-after-load "edebug"
+  '(def-edebug-spec c-lang-defconst
+     (&define name [&optional stringp] [&rest sexp def-form])))
 
 (defun c-define-lang-constant (name bindings &optional pre-files)
   ;; Used by `c-lang-defconst'.
@@ -1969,7 +2169,7 @@ constant.  A file is identified by its b
 	 (elem (assq file source)))
 
     ;;(when (cdr-safe elem)
-    ;;  (message "Language constant %s redefined in %S" name file))
+    ;;	(message "Language constant %s redefined in %S" name file))
 
     ;; Note that the order in the source alist is relevant.  Like how
     ;; `c-lang-defconst' reverses the bindings, this reverses the
@@ -2042,12 +2242,11 @@ quoted."
 	;; are no file dependencies needed.
 	(setq source-files (nreverse
 			    ;; Reverse to get the right load order.
-			    (apply 'nconc
-				   (mapcar (lambda (elem)
-					     (if (eq file (car elem))
-						 nil ; Exclude our own file.
-					       (list (car elem))))
-					   (get sym 'source))))))
+			    (mapcan (lambda (elem)
+				      (if (eq file (car elem))
+					  nil ; Exclude our own file.
+					(list (car elem))))
+				    (get sym 'source)))))
 
       ;; Make some effort to do a compact call to
       ;; `c-get-lang-constant' since it will be compiled in.
@@ -2123,7 +2322,7 @@ quoted."
 	      (or (assq sym c-lang-constants-under-evaluation)
 		  (cons sym (vector source nil))))
 	     ;; Append `c-lang-constants-under-evaluation' even if an
-	     ;; earlier entry is found.  It's only necessary to get
+	     ;; earlier entry is found.	 It's only necessary to get
 	     ;; the recording of dependencies above correct.
 	     (c-lang-constants-under-evaluation
 	      (cons source-pos c-lang-constants-under-evaluation))
@@ -2197,7 +2396,7 @@ quoted."
       (while (if assignment-entry
 		 t
 	       ;; Handled the last assignment from one file, begin on the
-	       ;; next.  Due to the check in `c-lang-defconst', we know
+	       ;; next.	 Due to the check in `c-lang-defconst', we know
 	       ;; there's at least one.
 	       (when file-entry
 
@@ -2239,7 +2438,7 @@ quoted."
 
 (defun c-lang-major-mode-is (mode)
   ;; `c-major-mode-is' expands to a call to this function inside
-  ;; `c-lang-defconst'.  Here we also match the mode(s) against any
+  ;; `c-lang-defconst'.	 Here we also match the mode(s) against any
   ;; fallback modes for the one in `c-buffer-is-cc-mode', so that
   ;; e.g. (c-major-mode-is 'c++-mode) is true in a derived language
   ;; that has c++-mode as base mode.
@@ -2256,4 +2455,5 @@ quoted."
 
 (cc-provide 'cc-defs)
 
+;;; arch-tag: 3bb2629d-dd84-4ff0-ad39-584be0fe3cda
 ;;; cc-defs.el ends here
--- emacs24-24.3+1.orig/lisp/progmodes/cc-engine.el
+++ emacs24-24.3+1/lisp/progmodes/cc-engine.el
@@ -1,32 +1,34 @@
 ;;; cc-engine.el --- core syntax guessing engine for CC mode
 
-;; Copyright (C) 1985, 1987, 1992-2013 Free Software Foundation, Inc.
+;; Copyright (C) 1985, 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+;;   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+;;   2010, 2011   Free Software Foundation, Inc.
 
 ;; Authors:    2001- Alan Mackenzie
-;;             1998- Martin Stjernholm
-;;             1992-1999 Barry A. Warsaw
-;;             1987 Dave Detlefs
-;;             1987 Stewart Clamen
-;;             1985 Richard M. Stallman
+;;	       1998- Martin Stjernholm
+;;	       1992-1999 Barry A. Warsaw
+;;	       1987 Dave Detlefs and Stewart Clamen
+;;	       1985 Richard M. Stallman
 ;; Maintainer: bug-cc-mode@gnu.org
 ;; Created:    22-Apr-1997 (split from cc-mode.el)
-;; Keywords:   c languages
-;; Package:    cc-mode
+;; Version:    See cc-mode.el
+;; Keywords:   c languages oop
 
 ;; This file is part of GNU Emacs.
 
-;; GNU Emacs is free software: you can redistribute it and/or modify
+;; GNU Emacs is free software; you can redistribute it and/or modify
 ;; it under the terms of the GNU General Public License as published by
-;; the Free Software Foundation, either version 3 of the License, or
-;; (at your option) any later version.
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
 
 ;; GNU Emacs is distributed in the hope that it will be useful,
 ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
 ;; GNU General Public License for more details.
 
 ;; You should have received a copy of the GNU General Public License
-;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
+;; along with this program; see the file COPYING.  If not, see
+;; <http://www.gnu.org/licenses/>.
 
 ;;; Commentary:
 
@@ -45,7 +47,7 @@
 ;; Various functions in CC Mode use text properties for caching and
 ;; syntactic markup purposes, and those of them that might modify such
 ;; properties but still don't modify the buffer in a visible way are
-;; said to do "hidden buffer changes".  They should be used within
+;; said to do "hidden buffer changes".	They should be used within
 ;; `c-save-buffer-state' or a similar function that saves and restores
 ;; buffer modifiedness, disables buffer change hooks, etc.
 ;;
@@ -107,27 +109,27 @@
 ;;   The value specifies the kind of position:
 ;;
 ;;     'c-decl-arg-start
-;;  	 Put on the last char of the token preceding each declaration
-;;  	 inside a declaration style arglist (typically in a function
-;;  	 prototype).
+;;	 Put on the last char of the token preceding each declaration
+;;	 inside a declaration style arglist (typically in a function
+;;	 prototype).
 ;;
 ;;     'c-decl-end
-;;  	 Put on the last char of the token preceding a declaration.
-;;  	 This is used in cases where declaration boundaries can't be
-;;  	 recognized simply by looking for a token like ";" or "}".
-;;  	 `c-type-decl-end-used' must be set if this is used (see also
-;;  	 `c-find-decl-spots').
+;;	 Put on the last char of the token preceding a declaration.
+;;	 This is used in cases where declaration boundaries can't be
+;;	 recognized simply by looking for a token like ";" or "}".
+;;	 `c-type-decl-end-used' must be set if this is used (see also
+;;	 `c-find-decl-spots').
 ;;
 ;;     'c-<>-arg-sep
-;;  	 Put on the commas that separate arguments in angle bracket
-;;  	 arglists like C++ template arglists.
+;;	 Put on the commas that separate arguments in angle bracket
+;;	 arglists like C++ template arglists.
 ;;
 ;;     'c-decl-id-start and 'c-decl-type-start
-;;  	 Put on the last char of the token preceding each declarator
-;;  	 in the declarator list of a declaration.  They are also used
-;;  	 between the identifiers cases like enum declarations.
-;;  	 'c-decl-type-start is used when the declarators are types,
-;;  	 'c-decl-id-start otherwise.
+;;	 Put on the last char of the token preceding each declarator
+;;	 in the declarator list of a declaration.  They are also used
+;;	 between the identifiers cases like enum declarations.
+;;	 'c-decl-type-start is used when the declarators are types,
+;;	 'c-decl-id-start otherwise.
 ;;
 ;; 'c-awk-NL-prop
 ;;   Used in AWK mode to mark the various kinds of newlines.  See
@@ -149,19 +151,20 @@
 
 ;; Silence the compiler.
 (cc-bytecomp-defun buffer-syntactic-context) ; XEmacs
+(cc-bytecomp-defun c-fontify-recorded-types-and-refs)
+(cc-bytecomp-defvar c-maybe-stale-found-type)
 
 
 ;; Make declarations for all the `c-lang-defvar' variables in cc-langs.
 
 (defmacro c-declare-lang-variables ()
   `(progn
-     ,@(apply 'nconc
-	      (mapcar (lambda (init)
-			`(,(if (elt init 2)
-			       `(defvar ,(car init) nil ,(elt init 2))
-			     `(defvar ,(car init) nil))
-			  (make-variable-buffer-local ',(car init))))
-		      (cdr c-lang-variable-inits)))))
+     ,@(mapcan (lambda (init)
+		 `(,(if (elt init 2)
+			`(defvar ,(car init) nil ,(elt init 2))
+		      `(defvar ,(car init) nil))
+		   (make-variable-buffer-local ',(car init))))
+	       (cdr c-lang-variable-inits))))
 (c-declare-lang-variables)
 
 
@@ -236,7 +239,7 @@
 
 (defun c-invalidate-macro-cache (beg end)
   ;; Called from a before-change function.  If the change region is before or
-  ;; in the macro characterized by `c-macro-cache' etc., nullify it
+  ;; in the macro characterised by `c-macro-cache' etc., nullify it
   ;; appropriately.  BEG and END are the standard before-change-functions
   ;; parameters.  END isn't used.
   (cond
@@ -256,7 +259,7 @@
 Leave point at the beginning of the directive and return t if in one,
 otherwise return nil and leave point unchanged.
 
-Note that this function might do hidden buffer changes.  See the
+Note that this function might do hidden buffer changes.	 See the
 comment at the start of cc-engine.el for more info."
   (let ((here (point)))
     (when c-opt-cpp-prefix
@@ -295,7 +298,7 @@ More accurately, move the point to the e
 line that doesn't end with a line continuation backslash - no check is
 done that the point is inside a cpp directive to begin with.
 
-Note that this function might do hidden buffer changes.  See the
+Note that this function might do hidden buffer changes.	 See the
 comment at the start of cc-engine.el for more info."
    (if (and (cdr c-macro-cache)
 	    (<= (point) (cdr c-macro-cache))
@@ -343,7 +346,7 @@ comment at the start of cc-engine.el for
 (defun c-forward-over-cpp-define-id ()
   ;; Assuming point is at the "#" that introduces a preprocessor
   ;; directive, it's moved forward to the end of the identifier which is
-  ;; "#define"d (or whatever c-opt-cpp-macro-define specifies).  Non-nil
+  ;; "#define"d (or whatever c-opt-cpp-macro-define specifies).	 Non-nil
   ;; is returned in this case, in all other cases nil is returned and
   ;; point isn't moved.
   ;;
@@ -419,7 +422,7 @@ comment at the start of cc-engine.el for
 
 (defun c-shift-line-indentation (shift-amt)
   ;; Shift the indentation of the current line with the specified
-  ;; amount (positive inwards).  The buffer is modified only if
+  ;; amount (positive inwards).	 The buffer is modified only if
   ;; SHIFT-AMT isn't equal to zero.
   (let ((pos (- (point-max) (point)))
 	(c-macro-start c-macro-start)
@@ -469,13 +472,13 @@ comment at the start of cc-engine.el for
 
 ;; String syntax chars, suitable for skip-syntax-(forward|backward).
 (defconst c-string-syntax (if (memq 'gen-string-delim c-emacs-features)
-                              "\"|"
-                            "\""))
+			      "\"|"
+			    "\""))
 
 ;; Regexp matching string limit syntax.
 (defconst c-string-limit-regexp (if (memq 'gen-string-delim c-emacs-features)
-                                    "\\s\"\\|\\s|"
-                                  "\\s\""))
+				    "\\s\"\\|\\s|"
+				  "\\s\""))
 
 ;; Regexp matching WS followed by string limit syntax.
 (defconst c-ws*-string-limit-regexp
@@ -491,7 +494,7 @@ comment at the start of cc-engine.el for
     (c-benign-error "%s" c-parsing-error))
   c-parsing-error)
 
-;; Faces given to comments and string literals.  This is used in some
+;; Faces given to comments and string literals.	 This is used in some
 ;; situations to speed up recognition; it isn't mandatory that font
 ;; locking is in use.  This variable is extended with the face in
 ;; `c-doc-face-name' when fontification is activated in cc-fonts.el.
@@ -506,7 +509,7 @@ comment at the start of cc-engine.el for
   (c-put-char-property pos 'c-type value))
 
 (defun c-clear-c-type-property (from to value)
-  ;; Remove all occurrences of the c-type property that has the given
+  ;; Remove all occurences of the c-type property that has the given
   ;; value in the region between FROM and TO.  VALUE is assumed to not
   ;; be nil.
   ;;
@@ -517,7 +520,7 @@ comment at the start of cc-engine.el for
     (while (progn
 	     (when (eq (get-text-property (point) 'c-type) value)
 	       (c-clear-char-property (point) 'c-type))
-	     (goto-char (next-single-property-change (point) 'c-type nil to))
+	     (goto-char (c-next-single-property-change (point) 'c-type nil to))
 	     (< (point) to)))))
 
 
@@ -621,7 +624,7 @@ returns 'same in this case.
 Stop at statement continuation tokens like \"else\", \"catch\",
 \"finally\" and the \"while\" in \"do ... while\" if the start point
 is within the continuation.  If starting at such a token, move to the
-corresponding statement start.  If at the beginning of a statement,
+corresponding statement start.	If at the beginning of a statement,
 move to the closest containing statement if there is any.  This might
 also stop at a continuation clause.
 
@@ -631,20 +634,20 @@ statement start keyword.)  Otherwise, ea
 separate statement.
 
 Macros are ignored \(i.e. skipped over) unless point is within one, in
-which case the content of the macro is treated as normal code.  Aside
+which case the content of the macro is treated as normal code.	Aside
 from any normal statement starts found in it, stop at the first token
 of the content in the macro, i.e. the expression of an \"#if\" or the
 start of the definition in a \"#define\".  Also stop at start of
 macros before leaving them.
 
 Return:
-'label          if stopped at a label or \"case...:\" or \"default:\";
-'same           if stopped at the beginning of the current statement;
-'up             if stepped to a containing statement;
-'previous       if stepped to a preceding statement;
-'beginning      if stepped from a statement continuation clause to
-                its start clause; or
-'macro          if stepped to a macro start.
+'label		if stopped at a label or \"case...:\" or \"default:\";
+'same		if stopped at the beginning of the current statement;
+'up		if stepped to a containing statement;
+'previous	if stepped to a preceding statement;
+'beginning	if stepped from a statement continuation clause to
+		its start clause; or
+'macro		if stepped to a macro start.
 Note that 'same and not 'label is returned if stopped at the same
 label without crossing the colon character.
 
@@ -658,7 +661,7 @@ Normally only ';' and virtual semicolons
 statements, but if COMMA-DELIM is non-nil then ',' is treated
 as a delimiter too.
 
-Note that this function might do hidden buffer changes.  See the
+Note that this function might do hidden buffer changes.	 See the
 comment at the start of cc-engine.el for more info."
 
   ;; The bulk of this function is a pushdown automaton that looks at statement
@@ -679,21 +682,21 @@ comment at the start of cc-engine.el for
   ;; The following variables constitute the PDA:
   ;;
   ;; sym:    This is either the "while"-like token (e.g. 'for) we've just
-  ;;         scanned back over, 'boundary if we've just gone back over a
-  ;;         statement boundary, or nil otherwise.
+  ;;	     scanned back over, 'boundary if we've just gone back over a
+  ;;	     statement boundary, or nil otherwise.
   ;; state:  takes one of the values (nil else else-boundary while
-  ;;         while-boundary catch catch-boundary).
-  ;;         nil means "no "while"-like token yet scanned".
-  ;;         'else, for example, means "just gone back over an else".
-  ;;         'else-boundary means "just gone back over a statement boundary
-  ;;         immediately after having gone back over an else".
+  ;;	     while-boundary catch catch-boundary).
+  ;;	     nil means "no "while"-like token yet scanned".
+  ;;	     'else, for example, means "just gone back over an else".
+  ;;	     'else-boundary means "just gone back over a statement boundary
+  ;;	     immediately after having gone back over an else".
   ;; saved-pos: A vector of either saved positions (tok ptok pptok, etc.) or
-  ;;         of error reporting information.
+  ;;	     of error reporting information.
   ;; stack:  The stack onto which the PDA pushes its state.  Each entry
-  ;;         consists of a saved value of state and saved-pos.  An entry is
-  ;;         pushed when we move back over a "continuation" token (e.g. else)
-  ;;         and popped when we encounter the corresponding opening token
-  ;;         (e.g. if).
+  ;;	     consists of a saved value of state and saved-pos.	An entry is
+  ;;	     pushed when we move back over a "continuation" token (e.g. else)
+  ;;	     and popped when we encounter the corresponding opening token
+  ;;	     (e.g. if).
   ;;
   ;;
   ;; The following diagram briefly outlines the PDA.
@@ -808,7 +811,7 @@ comment at the start of cc-engine.el for
 		    (/= (skip-chars-backward "-+!*&~@`#") 0))))
 
       ;; Skip back over any semicolon here.  If it was a bare semicolon, we're
-      ;; done.  Later on we ignore the boundaries for statements that don't
+      ;; done.	Later on we ignore the boundaries for statements that don't
       ;; contain any sexp.  The only thing that is affected is that the error
       ;; checking is a little less strict, and we really don't bother.
       (if (and (memq (char-before) delims)
@@ -829,18 +832,17 @@ comment at the start of cc-engine.el for
 	    ;; Record this as the first token if not starting inside it.
 	    (setq tok start))
 
-
 	;; The following while loop goes back one sexp (balanced parens,
 	;; etc. with contents, or symbol or suchlike) each iteration.  This
-	;; movement is accomplished with a call to c-backward-sexp approx 170
-	;; lines below.
-	;;
-	;; The loop is exited only by throwing nil to the (catch 'loop ...):
-	;; 1. On reaching the start of a macro;
-	;; 2. On having passed a stmt boundary with the PDA stack empty;
-	;; 3. On reaching the start of an Objective C method def;
-	;; 4. From macro `c-bos-pop-state'; when the stack is empty;
-	;; 5. From macro `c-bos-pop-state-and-retry' when the stack is empty.
+ 	;; movement is accomplished with a call to c-backward-sexp approx 170
+ 	;; lines below.
+ 	;;
+ 	;; The loop is exited only by throwing nil to the (catch 'loop ...):
+ 	;; 1. On reaching the start of a macro;
+ 	;; 2. On having passed a stmt boundary with the PDA stack empty;
+ 	;; 3. On reaching the start of an Objective C method def;
+ 	;; 4. From macro `c-bos-pop-state'; when the stack is empty;
+ 	;; 5. From macro `c-bos-pop-state-and-retry' when the stack is empty.
 	(while
 	    (catch 'loop ;; Throw nil to break, non-nil to continue.
 	      (cond
@@ -877,17 +879,17 @@ comment at the start of cc-engine.el for
 		  (throw 'loop nil))	; 2. Statement boundary.
 
 		;; The PDA state handling.
-                ;;
-                ;; Refer to the description of the PDA in the opening
-                ;; comments.  In the following OR form, the first leaf
-                ;; attempts to handles one of the specific actions detailed
-                ;; (e.g., finding token "if" whilst in state `else-boundary').
-                ;; We drop through to the second leaf (which handles common
-                ;; state) if no specific handler is found in the first cond.
-                ;; If a parsing error is detected (e.g. an "else" with no
-                ;; preceding "if"), we throw to the enclosing catch.
-                ;;
-                ;; Note that the (eq state 'else) means
+		;;
+		;; Refer to the description of the PDA in the opening
+		;; comments.  In the following OR form, the first leaf
+		;; attempts to handles one of the specific actions detailed
+		;; (e.g., finding token "if" whilst in state `else-boundary').
+		;; We drop through to the second leaf (which handles common
+		;; state) if no specific handler is found in the first cond.
+		;; If a parsing error is detected (e.g. an "else" with no
+		;; preceding "if"), we throw to the enclosing catch.
+		;;
+		;; Note that the (eq state 'else) means
 		;; "we've just passed an else", NOT "we're looking for an
 		;; else".
 		(or (cond
@@ -954,7 +956,7 @@ comment at the start of cc-engine.el for
 			  ((eq sym 'while)
 			   ;; Is this a real while, or a do-while?
 			   ;; The next `when' triggers unless we are SURE that
-			   ;; the `while' is not the tail end of a `do-while'.
+			   ;; the `while' is not the tailend of a `do-while'.
 			   (when (or (not pptok)
 				     (memq (char-after pptok) delims)
 				     ;; The following kludge is to prevent
@@ -988,7 +990,7 @@ comment at the start of cc-engine.el for
 	      (if (eq sym 'boundary)
 		  (setq ret 'previous)
 
-                ;; HERE IS THE SINGLE PLACE INSIDE THE PDA LOOP WHERE WE MOVE
+		;; HERE IS THE SINGLE PLACE INSIDE THE PDA LOOP WHERE WE MOVE
 		;; BACKWARDS THROUGH THE SOURCE.
 
 		(c-backward-syntactic-ws)
@@ -1036,7 +1038,10 @@ comment at the start of cc-engine.el for
 			 ;; Just gone back over a brace block?
 			 ((and
 			   (eq (char-after) ?{)
-			   (not (c-looking-at-inexpr-block lim nil t)))
+			   (not (c-looking-at-inexpr-block lim nil t))
+			   (save-excursion
+			     (c-backward-token-2 1 t nil)
+			     (not (looking-at "=\\([^=]\\|$\\)"))))
 			  (save-excursion
 			    (c-forward-sexp) (point)))
 			 ;; Just gone back over some paren block?
@@ -1049,7 +1054,7 @@ comment at the start of cc-engine.el for
 			 ;; Just gone back over an ordinary symbol of some sort?
 			 (t (c-crosses-statement-barrier-p
 			     (point) maybe-after-boundary-pos))))
-
+	
 		  (when boundary-pos
 		    (setq pptok ptok
 			  ptok tok
@@ -1126,7 +1131,7 @@ comment at the start of cc-engine.el for
 		    pos tok) ; always non-nil
 	      )		     ; end of (catch loop ....)
 	  )		     ; end of sexp-at-a-time (while ....)
-
+	
 	;; If the stack isn't empty there might be errors to report.
 	(while stack
 	  (if (and (vectorp saved-pos) (eq (length saved-pos) 3))
@@ -1138,9 +1143,13 @@ comment at the start of cc-engine.el for
 		   (not (memq sym '(boundary ignore nil))))
 	  ;; Need to investigate closer whether we've crossed
 	  ;; between a substatement and its containing statement.
-	  (if (setq saved (if (looking-at c-block-stmt-1-key)
-			      ptok
-			    pptok))
+	  (if (setq saved
+		    (cond ((and (looking-at c-block-stmt-1-2-key)
+				(eq (char-after ptok) ?\())
+			   pptok)
+			  ((looking-at c-block-stmt-1-key)
+			   ptok)
+			  (t pptok)))
 	      (cond ((> start saved) (setq pos saved))
 		    ((= start saved) (setq ret 'up)))))
 
@@ -1157,7 +1166,7 @@ comment at the start of cc-engine.el for
 					last-label-pos
 				      pos))
 			 (looking-at c-label-kwds-regexp))))
-	  ;; We're in a label.  Maybe we should step to the statement
+	  ;; We're in a label.	Maybe we should step to the statement
 	  ;; after it.
 	  (if (< after-labels-pos start)
 	      (setq pos after-labels-pos)
@@ -1213,7 +1222,7 @@ For AWK, a statement which is terminated
 regarded as having a \"virtual semicolon\" immediately after the last token on
 the line.  If this virtual semicolon is _at_ from, the function recognizes it.
 
-Note that this function might do hidden buffer changes.  See the
+Note that this function might do hidden buffer changes.	 See the
 comment at the start of cc-engine.el for more info."
   (let* ((skip-chars
 	  ;; If the current language has CPP macros, insert # into skip-chars.
@@ -1260,16 +1269,22 @@ comment at the start of cc-engine.el for
 	      ;; looking for more : and ?.
 	      (setq c-maybe-labelp nil
 		    skip-chars (substring c-stmt-delim-chars 0 -2)))
-	     ;; At a CPP construct?
-	     ((and c-opt-cpp-symbol (looking-at c-opt-cpp-symbol)
-		   (save-excursion
-		     (forward-line 0)
-		     (looking-at c-opt-cpp-prefix)))
-	      (c-end-of-macro))
+	     ;; At a CPP construct or a "#" or "##" operator?
+	     ((and c-opt-cpp-symbol (looking-at c-opt-cpp-symbol))
+	      (if (save-excursion
+		    (skip-chars-backward " \t")
+		    (and (bolp)
+			 (or (bobp)
+			     (not (eq (char-before (1- (point))) ?\\)))))
+		  (c-end-of-macro)
+		(skip-chars-forward c-opt-cpp-symbol)))
 	     ((memq (char-after) non-skip-list)
 	      (throw 'done (point)))))
 	  ;; In trailing space after an as yet undetected virtual semicolon?
 	  (c-backward-syntactic-ws from)
+	  (when (and (bolp) (not (bobp))) ; Can happen in AWK Mode with an
+					  ; unterminated string/regexp.
+	    (backward-char))
 	  (if (and (< (point) to)
 		   (c-at-vsemi-p))
 	      (point)
@@ -1283,7 +1298,7 @@ A \"statement\" here is not restricted t
 Any kind of declaration-like construct that occur outside function
 bodies is also considered a \"statement\".
 
-Note that this function might do hidden buffer changes.  See the
+Note that this function might do hidden buffer changes.	 See the
 comment at the start of cc-engine.el for more info."
 
   (save-excursion
@@ -1311,7 +1326,7 @@ contain parenthesis pairs of any sort ex
 Since expressions never cross statement boundaries, this function also
 recognizes statement beginnings, just like `c-at-statement-start-p'.
 
-Note that this function might do hidden buffer changes.  See the
+Note that this function might do hidden buffer changes.	 See the
 comment at the start of cc-engine.el for more info."
 
   (save-excursion
@@ -1330,15 +1345,15 @@ comment at the start of cc-engine.el for
 ;; implementations of `forward-comment'.
 
 ;; Note: Some emacsen considers incorrectly that any line comment
-;; ending with a backslash continues to the next line.  I can't think
+;; ending with a backslash continues to the next line.	I can't think
 ;; of any way to work around that in a reliable way without changing
-;; the buffer, though.  Suggestions welcome. ;) (No, temporarily
+;; the buffer, though.	Suggestions welcome. ;) (No, temporarily
 ;; changing the syntax for backslash doesn't work since we must treat
 ;; escapes in string literals correctly.)
 
 (defun c-forward-single-comment ()
   "Move forward past whitespace and the closest following comment, if any.
-Return t if a comment was found, nil otherwise.  In either case, the
+Return t if a comment was found, nil otherwise.	 In either case, the
 point is moved past the following whitespace.  Line continuations,
 i.e. a backslashes followed by line breaks, are treated as whitespace.
 The line breaks that end line comments are considered to be the
@@ -1358,7 +1373,7 @@ This function does not do any hidden buf
 	  nil
 
 	;; Emacs includes the ending newline in a b-style (c++)
-	;; comment, but XEmacs doesn't.  We depend on the Emacs
+	;; comment, but XEmacs doesn't.	 We depend on the Emacs
 	;; behavior (which also is symmetric).
 	(if (and (eolp) (elt (parse-partial-sexp start (point)) 7))
 	    (condition-case nil (forward-char 1)))
@@ -1370,7 +1385,7 @@ This function does not do any hidden buf
 Line continuations, i.e. a backslashes followed by line breaks, are
 treated as whitespace.
 
-Note that this function might do hidden buffer changes.  See the
+Note that this function might do hidden buffer changes.	 See the
 comment at the start of cc-engine.el for more info."
 
   (while (or
@@ -1388,7 +1403,7 @@ comment at the start of cc-engine.el for
 
 (defun c-backward-single-comment ()
   "Move backward past whitespace and the closest preceding comment, if any.
-Return t if a comment was found, nil otherwise.  In either case, the
+Return t if a comment was found, nil otherwise.	 In either case, the
 point is moved past the preceding whitespace.  Line continuations,
 i.e. a backslashes followed by line breaks, are treated as whitespace.
 The line breaks that end line comments are considered to be the
@@ -1437,13 +1452,13 @@ This function does not do any hidden buf
 (defsubst c-backward-comments ()
   "Move backward past all preceding whitespace and comments.
 Line continuations, i.e. a backslashes followed by line breaks, are
-treated as whitespace.  The line breaks that end line comments are
+treated as whitespace.	The line breaks that end line comments are
 considered to be the comment enders, so the point cannot be at the end
 of the same line to move over a line comment.  Unlike
 c-backward-syntactic-ws, this function doesn't move back over
 preprocessor directives.
 
-Note that this function might do hidden buffer changes.  See the
+Note that this function might do hidden buffer changes.	 See the
 comment at the start of cc-engine.el for more info."
 
   (let ((start (point)))
@@ -1558,30 +1573,30 @@ comment at the start of cc-engine.el for
 ;   (interactive)
 ;   (save-excursion
 ;     (c-save-buffer-state (in-face)
-;       (goto-char (point-min))
-;       (setq in-face (if (get-text-property (point) 'c-is-sws)
-; 			(point)))
-;       (while (progn
-; 	       (goto-char (next-single-property-change
-; 			   (point) 'c-is-sws nil (point-max)))
-; 	       (if in-face
-; 		   (progn
-; 		     (c-debug-add-face in-face (point) 'c-debug-is-sws-face)
-; 		     (setq in-face nil))
-; 		 (setq in-face (point)))
-; 	       (not (eobp))))
-;       (goto-char (point-min))
-;       (setq in-face (if (get-text-property (point) 'c-in-sws)
-; 			(point)))
-;       (while (progn
-; 	       (goto-char (next-single-property-change
-; 			   (point) 'c-in-sws nil (point-max)))
-; 	       (if in-face
-; 		   (progn
-; 		     (c-debug-add-face in-face (point) 'c-debug-in-sws-face)
-; 		     (setq in-face nil))
-; 		 (setq in-face (point)))
-; 	       (not (eobp)))))))
+;	(goto-char (point-min))
+;	(setq in-face (if (get-text-property (point) 'c-is-sws)
+;			(point)))
+;	(while (progn
+;	       (goto-char (next-single-property-change
+;			   (point) 'c-is-sws nil (point-max)))
+;	       (if in-face
+;		   (progn
+;		     (c-debug-add-face in-face (point) 'c-debug-is-sws-face)
+;		     (setq in-face nil))
+;		 (setq in-face (point)))
+;	       (not (eobp))))
+;	(goto-char (point-min))
+;	(setq in-face (if (get-text-property (point) 'c-in-sws)
+;			(point)))
+;	(while (progn
+;	       (goto-char (next-single-property-change
+;			   (point) 'c-in-sws nil (point-max)))
+;	       (if in-face
+;		   (progn
+;		     (c-debug-add-face in-face (point) 'c-debug-in-sws-face)
+;		     (setq in-face nil))
+;		 (setq in-face (point)))
+;	       (not (eobp)))))))
 
 (defmacro c-debug-sws-msg (&rest args)
   ;;`(message ,@args)
@@ -1651,9 +1666,9 @@ comment at the start of cc-engine.el for
     ;; Ensure that an `c-in-sws' range gets broken.  Note that it isn't
     ;; safe to keep a range that was continuous before the change.  E.g:
     ;;
-    ;;    #define foo
-    ;;         \
-    ;;    bar
+    ;;	  #define foo
+    ;;	       \
+    ;;	  bar
     ;;
     ;; There can be a "ladder" between "#" and "b".  Now, if the newline
     ;; after "foo" is removed then "bar" will become part of the cpp
@@ -1676,7 +1691,7 @@ comment at the start of cc-engine.el for
 	;; `safe-start' is set when it's safe to cache the start position.
 	;; It's not set if we've initially skipped over comments and line
 	;; continuations since we might have gone out through the end of a
-	;; macro then.  This provision makes `c-forward-sws' not populate the
+	;; macro then.	This provision makes `c-forward-sws' not populate the
 	;; cache in the majority of cases, but otoh is `c-backward-sws' by far
 	;; more common.
 	safe-start)
@@ -1694,14 +1709,13 @@ comment at the start of cc-engine.el for
 	  ;; the cases when the marked rung is complete.
 	  ;; (`next-single-property-change' is certain to move at least one
 	  ;; step forward.)
-	  (setq rung-pos (1- (next-single-property-change
+	  (setq rung-pos (1- (c-next-single-property-change
 			      rung-is-marked 'c-is-sws nil rung-end-pos)))
 	;; Got no marked rung here.  Since the simple ws might have started
 	;; inside a line comment or cpp directive we must set `rung-pos' as
 	;; high as possible.
 	(setq rung-pos (point)))
 
-      (with-silent-modifications
       (while
 	  (progn
 	    (while
@@ -1710,7 +1724,7 @@ comment at the start of cc-engine.el for
 
 		  ;; The following search is the main reason that `c-in-sws'
 		  ;; and `c-is-sws' aren't combined to one property.
-		  (goto-char (next-single-property-change
+		  (goto-char (c-next-single-property-change
 			      (point) 'c-in-sws nil (point-max)))
 		  (unless (get-text-property (point) 'c-is-sws)
 		    ;; If the `c-in-sws' region extended past the last
@@ -1752,7 +1766,7 @@ comment at the start of cc-engine.el for
 
 	    (cond
 	     ((/= (point) simple-ws-end)
-	      ;; Skipped over comments.  Don't cache at eob in case the buffer
+	      ;; Skipped over comments.	 Don't cache at eob in case the buffer
 	      ;; is narrowed.
 	      (not (eobp)))
 
@@ -1827,12 +1841,12 @@ comment at the start of cc-engine.el for
 	   rung-pos (1+ simple-ws-end) next-rung-pos rung-end-pos
 	   (point-max))
 
-	  ;; Set `rung-pos' for the next rung.  It's the same thing here as
+	  ;; Set `rung-pos' for the next rung.	It's the same thing here as
 	  ;; initially, except that the rung position is set as early as
 	  ;; possible since we can't be in the ending ws of a line comment or
 	  ;; cpp directive now.
 	  (if (setq rung-is-marked next-rung-is-marked)
-	      (setq rung-pos (1- (next-single-property-change
+	      (setq rung-pos (1- (c-next-single-property-change
 				  rung-is-marked 'c-is-sws nil rung-end-pos)))
 	    (setq rung-pos next-rung-pos))
 	  (setq safe-start t)))
@@ -1857,7 +1871,7 @@ comment at the start of cc-engine.el for
 		(1- last-put-in-sws-pos))
 	       (c-remove-is-and-in-sws (1- last-put-in-sws-pos)
 				       last-put-in-sws-pos))))
-      ))))
+      )))
 
 (defun c-backward-sws ()
   ;; Used by `c-backward-syntactic-ws' to implement the unbounded search.
@@ -1870,7 +1884,7 @@ comment at the start of cc-engine.el for
 	rung-is-marked simple-ws-beg cmt-skip-pos)
 
     ;; Skip simple horizontal ws and do a quick check on the preceding
-    ;; character to see if it's anything that can't end syntactic ws, so we can
+    ;; character to see if it's anying that can't end syntactic ws, so we can
     ;; bail out early in the majority of cases when there just are a few ws
     ;; chars.  Newlines are complicated in the backward direction, so we can't
     ;; skip over them.
@@ -1895,7 +1909,6 @@ comment at the start of cc-engine.el for
 	  (goto-char (setq rung-pos rung-is-marked))
 	(goto-char simple-ws-beg))
 
-      (with-silent-modifications
       (while
 	  (progn
 	    (while
@@ -1910,7 +1923,7 @@ comment at the start of cc-engine.el for
 		  (unless (get-text-property (point) 'c-is-sws)
 		    ;; If the `c-in-sws' region extended past the first
 		    ;; `c-is-sws' char we have to go forward a bit.
-		    (goto-char (next-single-property-change
+		    (goto-char (c-next-single-property-change
 				(point) 'c-is-sws)))
 
 		  (c-debug-sws-msg
@@ -2000,7 +2013,7 @@ comment at the start of cc-engine.el for
 		    (skip-chars-forward " \t\n\r\f\v" simple-ws-beg)
 		    (setq next-rung-pos (point)))
 		  simple-ws-beg)
-	      ;; Skipped over comments.  Must put point at the end of
+	      ;; Skipped over comments.	 Must put point at the end of
 	      ;; the simple ws at point since we might be after a line
 	      ;; comment or cpp directive that's been partially
 	      ;; narrowed out, and we can't risk marking the simple ws
@@ -2081,7 +2094,7 @@ comment at the start of cc-engine.el for
 		last-put-in-sws-pos)
 	       (c-remove-is-and-in-sws last-put-in-sws-pos
 				       (1+ last-put-in-sws-pos)))))
-      ))))
+      )))
 
 
 ;; Other whitespace tools
@@ -2108,14 +2121,14 @@ comment at the start of cc-engine.el for
 (defconst c-state-cache-too-far 5000)
 ;; A maximum comfortable scanning distance, e.g. between
 ;; `c-state-cache-good-pos' and "HERE" (where we call c-parse-state).  When
-;; this distance is exceeded, we take "emergency measures", e.g. by clearing
-;; the cache and starting again from point-min or a beginning of defun.  This
+;; this distance is exceeded, we take "emergency meausures", e.g. by clearing
+;; the cache and starting again from point-min or a beginning of defun.	 This
 ;; value can be tuned for efficiency or set to a lower value for testing.
 
 (defvar c-state-cache nil)
 (make-variable-buffer-local 'c-state-cache)
 ;; The state cache used by `c-parse-state' to cut down the amount of
-;; searching.  It's the result from some earlier `c-parse-state' call.  See
+;; searching.  It's the result from some earlier `c-parse-state' call.	See
 ;; `c-parse-state''s doc string for details of its structure.
 ;;
 ;; The use of the cached info is more effective if the next
@@ -2136,20 +2149,19 @@ comment at the start of cc-engine.el for
 ;; the position where `c-state-cache' will be called next.  Right now
 ;; the heuristic is to set it to the position after the last found
 ;; closing paren (of any type) before the line on which
-;; `c-parse-state' was called.  That is chosen primarily to work well
+;; `c-parse-state' was called.	That is chosen primarily to work well
 ;; with refontification of the current line.
 ;;
 ;; 2009-07-28: When `c-state-point-min' and the last position where
 ;; `c-parse-state' or for which `c-invalidate-state-cache' was called, are
 ;; both in the same literal, there is no such "good position", and
-;; c-state-cache-good-pos is then nil.  This is the ONLY circumstance in which
+;; c-state-cache-good-pos is then nil.	This is the ONLY circumstance in which
 ;; it can be nil.  In this case, `c-state-point-min-literal' will be non-nil.
 ;;
 ;; 2009-06-12: In a brace desert, c-state-cache-good-pos may also be in
 ;; the middle of the desert, as long as it is not within a brace pair
 ;; recorded in `c-state-cache' or a paren/bracket pair.
 
-
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; We maintain a simple cache of positions which aren't in a literal, so as to
 ;; speed up testing for non-literality.
@@ -2178,34 +2190,49 @@ comment at the start of cc-engine.el for
 (make-variable-buffer-local 'c-state-semi-nonlit-pos-cache-limit)
 ;; An upper limit on valid entries in `c-state-semi-nonlit-pos-cache'.  This is
 ;; reduced by buffer changes, and increased by invocations of
-;; `c-state-literal-at'.  FIXME!!!
+;; `c-state-literal-at'.  FIMXE!!!
 
-(defsubst c-state-pp-to-literal (from to)
+(defsubst c-state-pp-to-literal (from to &optional not-in-delimiter)
   ;; Do a parse-partial-sexp from FROM to TO, returning either
   ;;     (STATE TYPE (BEG . END))     if TO is in a literal; or
   ;;     (STATE)                      otherwise,
   ;; where STATE is the parsing state at TO, TYPE is the type of the literal
   ;; (one of 'c, 'c++, 'string) and (BEG . END) is the boundaries of the literal.
   ;;
+  ;; Unless NOT-IN-DELIMITER is non-nil, when TO is inside a two-character
+  ;; comment opener, this is recognized as being in a comment literal.
+  ;;
   ;; Only elements 3 (in a string), 4 (in a comment), 5 (following a quote),
   ;; 7 (comment type) and 8 (start of comment/string) (and possibly 9) of
   ;; STATE are valid.
   (save-excursion
     (let ((s (parse-partial-sexp from to))
-	  ty)
-      (when (or (nth 3 s) (nth 4 s))	; in a string or comment
+	  ty co-st)
+      (cond
+       ((or (nth 3 s) (nth 4 s))	; in a string or comment
 	(setq ty (cond
 		  ((nth 3 s) 'string)
-		  ((eq (nth 7 s) t) 'c++)
+		  ((nth 7 s) 'c++)
 		  (t 'c)))
 	(parse-partial-sexp (point) (point-max)
-			    nil			 ; TARGETDEPTH
-			    nil			 ; STOPBEFORE
-			    s			 ; OLDSTATE
-			    'syntax-table))	 ; stop at end of literal
-      (if ty
-	  `(,s ,ty (,(nth 8 s) . ,(point)))
-	`(,s)))))
+			    nil		   ; TARGETDEPTH
+			    nil		   ; STOPBEFORE
+			    s		   ; OLDSTATE
+			    'syntax-table) ; stop at end of literal
+	`(,s ,ty (,(nth 8 s) . ,(point))))
+
+       ((and (not not-in-delimiter)	; inside a comment starter
+	     (not (bobp))
+	     (progn (backward-char)
+		    (and (not (and (memq 'category-properties c-emacs-features)
+				   (looking-at "\\s!")))
+			 (looking-at c-comment-start-regexp))))
+	(setq ty (if (looking-at c-block-comment-start-regexp) 'c 'c++)
+	      co-st (point))
+	(forward-comment 1)
+	`(,s ,ty (,co-st . ,(point))))
+
+       (t `(,s))))))
 
 (defun c-state-safe-place (here)
   ;; Return a buffer position before HERE which is "safe", i.e. outside any
@@ -2313,7 +2340,7 @@ comment at the start of cc-engine.el for
   ;; buffer).  Otherwise, return nil.
   ;;
   ;; This function is almost the same as `c-literal-limits'.  Previously, it
-  ;; differed in that it was a lower level function, and that it rigorously
+  ;; differed in that it was a lower level function, and that it rigourously
   ;; followed the syntax from BOB.  `c-literal-limits' is now (2011-12)
   ;; virtually identical to this function.
   (save-restriction
@@ -2440,10 +2467,10 @@ comment at the start of cc-engine.el for
 
 (defun c-get-cache-scan-pos (here)
   ;; From the state-cache, determine the buffer position from which we might
-  ;; scan forward to HERE to update this cache.  This position will be just
+  ;; scan forward to HERE to update this cache.	 This position will be just
   ;; after a paren/brace/bracket recorded in the cache, if possible, otherwise
   ;; return the earliest position in the accessible region which isn't within
-  ;; a literal.  If the visible portion of the buffer is entirely within a
+  ;; a literal.	 If the visible portion of the buffer is entirely within a
   ;; literal, return NIL.
   (let ((c c-state-cache) elt)
     ;(while (>= (or (c-state-cache-top-lparen c) 1) here)
@@ -2476,7 +2503,7 @@ comment at the start of cc-engine.el for
 ;; `c-parse-state', or nil.
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-;; Defuns which analyze the buffer, yet don't change `c-state-cache'.
+;; Defuns which analyse the buffer, yet don't change `c-state-cache'.
 (defun c-state-balance-parens-backwards (here- here+ top)
   ;; Return the position of the opening paren/brace/bracket before HERE- which
   ;; matches the outermost close p/b/b between HERE+ and TOP.  Except when
@@ -2491,7 +2518,7 @@ comment at the start of cc-engine.el for
   ;;
   ;; If there aren't enough opening paren/brace/brackets, return the position
   ;; of the outermost one found, or HERE- if there are none.  If there are no
-  ;; closing p/b/bs between HERE+ and TOP, return HERE-.  HERE-/+ and TOP
+  ;; closeing p/b/bs between HERE+ and TOP, return HERE-.  HERE-/+ and TOP
   ;; must not be inside literals.  Only the accessible portion of the buffer
   ;; will be scanned.
 
@@ -2505,7 +2532,7 @@ comment at the start of cc-engine.el for
 	(setq pos here+)
 	(c-safe
 	  (while
-	      (setq ren+1 (scan-lists pos 1 1)) ; might signal
+	      (setq ren+1 (c-sc-scan-lists pos 1 1)) ; might signal
 	    (setq lonely-rens (cons ren+1 lonely-rens)
 		  pos ren+1)))))
 
@@ -2517,14 +2544,14 @@ comment at the start of cc-engine.el for
       (c-safe
 	(while
 	    (and lonely-rens		; actual values aren't used.
-		 (setq pa (scan-lists pos -1 1)))
+		 (setq pa (c-sc-scan-lists pos -1 1)))
 	  (setq pos pa)
 	  (setq lonely-rens (cdr lonely-rens)))))
     pos))
 
 (defun c-parse-state-get-strategy (here good-pos)
   ;; Determine the scanning strategy for adjusting `c-parse-state', attempting
-  ;; to minimize the amount of scanning.  HERE is the pertinent position in
+  ;; to minimise the amount of scanning.  HERE is the pertinent position in
   ;; the buffer, GOOD-POS is a position where `c-state-cache' (possibly with
   ;; its head trimmed) is known to be good, or nil if there is no such
   ;; position.
@@ -2532,8 +2559,11 @@ comment at the start of cc-engine.el for
   ;; The return value is a list, one of the following:
   ;;
   ;; o - ('forward START-POINT) - scan forward from START-POINT,
-  ;;	 which is not less than the highest position in `c-state-cache' below here.
+  ;;	 which is not less than the highest position in `c-state-cache' below HERE,
+  ;;     which is after GOOD-POS.
   ;; o - ('backward nil) - scan backwards (from HERE).
+  ;; o - ('back-and-forward START-POINT) - like 'forward, but when HERE is earlier
+  ;;     than GOOD-POS.
   ;; o - ('IN-LIT nil) - point is inside the literal containing point-min.
   (let ((cache-pos (c-get-cache-scan-pos here))	; highest position below HERE in cache (or 1)
 	strategy	    ; 'forward, 'backward, or 'IN-LIT.
@@ -2548,9 +2578,9 @@ comment at the start of cc-engine.el for
      ((< (- good-pos here) (- here cache-pos)) ; FIXME!!! ; apply some sort of weighting.
       (setq strategy 'backward))
      (t
-      (setq strategy 'forward
+      (setq strategy 'back-and-forward
 	    start-point cache-pos)))
-    (list strategy (and (eq strategy 'forward) start-point))))
+    (list strategy start-point)))
 
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@@ -2670,8 +2700,8 @@ comment at the start of cc-engine.el for
 	      (progn
 		(c-safe
 		  (while
-		      (and (setq ce (scan-lists bra -1 -1)) ; back past )/]/}; might signal
-			   (setq bra (scan-lists ce -1 1)) ; back past (/[/{; might signal
+		      (and (setq ce (c-sc-scan-lists bra -1 -1)) ; back past )/]/}; might signal
+			   (setq bra (c-sc-scan-lists ce -1 1)) ; back past (/[/{; might signal
 			   (or (> bra here) ;(> ce here)
 			       (and
 				(< ce here)
@@ -2714,7 +2744,7 @@ comment at the start of cc-engine.el for
   ;; The brace pair we push is normally the one surrounding BRA+1, but if the
   ;; latter is inside a macro, not being a macro containing
   ;; MACRO-START-OR-HERE, we scan backwards through the buffer for a non-macro
-  ;; base pair.  This latter case is assumed to be rare.
+  ;; base pair.	 This latter case is assumed to be rare.
   ;;
   ;; Note: POINT is not preserved in this routine.
   (if bra+1
@@ -2723,13 +2753,13 @@ comment at the start of cc-engine.el for
 		     (not (c-beginning-of-macro))))
 	  (setq c-state-cache
 		(cons (cons (1- bra+1)
-			    (scan-lists bra+1 1 1))
+			    (c-sc-scan-lists bra+1 1 1))
 		      (if (consp (car c-state-cache))
 			  (cdr c-state-cache)
 			c-state-cache)))
 	;; N.B.	 This defsubst codes one method for the simple, normal case,
 	;; and a more sophisticated, slower way for the general case.  Don't
-	;; eliminate this defsubst - it's a speed optimization.
+	;; eliminate this defsubst - it's a speed optimisation.
 	(c-append-lower-brace-pair-to-state-cache (1- bra+1) (point-max)))))
 
 (defun c-append-to-state-cache (from here)
@@ -2752,30 +2782,30 @@ comment at the start of cc-engine.el for
 	paren+1		      ; Pos after some opening or closing paren.
 	paren+1s	      ; A list of `paren+1's; used to determine a
 			      ; good-pos.
-	bra+1 ce+1	      ; just after L/R bra-ces.
+	bra+1		      ; just after L bra-ce.
 	bra+1s		      ; list of OLD values of bra+1.
 	mstart)		      ; start of a macro.
 
     (save-excursion
       (save-restriction
 	(narrow-to-region (point-min) here)
-	;; Each time round the following loop, we enter a successively deeper
-	;; level of brace/paren nesting.  (Except sometimes we "continue at
-	;; the existing level".)  `pa+1' is a pos inside an opening
+	;; Each time round the following loop, we enter a succesively deeper
+	;; level of brace/paren nesting.	(Except sometimes we "continue at
+	;; the existing level".)	`pa+1' is a pos inside an opening
 	;; brace/paren/bracket, usually just after it.
 	(while
 	    (progn
 	      ;; Each time round the next loop moves forward over an opening then
 	      ;; a closing brace/bracket/paren.  This loop is white hot, so it
 	      ;; plays ugly tricks to go fast.  DON'T PUT ANYTHING INTO THIS
-	      ;; LOOP WHICH ISN'T ABSOLUTELY NECESSARY!!!  It terminates when a
+	      ;; LOOP WHICH ISN'T ABSOLUTELY NECESSARY!!!	 It terminates when a
 	      ;; call of `scan-lists' signals an error, which happens when there
 	      ;; are no more b/b/p's to scan.
 	      (c-safe
 		(while t
-		  (setq pa+1 (scan-lists ren+1 1 -1) ; Into (/{/[; might signal
+		  (setq pa+1 (c-sc-scan-lists ren+1 1 -1) ; Into (/{/[; might signal
 			paren+1s (cons pa+1 paren+1s))
-		  (setq ren+1 (scan-lists pa+1 1 1)) ; Out of )/}/]; might signal
+		  (setq ren+1 (c-sc-scan-lists pa+1 1 1)) ; Out of )/}/]; might signal
 		  (if (and (eq (char-before pa+1) ?{)) ; Check for a macro later.
 		      (setq bra+1 pa+1))
 		  (setcar paren+1s ren+1)))
@@ -2791,7 +2821,7 @@ comment at the start of cc-engine.el for
 		    ;; Insert the opening brace/bracket/paren position.
 		    (setq c-state-cache (cons (1- pa+1) c-state-cache))
 		    ;; Clear admin stuff for the next more nested part of the scan.
-		    (setq ren+1 pa+1  pa+1 nil  bra+1 nil  bra+1s nil)
+		    (setq ren+1 pa+1  pa+1 nil  bra+1 nil	 bra+1s nil)
 		    t)			; Carry on the loop
 
 		;; All open p/b/b's at this nesting level, if any, have probably
@@ -2799,7 +2829,7 @@ comment at the start of cc-engine.el for
 		;; finished - we just need to check for having found an
 		;; unmatched )/}/], which we ignore.  Such a )/}/] can't be in a
 		;; macro, due the action of `c-neutralize-syntax-in-CPP'.
-		(c-safe (setq ren+1 (scan-lists ren+1 1 1)))))) ; acts as loop control.
+		(c-safe (setq ren+1 (c-sc-scan-lists ren+1 1 1)))))) ; acts as loop control.
 
 	;; Record the final, innermost, brace-pair if there is one.
 	(c-state-push-any-brace-pair bra+1 macro-start-or-here)
@@ -2822,9 +2852,10 @@ comment at the start of cc-engine.el for
 
 (defun c-remove-stale-state-cache (start-point here pps-point)
   ;; Remove stale entries from the `c-cache-state', i.e. those which will
-  ;; not be in it when it is amended for position HERE.  Additionally, the
-  ;; "outermost" open-brace entry before HERE will be converted to a cons if
-  ;; the matching close-brace is scanned.
+  ;; not be in it when it is amended for position HERE.  This may involve
+  ;; replacing a CONS element for a brace pair containing HERE with its car.
+  ;; Additionally, the "outermost" open-brace entry before HERE will be
+  ;; converted to a cons if the matching close-brace is below HERE.
   ;;
   ;; START-POINT is a "maximal" "safe position" - there must be no open
   ;; parens/braces/brackets between START-POINT and HERE.
@@ -2835,7 +2866,7 @@ comment at the start of cc-engine.el for
   ;; adjust it to get outside a string/comment.	 (Sorry about this!  The code
   ;; needs to be FAST).
   ;;
-  ;; Return a list (GOOD-POS SCAN-BACK-POS PPS-STATE), where
+  ;; Return a list (GOOD-POS SCAN-BACK-POS CONS-SEPARATED PPS-STATE), where
   ;; o - GOOD-POS is a position where the new value `c-state-cache' is known
   ;;   to be good (we aim for this to be as high as possible);
   ;; o - SCAN-BACK-POS, if not nil, indicates there may be a brace pair
@@ -2843,6 +2874,9 @@ comment at the start of cc-engine.el for
   ;;   position to scan backwards from.  It is the position of the "{" of the
   ;;   last element to be removed from `c-state-cache', when that elt is a
   ;;   cons, otherwise nil.
+  ;; o - CONS-SEPARATED is t when a cons element in `c-state-cache' has been
+  ;;   replaced by its car because HERE lies inside the brace pair represented
+  ;;   by the cons.
   ;; o - PPS-STATE is the parse-partial-sexp state at PPS-POINT.
   (save-excursion
     (save-restriction
@@ -2870,6 +2904,7 @@ comment at the start of cc-engine.el for
 	     pos
 	     upper-lim	   ; ,beyond which `c-state-cache' entries are removed
 	     scan-back-pos
+	     cons-separated
 	     pair-beg pps-point-state target-depth)
 
 	;; Remove entries beyond HERE.  Also remove any entries inside
@@ -2891,7 +2926,8 @@ comment at the start of cc-engine.el for
 		   (consp (car c-state-cache))
 		   (> (cdar c-state-cache) upper-lim))
 	  (setcar c-state-cache (caar c-state-cache))
-	  (setq scan-back-pos (car c-state-cache)))
+	  (setq scan-back-pos (car c-state-cache)
+		cons-separated t))
 
 	;; The next loop jumps forward out of a nested level of parens each
 	;; time round; the corresponding elements in `c-state-cache' are
@@ -2920,7 +2956,7 @@ comment at the start of cc-engine.el for
 
 	  ;; Scan!
 	  (setq pps-state
-		(parse-partial-sexp
+		(c-sc-parse-partial-sexp
 		 (point) (if (< (point) pps-point) pps-point here)
 		 target-depth
 		 nil pps-state))
@@ -2951,9 +2987,10 @@ comment at the start of cc-engine.el for
 	     )))
 
 	(if (< (point) pps-point)
-	    (setq pps-state (parse-partial-sexp (point) pps-point
-						nil nil ; TARGETDEPTH, STOPBEFORE
-						pps-state)))
+	    (setq pps-state (c-sc-parse-partial-sexp
+			     (point) pps-point
+			     nil nil ; TARGETDEPTH, STOPBEFORE
+			     pps-state)))
 
 	;; If the last paren pair we moved out of was actually a brace pair,
 	;; insert it into `c-state-cache'.
@@ -2963,7 +3000,7 @@ comment at the start of cc-engine.el for
 	  (setq c-state-cache (cons (cons pair-beg pos)
 				    c-state-cache)))
 
-	(list pos scan-back-pos pps-state)))))
+	(list pos scan-back-pos cons-separated pps-state)))))
 
 (defun c-remove-stale-state-cache-backwards (here)
   ;; Strip stale elements of `c-state-cache' by moving backwards through the
@@ -2976,13 +3013,13 @@ comment at the start of cc-engine.el for
   ;;
   ;; This function must only be called only when (> `c-state-cache-good-pos'
   ;; HERE).  Usually the gap between CACHE-POS and HERE is large.  It is thus
-  ;; optimized to eliminate (or minimize) scanning between these two
+  ;; optimised to eliminate (or minimise) scanning between these two
   ;; positions.
   ;;
   ;; Return a three element list (GOOD-POS SCAN-BACK-POS FWD-FLAG), where:
   ;; o - GOOD-POS is a "good position", where `c-state-cache' is valid, or
   ;;   could become so after missing elements are inserted into
-  ;;   `c-state-cache'.  This is JUST AFTER an opening or closing
+  ;;   `c-state-cache'.	 This is JUST AFTER an opening or closing
   ;;   brace/paren/bracket which is already in `c-state-cache' or just before
   ;;   one otherwise.  exceptionally (when there's no such b/p/b handy) the BOL
   ;;   before `here''s line, or the start of the literal containing it.
@@ -3009,7 +3046,7 @@ comment at the start of cc-engine.el for
 					; or `here' itself.
 	here- here+		     ; start/end of macro around HERE, or HERE
 	(here-bol (c-point 'bol here))
-	(too-far-back (max (- here c-state-cache-too-far) (point-min))))
+	(too-far-back (max (- here c-state-cache-too-far) 1)))
 
     ;; Remove completely irrelevant entries from `c-state-cache'.
     (while (and c-state-cache
@@ -3074,19 +3111,22 @@ comment at the start of cc-engine.el for
 	(save-restriction
 	  (narrow-to-region here-bol (point-max))
 	  (setq pos here-lit-start)
-	  (c-safe (while (setq pa (scan-lists pos -1 1))
+	  (c-safe (while (setq pa (c-sc-scan-lists pos -1 1))
 		    (setq pos pa))))	; might signal
 	nil))				; for the cond
 
-     ((setq ren (c-safe-scan-lists pos -1 -1 too-far-back))
-       ;; CASE 3: After a }/)/] before `here''s BOL.
-      (list (1+ ren) (and dropped-cons pos) nil)) ; Return value
-
-     (t
-      ;; CASE 4; Best of a bad job: BOL before `here-bol', or beginning of
-      ;; literal containing it.
-      (setq good-pos (c-state-lit-beg (c-point 'bopl here-bol)))
-      (list good-pos (and dropped-cons good-pos) nil)))))
+	((save-restriction
+	   (narrow-to-region too-far-back (point-max))
+	   (setq ren (c-safe (c-sc-scan-lists pos -1 -1))))
+
+	 ;; CASE 3: After a }/)/] before `here''s BOL.
+	 (list (1+ ren) (and dropped-cons pos) nil)) ; Return value
+
+	(t
+	 ;; CASE 4; Best of a bad job: BOL before `here-bol', or beginning of
+	 ;; literal containing it.
+	 (setq good-pos (c-state-lit-beg (c-point 'bopl here-bol)))
+	 (list good-pos (and dropped-cons good-pos) nil)))))
 
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@@ -3143,10 +3183,13 @@ comment at the start of cc-engine.el for
   ;; This function is called from c-after-change.
 
   ;; The caches of non-literals:
-  (if (< here c-state-nonlit-pos-cache-limit)
-      (setq c-state-nonlit-pos-cache-limit here))
-  (if (< here c-state-semi-nonlit-pos-cache-limit)
-      (setq c-state-semi-nonlit-pos-cache-limit here))
+  ;; Note that we use "<=" for the possibility of the second char of a two-char
+  ;; comment opener being typed; this would invalidate any cache position at
+  ;; HERE.
+  (if (<= here c-state-nonlit-pos-cache-limit)
+      (setq c-state-nonlit-pos-cache-limit (1- here)))
+  (if (<= here c-state-semi-nonlit-pos-cache-limit)
+      (setq c-state-semi-nonlit-pos-cache-limit (1- here)))
 
   ;; `c-state-cache':
   ;; Case 1: if `here' is in a literal containing point-min, everything
@@ -3157,10 +3200,11 @@ comment at the start of cc-engine.el for
 	    c-state-cache-good-pos nil
 	    c-state-min-scan-pos nil)
 
-    ;; Truncate `c-state-cache' and set `c-state-cache-good-pos' to a value
-    ;; below `here'.  To maintain its consistency, we may need to insert a new
-    ;; brace pair.
-    (let ((here-bol (c-point 'bol here))
+;;; Truncate `c-state-cache' and set `c-state-cache-good-pos' to a value below
+;;; `here'.  To maintain its consistency, we may need to insert a new brace
+;;; pair.
+    (let (open-paren-in-column-0-is-defun-start
+	  (here-bol (c-point 'bol here))
 	  too-high-pa		  ; recorded {/(/[ next above here, or nil.
 	  dropped-cons		  ; was the last removed element a brace pair?
 	  pa)
@@ -3204,7 +3248,7 @@ comment at the start of cc-engine.el for
   ;;
   ;; [*] N.B. The close "brace" might be a mismatching close bracket or paren.
   ;; This defun explicitly treats mismatching parens/braces/brackets as
-  ;; matching.  It is the open brace which makes it a "brace" pair.
+  ;; matching.	It is the open brace which makes it a "brace" pair.
   ;;
   ;; If POINT is within a macro, open parens and brace pairs within
   ;; THIS macro MIGHT be recorded.  This depends on whether their
@@ -3216,14 +3260,14 @@ comment at the start of cc-engine.el for
   ;; parens are never present here.  Note that this might change.
   ;;
   ;; BUG: This function doesn't cope entirely well with unbalanced
-  ;; parens in macros.  (2008-12-11: this has probably been resolved
+  ;; parens in macros.	(2008-12-11: this has probably been resolved
   ;; by the function `c-neutralize-syntax-in-CPP'.)  E.g. in the
   ;; following case the brace before the macro isn't balanced with the
   ;; one after it:
   ;;
-  ;;     {
-  ;;     #define X {
-  ;;     }
+  ;;	 {
+  ;;	 #define X {
+  ;;	 }
   ;;
   ;; Note to maintainers: this function DOES get called with point
   ;; within comments and strings, so don't assume it doesn't!
@@ -3231,6 +3275,7 @@ comment at the start of cc-engine.el for
   ;; This function might do hidden buffer changes.
   (let* ((here (point))
 	 (here-bopl (c-point 'bopl))
+	 open-paren-in-column-0-is-defun-start
 	 strategy	     ; 'forward, 'backward etc..
 	 ;; Candidate positions to start scanning from:
 	 cache-pos	     ; highest position below HERE already existing in
@@ -3240,6 +3285,7 @@ comment at the start of cc-engine.el for
 		     ; are no open parens/braces between it and HERE.
 	 bopl-state
 	 res
+	 cons-separated
 	 scan-backward-pos scan-forward-p) ; used for 'backward.
     ;; If POINT-MIN has changed, adjust the cache
     (unless (= (point-min) c-state-point-min)
@@ -3252,13 +3298,15 @@ comment at the start of cc-engine.el for
 
     ;; SCAN!
     (cond
-     ((eq strategy 'forward)
+     ((memq strategy '(forward back-and-forward))
       (setq res (c-remove-stale-state-cache start-point here here-bopl))
       (setq cache-pos (car res)
 	    scan-backward-pos (cadr res)
-	    bopl-state (car (cddr res))) ; will be nil if (< here-bopl
+	    cons-separated (car (cddr res)) 
+	    bopl-state (cadr (cddr res))) ; will be nil if (< here-bopl
 					; start-point)
-      (if scan-backward-pos
+      (if (and scan-backward-pos
+	       (or cons-separated (eq strategy 'forward))) ;scan-backward-pos
 	  (c-append-lower-brace-pair-to-state-cache scan-backward-pos here))
       (setq good-pos
 	    (c-append-to-state-cache cache-pos here))
@@ -3291,17 +3339,21 @@ comment at the start of cc-engine.el for
   ;;
   ;; It suppresses the syntactic effect of the < and > (template) brackets and
   ;; of all parens in preprocessor constructs, except for any such construct
-  ;; containing point.  We can then call `c-invalidate-state-cache-1' without
+  ;; containing point.	We can then call `c-invalidate-state-cache-1' without
   ;; worrying further about macros and template delimiters.
-  (c-with-<->-as-parens-suppressed
-   (if (and c-state-old-cpp-beg
-	    (< c-state-old-cpp-beg here))
-       (c-with-all-but-one-cpps-commented-out
-	c-state-old-cpp-beg
-	(min c-state-old-cpp-end here)
-	(c-invalidate-state-cache-1 here))
-     (c-with-cpps-commented-out
-      (c-invalidate-state-cache-1 here)))))
+  (if (memq 'category-properties c-emacs-features)
+      ;; Emacs
+      (c-with-<->-as-parens-suppressed
+       (if (and c-state-old-cpp-beg
+		(< c-state-old-cpp-beg here))
+	   (c-with-all-but-one-cpps-commented-out
+	    c-state-old-cpp-beg
+	    (min c-state-old-cpp-end here)
+	    (c-invalidate-state-cache-1 here))
+	 (c-with-cpps-commented-out
+	  (c-invalidate-state-cache-1 here))))
+    ;; XEmacs
+    (c-invalidate-state-cache-1 here)))
 
 (defmacro c-state-maybe-marker (place marker)
   ;; If PLACE is non-nil, return a marker marking it, otherwise nil.
@@ -3311,31 +3363,36 @@ comment at the start of cc-engine.el for
 	(set-marker ,marker ,place)))
 
 (defun c-parse-state ()
-  ;; This is a wrapper over `c-parse-state-1'.  See that function for a
+  ;; This is a wrapper over `c-parse-state-1'.	See that function for a
   ;; description of the functionality and return value.
   ;;
   ;; It suppresses the syntactic effect of the < and > (template) brackets and
   ;; of all parens in preprocessor constructs, except for any such construct
-  ;; containing point.  We can then call `c-parse-state-1' without worrying
+  ;; containing point.	We can then call `c-parse-state-1' without worrying
   ;; further about macros and template delimiters.
   (let (here-cpp-beg here-cpp-end)
     (save-excursion
-      (when (c-beginning-of-macro)
-	(setq here-cpp-beg (point))
-	(unless
-	    (> (setq here-cpp-end (c-syntactic-end-of-macro))
-	       here-cpp-beg)
-	  (setq here-cpp-beg nil  here-cpp-end nil))))
+      (if (c-beginning-of-macro)
+	  (progn
+	    (setq here-cpp-beg (point))
+	    (unless
+		(> (setq here-cpp-end (c-syntactic-end-of-macro))
+		   here-cpp-beg)
+	      (setq here-cpp-beg nil  here-cpp-end nil)))))
     ;; FIXME!!! Put in a `condition-case' here to protect the integrity of the
     ;; subsystem.
     (prog1
-	(c-with-<->-as-parens-suppressed
-	 (if (and here-cpp-beg (> here-cpp-end here-cpp-beg))
-	     (c-with-all-but-one-cpps-commented-out
-	      here-cpp-beg here-cpp-end
-	      (c-parse-state-1))
-	   (c-with-cpps-commented-out
-	    (c-parse-state-1))))
+	(if (memq 'category-properties c-emacs-features)
+	    ;; Emacs
+	    (c-with-<->-as-parens-suppressed
+	     (if (and here-cpp-beg (> here-cpp-end here-cpp-beg))
+		 (c-with-all-but-one-cpps-commented-out
+		  here-cpp-beg here-cpp-end
+		  (c-parse-state-1))
+	       (c-with-cpps-commented-out
+		(c-parse-state-1))))
+	  ;; XEmacs
+	  (c-parse-state-1))
       (setq c-state-old-cpp-beg
 	    (c-state-maybe-marker here-cpp-beg c-state-old-cpp-beg-marker)
 	    c-state-old-cpp-end
@@ -3350,6 +3407,7 @@ comment at the start of cc-engine.el for
 
 (defvar c-parse-state-point nil)
 (defvar c-parse-state-state nil)
+(make-variable-buffer-local 'c-parse-state-state)
 (defun c-record-parse-state-state ()
   (setq c-parse-state-point (point))
   (setq c-parse-state-state
@@ -3357,9 +3415,16 @@ comment at the start of cc-engine.el for
 	 (lambda (arg)
 	   (let ((val (symbol-value arg)))
 	     (cons arg
-		   (if (consp val)
-		       (copy-tree val)
-		     val))))
+
+		   ;; (if (consp val)
+		   ;;     (copy-tree val)
+		   ;;   val)
+
+		   (cond ((consp val) (copy-tree val))
+			 ((markerp val) (copy-marker val))
+			 (t val))
+
+)))
 	 '(c-state-cache
 	   c-state-cache-good-pos
 	   c-state-nonlit-pos-cache
@@ -3379,7 +3444,11 @@ comment at the start of cc-engine.el for
    (concat "(setq "
     (mapconcat
      (lambda (arg)
-       (format "%s %s%s" (car arg) (if (atom (cdr arg)) "" "'") (cdr arg)))
+       (format "%s %s%s" (car arg)
+	       (if (atom (cdr arg)) "" "'")
+	       (if (markerp (cdr arg))
+		   (format "(copy-marker %s)" (marker-position (cdr arg)))
+		 (cdr arg))))
      c-parse-state-state "  ")
     ")")))
 
@@ -3480,7 +3549,7 @@ comment at the start of cc-engine.el for
 	      (if (< bufpos (cdr car))
 		  ;; its possible that the open brace is before
 		  ;; bufpos, but the close brace is after.  In that
-		  ;; case, convert this to a non-cons element.  The
+		  ;; case, convert this to a non-cons element.	The
 		  ;; rest of the state is before bufpos, so we're
 		  ;; done.
 		  (throw 'done (cons (car car) (cdr paren-state)))
@@ -3522,7 +3591,7 @@ comment at the start of cc-engine.el for
 
 (defun c-safe-position (bufpos paren-state)
   ;; Return the closest "safe" position recorded on PAREN-STATE that
-  ;; is higher up than BUFPOS.  Return nil if PAREN-STATE doesn't
+  ;; is higher up than BUFPOS.	Return nil if PAREN-STATE doesn't
   ;; contain any.  Return nil if BUFPOS is nil, which is useful to
   ;; find the closest limit before a given limit that might be nil.
   ;;
@@ -3551,7 +3620,7 @@ comment at the start of cc-engine.el for
 	  (setq paren-state (cdr paren-state)))))))
 
 (defun c-beginning-of-syntax ()
-  ;; This is used for `font-lock-beginning-of-syntax-function'.  It
+  ;; This is used for `font-lock-beginning-of-syntax-function'.	 It
   ;; goes to the closest previous point that is known to be outside
   ;; any string literal or comment.  `c-state-cache' is used if it has
   ;; a position in the vicinity.
@@ -3590,12 +3659,12 @@ comment at the start of cc-engine.el for
 
 (defun c-on-identifier ()
   "Return non-nil if the point is on or directly after an identifier.
-Keywords are recognized and not considered identifiers.  If an
+Keywords are recognized and not considered identifiers.	 If an
 identifier is detected, the returned value is its starting position.
 If an identifier ends at the point and another begins at it \(can only
 happen in Pike) then the point for the preceding one is returned.
 
-Note that this function might do hidden buffer changes.  See the
+Note that this function might do hidden buffer changes.	 See the
 comment at the start of cc-engine.el for more info."
 
   ;; FIXME: Shouldn't this function handle "operator" in C++?
@@ -3721,7 +3790,7 @@ A token is defined as all symbols and id
 syntactic whitespace \(note that multicharacter tokens like \"==\" are
 treated properly).  Point is always either left at the beginning of a
 token or not moved at all.  COUNT specifies the number of tokens to
-move; a negative COUNT moves in the opposite direction.  A COUNT of 0
+move; a negative COUNT moves in the opposite direction.	 A COUNT of 0
 moves to the next token beginning only if not already at one.  If
 BALANCED is true, move over balanced parens, otherwise move into them.
 Also, if BALANCED is true, never move out of an enclosing paren.
@@ -3737,7 +3806,7 @@ be returned.  Thus, a return value of 0
 the requested position and a return value less \(without signs) than
 COUNT guarantees that point is at the beginning of some token.
 
-Note that this function might do hidden buffer changes.  See the
+Note that this function might do hidden buffer changes.	 See the
 comment at the start of cc-engine.el for more info."
 
   (or count (setq count 1))
@@ -3758,7 +3827,7 @@ comment at the start of cc-engine.el for
 	(if limit (narrow-to-region (point-min) limit))
 	(if (/= (point)
 		(progn (c-forward-syntactic-ws) (point)))
-	    ;; Skip whitespace.  Count this as a move if we did in
+	    ;; Skip whitespace.	 Count this as a move if we did in
 	    ;; fact move.
 	    (setq count (max (1- count) 0)))
 
@@ -3894,7 +3963,7 @@ for compatibility only; it's only a wrap
 				      lookbehind-submatch)
   "Like `re-search-forward', but only report matches that are found
 in syntactically significant text.  I.e. matches in comments, macros
-or string literals are ignored.  The start point is assumed to be
+or string literals are ignored.	 The start point is assumed to be
 outside any comment, macro or string literal, or else the content of
 that region is taken as syntactically significant text.
 
@@ -3929,7 +3998,7 @@ Bug: Unbalanced parens inside cpp direct
 correctly \(i.e. they don't get ignored as they should) when
 PAREN-LEVEL is set.
 
-Note that this function might do hidden buffer changes.  See the
+Note that this function might do hidden buffer changes.	 See the
 comment at the start of cc-engine.el for more info."
 
   (or bound (setq bound (point-max)))
@@ -3988,7 +4057,7 @@ comment at the start of cc-engine.el for
 
 	       (cond
 		((elt check-state 7)
-		 ;; Match inside a line comment.  Skip to eol.  Use
+		 ;; Match inside a line comment.  Skip to eol.	Use
 		 ;; `re-search-forward' instead of `skip-chars-forward' to get
 		 ;; the right bound behavior.
 		 (re-search-forward "[\n\r]" bound noerror))
@@ -4108,14 +4177,13 @@ comment at the start of cc-engine.el for
 	  (goto-char (match-end 0))
 	  (match-end 0))
 
-      ;; Search failed.  Set point as appropriate.
+      ;; Search failed.	 Set point as appropriate.
       (if (eq noerror t)
 	  (goto-char start)
 	(goto-char bound))
       nil)))
 
-(defvar safe-pos-list)		  ; bound in c-syntactic-skip-backward
-
+(cc-bytecomp-defvar safe-pos-list)
 (defsubst c-ssb-lit-begin ()
   ;; Return the start of the literal point is in, or nil.
   ;; We read and write the variables `safe-pos', `safe-pos-list', `state'
@@ -4124,7 +4192,7 @@ comment at the start of cc-engine.el for
   ;; Use `parse-partial-sexp' from a safe position down to the point to check
   ;; if it's outside comments and strings.
   (save-excursion
-    (let ((pos (point)) safe-pos state pps-end-pos)
+    (let ((pos (point)) safe-pos state)
       ;; Pick a safe position as close to the point as possible.
       ;;
       ;; FIXME: Consult `syntax-ppss' here if our cache doesn't give a good
@@ -4144,7 +4212,7 @@ comment at the start of cc-engine.el for
       ;; Cache positions along the way to use if we have to back up more.  We
       ;; cache every closing paren on the same level.  If the paren cache is
       ;; relevant in this region then we're typically already on the same
-      ;; level as the target position.  Note that we might cache positions
+      ;; level as the target position.	Note that we might cache positions
       ;; after opening parens in case safe-pos is in a nested list.  That's
       ;; both uncommon and harmless.
       (while (progn
@@ -4163,7 +4231,7 @@ comment at the start of cc-engine.el for
 		safe-pos-list (cons safe-pos safe-pos-list)))
 
       (if (or (elt state 3) (elt state 4))
-	  ;; Inside string or comment.  Continue search at the
+	  ;; Inside string or comment.	Continue search at the
 	  ;; beginning of it.
 	  (elt state 8)))))
 
@@ -4181,7 +4249,7 @@ then the point will be left at the limit
 
 Non-nil is returned if the point moved, nil otherwise.
 
-Note that this function might do hidden buffer changes.  See the
+Note that this function might do hidden buffer changes.	 See the
 comment at the start of cc-engine.el for more info."
 
   (let ((start (point))
@@ -4206,16 +4274,18 @@ comment at the start of cc-engine.el for
 	  ;; loops when it hasn't succeeded.
 	  (while
 	      (and
-	       (< (skip-chars-backward skip-chars limit) 0)
+	       (let ((pos (point)))
+		 (while (and
+			 (< (skip-chars-backward skip-chars limit) 0)
+			 ;; Don't stop inside a literal.
+			 (when (setq lit-beg (c-ssb-lit-begin))
+			   (goto-char lit-beg)
+			   t)))
+		 (< (point) pos))
 
 	       (let ((pos (point)) state-2 pps-end-pos)
 
 		 (cond
-		  ;; Don't stop inside a literal
-		  ((setq lit-beg (c-ssb-lit-begin))
-		   (goto-char lit-beg)
-		   t)
-
 		  ((and paren-level
 			(save-excursion
 			  (setq state-2 (parse-partial-sexp
@@ -4236,7 +4306,7 @@ comment at the start of cc-engine.el for
 			      (< (car state-2) 0)))
 
 		       ;; We've stopped short of the starting position
-		       ;; so the hit was inside a nested list.  Go up
+		       ;; so the hit was inside a nested list.	Go up
 		       ;; until we are at the right level.
 		       (condition-case nil
 			   (progn
@@ -4316,7 +4386,7 @@ comment at the start of cc-engine.el for
 ;;(defun c-syntactic-skip-backward (skip-chars &optional limit paren-level)
 ;;  "Like `skip-chars-backward' but only look at syntactically relevant chars,
 ;;i.e. don't stop at positions inside syntactic whitespace or string
-;;literals.  Preprocessor directives are also ignored.  However, if the
+;;literals.  Preprocessor directives are also ignored.	However, if the
 ;;point is within a comment, string literal or preprocessor directory to
 ;;begin with, its contents is treated as syntactically relevant chars.
 ;;If LIMIT is given, it limits the backward search and the point will be
@@ -4413,7 +4483,7 @@ or nil, `c-beginning-of-defun' is used.
 The last point calculated is cached if the cache is enabled, i.e. if
 `c-in-literal-cache' is bound to a two element vector.
 
-Note that this function might do hidden buffer changes.  See the
+Note that this function might do hidden buffer changes.	 See the
 comment at the start of cc-engine.el for more info."
   (save-restriction
     (widen)
@@ -4428,15 +4498,15 @@ comment at the start of cc-engine.el for
   "Return a cons of the beginning and end positions of the comment or
 string surrounding point (including both delimiters), or nil if point
 isn't in one.  If LIM is non-nil, it's used as the \"safe\" position
-to start parsing from.  If NEAR is non-nil, then the limits of any
+to start parsing from.	If NEAR is non-nil, then the limits of any
 literal next to point is returned.  \"Next to\" means there's only
-spaces and tabs between point and the literal.  The search for such a
+spaces and tabs between point and the literal.	The search for such a
 literal is done first in forward direction.  If NOT-IN-DELIMITER is
 non-nil, the case when point is inside a starting delimiter won't be
 recognized.  This only has effect for comments which have starting
 delimiters with more than one character.
 
-Note that this function might do hidden buffer changes.  See the
+Note that this function might do hidden buffer changes.	 See the
 comment at the start of cc-engine.el for more info."
 
   (save-excursion
@@ -4444,19 +4514,12 @@ comment at the start of cc-engine.el for
 	   (lim (or lim (c-state-semi-safe-place pos)))
 	   (pp-to-lit (save-restriction
 			(widen)
-			(c-state-pp-to-literal lim pos)))
+			(c-state-pp-to-literal lim pos not-in-delimiter)))
 	   (state (car pp-to-lit))
 	   (lit-limits (car (cddr pp-to-lit))))
 
       (cond
        (lit-limits)
-       ((and (not not-in-delimiter)
-	     (not (elt state 5))
-	     (eq (char-before) ?/)
-	     (looking-at "[/*]")) ; FIXME!!! use c-line/block-comment-starter.  2008-09-28.
-	;; We're standing in a comment starter.
-	(backward-char 1)
-	(cons (point) (progn (c-forward-single-comment) (point))))
 
        (near
 	(goto-char pos)
@@ -4501,10 +4564,10 @@ comment at the start of cc-engine.el for
 `c-literal-limits'), and that range contains a C++ style line comment,
 then an extended range is returned that contains all adjacent line
 comments (i.e. all comments that starts in the same column with no
-empty lines or non-whitespace characters between them).  Otherwise the
+empty lines or non-whitespace characters between them).	 Otherwise the
 argument is returned.
 
-Note that this function might do hidden buffer changes.  See the
+Note that this function might do hidden buffer changes.	 See the
 comment at the start of cc-engine.el for more info."
 
   (save-excursion
@@ -4541,7 +4604,7 @@ of the symbols 'c, 'c++ or 'string.  It'
 `c-in-literal' and is intended to be used when you need both the
 type of a literal and its limits.
 
-Note that this function might do hidden buffer changes.  See the
+Note that this function might do hidden buffer changes.	 See the
 comment at the start of cc-engine.el for more info."
 
   (if (consp range)
@@ -4551,7 +4614,7 @@ comment at the start of cc-engine.el for
 	      ((or (looking-at "//") ; c++ line comment
 		   (and (looking-at "\\s<") ; comment starter
 			(looking-at "#"))) ; awk comment.
-               'c++)
+	       'c++)
 	      (t 'c)))			; Assuming the range is valid.
     range))
 
@@ -4716,6 +4779,11 @@ comment at the start of cc-engine.el for
   ;; inside `c-find-decl-spots'.  The point is left at `cfd-match-pos'
   ;; if there is a match, otherwise at `cfd-limit'.
   ;;
+  ;; The macro moves point forward to the next putative start of a declaration
+  ;; or cfd-limit.  This decl start is the next token after a "declaration
+  ;; prefix".  The declaration prefix is the earlier of `cfd-prop-match' and
+  ;; `cfd-re-match'.  `cfd-match-pos' is set to the decl prefix.
+  ;; 
   ;; This macro might do hidden buffer changes.
 
   '(progn
@@ -4723,7 +4791,7 @@ comment at the start of cc-engine.el for
      (unless cfd-prop-match
        (save-excursion
 	 (while (progn
-		  (goto-char (next-single-property-change
+		  (goto-char (c-next-single-property-change
 			      (point) 'c-type nil cfd-limit))
 		  (and (< (point) cfd-limit)
 		       (not (eq (c-get-char-property (1- (point)) 'c-type)
@@ -4737,34 +4805,47 @@ comment at the start of cc-engine.el for
        (if (> cfd-re-match-end (point))
 	   (goto-char cfd-re-match-end))
 
-       (while (if (setq cfd-re-match-end
-			(re-search-forward c-decl-prefix-or-start-re
-					   cfd-limit 'move))
-
-		  ;; Match.  Check if it's inside a comment or string literal.
-		  (c-got-face-at
-		   (if (setq cfd-re-match (match-end 1))
-		       ;; Matched the end of a token preceding a decl spot.
-		       (progn
-			 (goto-char cfd-re-match)
-			 (1- cfd-re-match))
-		     ;; Matched a token that start a decl spot.
-		     (goto-char (match-beginning 0))
-		     (point))
-		   c-literal-faces)
-
-		;; No match.  Finish up and exit the loop.
-		(setq cfd-re-match cfd-limit)
-		nil)
-
-	 ;; Skip out of comments and string literals.
-	 (while (progn
-		  (goto-char (next-single-property-change
-			      (point) 'face nil cfd-limit))
-		  (and (< (point) cfd-limit)
-		       (c-got-face-at (point) c-literal-faces)))))
+       ;; Each time round, the next `while' moves forward over a pseudo match
+       ;; of `c-decl-prefix-or-start-re' which is either inside a literal, or
+       ;; is a ":" not preceded by "public", etc..  `cfd-re-match' and
+       ;; `cfd-re-match-end' get set.
+       (while
+	   (progn
+	     (setq cfd-re-match-end (re-search-forward c-decl-prefix-or-start-re
+						       cfd-limit 'move))
+	     (cond
+	      ((null cfd-re-match-end)
+	       ;; No match.  Finish up and exit the loop.
+	       (setq cfd-re-match cfd-limit)
+	       nil)
+	      ((c-got-face-at
+		(if (setq cfd-re-match (match-end 1))
+		    ;; Matched the end of a token preceding a decl spot.
+		    (progn
+		      (goto-char cfd-re-match)
+		      (1- cfd-re-match))
+		  ;; Matched a token that start a decl spot.
+		  (goto-char (match-beginning 0))
+		  (point))
+		c-literal-faces)
+	       ;; Pseudo match inside a comment or string literal.  Skip out
+	       ;; of comments and string literals.
+	       (while (progn
+			(goto-char (c-next-single-property-change
+				    (point) 'face nil cfd-limit))
+			(and (< (point) cfd-limit)
+			     (c-got-face-at (point) c-literal-faces))))
+	       t)		      ; Continue the loop over pseudo matches.
+	      ((and (match-string 1)
+		    (string= (match-string 1) ":")
+		    (save-excursion
+		      (or (/= (c-backward-token-2 2) 0) ; no search limit.  :-(
+			  (not (looking-at c-decl-start-colon-kwd-re)))))
+	       ;; Found a ":" which isn't part of "public:", etc.
+	       t)
+	      (t nil)))) ;; Found a real match.  Exit the pseudo-match loop.
 
-       ;; If we matched at the decl start, we have to back up over the
+       ;; If our match was at the decl start, we have to back up over the
        ;; preceding syntactic ws to set `cfd-match-pos' and to catch
        ;; any decl spots in the syntactic ws.
        (unless cfd-re-match
@@ -4805,14 +4886,17 @@ comment at the start of cc-engine.el for
   ;; it should return non-nil to ensure that the next search will find them.
   ;;
   ;; Such a spot is:
-  ;; o  The first token after bob.
-  ;; o  The first token after the end of submatch 1 in
-  ;;    `c-decl-prefix-or-start-re' when that submatch matches.
-  ;; o  The start of each `c-decl-prefix-or-start-re' match when
-  ;;    submatch 1 doesn't match.
-  ;; o  The first token after the end of each occurrence of the
-  ;;    `c-type' text property with the value `c-decl-end', provided
-  ;;    `c-type-decl-end-used' is set.
+  ;; o	The first token after bob.
+  ;; o	The first token after the end of submatch 1 in
+  ;;	`c-decl-prefix-or-start-re' when that submatch matches.	 This
+  ;;	submatch is typically a (L or R) brace or paren, a ;, or a ,.
+  ;; o	The start of each `c-decl-prefix-or-start-re' match when
+  ;;	submatch 1 doesn't match.  This is, for example, the keyword
+  ;;	"class" in Pike.
+  ;; o	The start of a previously recognized declaration; "recognized"
+  ;;	means that the last char of the previous token has a `c-type'
+  ;;	text property with the value `c-decl-end'; this only holds
+  ;;	when `c-type-decl-end-used' is set.
   ;;
   ;; Only a spot that match CFD-DECL-RE and whose face is in the
   ;; CFD-FACE-CHECKLIST list causes CFD-FUN to be called.  The face
@@ -4844,7 +4928,7 @@ comment at the start of cc-engine.el for
   ;;
   ;; This function might do hidden buffer changes.
 
-  (let ((cfd-start-pos (point))
+  (let ((cfd-start-pos (point))		; never changed
 	(cfd-buffer-end (point-max))
 	;; The end of the token preceding the decl spot last found
 	;; with `c-decl-prefix-or-start-re'.  `cfd-limit' if there's
@@ -4855,13 +4939,22 @@ comment at the start of cc-engine.el for
 	;; next regexp search is started here instead.
 	(cfd-re-match-end (point-min))
 	;; The end of the last `c-decl-end' found by
-	;; `c-find-decl-prefix-search'.  `cfd-limit' if there's no
+	;; `c-find-decl-prefix-search'.	 `cfd-limit' if there's no
 	;; match.  If searching for the property isn't needed then we
 	;; disable it by setting it to `cfd-limit' directly.
-	(cfd-prop-match (unless c-type-decl-end-used cfd-limit))
+	(cfd-prop-match
+	 (if c-type-decl-end-used
+	     (save-excursion
+	       (c-backward-syntactic-ws)
+	       (and
+		(not (bobp))
+		(eq (c-get-char-property (1- (point)) 'c-type)
+		    'c-decl-end)
+		(point)))
+	   cfd-limit))
 	;; The end of the token preceding the decl spot last found by
-	;; `c-find-decl-prefix-search'.  0 for the implicit match at
-	;; bob.  `cfd-limit' if there's no match.  In other words,
+	;; `c-find-decl-prefix-search'.	 0 for the implicit match at
+	;; bob.	 `cfd-limit' if there's no match.  In other words,
 	;; this is the minimum of `cfd-re-match' and `cfd-prop-match'.
 	(cfd-match-pos cfd-limit)
 	;; The position to continue searching at.
@@ -4883,13 +4976,23 @@ comment at the start of cc-engine.el for
       ;; statement or declaration, which is earlier than the first
       ;; returned match.
 
+      ;; This `cond' moves back over any literals or macros.  It has special
+      ;; handling for when the region being searched is entirely within a
+      ;; macro.  It sets `cfd-continue-pos' (unless we've reached
+      ;; `cfd-limit').
       (cond
        ;; First we need to move to a syntactically relevant position.
        ;; Begin by backing out of comment or string literals.
+       ;;
+       ;; This arm of the cond actually triggers if we're in a literal,
+       ;; and cfd-limit is at most at BONL.
        ((and
+	 ;; This arm of the `and' moves backwards out of a literal when
+	 ;; the face at point is a literal face.  In this case, its value
+	 ;; is always non-nil.
 	 (when (c-got-face-at (point) c-literal-faces)
 	   ;; Try to use the faces to back up to the start of the
-	   ;; literal.  FIXME: What if the point is on a declaration
+	   ;; literal.	FIXME: What if the point is on a declaration
 	   ;; inside a comment?
 	   (while (and (not (bobp))
 		       (c-got-face-at (1- (point)) c-literal-faces))
@@ -4915,10 +5018,10 @@ comment at the start of cc-engine.el for
 	     (let ((range (c-literal-limits)))
 	       (if range (goto-char (car range)))))
 
-	   (setq start-in-literal (point)))
+	   (setq start-in-literal (point))) ; end of `and' arm.
 
-	 ;; The start is in a literal.  If the limit is in the same
-	 ;; one we don't have to find a syntactic position etc.  We
+	 ;; The start is in a literal.	If the limit is in the same
+	 ;; one we don't have to find a syntactic position etc.	 We
 	 ;; only check that if the limit is at or before bonl to save
 	 ;; time; it covers the by far most common case when font-lock
 	 ;; refontifies the current line only.
@@ -4926,22 +5029,22 @@ comment at the start of cc-engine.el for
 	 (save-excursion
 	   (goto-char cfd-start-pos)
 	   (while (progn
-		    (goto-char (next-single-property-change
+		    (goto-char (c-next-single-property-change
 				(point) 'face nil cfd-limit))
 		    (and (< (point) cfd-limit)
 			 (c-got-face-at (point) c-literal-faces))))
-	   (= (point) cfd-limit)))
+	   (= (point) cfd-limit)))	; end of `cond' arm condition
 
-	;; Completely inside a literal.  Set up variables to trig the
+	;; Completely inside a literal.	 Set up variables to trig the
 	;; (< cfd-continue-pos cfd-start-pos) case below and it'll
 	;; find a suitable start position.
-	(setq cfd-continue-pos start-in-literal))
+	(setq cfd-continue-pos start-in-literal)) ; end of `cond' arm
 
        ;; Check if the region might be completely inside a macro, to
        ;; optimize that like the completely-inside-literal above.
        ((save-excursion
 	  (and (= (forward-line 1) 0)
-	       (bolp)			; forward-line has funny behavior at eob.
+	       (bolp)		     ; forward-line has funny behavior at eob.
 	       (>= (point) cfd-limit)
 	       (progn (backward-char)
 		      (eq (char-before) ?\\))))
@@ -4951,6 +5054,8 @@ comment at the start of cc-engine.el for
 	(setq cfd-continue-pos (1- cfd-start-pos)
 	      start-in-macro t))
 
+       ;; The default arm of the `cond' moves back over any macro we're in
+       ;; and over any syntactic WS.  It sets `c-find-decl-syntactic-pos'.
        (t
 	;; Back out of any macro so we don't miss any declaration
 	;; that could follow after it.
@@ -4987,7 +5092,7 @@ comment at the start of cc-engine.el for
 
 	  (when (if (bobp)
 		    ;; Always consider bob a match to get the first
-		    ;; declaration in the file.  Do this separately instead of
+		    ;; declaration in the file.	 Do this separately instead of
 		    ;; letting `c-decl-prefix-or-start-re' match bob, so that
 		    ;; regexp always can consume at least one character to
 		    ;; ensure that we won't get stuck in an infinite loop.
@@ -4997,14 +5102,14 @@ comment at the start of cc-engine.el for
 		  (< (point) cfd-limit))
 	    ;; Do an initial search now.  In the bob case above it's
 	    ;; only done to search for a `c-decl-end' spot.
-	    (c-find-decl-prefix-search))
+	    (c-find-decl-prefix-search)) ; sets cfd-continue-pos
 
 	  (setq c-find-decl-match-pos (and (< cfd-match-pos cfd-start-pos)
-					   cfd-match-pos)))))
+					   cfd-match-pos))))) ; end of `cond'
 
       ;; Advance `cfd-continue-pos' if it's before the start position.
       ;; The closest continue position that might have effect at or
-      ;; after the start depends on what we started in.  This also
+      ;; after the start depends on what we started in.	 This also
       ;; finds a suitable start position in the special cases when the
       ;; region is completely within a literal or macro.
       (when (and cfd-continue-pos (< cfd-continue-pos cfd-start-pos))
@@ -5059,7 +5164,7 @@ comment at the start of cc-engine.el for
 	  ;; `cfd-match-pos' so we can continue at the start position.
 	  ;; (Note that we don't get here if the first match is below
 	  ;; it.)
-	  (goto-char cfd-start-pos)))
+	  (goto-char cfd-start-pos)))	; end of `cond'
 
 	;; Delete found matches if they are before our new continue
 	;; position, so that `c-find-decl-prefix-search' won't back up
@@ -5068,11 +5173,11 @@ comment at the start of cc-engine.el for
 	(when (and cfd-re-match (< cfd-re-match cfd-continue-pos))
 	  (setq cfd-re-match nil))
 	(when (and cfd-prop-match (< cfd-prop-match cfd-continue-pos))
-	  (setq cfd-prop-match nil)))
+	  (setq cfd-prop-match nil)))	; end of `when'
 
       (if syntactic-pos
 	  ;; This is the normal case and we got a proper syntactic
-	  ;; position.  If there's a match then it's always outside
+	  ;; position.	If there's a match then it's always outside
 	  ;; macros and comments, so advance to the next token and set
 	  ;; `cfd-token-pos'.  The loop below will later go back using
 	  ;; `cfd-continue-pos' to fix declarations inside the
@@ -5089,9 +5194,10 @@ comment at the start of cc-engine.el for
 	;; good start position for the search, so do it.
 	(c-find-decl-prefix-search)))
 
-    ;; Now loop.  Round what?  (ACM, 2006/7/5).  We already got the first match.
-
+    ;; Now loop, one decl spot per iteration.  We already have the first
+    ;; match in `cfd-match-pos'.
     (while (progn
+	     ;; Go foward over "false matches", one per iteration.
 	     (while (and
 		     (< cfd-match-pos cfd-limit)
 
@@ -5132,10 +5238,10 @@ comment at the start of cc-engine.el for
 			  (goto-char cfd-continue-pos)
 			  t)))
 
-		     (< (point) cfd-limit))
-	       (c-find-decl-prefix-search))
+		     (< (point) cfd-limit)) ; end of "false matches" condition
+	       (c-find-decl-prefix-search)) ; end of "false matches" loop
 
-	     (< (point) cfd-limit))
+	     (< (point) cfd-limit))   ; end of condition for "decl-spot" while
 
       (when (and
 	     (>= (point) cfd-start-pos)
@@ -5163,14 +5269,14 @@ comment at the start of cc-engine.el for
 		   ;; The matched token was the last thing in the macro,
 		   ;; so the whole match is bogus.
 		   (setq cfd-macro-end 0)
-		   nil))))
+		   nil))))		; end of when condition
 
 	(c-debug-put-decl-spot-faces cfd-match-pos (point))
 	(if (funcall cfd-fun cfd-match-pos (/= cfd-macro-end 0))
 	    (setq cfd-prop-match nil))
 
 	(when (/= cfd-macro-end 0)
-	  ;; Restore limits if we did macro narrowing above.
+	  ;; Restore limits if we did macro narrowment above.
 	  (narrow-to-region (point-min) cfd-buffer-end)))
 
       (goto-char cfd-continue-pos)
@@ -5212,11 +5318,11 @@ comment at the start of cc-engine.el for
   (setq c-found-types (make-vector 53 0)))
 
 (defun c-add-type (from to)
-  ;; Add the given region as a type in `c-found-types'.  If the region
+  ;; Add the given region as a type in `c-found-types'.	 If the region
   ;; doesn't match an existing type but there is a type which is equal
   ;; to the given one except that the last character is missing, then
   ;; the shorter type is removed.  That's done to avoid adding all
-  ;; prefixes of a type as it's being entered and font locked.  This
+  ;; prefixes of a type as it's being entered and font locked.	This
   ;; doesn't cover cases like when characters are removed from a type
   ;; or added in the middle.  We'd need the position of point when the
   ;; font locking is invoked to solve this well.
@@ -5249,13 +5355,10 @@ comment at the start of cc-engine.el for
 	      c-found-types)
     (sort type-list 'string-lessp)))
 
-;; Shut up the byte compiler.
-(defvar c-maybe-stale-found-type)
-
 (defun c-trim-found-types (beg end old-len)
   ;; An after change function which, in conjunction with the info in
   ;; c-maybe-stale-found-type (set in c-before-change), removes a type
-  ;; from `c-found-types', should this type have become stale.  For
+  ;; from `c-found-types', should this type have become stale.	For
   ;; example, this happens to "foo" when "foo \n bar();" becomes
   ;; "foo(); \n bar();".  Such stale types, if not removed, foul up
   ;; the fontification.
@@ -5290,7 +5393,7 @@ comment at the start of cc-engine.el for
        ;; destroyed.
        ((eq (car c-maybe-stale-found-type) 'c-decl-id-start)
 	(c-unfind-type (cadr c-maybe-stale-found-type)))
-;;        ((eq (car c-maybe-stale-found-type) 'c-decl-type-start)  FIXME!!!
+;;	  ((eq (car c-maybe-stale-found-type) 'c-decl-type-start)  FIXME!!!
 	)))
 
 
@@ -5298,7 +5401,7 @@ comment at the start of cc-engine.el for
 ;; and Java) where they can be template/generic delimiters as well as
 ;; their normal meaning of "less/greater than".
 
-;; Normally, < and > have syntax 'punctuation'.  When they are found to
+;; Normally, < and > have syntax 'punctuation'.	 When they are found to
 ;; be delimiters, they are marked as such with the category properties
 ;; c-<-as-paren-syntax, c->-as-paren-syntax respectively.
 
@@ -5319,7 +5422,7 @@ comment at the start of cc-engine.el for
 ;; The strategy now (2010-01) adopted is to mark and unmark < and
 ;; > IN MATCHING PAIRS ONLY.  [Previously, they were marked
 ;; individually when their context so indicated.  This gave rise to
-;; intractable problems when one of a matching pair was deleted, or
+;; intractible problems when one of a matching pair was deleted, or
 ;; pulled into a literal.]
 ;;
 ;; At each buffer change, the syntax-table properties are removed in a
@@ -5343,8 +5446,8 @@ comment at the start of cc-engine.el for
 	(c-go-list-forward))
       (when (equal (c-get-char-property (1- (point)) 'syntax-table)
 		   c->-as-paren-syntax) ; should always be true.
-	(c-clear-char-property (1- (point)) 'category))
-      (c-clear-char-property pos 'category))))
+	(c-unmark-<->-as-paren (1- (point))))
+      (c-unmark-<->-as-paren pos))))
 
 (defun c-clear->-pair-props (&optional pos)
   ;; POS (default point) is at a > character.  If it is marked with
@@ -5360,8 +5463,8 @@ comment at the start of cc-engine.el for
 	(c-go-up-list-backward))
       (when (equal (c-get-char-property (point) 'syntax-table)
 			c-<-as-paren-syntax) ; should always be true.
-	(c-clear-char-property (point) 'category))
-      (c-clear-char-property pos 'category))))
+	(c-unmark-<->-as-paren (point)))
+      (c-unmark-<->-as-paren (point)))))
 
 (defun c-clear-<>-pair-props (&optional pos)
   ;; POS (default point) is at a < or > character.  If it has an
@@ -5418,10 +5521,6 @@ comment at the start of cc-engine.el for
 	(c-unmark-<->-as-paren pos))
       t)))
 
-;; Set by c-common-init in cc-mode.el.
-(defvar c-new-BEG)
-(defvar c-new-END)
-
 (defun c-before-change-check-<>-operators (beg end)
   ;; Unmark certain pairs of "< .... >" which are currently marked as
   ;; template/generic delimiters.  (This marking is via syntax-table
@@ -5450,9 +5549,10 @@ comment at the start of cc-engine.el for
       (c-syntactic-skip-backward "^;{}" (c-determine-limit 512))
       (setq new-beg (point))
 
-      ;; Remove the syntax-table properties from each pertinent <...> pair.
-      ;; Firsly, the ones with the < before beg and > after beg.
-      (while (c-search-forward-char-property 'category 'c-<-as-paren-syntax beg)
+      ;; Remove the syntax-table/category properties from each pertinent <...>
+      ;; pair.  Firsly, the ones with the < before beg and > after beg.
+      (while
+	  (c-search-forward-char-property 'syntax-table c-<-as-paren-syntax beg)
 	(if (c-clear-<-pair-props-if-match-after beg (1- (point)))
 	    (setq need-new-beg t)))
 
@@ -5463,7 +5563,7 @@ comment at the start of cc-engine.el for
 
       ;; Remove syntax-table properties from the remaining pertinent <...>
       ;; pairs, those with a > after end and < before end.
-      (while (c-search-backward-char-property 'category 'c->-as-paren-syntax end)
+      (while (c-search-backward-char-property 'syntax-table c->-as-paren-syntax end)
 	(if (c-clear->-pair-props-if-match-before end)
 	    (setq need-new-end t)))
 
@@ -5476,8 +5576,6 @@ comment at the start of cc-engine.el for
       (when need-new-end
 	(and (> new-end c-new-END) (setq c-new-END new-end))))))
 
-
-
 (defun c-after-change-check-<>-operators (beg end)
   ;; This is called from `after-change-functions' when
   ;; c-recognize-<>-arglists' is set.  It ensures that no "<" or ">"
@@ -5547,7 +5645,7 @@ comment at the start of cc-engine.el for
 ;; This is primarily used to handle C++ template arglists.  C++
 ;; disambiguates them by checking whether the preceding name is a
 ;; template or not.  We can't do that, so we assume it is a template
-;; if it can be parsed as one.  That usually works well since
+;; if it can be parsed as one.	That usually works well since
 ;; comparison expressions on the forms "a < b > c" or "a < b, c > d"
 ;; in almost all cases would be pointless.
 ;;
@@ -5584,7 +5682,7 @@ comment at the start of cc-engine.el for
 
 ;; This variable will receive a cons cell of the range of the last
 ;; single identifier symbol stepped over by `c-forward-name' if it's
-;; successful.  This is the range that should be put on one of the
+;; successful.	This is the range that should be put on one of the
 ;; record lists above by the caller.  It's assigned nil if there's no
 ;; such symbol in the name.
 (defvar c-last-identifier-range nil)
@@ -5620,7 +5718,7 @@ comment at the start of cc-engine.el for
   ;; possibly is prefixed by keywords and their associated clauses.
   ;; Try with a type/name first to not trip up on those that begin
   ;; with a keyword.  Return t if a known or found type is moved
-  ;; over.  The point is clobbered if nil is returned.  If range
+  ;; over.  The point is clobbered if nil is returned.	If range
   ;; recording is enabled, the identifier is recorded on as a type
   ;; if TYPE is 'type or as a reference if TYPE is 'ref.
   ;;
@@ -5658,7 +5756,7 @@ comment at the start of cc-engine.el for
   ;; token.  If it's a keyword, move over it and any immediately
   ;; following clauses associated with it, stopping at the start of
   ;; the next token.  t is returned in that case, otherwise the point
-  ;; stays and nil is returned.  The kind of clauses that are
+  ;; stays and nil is returned.	 The kind of clauses that are
   ;; recognized are those specified by `c-type-list-kwds',
   ;; `c-ref-list-kwds', `c-colon-type-list-kwds',
   ;; `c-paren-nontype-kwds', `c-paren-type-kwds', `c-<>-type-kwds',
@@ -5764,15 +5862,13 @@ comment at the start of cc-engine.el for
       (goto-char safe-pos)
       t)))
 
-;; cc-mode requires cc-fonts.
-(declare-function c-fontify-recorded-types-and-refs "cc-fonts" ())
 
 (defun c-forward-<>-arglist (all-types)
   ;; The point is assumed to be at a "<".  Try to treat it as the open
-  ;; paren of an angle bracket arglist and move forward to the
-  ;; corresponding ">".  If successful, the point is left after the
+  ;; paren of an angle bracket arglist and move forward to the the
+  ;; corresponding ">".	 If successful, the point is left after the
   ;; ">" and t is returned, otherwise the point isn't moved and nil is
-  ;; returned.  If ALL-TYPES is t then all encountered arguments in
+  ;; returned.	If ALL-TYPES is t then all encountered arguments in
   ;; the arglist that might be types are treated as found types.
   ;;
   ;; The variable `c-parse-and-markup-<>-arglists' controls how this
@@ -5812,7 +5908,6 @@ comment at the start of cc-engine.el for
   ;; Recursive part of `c-forward-<>-arglist'.
   ;;
   ;; This function might do hidden buffer changes.
-
   (let ((start (point)) res pos tmp
 	;; Cover this so that any recorded found type ranges are
 	;; automatically lost if it turns out to not be an angle
@@ -5848,32 +5943,31 @@ comment at the start of cc-engine.el for
 	(while (and
 		(progn
 		  (c-forward-syntactic-ws)
-		  (let ((orig-record-found-types c-record-found-types))
-		    (when (or (and c-record-type-identifiers all-types)
-			      (c-major-mode-is 'java-mode))
-		      ;; All encountered identifiers are types, so set the
-		      ;; promote flag and parse the type.
-		      (progn
-			(c-forward-syntactic-ws)
-			(if (looking-at "\\?")
-			    (forward-char)
-			  (when (looking-at c-identifier-start)
-			    (let ((c-promote-possible-types t)
-				  (c-record-found-types t))
-			      (c-forward-type))))
-
-			(c-forward-syntactic-ws)
-
-			(when (or (looking-at "extends")
-				  (looking-at "super"))
-			  (forward-word)
-			  (c-forward-syntactic-ws)
+		  (when (or (and c-record-type-identifiers all-types)
+			    (c-major-mode-is 'java-mode))
+		    ;; All encountered identifiers are types, so set the
+		    ;; promote flag and parse the type.
+		    (progn
+		      (c-forward-syntactic-ws)
+		      (if (looking-at "\\?")
+			  (forward-char)
+			(when (looking-at c-identifier-start)
 			  (let ((c-promote-possible-types t)
 				(c-record-found-types t))
-			    (c-forward-type)
-			    (c-forward-syntactic-ws))))))
+			    (c-forward-type))))
+
+		      (c-forward-syntactic-ws)
 
-		  (setq pos (point))    ; e.g. first token inside the '<'
+		      (when (or (looking-at "extends")
+				(looking-at "super"))
+			(forward-word)
+			(c-forward-syntactic-ws)
+			(let ((c-promote-possible-types t)
+			      (c-record-found-types t))
+			  (c-forward-type)
+			  (c-forward-syntactic-ws)))))
+
+		  (setq pos (point))	; e.g. first token inside the '<'
 
 		  ;; Note: These regexps exploit the match order in \| so
 		  ;; that "<>" is matched by "<" rather than "[^>:-]>".
@@ -5909,7 +6003,7 @@ comment at the start of cc-engine.el for
 		  ;; Either an operator starting with '<' or a nested arglist.
 		  (setq pos (point))
 		  (let (id-start id-end subres keyword-match)
-                  (cond
+		    (cond
 		     ;; The '<' begins a multi-char operator.
 		     ((looking-at c-<-op-cont-regexp)
 		      (setq tmp (match-end 0))
@@ -5917,7 +6011,7 @@ comment at the start of cc-engine.el for
 		     ;; We're at a nested <.....>
 		     ((progn
 			(setq tmp pos)
-			(backward-char) ; to the '<'
+			(backward-char)	; to the '<'
 			(and
 			 (save-excursion
 			   ;; There's always an identifier before an angle
@@ -5938,7 +6032,6 @@ comment at the start of cc-engine.el for
 				       (c-keyword-member
 					(c-keyword-sym (match-string 1))
 					'c-<>-type-kwds)))))))
-
 		      ;; It was an angle bracket arglist.
 		      (setq c-record-found-types subres)
 
@@ -5952,13 +6045,13 @@ comment at the start of cc-engine.el for
 				   (c-forward-syntactic-ws)
 				   (looking-at c-opt-identifier-concat-key)))
 			    (c-record-ref-id (cons id-start id-end))
-                        (c-record-type-id (cons id-start id-end)))))
+			  (c-record-type-id (cons id-start id-end)))))
 
-                   ;; At a "less than" operator.
-                   (t
-                    (forward-char)
-                    )))
-                t)                    ; carry on looping.
+		     ;; At a "less than" operator.
+		     (t
+		      (forward-char)
+		      )))
+		  t)			; carry on looping.
 
 		 ((and (not c-restricted-<>-arglists)
 		       (or (and (eq (char-before) ?&)
@@ -6231,7 +6324,7 @@ comment at the start of cc-engine.el for
   ;;     `*-font-lock-extra-types');
   ;;   o - 'prefix if it's a known prefix of a type;
   ;;   o - 'found if it's a type that matches one in `c-found-types';
-  ;;   o - 'maybe if it's an identifier that might be a type; or
+  ;;   o - 'maybe if it's an identfier that might be a type; or
   ;;   o -  nil if it can't be a type (the point isn't moved then).
   ;;
   ;; The point is assumed to be at the beginning of a token.
@@ -6383,6 +6476,7 @@ comment at the start of cc-engine.el for
 	  (goto-char (match-end 1))
 	  (c-forward-syntactic-ws)
 	  (setq res t)))
+
       ;; Step over any type suffix operator.  Do not let the existence
       ;; of these alter the classification of the found type, since
       ;; these operators typically are allowed in normal expressions
@@ -6466,6 +6560,61 @@ comment at the start of cc-engine.el for
 	   (c-go-list-forward)
          t)))
 
+(defmacro c-pull-open-brace (ps)
+  ;; Pull the next open brace from PS (which has the form of paren-state),
+  ;; skipping over any brace pairs.  Returns NIL when PS is exhausted.
+  `(progn
+     (while (consp (car ,ps))
+       (setq ,ps (cdr ,ps)))
+     (prog1 (car ,ps)
+       (setq ,ps (cdr ,ps)))))
+
+(defun c-back-over-member-initializers ()
+  ;; Test whether we are in a C++ member initializer list, and if so, go back
+  ;; to the introducing ":", returning the position of the opening paren of
+  ;; the function's arglist.  Otherwise return nil, leaving point unchanged.
+  (let ((here (point))
+	(paren-state (c-parse-state))
+	res)
+
+    (setq res
+	  (catch 'done
+	    (if (not (c-at-toplevel-p))
+		(progn
+		  (while (not (c-at-toplevel-p))
+		    (goto-char (c-pull-open-brace paren-state)))
+		  (c-backward-syntactic-ws)
+		  (when (not (c-simple-skip-symbol-backward))
+		    (throw 'done nil))
+		  (c-backward-syntactic-ws))
+	      (c-backward-syntactic-ws)
+	      (when (memq (char-before) '(?\) ?}))
+		(when (not (c-go-list-backward))
+		  (throw 'done nil))
+		(c-backward-syntactic-ws))
+	      (when (c-simple-skip-symbol-backward)
+		(c-backward-syntactic-ws)))
+
+	    (while (eq (char-before) ?,)
+	      (backward-char)
+	      (c-backward-syntactic-ws)
+
+	      (when (not (memq (char-before) '(?\) ?})))
+		(throw 'done nil))
+	      (when (not (c-go-list-backward))
+		(throw 'done nil))
+	      (c-backward-syntactic-ws)
+	      (when (not (c-simple-skip-symbol-backward))
+		(throw 'done nil))
+	      (c-backward-syntactic-ws))
+
+	    (and
+	     (eq (char-before) ?:)
+	     (c-just-after-func-arglist-p))))
+
+    (or res (goto-char here))
+    res))
+
 
 ;; Handling of large scale constructs like statements and declarations.
 
@@ -6543,7 +6692,7 @@ comment at the start of cc-engine.el for
   ;;      car ^                                     ^ point
   ;;     Foo::Foo (int b) : Base (b) {}
   ;; car ^                ^ point
-  ;;
+  ;; 
   ;;   The cdr of the return value is non-nil when a
   ;;   `c-typedef-decl-kwds' specifier is found in the declaration.
   ;;   Specifically it is a dotted pair (A . B) where B is t when a
@@ -6551,7 +6700,7 @@ comment at the start of cc-engine.el for
   ;;   other `c-typedef-decl-kwds' (e.g. class, struct, enum)
   ;;   specifier is present.  I.e., (some of) the declared
   ;;   identifier(s) are types.
-  ;;
+  ;; 
   ;; If a cast is parsed:
   ;;
   ;;   The point is left at the first token after the closing paren of
@@ -6566,11 +6715,11 @@ comment at the start of cc-engine.el for
   ;;
   ;; CONTEXT is a symbol that describes the context at the point:
   ;; 'decl     In a comma-separated declaration context (typically
-  ;;           inside a function declaration arglist).
+  ;;	       inside a function declaration arglist).
   ;; '<>       In an angle bracket arglist.
   ;; 'arglist  Some other type of arglist.
   ;; nil       Some other context or unknown context.  Includes
-  ;;           within the parens of an if, for, ... construct.
+  ;;	       within the parens of an if, for, ... construct.
   ;;
   ;; LAST-CAST-END is the first token after the closing paren of a
   ;; preceding cast, or nil if none is known.  If
@@ -6597,7 +6746,7 @@ comment at the start of cc-engine.el for
 	;; specifiers and their associated clauses.
 	type-start
 	;; The position of the first token in what we currently
-	;; believe is the declarator for the first identifier.  Set
+	;; believe is the declarator for the first identifier.	Set
 	;; when the type is found, and moved forward over any
 	;; `c-decl-hangon-kwds' and their associated clauses that
 	;; occurs after the type.
@@ -6618,12 +6767,12 @@ comment at the start of cc-engine.el for
 	;; where there's no type.
 	maybe-typeless
 	;; If a specifier is found that also can be a type prefix,
-	;; these flags are set instead of those above.  If we need to
+	;; these flags are set instead of those above.	If we need to
 	;; back up an identifier, they are copied to the real flag
 	;; variables.  Thus they only take effect if we fail to
 	;; interpret it as a type.
 	backup-at-type-decl backup-maybe-typeless
-	;; Whether we've found a declaration or a cast.  We might know
+	;; Whether we've found a declaration or a cast.	 We might know
 	;; this before we've found the type in it.  It's 'ids if we've
 	;; found two consecutive identifiers (usually a sure sign, but
 	;; we should allow that in labels too), and t if we've found a
@@ -6667,7 +6816,7 @@ comment at the start of cc-engine.el for
 
 	    (when at-type
 	      ;; Got two identifiers with nothing but whitespace
-	      ;; between them.  That can only happen in declarations.
+	      ;; between them.	That can only happen in declarations.
 	      (setq at-decl-or-cast 'ids)
 
 	      (when (eq at-type 'found)
@@ -6718,7 +6867,7 @@ comment at the start of cc-engine.el for
 		  (if found-type
 		      ;; It's ambiguous whether this keyword is a
 		      ;; specifier or a type prefix, so set the backup
-		      ;; flags.  (It's assumed that `c-forward-type'
+		      ;; flags.	 (It's assumed that `c-forward-type'
 		      ;; moved further than `c-forward-keyword-clause'.)
 		      (progn
 			(when (c-keyword-member kwd-sym 'c-typedef-decl-kwds)
@@ -6733,7 +6882,7 @@ comment at the start of cc-engine.el for
 		    (when (c-keyword-member kwd-sym 'c-typeless-decl-kwds)
 		      (setq maybe-typeless t))
 
-		    ;; Haven't matched a type so it's an unambiguous
+		    ;; Haven't matched a type so it's an umambiguous
 		    ;; specifier keyword and we know we're in a
 		    ;; declaration.
 		    (setq at-decl-or-cast t)
@@ -6816,7 +6965,7 @@ comment at the start of cc-engine.el for
 	  ;; paren pair that surrounds the declarator.
 	  got-prefix-before-parens
 	  ;; True if there's a suffix match outside the outermost
-	  ;; paren pair that surrounds the declarator.  The value is
+	  ;; paren pair that surrounds the declarator.	The value is
 	  ;; the position of the first suffix match.
 	  got-suffix-after-parens
 	  ;; True if we've parsed the type decl to a token that is
@@ -6831,45 +6980,57 @@ comment at the start of cc-engine.el for
 	  ;; can happen since we don't know if
 	  ;; `c-restricted-<>-arglists' will be correct inside the
 	  ;; arglist paren that gets entered.
-	  c-parse-and-markup-<>-arglists)
+	  c-parse-and-markup-<>-arglists
+	  ;; Start of the identifier for which `got-identifier' was set.
+	  name-start)
 
       (goto-char id-start)
 
-      ;; Skip over type decl prefix operators.  (Note similar code in
+      ;; Skip over type decl prefix operators.	(Note similar code in
       ;; `c-font-lock-declarators'.)
-      (while (and (looking-at c-type-decl-prefix-key)
-		  (if (and (c-major-mode-is 'c++-mode)
-			   (match-beginning 3))
-		      ;; If the second submatch matches in C++ then
-		      ;; we're looking at an identifier that's a
-		      ;; prefix only if it specifies a member pointer.
-		      (when (setq got-identifier (c-forward-name))
-			(if (looking-at "\\(::\\)")
-			    ;; We only check for a trailing "::" and
-			    ;; let the "*" that should follow be
-			    ;; matched in the next round.
-			    (progn (setq got-identifier nil) t)
-			  ;; It turned out to be the real identifier,
-			  ;; so stop.
-			  nil))
-		    t))
-
-	(if (eq (char-after) ?\()
+      (if (and c-recognize-typeless-decls
+	       (equal c-type-decl-prefix-key "\\<\\>"))
+	  (when (eq (char-after) ?\()
 	    (progn
 	      (setq paren-depth (1+ paren-depth))
-	      (forward-char))
-	  (unless got-prefix-before-parens
-	    (setq got-prefix-before-parens (= paren-depth 0)))
-	  (setq got-prefix t)
-	  (goto-char (match-end 1)))
-	(c-forward-syntactic-ws))
+	      (forward-char)))
+	(while (and (looking-at c-type-decl-prefix-key)
+		    (if (and (c-major-mode-is 'c++-mode)
+			     (match-beginning 3))
+			;; If the third submatch matches in C++ then
+			;; we're looking at an identifier that's a
+			;; prefix only if it specifies a member pointer.
+			(when (progn (setq pos (point))
+				     (setq got-identifier (c-forward-name)))
+			  (setq name-start pos)
+			  (if (looking-at "\\(::\\)")
+			      ;; We only check for a trailing "::" and
+			      ;; let the "*" that should follow be
+			      ;; matched in the next round.
+			      (progn (setq got-identifier nil) t)
+			    ;; It turned out to be the real identifier,
+			    ;; so stop.
+			    nil))
+		      t))
+
+	  (if (eq (char-after) ?\()
+	      (progn
+		(setq paren-depth (1+ paren-depth))
+		(forward-char))
+	    (unless got-prefix-before-parens
+	      (setq got-prefix-before-parens (= paren-depth 0)))
+	    (setq got-prefix t)
+	    (goto-char (match-end 1)))
+	  (c-forward-syntactic-ws)))
 
       (setq got-parens (> paren-depth 0))
 
       ;; Skip over an identifier.
       (or got-identifier
 	  (and (looking-at c-identifier-start)
-	       (setq got-identifier (c-forward-name))))
+	       (setq pos (point))
+	       (setq got-identifier (c-forward-name))
+	       (setq name-start pos)))
 
       ;; Skip over type decl suffix operators.
       (while (if (looking-at c-type-decl-suffix-key)
@@ -6930,56 +7091,59 @@ comment at the start of cc-engine.el for
        (catch 'at-decl-or-cast
 
 	 ;; CASE 1
-	(when (> paren-depth 0)
-	  ;; Encountered something inside parens that isn't matched by
-	  ;; the `c-type-decl-*' regexps, so it's not a type decl
-	  ;; expression.  Try to skip out to the same paren depth to
-	  ;; not confuse the cast check below.
-	  (c-safe (goto-char (scan-lists (point) 1 paren-depth)))
-	  ;; If we've found a specifier keyword then it's a
-	  ;; declaration regardless.
-	  (throw 'at-decl-or-cast (eq at-decl-or-cast t)))
-
-	(setq at-decl-end
-	      (looking-at (cond ((eq context '<>) "[,>]")
-				(context "[,\)]")
-				(t "[,;]"))))
-
-	;; Now we've collected info about various characteristics of
-	;; the construct we're looking at.  Below follows a decision
-	;; tree based on that.  It's ordered to check more certain
-	;; signs before less certain ones.
-
-	(if got-identifier
-	    (progn
+	 (when (> paren-depth 0)
+	   ;; Encountered something inside parens that isn't matched by
+	   ;; the `c-type-decl-*' regexps, so it's not a type decl
+	   ;; expression.  Try to skip out to the same paren depth to
+	   ;; not confuse the cast check below.
+	   (c-safe (goto-char (scan-lists (point) 1 paren-depth)))
+	   ;; If we've found a specifier keyword then it's a
+	   ;; declaration regardless.
+	   (throw 'at-decl-or-cast (eq at-decl-or-cast t)))
+
+	 (setq at-decl-end
+	       (looking-at (cond ((eq context '<>) "[,>]")
+				 (context "[,\)]")
+				 (t "[,;]"))))
+
+	 ;; Now we've collected info about various characteristics of
+	 ;; the construct we're looking at.  Below follows a decision
+	 ;; tree based on that.	 It's ordered to check more certain
+	 ;; signs before less certain ones.
 
-	      ;; CASE 2
-	      (when (and (or at-type maybe-typeless)
-			 (not (or got-prefix got-parens)))
-		;; Got another identifier directly after the type, so it's a
-		;; declaration.
-		(throw 'at-decl-or-cast t))
-
-	      (when (and got-parens
-			 (not got-prefix)
-			 (not got-suffix-after-parens)
-			 (or backup-at-type
-			     maybe-typeless
-			     backup-maybe-typeless))
-		;; Got a declaration of the form "foo bar (gnu);" where we've
-		;; recognized "bar" as the type and "gnu" as the declarator.
-		;; In this case it's however more likely that "bar" is the
-		;; declarator and "gnu" a function argument or initializer (if
-		;; `c-recognize-paren-inits' is set), since the parens around
-		;; "gnu" would be superfluous if it's a declarator.  Shift the
-		;; type one step backward.
-		(c-fdoc-shift-type-backward)))
+	 (if got-identifier
+	     (progn
 
-	  ;; Found no identifier.
+	       ;; CASE 2
+	       (when (and (or at-type maybe-typeless)
+			  (not (or got-prefix got-parens)))
+		 ;; Got another identifier directly after the type, so it's a
+		 ;; declaration.
+		 (throw 'at-decl-or-cast t))
+
+	       (when (and got-parens
+			  (not got-prefix)
+			  ;; (not got-suffix-after-parens)
+			  (or backup-at-type
+			      maybe-typeless
+			      backup-maybe-typeless
+			      (eq at-decl-or-cast t)
+			      (save-excursion
+				(goto-char name-start)
+				(not (memq (c-forward-type) '(nil maybe))))))
+		 ;; Got a declaration of the form "foo bar (gnu);" or "bar
+		 ;; (gnu);" where we've recognized "bar" as the type and "gnu"
+		 ;; as the declarator.  In this case it's however more likely
+		 ;; that "bar" is the declarator and "gnu" a function argument
+		 ;; or initializer (if `c-recognize-paren-inits' is set),
+		 ;; since the parens around "gnu" would be superfluous if it's
+		 ;; a declarator.  Shift the type one step backward.
+		 (c-fdoc-shift-type-backward)))
 
-	  (if backup-at-type
-	      (progn
+	   ;; Found no identifier.
 
+	   (if backup-at-type
+	       (progn
 
 		 ;; CASE 3
 		 (when (= (point) start)
@@ -7002,246 +7166,250 @@ comment at the start of cc-engine.el for
 		     (setq backup-if-not-cast t)
 		     (throw 'at-decl-or-cast t)))
 
-		;; CASE 4
-		(when (and got-suffix
-			   (not got-prefix)
-			   (not got-parens))
-		  ;; Got a plain list of identifiers followed by some suffix.
-		  ;; If this isn't a cast then the last identifier probably is
-		  ;; the declared one and we should back up to the previous
-		  ;; type.
-		  (setq backup-if-not-cast t)
-		  (throw 'at-decl-or-cast t)))
-
-	    ;; CASE 5
-	    (when (eq at-type t)
-	      ;; If the type is known we know that there can't be any
-	      ;; identifier somewhere else, and it's only in declarations in
-	      ;; e.g. function prototypes and in casts that the identifier may
-	      ;; be left out.
-	      (throw 'at-decl-or-cast t))
-
-	    (when (= (point) start)
-	      ;; Only got a single identifier (parsed as a type so far).
-	      ;; CASE 6
-	      (if (and
-		   ;; Check that the identifier isn't at the start of an
-		   ;; expression.
-		   at-decl-end
-		   (cond
-		    ((eq context 'decl)
-		     ;; Inside an arglist that contains declarations.  If K&R
-		     ;; style declarations and parenthesis style initializers
-		     ;; aren't allowed then the single identifier must be a
-		     ;; type, else we require that it's known or found
-		     ;; (primitive types are handled above).
-		     (or (and (not c-recognize-knr-p)
-			      (not c-recognize-paren-inits))
-			 (memq at-type '(known found))))
-		    ((eq context '<>)
-		     ;; Inside a template arglist.  Accept known and found
-		     ;; types; other identifiers could just as well be
-		     ;; constants in C++.
-		     (memq at-type '(known found)))))
-		  (throw 'at-decl-or-cast t)
-		;; CASE 7
-		;; Can't be a valid declaration or cast, but if we've found a
-		;; specifier it can't be anything else either, so treat it as
-		;; an invalid/unfinished declaration or cast.
-		(throw 'at-decl-or-cast at-decl-or-cast))))
-
-	  (if (and got-parens
-		   (not got-prefix)
-		   (not context)
-		   (not (eq at-type t))
-		   (or backup-at-type
-		       maybe-typeless
-		       backup-maybe-typeless
-		       (when c-recognize-typeless-decls
-			 (or (not got-suffix)
-			     (not (looking-at
-				   c-after-suffixed-type-maybe-decl-key))))))
-	      ;; Got an empty paren pair and a preceding type that probably
-	      ;; really is the identifier.  Shift the type backwards to make
-	      ;; the last one the identifier.  This is analogous to the
-	      ;; "backtracking" done inside the `c-type-decl-suffix-key' loop
-	      ;; above.
-	      ;;
-	      ;; Exception: In addition to the conditions in that
-	      ;; "backtracking" code, do not shift backward if we're not
-	      ;; looking at either `c-after-suffixed-type-decl-key' or "[;,]".
-	      ;; Since there's no preceding type, the shift would mean that
-	      ;; the declaration is typeless.  But if the regexp doesn't match
-	      ;; then we will simply fall through in the tests below and not
-	      ;; recognize it at all, so it's better to try it as an abstract
-	      ;; declarator instead.
-	      (c-fdoc-shift-type-backward)
-
-	    ;; Still no identifier.
-	    ;; CASE 8
-	    (when (and got-prefix (or got-parens got-suffix))
-	      ;; Require `got-prefix' together with either `got-parens' or
-	      ;; `got-suffix' to recognize it as an abstract declarator:
-	      ;; `got-parens' only is probably an empty function call.
-	      ;; `got-suffix' only can build an ordinary expression together
-	      ;; with the preceding identifier which we've taken as a type.
-	      ;; We could actually accept on `got-prefix' only, but that can
-	      ;; easily occur temporarily while writing an expression so we
-	      ;; avoid that case anyway.  We could do a better job if we knew
-	      ;; the point when the fontification was invoked.
-	      (throw 'at-decl-or-cast t))
-
-	    ;; CASE 9
-	    (when (and at-type
-		       (not got-prefix)
-		       (not got-parens)
-		       got-suffix-after-parens
-		       (eq (char-after got-suffix-after-parens) ?\())
-	      ;; Got a type, no declarator but a paren suffix. I.e. it's a
-	      ;; normal function call after all (or perhaps a C++ style object
-	      ;; instantiation expression).
-	      (throw 'at-decl-or-cast nil))))
-
-	;; CASE 10
-	(when at-decl-or-cast
-	  ;; By now we've located the type in the declaration that we know
-	  ;; we're in.
-	  (throw 'at-decl-or-cast t))
-
-	;; CASE 11
-	(when (and got-identifier
-		   (not context)
-		   (looking-at c-after-suffixed-type-decl-key)
-		   (if (and got-parens
+		 ;; CASE 4
+		 (when (and got-suffix
 			    (not got-prefix)
-			    (not got-suffix)
-			    (not (eq at-type t)))
-		       ;; Shift the type backward in the case that there's a
-		       ;; single identifier inside parens.  That can only
-		       ;; occur in K&R style function declarations so it's
-		       ;; more likely that it really is a function call.
-		       ;; Therefore we only do this after
-		       ;; `c-after-suffixed-type-decl-key' has matched.
-		       (progn (c-fdoc-shift-type-backward) t)
-		     got-suffix-after-parens))
-	  ;; A declaration according to `c-after-suffixed-type-decl-key'.
-	  (throw 'at-decl-or-cast t))
-
-	;; CASE 12
-	(when (and (or got-prefix (not got-parens))
-		   (memq at-type '(t known)))
-	  ;; It's a declaration if a known type precedes it and it can't be a
-	  ;; function call.
-	  (throw 'at-decl-or-cast t))
-
-	;; If we get here we can't tell if this is a type decl or a normal
-	;; expression by looking at it alone.  (That's under the assumption
-	;; that normal expressions always can look like type decl expressions,
-	;; which isn't really true but the cases where it doesn't hold are so
-	;; uncommon (e.g. some placements of "const" in C++) it's not worth
-	;; the effort to look for them.)
-
-	(unless (or at-decl-end (looking-at "=[^=]"))
-	  ;; If this is a declaration it should end here or its initializer(*)
-	  ;; should start here, so check for allowed separation tokens.  Note
-	  ;; that this rule doesn't work e.g. with a K&R arglist after a
-	  ;; function header.
-	  ;;
-	  ;; *) Don't check for C++ style initializers using parens
-	  ;; since those already have been matched as suffixes.
-	  ;;
-	  ;; If `at-decl-or-cast' is then we've found some other sign that
-	  ;; it's a declaration or cast, so then it's probably an
-	  ;; invalid/unfinished one.
-	  (throw 'at-decl-or-cast at-decl-or-cast))
-
-	;; Below are tests that only should be applied when we're certain to
-	;; not have parsed halfway through an expression.
-
-	;; CASE 14
-	(when (memq at-type '(t known))
-	  ;; The expression starts with a known type so treat it as a
-	  ;; declaration.
-	  (throw 'at-decl-or-cast t))
-
-	;; CASE 15
-	(when (and (c-major-mode-is 'c++-mode)
-		   ;; In C++ we check if the identifier is a known type, since
-		   ;; (con|de)structors use the class name as identifier.
-		   ;; We've always shifted over the identifier as a type and
-		   ;; then backed up again in this case.
-		   identifier-type
-		   (or (memq identifier-type '(found known))
-		       (and (eq (char-after identifier-start) ?~)
-			    ;; `at-type' probably won't be 'found for
-			    ;; destructors since the "~" is then part of the
-			    ;; type name being checked against the list of
-			    ;; known types, so do a check without that
-			    ;; operator.
-			    (or (save-excursion
-				  (goto-char (1+ identifier-start))
-				  (c-forward-syntactic-ws)
-				  (c-with-syntax-table
-				      c-identifier-syntax-table
-				    (looking-at c-known-type-key)))
-				(save-excursion
-				  (goto-char (1+ identifier-start))
-				  ;; We have already parsed the type earlier,
-				  ;; so it'd be possible to cache the end
-				  ;; position instead of redoing it here, but
-				  ;; then we'd need to keep track of another
-				  ;; position everywhere.
-				  (c-check-type (point)
-						(progn (c-forward-type)
-						       (point))))))))
-	  (throw 'at-decl-or-cast t))
+			    (not got-parens))
+		   ;; Got a plain list of identifiers followed by some suffix.
+		   ;; If this isn't a cast then the last identifier probably is
+		   ;; the declared one and we should back up to the previous
+		   ;; type.
+		   (setq backup-if-not-cast t)
+		   (throw 'at-decl-or-cast t)))
+
+	     ;; CASE 5
+	     (when (eq at-type t)
+	       ;; If the type is known we know that there can't be any
+	       ;; identifier somewhere else, and it's only in declarations in
+	       ;; e.g. function prototypes and in casts that the identifier may
+	       ;; be left out.
+	       (throw 'at-decl-or-cast t))
+
+	     (when (= (point) start)
+	       ;; Only got a single identifier (parsed as a type so far).
+	       ;; CASE 6
+	       (if (and
+		    ;; Check that the identifier isn't at the start of an
+		    ;; expression.
+		    at-decl-end
+		    (cond
+		     ((eq context 'decl)
+		      ;; Inside an arglist that contains declarations.	If K&R
+		      ;; style declarations and parenthesis style initializers
+		      ;; aren't allowed then the single identifier must be a
+		      ;; type, else we require that it's known or found
+		      ;; (primitive types are handled above).
+		      (or (and (not c-recognize-knr-p)
+			       (not c-recognize-paren-inits))
+			  (memq at-type '(known found))))
+		     ((eq context '<>)
+		      ;; Inside a template arglist.  Accept known and found
+		      ;; types; other identifiers could just as well be
+		      ;; constants in C++.
+		      (memq at-type '(known found)))))
+		   (throw 'at-decl-or-cast t)
+		 ;; CASE 7
+		 ;; Can't be a valid declaration or cast, but if we've found a
+		 ;; specifier it can't be anything else either, so treat it as
+		 ;; an invalid/unfinished declaration or cast.
+		 (throw 'at-decl-or-cast at-decl-or-cast))))
+
+	   (if (and got-parens
+		    (not got-prefix)
+		    (not context)
+		    (not (eq at-type t))
+		    (or backup-at-type
+			maybe-typeless
+			backup-maybe-typeless
+			(when c-recognize-typeless-decls
+			  (or (not got-suffix)
+			      (not (looking-at
+				    c-after-suffixed-type-maybe-decl-key))))))
+	       ;; Got an empty paren pair and a preceding type that probably
+	       ;; really is the identifier.  Shift the type backwards to make
+	       ;; the last one the identifier.	This is analogous to the
+	       ;; "backtracking" done inside the `c-type-decl-suffix-key' loop
+	       ;; above.
+	       ;;
+	       ;; Exception: In addition to the conditions in that
+	       ;; "backtracking" code, do not shift backward if we're not
+	       ;; looking at either `c-after-suffixed-type-decl-key' or "[;,]".
+	       ;; Since there's no preceding type, the shift would mean that
+	       ;; the declaration is typeless.	But if the regexp doesn't match
+	       ;; then we will simply fall through in the tests below and not
+	       ;; recognize it at all, so it's better to try it as an abstract
+	       ;; declarator instead.
+	       (c-fdoc-shift-type-backward)
+
+	     ;; Still no identifier.
+	     ;; CASE 8
+	     (when (and got-prefix (or got-parens got-suffix))
+	       ;; Require `got-prefix' together with either `got-parens' or
+	       ;; `got-suffix' to recognize it as an abstract declarator:
+	       ;; `got-parens' only is probably an empty function call.
+	       ;; `got-suffix' only can build an ordinary expression together
+	       ;; with the preceding identifier which we've taken as a type.
+	       ;; We could actually accept on `got-prefix' only, but that can
+	       ;; easily occur temporarily while writing an expression so we
+	       ;; avoid that case anyway.  We could do a better job if we knew
+	       ;; the point when the fontification was invoked.
+	       (throw 'at-decl-or-cast t))
+
+	     ;; CASE 9
+	     (when (and at-type
+			(not got-prefix)
+			(not got-parens)
+			got-suffix-after-parens
+			(eq (char-after got-suffix-after-parens) ?\())
+	       ;; Got a type, no declarator but a paren suffix. I.e. it's a
+	       ;; normal function call afterall (or perhaps a C++ style object
+	       ;; instantiation expression).
+	       (throw 'at-decl-or-cast nil))))
+
+	 ;; CASE 10
+	 (when at-decl-or-cast
+	   ;; By now we've located the type in the declaration that we know
+	   ;; we're in.
+	   (throw 'at-decl-or-cast t))
+
+	 ;; CASE 11
+	 (when (and got-identifier
+		    (not context)
+		    (looking-at c-after-suffixed-type-decl-key)
+		    (if (and got-parens
+			     (not got-prefix)
+			     (not got-suffix)
+			     (not (eq at-type t)))
+			;; Shift the type backward in the case that there's a
+			;; single identifier inside parens.  That can only
+			;; occur in K&R style function declarations so it's
+			;; more likely that it really is a function call.
+			;; Therefore we only do this after
+			;; `c-after-suffixed-type-decl-key' has matched.
+			(progn (c-fdoc-shift-type-backward) t)
+		      got-suffix-after-parens))
+	   ;; A declaration according to `c-after-suffixed-type-decl-key'.
+	   (throw 'at-decl-or-cast t))
+
+	 ;; CASE 12
+	 (when (and (or got-prefix (not got-parens))
+		    (memq at-type '(t known)))
+	   ;; It's a declaration if a known type precedes it and it can't be a
+	   ;; function call.
+	   (throw 'at-decl-or-cast t))
+
+	 ;; If we get here we can't tell if this is a type decl or a normal
+	 ;; expression by looking at it alone.	(That's under the assumption
+	 ;; that normal expressions always can look like type decl expressions,
+	 ;; which isn't really true but the cases where it doesn't hold are so
+	 ;; uncommon (e.g. some placements of "const" in C++) it's not worth
+	 ;; the effort to look for them.)
+
+;;; 2008-04-16: commented out the next form, to allow the function to recognise
+;;; "foo (int bar)" in CC (an implicit type (in class foo) without a semicolon)
+;;; as a(n almost complete) declaration, enabling it to be fontified.
+	 ;; CASE 13
+	 ;;	(unless (or at-decl-end (looking-at "=[^=]"))
+	 ;; If this is a declaration it should end here or its initializer(*)
+	 ;; should start here, so check for allowed separation tokens.	Note
+	 ;; that this rule doesn't work e.g. with a K&R arglist after a
+	 ;; function header.
+	 ;;
+	 ;; *) Don't check for C++ style initializers using parens
+	 ;; since those already have been matched as suffixes.
+	 ;;
+	 ;; If `at-decl-or-cast' is then we've found some other sign that
+	 ;; it's a declaration or cast, so then it's probably an
+	 ;; invalid/unfinished one.
+	 ;;	  (throw 'at-decl-or-cast at-decl-or-cast))
+
+	 ;; Below are tests that only should be applied when we're certain to
+	 ;; not have parsed halfway through an expression.
+
+	 ;; CASE 14
+	 (when (memq at-type '(t known))
+	   ;; The expression starts with a known type so treat it as a
+	   ;; declaration.
+	   (throw 'at-decl-or-cast t))
+
+	 ;; CASE 15
+	 (when (and (c-major-mode-is 'c++-mode)
+		    ;; In C++ we check if the identifier is a known type, since
+		    ;; (con|de)structors use the class name as identifier.
+		    ;; We've always shifted over the identifier as a type and
+		    ;; then backed up again in this case.
+		    identifier-type
+		    (or (memq identifier-type '(found known))
+			(and (eq (char-after identifier-start) ?~)
+			     ;; `at-type' probably won't be 'found for
+			     ;; destructors since the "~" is then part of the
+			     ;; type name being checked against the list of
+			     ;; known types, so do a check without that
+			     ;; operator.
+			     (or (save-excursion
+				   (goto-char (1+ identifier-start))
+				   (c-forward-syntactic-ws)
+				   (c-with-syntax-table
+				       c-identifier-syntax-table
+				     (looking-at c-known-type-key)))
+				 (save-excursion
+				   (goto-char (1+ identifier-start))
+				   ;; We have already parsed the type earlier,
+				   ;; so it'd be possible to cache the end
+				   ;; position instead of redoing it here, but
+				   ;; then we'd need to keep track of another
+				   ;; position everywhere.
+				   (c-check-type (point)
+						 (progn (c-forward-type)
+							(point))))))))
+	   (throw 'at-decl-or-cast t))
 
-	(if got-identifier
-	    (progn
-	      ;; CASE 16
-	      (when (and got-prefix-before-parens
-			 at-type
-			 (or at-decl-end (looking-at "=[^=]"))
-			 (not context)
-			 (not got-suffix))
-		;; Got something like "foo * bar;".  Since we're not inside an
-		;; arglist it would be a meaningless expression because the
-		;; result isn't used.  We therefore choose to recognize it as
-		;; a declaration.  Do not allow a suffix since it could then
-		;; be a function call.
-		(throw 'at-decl-or-cast t))
-
-	      ;; CASE 17
-	      (when (and (or got-suffix-after-parens
-			     (looking-at "=[^=]"))
-			 (eq at-type 'found)
-			 (not (eq context 'arglist)))
-		;; Got something like "a (*b) (c);" or "a (b) = c;".  It could
-		;; be an odd expression or it could be a declaration.  Treat
-		;; it as a declaration if "a" has been used as a type
-		;; somewhere else (if it's a known type we won't get here).
-		(throw 'at-decl-or-cast t)))
-
-	  ;; CASE 18
-	  (when (and context
-		     (or got-prefix
-			 (and (eq context 'decl)
-			      (not c-recognize-paren-inits)
-			      (or got-parens got-suffix))))
-	    ;; Got a type followed by an abstract declarator.  If `got-prefix'
-	    ;; is set it's something like "a *" without anything after it.  If
-	    ;; `got-parens' or `got-suffix' is set it's "a()", "a[]", "a()[]",
-	    ;; or similar, which we accept only if the context rules out
-	    ;; expressions.
-	    (throw 'at-decl-or-cast t)))
-
-	;; If we had a complete symbol table here (which rules out
-	;; `c-found-types') we should return t due to the disambiguation rule
-	;; (in at least C++) that anything that can be parsed as a declaration
-	;; is a declaration.  Now we're being more defensive and prefer to
-	;; highlight things like "foo (bar);" as a declaration only if we're
-	;; inside an arglist that contains declarations.
-	(eq context 'decl))))
+	 (if got-identifier
+	     (progn
+	       ;; CASE 16
+	       (when (and got-prefix-before-parens
+			  at-type
+			  (or at-decl-end (looking-at "=[^=]"))
+			  (not context)
+			  (not got-suffix))
+		 ;; Got something like "foo * bar;".  Since we're not inside an
+		 ;; arglist it would be a meaningless expression because the
+		 ;; result isn't used.	We therefore choose to recognize it as
+		 ;; a declaration.  Do not allow a suffix since it could then
+		 ;; be a function call.
+		 (throw 'at-decl-or-cast t))
+
+	       ;; CASE 17
+	       (when (and (or got-suffix-after-parens
+			      (looking-at "=[^=]"))
+			  (eq at-type 'found)
+			  (not (eq context 'arglist)))
+		 ;; Got something like "a (*b) (c);" or "a (b) = c;".  It could
+		 ;; be an odd expression or it could be a declaration.	Treat
+		 ;; it as a declaration if "a" has been used as a type
+		 ;; somewhere else (if it's a known type we won't get here).
+		 (throw 'at-decl-or-cast t)))
+
+	   ;; CASE 18
+	   (when (and context
+		      (or got-prefix
+			  (and (eq context 'decl)
+			       (not c-recognize-paren-inits)
+			       (or got-parens got-suffix))))
+	     ;; Got a type followed by an abstract declarator.	If `got-prefix'
+	     ;; is set it's something like "a *" without anything after it.  If
+	     ;; `got-parens' or `got-suffix' is set it's "a()", "a[]", "a()[]",
+	     ;; or similar, which we accept only if the context rules out
+	     ;; expressions.
+	     (throw 'at-decl-or-cast t)))
+
+	 ;; If we had a complete symbol table here (which rules out
+	 ;; `c-found-types') we should return t due to the disambiguation rule
+	 ;; (in at least C++) that anything that can be parsed as a declaration
+	 ;; is a declaration.  Now we're being more defensive and prefer to
+	 ;; highlight things like "foo (bar);" as a declaration only if we're
+	 ;; inside an arglist that contains declarations.
+	 (eq context 'decl))))
 
     ;; The point is now after the type decl expression.
 
@@ -7272,7 +7440,7 @@ comment at the start of cc-engine.el for
 		   ;; Check if the expression begins with a prefix keyword.
 		   (match-beginning 2)
 		   (if (match-beginning 1)
-		       ;; Expression begins with an ambiguous operator.  Treat
+		       ;; Expression begins with an ambiguous operator.	 Treat
 		       ;; it as a cast if it's a type decl or if we've
 		       ;; recognized the type somewhere else.
 		       (or at-decl-or-cast
@@ -7282,7 +7450,7 @@ comment at the start of cc-engine.el for
 		     (not (looking-at c-keywords-regexp)))))
 		;; If `c-primary-expr-regexp' matched a nonsymbol token, check
 		;; that it matched a whole one so that we don't e.g. confuse
-		;; the operator '-' with '->'.  It's ok if it matches further,
+		;; the operator '-' with '->'.	It's ok if it matches further,
 		;; though, since it e.g. can match the float '.5' while the
 		;; operator regexp only matches '.'.
 		(or (not (looking-at c-nonsymbol-token-regexp))
@@ -7297,7 +7465,7 @@ comment at the start of cc-engine.el for
 	       (progn
 		 (c-backward-syntactic-ws)
 		 (if (< (skip-syntax-backward "w_") 0)
-		     ;; It's a symbol.  Accept it only if it's one of the
+		     ;; It's a symbol.	Accept it only if it's one of the
 		     ;; keywords that can precede an expression (without
 		     ;; surrounding parens).
 		     (looking-at c-simple-stmt-key)
@@ -7330,7 +7498,11 @@ comment at the start of cc-engine.el for
 	;; interactive refontification.
 	(c-put-c-type-property (point) 'c-decl-arg-start))
 
-      (when (and c-record-type-identifiers at-type (not (eq at-type t)))
+      (when (and c-record-type-identifiers at-type ;; (not (eq at-type t))
+		 ;; There seems no reason to exclude a token from
+		 ;; fontification just because it's "a known type that can't
+		 ;; be a name or other expression".  2013-09-18.
+		 )
 	(let ((c-promote-possible-types t))
 	  (save-excursion
 	    (goto-char type-start)
@@ -7363,10 +7535,10 @@ comment at the start of cc-engine.el for
   ;;   Returns the symbol `qt-2kwds-colon'.
   ;; (v) QT's construct "signals:".  Returns the symbol `qt-1kwd-colon'.
   ;; (vi) One of the keywords matched by `c-opt-extra-label-key' (without any
-  ;;   colon).  Currently (2006-03), this applies only to Objective C's
+  ;;   colon).	Currently (2006-03), this applies only to Objective C's
   ;;   keywords "@private", "@protected", and "@public".  Returns t.
   ;;
-  ;; One of the things which will NOT be recognized as a label is a bit-field
+  ;; One of the things which will NOT be recognised as a label is a bit-field
   ;; element of a struct, something like "int foo:5".
   ;;
   ;; The end of the label is taken to be just after the colon, or the end of
@@ -7424,10 +7596,10 @@ comment at the start of cc-engine.el for
 		    (c-put-c-type-property (1- (point)) 'c-decl-end)
 		    t)
 
-	      ;; It's an unfinished label.  We consider the keyword enough
-	      ;; to recognize it as a label, so that it gets fontified.
-	      ;; Leave the point at the end of it, but don't put any
-	      ;; `c-decl-end' marker.
+		;; It's an unfinished label.  We consider the keyword enough
+		;; to recognize it as a label, so that it gets fontified.
+		;; Leave the point at the end of it, but don't put any
+		;; `c-decl-end' marker.
 		(goto-char kwd-end)
 		t))))
 
@@ -7504,7 +7676,7 @@ comment at the start of cc-engine.el for
 		     (if macro-start (narrow-to-region macro-start (point-max)))
 		     (c-syntactic-skip-backward "^-]:?;}=*/%&|,<>!@+" nil t)
 		     ;; Note: the following should work instead of the
-		     ;; narrow-to-region above.  Investigate why not,
+		     ;; narrow-to-region above.	 Investigate why not,
 		     ;; sometime.  ACM, 2006-03-31.
 		     ;; (c-syntactic-skip-backward "^-]:?;}=*/%&|,<>!@+"
 		     ;;				    macro-start t)
@@ -7612,73 +7784,73 @@ comment at the start of cc-engine.el for
   ;;
   ;; This function might do hidden buffer changes.
 
-    (let ((start (point))
-	  start-char
-	  (c-promote-possible-types t)
-	  lim
-	  ;; Turn off recognition of angle bracket arglists while parsing
-	  ;; types here since the protocol reference list might then be
-	  ;; considered part of the preceding name or superclass-name.
-	  c-recognize-<>-arglists)
-
-      (if (or
-	   (when (looking-at
-		  (eval-when-compile
-		    (c-make-keywords-re t
-		      (append (c-lang-const c-protection-kwds objc)
-			      '("@end"))
-		      'objc-mode)))
-	     (goto-char (match-end 1))
-	     t)
-
-	   (and
-	    (looking-at
-	     (eval-when-compile
-	       (c-make-keywords-re t
-		 '("@interface" "@implementation" "@protocol")
-		 'objc-mode)))
+  (let ((start (point))
+	start-char
+	(c-promote-possible-types t)
+	lim
+	;; Turn off recognition of angle bracket arglists while parsing
+	;; types here since the protocol reference list might then be
+	;; considered part of the preceding name or superclass-name.
+	c-recognize-<>-arglists)
+
+    (if (or
+	 (when (looking-at
+		(eval-when-compile
+		  (c-make-keywords-re t
+		    (append (c-lang-const c-protection-kwds objc)
+			    '("@end"))
+		    'objc-mode)))
+	   (goto-char (match-end 1))
+	   t)
+
+	 (and
+	  (looking-at
+	   (eval-when-compile
+	     (c-make-keywords-re t
+	       '("@interface" "@implementation" "@protocol")
+	       'objc-mode)))
 
-	    ;; Handle the name of the class itself.
-	    (progn
-;	      (c-forward-token-2) ; 2006/1/13 This doesn't move if the token's
-;	      at EOB.
-	      (goto-char (match-end 0))
-	      (setq lim (point))
-	      (c-skip-ws-forward)
-	      (c-forward-type))
-
-	    (catch 'break
-	      ;; Look for ": superclass-name" or "( category-name )".
-	      (when (looking-at "[:\(]")
-		(setq start-char (char-after))
+	  ;; Handle the name of the class itself.
+	  (progn
+					;	      (c-forward-token-2) ; 2006/1/13 This doesn't move if the token's
+					;	      at EOB.
+	    (goto-char (match-end 0))
+	    (setq lim (point))
+	    (c-skip-ws-forward)
+	    (c-forward-type))
+
+	  (catch 'break
+	    ;; Look for ": superclass-name" or "( category-name )".
+	    (when (looking-at "[:\(]")
+	      (setq start-char (char-after))
+	      (forward-char)
+	      (c-forward-syntactic-ws)
+	      (unless (c-forward-type) (throw 'break nil))
+	      (when (eq start-char ?\()
+		(unless (eq (char-after) ?\)) (throw 'break nil))
 		(forward-char)
-		(c-forward-syntactic-ws)
-		(unless (c-forward-type) (throw 'break nil))
-		(when (eq start-char ?\()
-		  (unless (eq (char-after) ?\)) (throw 'break nil))
-		  (forward-char)
-		  (c-forward-syntactic-ws)))
+		(c-forward-syntactic-ws)))
 
-	      ;; Look for a protocol reference list.
-	      (if (eq (char-after) ?<)
-		  (let ((c-recognize-<>-arglists t)
-			(c-parse-and-markup-<>-arglists t)
-			c-restricted-<>-arglists)
-		    (c-forward-<>-arglist t))
-		t))))
+	    ;; Look for a protocol reference list.
+	    (if (eq (char-after) ?<)
+		(let ((c-recognize-<>-arglists t)
+		      (c-parse-and-markup-<>-arglists t)
+		      c-restricted-<>-arglists)
+		  (c-forward-<>-arglist t))
+	      t))))
 
-	  (progn
-	    (c-backward-syntactic-ws lim)
-	    (c-clear-c-type-property start (1- (point)) 'c-decl-end)
-	    (c-put-c-type-property (1- (point)) 'c-decl-end)
-	    t)
+	(progn
+	  (c-backward-syntactic-ws lim)
+	  (c-clear-c-type-property start (1- (point)) 'c-decl-end)
+	  (c-put-c-type-property (1- (point)) 'c-decl-end)
+	  t)
 
-	(c-clear-c-type-property start (point) 'c-decl-end)
-	nil)))
+      (c-clear-c-type-property start (point) 'c-decl-end)
+      nil)))
 
 (defun c-beginning-of-inheritance-list (&optional lim)
   ;; Go to the first non-whitespace after the colon that starts a
-  ;; multiple inheritance introduction.  Optional LIM is the farthest
+  ;; multiple inheritance introduction.	 Optional LIM is the farthest
   ;; back we should search.
   ;;
   ;; This function might do hidden buffer changes.
@@ -7737,7 +7909,7 @@ buffer position of the start of the clas
 element is the buffer position of the enclosing class's opening
 brace.
 
-Note that this function might do hidden buffer changes.  See the
+Note that this function might do hidden buffer changes.	 See the
 comment at the start of cc-engine.el for more info."
   (let ((paren-state (c-parse-state)))
     (or (not (c-most-enclosing-brace paren-state))
@@ -7761,7 +7933,7 @@ comment at the start of cc-engine.el for
   ;;
   ;; This function might do hidden buffer changes.
 
-  (let ((beg (point)) end id-start)
+  (let ((beg (point)) id-start)
     (and
      (eq (c-beginning-of-statement-1 lim) 'same)
 
@@ -7851,54 +8023,54 @@ comment at the start of cc-engine.el for
 		   (throw 'knr nil)))
 
 	    (if after-rparen
-	    ;; We're inside a paren.  Could it be our argument list....?
-	      (if
-		  (and
-		   (progn
-		     (goto-char after-rparen)
-		     (unless (c-go-list-backward) (throw 'knr nil)) ;
-		;; FIXME!!!  What about macros between the parens?  2007/01/20
-		     (setq before-lparen (point)))
+		;; We're inside a paren.  Could it be our argument list....?
+		(if
+		    (and
+		     (progn
+		       (goto-char after-rparen)
+		       (unless (c-go-list-backward) (throw 'knr nil)) ;
+		       ;; FIXME!!!  What about macros between the parens?  2007/01/20
+		       (setq before-lparen (point)))
 
-		   ;; It can't be the arg list if next token is ; or {
-		   (progn (goto-char after-rparen)
-			  (c-forward-syntactic-ws)
-			  (not (memq (char-after) '(?\; ?\{ ?\=))))
+		     ;; It can't be the arg list if next token is ; or {
+		     (progn (goto-char after-rparen)
+			    (c-forward-syntactic-ws)
+			    (not (memq (char-after) '(?\; ?\{ ?\=))))
 
-		   ;; Is the thing preceding the list an identifier (the
-		   ;; function name), or a macro expansion?
-		   (progn
-		     (goto-char before-lparen)
-		     (eq (c-backward-token-2) 0)
-		     (or (eq (c-on-identifier) (point))
-			 (and (eq (char-after) ?\))
-			      (c-go-up-list-backward)
-			      (eq (c-backward-token-2) 0)
-			      (eq (c-on-identifier) (point)))))
+		     ;; Is the thing preceding the list an identifier (the
+		     ;; function name), or a macro expansion?
+		     (progn
+		       (goto-char before-lparen)
+		       (eq (c-backward-token-2) 0)
+		       (or (eq (c-on-identifier) (point))
+			   (and (eq (char-after) ?\))
+				(c-go-up-list-backward)
+				(eq (c-backward-token-2) 0)
+				(eq (c-on-identifier) (point)))))
 
-		   ;; Have we got a non-empty list of comma-separated
-		   ;; identifiers?
-		   (progn
-		     (goto-char before-lparen)
-		     (c-forward-token-2) ; to first token inside parens
-		     (and
-		      (c-on-identifier)
-		      (c-forward-token-2)
-		      (catch 'id-list
-			(while (eq (char-after) ?\,)
-			  (c-forward-token-2)
-			  (unless (c-on-identifier) (throw 'id-list nil))
-			  (c-forward-token-2))
-			(eq (char-after) ?\))))))
-
-		  ;; ...Yes.  We've identified the function's argument list.
-		  (throw 'knr
-		       (progn (goto-char after-rparen)
-			      (c-forward-syntactic-ws)
-			      (point)))
+		     ;; Have we got a non-empty list of comma-separated
+		     ;; identifiers?
+		     (progn
+		       (goto-char before-lparen)
+		       (c-forward-token-2) ; to first token inside parens
+		       (and
+			(c-on-identifier)
+			(c-forward-token-2)
+			(catch 'id-list
+			  (while (eq (char-after) ?\,)
+			    (c-forward-token-2)
+			    (unless (c-on-identifier) (throw 'id-list nil))
+			    (c-forward-token-2))
+			  (eq (char-after) ?\))))))
+
+		    ;; ...Yes.	We've identified the function's argument list.
+		    (throw 'knr
+			   (progn (goto-char after-rparen)
+				  (c-forward-syntactic-ws)
+				  (point)))
 
-		;; ...No.  The current parens aren't the function's arg list.
-		(goto-char before-lparen))
+		  ;; ...No.  The current parens aren't the function's arg list.
+		  (goto-char before-lparen))
 
 	      (or (c-go-list-backward)	; backwards over [ .... ]
 		  (throw 'knr nil)))))))))
@@ -7932,7 +8104,8 @@ comment at the start of cc-engine.el for
 	 (or (looking-at c-block-stmt-1-key)
 	     (and (eq (char-after) ?\()
 		  (zerop (c-backward-token-2 1 t lim))
-		  (looking-at c-block-stmt-2-key)))
+		  (or (looking-at c-block-stmt-2-key)
+		      (looking-at c-block-stmt-1-2-key))))
 	 (point))))
 
 (defun c-after-special-operator-id (&optional lim)
@@ -7979,7 +8152,7 @@ comment at the start of cc-engine.el for
   ;; Search forward for the end of the "header" of the current
   ;; declaration.  That's the position where the definition body
   ;; starts, or the first variable initializer, or the ending
-  ;; semicolon.  I.e. search forward for the closest following
+  ;; semicolon.	 I.e. search forward for the closest following
   ;; (syntactically relevant) '{', '=' or ';' token.  Point is left
   ;; _after_ the first found token, or at point-max if none is found.
   ;;
@@ -8014,7 +8187,7 @@ comment at the start of cc-engine.el for
 
 (defun c-beginning-of-decl-1 (&optional lim)
   ;; Go to the beginning of the current declaration, or the beginning
-  ;; of the previous one if already at the start of it.  Point won't
+  ;; of the previous one if already at the start of it.	 Point won't
   ;; be moved out of any surrounding paren.  Return a cons cell of the
   ;; form (MOVE . KNR-POS).  MOVE is like the return value from
   ;; `c-beginning-of-statement-1'.  If point skipped over some K&R
@@ -8068,7 +8241,7 @@ comment at the start of cc-engine.el for
 	  ;; Handle K&R argdecls.  Back up after the "statement" jumped
 	  ;; over by `c-beginning-of-statement-1', unless it was the
 	  ;; function body, in which case we're sitting on the opening
-	  ;; brace now.  Then test if we're in a K&R argdecl region and
+	  ;; brace now.	 Then test if we're in a K&R argdecl region and
 	  ;; that we started at the other side of the first argdecl in
 	  ;; it.
 	  (unless (eq (char-after) ?{)
@@ -8093,7 +8266,7 @@ comment at the start of cc-engine.el for
       ;; declaration boundary though, so change it to 'same if we've moved
       ;; past a '=' before '{', but not ';'.  (This ought to be integrated
       ;; into `c-beginning-of-statement-1', so we avoid this extra pass which
-      ;; potentially can search over a large amount of text.).  Take special
+      ;; potentially can search over a large amount of text.).	Take special
       ;; pains not to get mislead by C++'s "operator=", and the like.
       (if (and (eq move 'previous)
 	       (c-with-syntax-table (if (c-major-mode-is 'c++-mode)
@@ -8103,7 +8276,7 @@ comment at the start of cc-engine.el for
 		   (and
 		    (progn
 		      (while  ; keep going back to "[;={"s until we either find
-			    ; no more, or get to one which isn't an "operator ="
+					; no more, or get to one which isn't an "operator ="
 			  (and (c-syntactic-re-search-forward "[;={]" start t t t)
 			       (eq (char-before) ?=)
 			       c-overloadable-operators-regexp
@@ -8217,10 +8390,7 @@ comment at the start of cc-engine.el for
     (when (and c-recognize-<>-arglists
 	       (eq (char-before) ?>))
       ;; Could be at the end of a template arglist.
-      (let ((c-parse-and-markup-<>-arglists t)
-	    (c-disallow-comma-in-<>-arglists
-	     (and containing-sexp
-		  (not (eq (char-after containing-sexp) ?{)))))
+      (let ((c-parse-and-markup-<>-arglists t))
 	(while (and
 		(c-backward-<>-arglist nil limit)
 		(progn
@@ -8262,13 +8432,13 @@ comment at the start of cc-engine.el for
 	      ;;
 	      ;; Note: This doesn't cope with the case when a declared
 	      ;; identifier is followed by e.g. '(' in a language where '('
-	      ;; also might be part of a declarator expression.  Currently
+	      ;; also might be part of a declarator expression.	 Currently
 	      ;; there's no such language.
 	      (not (or (looking-at c-symbol-start)
 		       (looking-at c-type-decl-prefix-key)))))
 
 	    ;; In Pike a list of modifiers may be followed by a brace
-	    ;; to make them apply to many identifiers.  Note that the
+	    ;; to make them apply to many identifiers.	Note that the
 	    ;; match data will be empty on return in this case.
 	    ((and (c-major-mode-is 'pike-mode)
 		  (progn
@@ -8307,7 +8477,7 @@ comment at the start of cc-engine.el for
 		      (c-forward-syntactic-ws)))
 
 		;; Can't parse a declaration preamble and is still
-		;; before `kwd-start'.  That means `first-specifier-pos'
+		;; before `kwd-start'.	That means `first-specifier-pos'
 		;; was in some earlier construct.  Search again.
 		(if (c-syntactic-re-search-forward c-symbol-start
 						   kwd-start 'move t)
@@ -8322,7 +8492,7 @@ comment at the start of cc-engine.el for
 
 (defun c-search-uplist-for-classkey (paren-state)
   ;; Check if the closest containing paren sexp is a declaration
-  ;; block, returning a 2 element vector in that case.  Aref 0
+  ;; block, returning a 2 element vector in that case.	Aref 0
   ;; contains the bufpos at boi of the class key line, and aref 1
   ;; contains the bufpos of the open brace.  This function is an
   ;; obsolete wrapper for `c-looking-at-decl-block'.
@@ -8339,15 +8509,6 @@ comment at the start of cc-engine.el for
 	  (back-to-indentation)
 	  (vector (point) open-paren-pos))))))
 
-(defmacro c-pull-open-brace (ps)
-  ;; Pull the next open brace from PS (which has the form of paren-state),
-  ;; skipping over any brace pairs.  Returns NIL when PS is exhausted.
-  `(progn
-     (while (consp (car ,ps))
-       (setq ,ps (cdr ,ps)))
-     (prog1 (car ,ps)
-       (setq ,ps (cdr ,ps)))))
-
 (defun c-most-enclosing-decl-block (paren-state)
   ;; Return the buffer position of the most enclosing decl-block brace (in the
   ;; sense of c-looking-at-decl-block) in the PAREN-STATE structure, or nil if
@@ -8379,6 +8540,34 @@ comment at the start of cc-engine.el for
 		      (not (looking-at "=")))))
       b-pos)))
 
+(defun c-backward-over-enum-header ()
+  ;; We're at a "{".  Move back to the enum-like keyword that starts this
+  ;; declaration and return t, otherwise don't move and return nil.
+  (let ((here (point))
+	up-sexp-pos before-identifier)
+    (while
+	(and
+	 (eq (c-backward-token-2) 0)
+	 (or (not (looking-at "\\s)"))
+	     (c-go-up-list-backward))
+	 (cond
+	  ((and (looking-at c-symbol-key) (c-on-identifier)
+		(not before-identifier))
+	   (setq before-identifier t))
+	  ((and before-identifier
+		(or (eq (char-after) ?,)
+		    (looking-at c-postfix-decl-spec-key)))
+	   (setq before-identifier nil)
+	   t)
+	  ((looking-at c-brace-list-key) nil)
+	  ((and c-recognize-<>-arglists
+		(eq (char-after) ?<)
+		(looking-at "\\s("))
+	   t)
+	  (t nil))))
+    (or (looking-at c-brace-list-key)
+	(progn (goto-char here) nil))))
+
 (defun c-inside-bracelist-p (containing-sexp paren-state)
   ;; return the buffer position of the beginning of the brace list
   ;; statement if we're inside a brace list, otherwise return nil.
@@ -8387,24 +8576,15 @@ comment at the start of cc-engine.el for
   ;; braces
   ;;
   ;; N.B.: This algorithm can potentially get confused by cpp macros
-  ;; placed in inconvenient locations.  It's a trade-off we make for
+  ;; placed in inconvenient locations.	It's a trade-off we make for
   ;; speed.
   ;;
   ;; This function might do hidden buffer changes.
   (or
    ;; This will pick up brace list declarations.
-   (c-safe
-    (save-excursion
-      (goto-char containing-sexp)
-      (c-forward-sexp -1)
-      (let (bracepos)
-	(if (and (or (looking-at c-brace-list-key)
-		     (progn (c-forward-sexp -1)
-			    (looking-at c-brace-list-key)))
-		 (setq bracepos (c-down-list-forward (point)))
-		 (not (c-crosses-statement-barrier-p (point)
-						     (- bracepos 2))))
-	    (point)))))
+   (save-excursion
+     (goto-char containing-sexp)
+     (c-backward-over-enum-header))
    ;; this will pick up array/aggregate init lists, even if they are nested.
    (save-excursion
      (let ((class-key
@@ -8412,114 +8592,130 @@ comment at the start of cc-engine.el for
 	    ;; check for the class key here.
 	    (and (c-major-mode-is 'pike-mode)
 		 c-decl-block-key))
-	   bufpos braceassignp lim next-containing)
+	   bufpos braceassignp lim next-containing macro-start)
        (while (and (not bufpos)
 		   containing-sexp)
+	 (when paren-state
+	   (if (consp (car paren-state))
+	       (setq lim (cdr (car paren-state))
+		     paren-state (cdr paren-state))
+	     (setq lim (car paren-state)))
 	   (when paren-state
-	     (if (consp (car paren-state))
-		 (setq lim (cdr (car paren-state))
-		       paren-state (cdr paren-state))
-	       (setq lim (car paren-state)))
-	     (when paren-state
-	       (setq next-containing (car paren-state)
-		     paren-state (cdr paren-state))))
-	   (goto-char containing-sexp)
-	   (if (c-looking-at-inexpr-block next-containing next-containing)
-	       ;; We're in an in-expression block of some kind.  Do not
-	       ;; check nesting.  We deliberately set the limit to the
-	       ;; containing sexp, so that c-looking-at-inexpr-block
-	       ;; doesn't check for an identifier before it.
-	       (setq containing-sexp nil)
-	     ;; see if the open brace is preceded by = or [...] in
-	     ;; this statement, but watch out for operator=
-	     (setq braceassignp 'dontknow)
-	     (c-backward-token-2 1 t lim)
-	     ;; Checks to do only on the first sexp before the brace.
-	     (when (and c-opt-inexpr-brace-list-key
-			(eq (char-after) ?\[))
-	       ;; In Java, an initialization brace list may follow
-	       ;; directly after "new Foo[]", so check for a "new"
-	       ;; earlier.
-	       (while (eq braceassignp 'dontknow)
-		 (setq braceassignp
-		       (cond ((/= (c-backward-token-2 1 t lim) 0) nil)
-			     ((looking-at c-opt-inexpr-brace-list-key) t)
-			     ((looking-at "\\sw\\|\\s_\\|[.[]")
-			      ;; Carry on looking if this is an
-			      ;; identifier (may contain "." in Java)
-			      ;; or another "[]" sexp.
-			      'dontknow)
-			     (t nil)))))
-	     ;; Checks to do on all sexps before the brace, up to the
-	     ;; beginning of the statement.
+	     (setq next-containing (car paren-state)
+		   paren-state (cdr paren-state))))
+	 (goto-char containing-sexp)
+	 (if (c-looking-at-inexpr-block next-containing next-containing)
+	     ;; We're in an in-expression block of some kind.  Do not
+	     ;; check nesting.	We deliberately set the limit to the
+	     ;; containing sexp, so that c-looking-at-inexpr-block
+	     ;; doesn't check for an identifier before it.
+	     (setq containing-sexp nil)
+	   ;; see if the open brace is preceded by = or [...] in
+	   ;; this statement, but watch out for operator=
+	   (setq braceassignp 'dontknow)
+	   (c-backward-token-2 1 t lim)
+	   ;; Checks to do only on the first sexp before the brace.
+	   (when (and c-opt-inexpr-brace-list-key
+		      (eq (char-after) ?\[))
+	     ;; In Java, an initialization brace list may follow
+	     ;; directly after "new Foo[]", so check for a "new"
+	     ;; earlier.
 	     (while (eq braceassignp 'dontknow)
-	       (cond ((eq (char-after) ?\;)
-		      (setq braceassignp nil))
-		     ((and class-key
-			   (looking-at class-key))
-		      (setq braceassignp nil))
-		     ((eq (char-after) ?=)
-		      ;; We've seen a =, but must check earlier tokens so
-		      ;; that it isn't something that should be ignored.
-		      (setq braceassignp 'maybe)
-		      (while (and (eq braceassignp 'maybe)
-				  (zerop (c-backward-token-2 1 t lim)))
-			(setq braceassignp
-			      (cond
-			       ;; Check for operator =
-			       ((and c-opt-op-identifier-prefix
-				     (looking-at c-opt-op-identifier-prefix))
-				nil)
-			       ;; Check for `<opchar>= in Pike.
-			       ((and (c-major-mode-is 'pike-mode)
-				     (or (eq (char-after) ?`)
-					 ;; Special case for Pikes
-					 ;; `[]=, since '[' is not in
-					 ;; the punctuation class.
-					 (and (eq (char-after) ?\[)
-					      (eq (char-before) ?`))))
-				nil)
-			       ((looking-at "\\s.") 'maybe)
-			       ;; make sure we're not in a C++ template
-			       ;; argument assignment
-			       ((and
-				 (c-major-mode-is 'c++-mode)
-				 (save-excursion
-				   (let ((here (point))
-					 (pos< (progn
-						 (skip-chars-backward "^<>")
-						 (point))))
-				     (and (eq (char-before) ?<)
-					  (not (c-crosses-statement-barrier-p
-						pos< here))
-					  (not (c-in-literal))
-					  ))))
-				nil)
-			       (t t))))))
-	       (if (and (eq braceassignp 'dontknow)
-			(/= (c-backward-token-2 1 t lim) 0))
-		   (setq braceassignp nil)))
-	     (if (not braceassignp)
-		 (if (eq (char-after) ?\;)
-		     ;; Brace lists can't contain a semicolon, so we're done.
-		     (setq containing-sexp nil)
-		   ;; Go up one level.
-		   (setq containing-sexp next-containing
-			 lim nil
-			 next-containing nil))
-	       ;; we've hit the beginning of the aggregate list
-	       (c-beginning-of-statement-1
-		(c-most-enclosing-brace paren-state))
-	       (setq bufpos (point))))
-	   )
+	       (setq braceassignp
+		     (cond ((/= (c-backward-token-2 1 t lim) 0) nil)
+			   ((looking-at c-opt-inexpr-brace-list-key) t)
+			   ((looking-at "\\sw\\|\\s_\\|[.[]")
+			    ;; Carry on looking if this is an
+			    ;; identifier (may contain "." in Java)
+			    ;; or another "[]" sexp.
+			    'dontknow)
+			   (t nil)))))
+	   ;; Checks to do on all sexps before the brace, up to the
+	   ;; beginning of the statement.
+	   (while (eq braceassignp 'dontknow)
+	     (cond ((eq (char-after) ?\;)
+		    (setq braceassignp nil))
+		   ((and class-key
+			 (looking-at class-key))
+		    (setq braceassignp nil))
+		   ((eq (char-after) ?=)
+		    ;; We've seen a =, but must check earlier tokens so
+		    ;; that it isn't something that should be ignored.
+		    (setq braceassignp 'maybe)
+		    (while (and (eq braceassignp 'maybe)
+				(zerop (c-backward-token-2 1 t lim)))
+		      (setq braceassignp
+			    (cond
+			     ;; Check for operator =
+			     ((and c-opt-op-identifier-prefix
+				   (looking-at c-opt-op-identifier-prefix))
+			      nil)
+			     ;; Check for `<opchar>= in Pike.
+			     ((and (c-major-mode-is 'pike-mode)
+				   (or (eq (char-after) ?`)
+				       ;; Special case for Pikes
+				       ;; `[]=, since '[' is not in
+				       ;; the punctuation class.
+				       (and (eq (char-after) ?\[)
+					    (eq (char-before) ?`))))
+			      nil)
+			     ((looking-at "\\s.") 'maybe)
+			     ;; make sure we're not in a C++ template
+			     ;; argument assignment
+			     ((and
+			       (c-major-mode-is 'c++-mode)
+			       (save-excursion
+				 (let ((here (point))
+				       (pos< (progn
+					       (skip-chars-backward "^<>")
+					       (point))))
+				   (and (eq (char-before) ?<)
+					(not (c-crosses-statement-barrier-p
+					      pos< here))
+					(not (c-in-literal))
+					))))
+			      nil)
+			     (t t))))))
+	     (if (and (eq braceassignp 'dontknow)
+		      (/= (c-backward-token-2 1 t lim) 0))
+		 (setq braceassignp nil)))
+	   (cond
+	    (braceassignp
+	     ;; We've hit the beginning of the aggregate list.
+	     (c-beginning-of-statement-1
+	      (c-most-enclosing-brace paren-state))
+	     (setq bufpos (point)))
+	    ((eq (char-after) ?\;)
+	     ;; Brace lists can't contain a semicolon, so we're done.
+	     (setq containing-sexp nil))
+	    ((and (setq macro-start (point))
+		  (c-forward-to-cpp-define-body)
+		  (eq (point) containing-sexp))
+	     ;; We've a macro whose expansion starts with the '{'.
+	     ;; Heuristically, if we have a ';' in it we've not got a
+	     ;; brace list, otherwise we have.
+	     (let ((macro-end (progn (c-end-of-macro) (point))))
+	       (goto-char containing-sexp)
+	       (forward-char)
+	       (if (and (c-syntactic-re-search-forward "[;,]" macro-end t t)
+			(eq (char-before) ?\;))
+		   (setq bufpos nil
+			 containing-sexp nil)
+		 (setq bufpos macro-start))))
+	    (t
+	     ;; Go up one level
+	     (setq containing-sexp next-containing
+		   lim nil
+		   next-containing nil)))))
+
        bufpos))
    ))
 
 (defun c-looking-at-special-brace-list (&optional lim)
-  ;; If we're looking at the start of a pike-style list, ie `({})',
-  ;; `([])', `(<>)' etc, a cons of a cons of its starting and ending
+  ;; If we're looking at the start of a pike-style list, ie `({})',
+  ;; `([])', `(<>)' etc, a cons of a cons of its starting and ending
   ;; positions and its entry in c-special-brace-lists is returned, nil
-  ;; otherwise.  The ending position is nil if the list is still open.
+  ;; otherwise.	 The ending position is nil if the list is still open.
   ;; LIM is the limit for forward search.  The point may either be at
   ;; the `(' or at the following paren character.  Tries to check the
   ;; matching closer, but assumes it's correct if no balanced paren is
@@ -8587,7 +8783,7 @@ comment at the start of cc-engine.el for
   ;;
   ;; This function might do hidden buffer changes.
   (c-at-statement-start-p))
-(make-obsolete 'c-looking-at-bos 'c-at-statement-start-p "22.1")
+(make-obsolete 'c-looking-at-bos 'c-at-statement-start-p nil)
 
 (defun c-looking-at-inexpr-block (lim containing-sexp &optional check-at-end)
   ;; Return non-nil if we're looking at the beginning of a block
@@ -8598,11 +8794,11 @@ comment at the start of cc-engine.el for
   ;; LIM limits the backward search.  CONTAINING-SEXP is the start
   ;; position of the closest containing list.  If it's nil, the
   ;; containing paren isn't used to decide whether we're inside an
-  ;; expression or not.  If both LIM and CONTAINING-SEXP are used, LIM
+  ;; expression or not.	 If both LIM and CONTAINING-SEXP are used, LIM
   ;; needs to be farther back.
   ;;
   ;; If CHECK-AT-END is non-nil then extra checks at the end of the
-  ;; brace block might be done.  It should only be used when the
+  ;; brace block might be done.	 It should only be used when the
   ;; construct can be assumed to be complete, i.e. when the original
   ;; starting position was further down than that.
   ;;
@@ -8782,7 +8978,7 @@ comment at the start of cc-engine.el for
   ;; "namespace".
   ;;
   ;; Currently (2007-08-17), "like namespace" means "matches
-  ;; c-other-block-decl-kwds".  It doesn't work with "class" or "struct"
+  ;; c-other-block-decl-kwds".	It doesn't work with "class" or "struct"
   ;; or anything like that.
   (save-excursion
     (let ((boi (c-point 'boi bracepos)))
@@ -9002,7 +9198,7 @@ comment at the start of cc-engine.el for
 		     (max (c-point 'boi paren-pos) (point))))
 		   (t (c-add-syntax 'defun-block-intro nil))))
 
-		 (c-add-syntax 'statement-block-intro nil)))
+	      (c-add-syntax 'statement-block-intro nil)))
 
 	  (if (= paren-pos boi)
 	      ;; Always done if the open brace was at boi.  The
@@ -9122,7 +9318,7 @@ comment at the start of cc-engine.el for
        ;; CASE B.4: Continued statement with block open.  The most
        ;; accurate analysis is perhaps `statement-cont' together with
        ;; `block-open' but we play DWIM and use `substatement-open'
-       ;; instead.  The rationale is that this typically is a macro
+       ;; instead.  The rationaly is that this typically is a macro
        ;; followed by a block which makes it very similar to a
        ;; statement with a substatement block.
        (t
@@ -9199,20 +9395,20 @@ comment at the start of cc-engine.el for
 		    (not (looking-at c-<-op-cont-regexp))))))
       (c-with-syntax-table c++-template-syntax-table
 	(goto-char placeholder)
-	(c-beginning-of-statement-1 containing-sexp t)
-	(if (save-excursion
-	      (c-backward-syntactic-ws containing-sexp)
-	      (eq (char-before) ?<))
-	    ;; In a nested template arglist.
-	    (progn
-	      (goto-char placeholder)
-	      (c-syntactic-skip-backward "^,;" containing-sexp t)
-	      (c-forward-syntactic-ws))
-	  (back-to-indentation)))
+	(c-beginning-of-statement-1 containing-sexp t))
+      (if (save-excursion
+	    (c-backward-syntactic-ws containing-sexp)
+	    (eq (char-before) ?<))
+	  ;; In a nested template arglist.
+	  (progn
+	    (goto-char placeholder)
+	    (c-syntactic-skip-backward "^,;" containing-sexp t)
+	    (c-forward-syntactic-ws))
+	(back-to-indentation))
       ;; FIXME: Should use c-add-stmt-syntax, but it's not yet
       ;; template aware.
       (c-add-syntax 'template-args-cont (point) placeholder))
-
+     
      ;; CASE D: continued statement.
      (t
       (c-beginning-of-statement-1 containing-sexp)
@@ -9230,7 +9426,8 @@ comment at the start of cc-engine.el for
     (c-save-buffer-state
 	((indent-point (point))
 	 (case-fold-search nil)
-	 ;; A whole ugly bunch of various temporary variables.  Have
+	 open-paren-in-column-0-is-defun-start
+	 ;; A whole ugly bunch of various temporary variables.	Have
 	 ;; to declare them here since it's not possible to declare
 	 ;; a variable with only the scope of a cond test and the
 	 ;; following result clauses, and most of this function is a
@@ -9293,7 +9490,7 @@ comment at the start of cc-engine.el for
 		(progn
 		  (setq lim (cdr containing-sexp))
 		  (if (cdr c-state-cache)
-		      ;; Ignore balanced paren.  The next entry
+		      ;; Ignore balanced paren.	 The next entry
 		      ;; can't be another one.
 		      (setq containing-sexp (car (cdr c-state-cache))
 			    paren-state (cdr paren-state))
@@ -9303,10 +9500,6 @@ comment at the start of cc-engine.el for
 			  containing-sexp nil)))
 	      (setq lim (1+ containing-sexp))))
 	(setq lim (point-min)))
-      (when (c-beginning-of-macro)
-	(goto-char indent-point)
-	(let ((lim1 (c-determine-limit 2000)))
-	  (setq lim (max lim lim1))))
 
       ;; If we're in a parenthesis list then ',' delimits the
       ;; "statements" rather than being an operator (with the
@@ -9445,7 +9638,7 @@ comment at the start of cc-engine.el for
 				    'label))
 			    (if (eq step 'up)
 				(setq placeholder (point))
-			      ;; There was no containing statement after all.
+			      ;; There was no containing statement afterall.
 			      (goto-char placeholder)))))
 		    placeholder))
 	       (if (looking-at c-block-stmt-2-key)
@@ -9475,7 +9668,7 @@ comment at the start of cc-engine.el for
 		(c-add-stmt-syntax 'substatement nil nil
 				   containing-sexp paren-state))))
 
-	  ;; CASE 18B: Some other substatement.  This is shared
+	  ;; CASE 18B: Some other substatement.	 This is shared
 	  ;; with case 10.
 	  (c-guess-continued-construct indent-point
 				       char-after-ip
@@ -9668,18 +9861,13 @@ comment at the start of cc-engine.el for
 	      ;; 2007-11-09)
 	      ))))
 
-	 ;; CASE 5B: After a function header but before the body (or
-	 ;; the ending semicolon if there's no body).
+	 ;; CASE 5R: Member init list.  (Used to be part of CASE  5B.1)
+	 ;; Note there is no limit on the backward search here, since member
+	 ;; init lists can, in practice, be very large.
 	 ((save-excursion
-	    (when (setq placeholder (c-just-after-func-arglist-p
-				     (max lim (c-determine-limit 500))))
+	    (when (setq placeholder (c-back-over-member-initializers))
 	      (setq tmp-pos (point))))
-	  (cond
-
-	   ;; CASE 5B.1: Member init list.
-	   ((eq (char-after tmp-pos) ?:)
-	    (if (or (>= tmp-pos indent-point)
-		    (= (c-point 'bosws) (1+ tmp-pos)))
+	  (if (= (c-point 'bosws) (1+ tmp-pos))
 		(progn
 		  ;; There is no preceding member init clause.
 		  ;; Indent relative to the beginning of indentation
@@ -9692,6 +9880,23 @@ comment at the start of cc-engine.el for
 	      (c-forward-syntactic-ws)
 	      (c-add-syntax 'member-init-cont (point))))
 
+	 ;; CASE 5B: After a function header but before the body (or
+	 ;; the ending semicolon if there's no body).
+	 ((save-excursion
+	    (when (setq placeholder (c-just-after-func-arglist-p
+				     (max lim (c-determine-limit 500))))
+	      (setq tmp-pos (point))))
+	  (cond
+
+	   ;; CASE 5B.1: Member init list.
+	   ((eq (char-after tmp-pos) ?:)
+	    ;; There is no preceding member init clause.
+	    ;; Indent relative to the beginning of indentation
+	    ;; for the topmost-intro line that contains the
+	    ;; prototype's open paren.
+	    (goto-char placeholder)
+	    (c-add-syntax 'member-init-intro (c-point 'boi)))
+
 	   ;; CASE 5B.2: K&R arg decl intro
 	   ((and c-recognize-knr-p
 		 (c-in-knr-argdecl lim))
@@ -9727,12 +9932,12 @@ comment at the start of cc-engine.el for
 			      (not (eq (char-after) ?:))
 			      )))
 		   (save-excursion
-		     (c-backward-syntactic-ws lim)
-		     (if (eq char-before-ip ?:)
-			 (progn
-			   (forward-char -1)
-			   (c-backward-syntactic-ws lim)))
-		     (back-to-indentation)
+		     (c-beginning-of-statement-1 lim)
+		     (when (looking-at c-opt-<>-sexp-key)
+		       (goto-char (match-end 1))
+		       (c-forward-syntactic-ws)
+		       (c-forward-<>-arglist nil)
+		       (c-forward-syntactic-ws))
 		     (looking-at c-class-key)))
 	      ;; for Java
 	      (and (c-major-mode-is 'java-mode)
@@ -9799,6 +10004,18 @@ comment at the start of cc-engine.el for
 	    ;; contains any class offset
 	    )))
 
+	 ;; CASE 5P: AWK pattern or function or continuation
+	 ;; thereof.
+	 ((c-major-mode-is 'awk-mode)
+	  (setq placeholder (point))
+	  (c-add-stmt-syntax
+	   (if (and (eq (c-beginning-of-statement-1) 'same)
+		    (/= (point) placeholder))
+	       'topmost-intro-cont
+	     'topmost-intro)
+	   nil nil
+	   containing-sexp paren-state))
+
 	 ;; CASE 5D: this could be a top-level initialization, a
 	 ;; member init list continuation, or a template argument
 	 ;; list continuation.
@@ -9845,16 +10062,16 @@ comment at the start of cc-engine.el for
 			    (eq (char-after placeholder) ?<))))))
 	    (c-with-syntax-table c++-template-syntax-table
 	      (goto-char placeholder)
-	      (c-beginning-of-statement-1 lim t)
-	      (if (save-excursion
-		    (c-backward-syntactic-ws lim)
-		    (eq (char-before) ?<))
-		  ;; In a nested template arglist.
-		  (progn
-		    (goto-char placeholder)
-		    (c-syntactic-skip-backward "^,;" lim t)
-		    (c-forward-syntactic-ws))
-		(back-to-indentation)))
+	      (c-beginning-of-statement-1 lim t))
+	    (if (save-excursion
+		  (c-backward-syntactic-ws lim)
+		  (eq (char-before) ?<))
+		;; In a nested template arglist.
+		(progn
+		  (goto-char placeholder)
+		  (c-syntactic-skip-backward "^,;" lim t)
+		  (c-forward-syntactic-ws))
+	      (back-to-indentation))
 	    ;; FIXME: Should use c-add-stmt-syntax, but it's not yet
 	    ;; template aware.
 	    (c-add-syntax 'template-args-cont (point) placeholder))
@@ -9877,7 +10094,7 @@ comment at the start of cc-engine.el for
 	    (c-add-syntax 'inher-cont (c-point 'boi)))
 
 	   ;; CASE 5D.5: Continuation of the "expression part" of a
-	   ;; top level construct.  Or, perhaps, an unrecognized construct.
+	   ;; top level construct.  Or, perhaps, an unrecognised construct.
 	   (t
 	    (while (and (setq placeholder (point))
 			(eq (car (c-beginning-of-decl-1 containing-sexp)) ; Can't use `lim' here.
@@ -9888,9 +10105,9 @@ comment at the start of cc-engine.el for
 			(< (point) placeholder)))
 	    (c-add-stmt-syntax
 	     (cond
-	      ((eq (point) placeholder) 'statement) ; unrecognized construct
+	      ((eq (point) placeholder) 'statement) ; unrecognised construct
 	      ;; A preceding comma at the top level means that a
-	      ;; new variable declaration starts here.  Use
+	      ;; new variable declaration starts here.	Use
 	      ;; topmost-intro-cont for it, for consistency with
 	      ;; the first variable declaration.  C.f. case 5N.
 	      ((eq char-before-ip ?,) 'topmost-intro-cont)
@@ -9958,18 +10175,6 @@ comment at the start of cc-engine.el for
 	      (goto-char (point-min)))
 	  (c-add-syntax 'objc-method-intro (c-point 'boi)))
 
-	 ;; CASE 5P: AWK pattern or function or continuation
-	 ;; thereof.
-	 ((c-major-mode-is 'awk-mode)
-	  (setq placeholder (point))
-	  (c-add-stmt-syntax
-	   (if (and (eq (c-beginning-of-statement-1) 'same)
-		    (/= (point) placeholder))
-	       'topmost-intro-cont
-	     'topmost-intro)
-	   nil nil
-	   containing-sexp paren-state))
-
 	 ;; CASE 5N: At a variable declaration that follows a class
 	 ;; definition or some other block declaration that doesn't
 	 ;; end at the closing '}'.  C.f. case 5D.5.
@@ -10023,7 +10228,7 @@ comment at the start of cc-engine.el for
 			  (setq placeholder (point)))
 			nil)))))
 	  ;; For historic reasons we anchor at bol of the last
-	  ;; line of the previous declaration.  That's clearly
+	  ;; line of the previous declaration.	That's clearly
 	  ;; highly bogus and useless, and it makes our lives hard
 	  ;; to remain compatible.  :P
 	  (goto-char placeholder)
@@ -10079,19 +10284,19 @@ comment at the start of cc-engine.el for
 	  (c-beginning-of-statement-1 containing-sexp)
 	  (c-add-stmt-syntax 'statement nil t containing-sexp paren-state))
 
-	 ;;CASE 5N: We are at a topmost continuation line and the only
-	 ;;preceding items are annotations.
+     ;;CASE 5N: We are at a tompmost continuation line and the only
+     ;;preceding items are annotations.
 	 ((and (c-major-mode-is 'java-mode)
 	       (setq placeholder (point))
-	       (c-beginning-of-statement-1)
-	       (progn
+           (c-beginning-of-statement-1)
+           (progn
 		 (while (and (c-forward-annotation))
-		   (c-forward-syntactic-ws))
-		 t)
-	       (prog1
-		   (>= (point) placeholder)
-		 (goto-char placeholder)))
-	  (c-add-syntax 'annotation-top-cont (c-point 'boi)))
+	       (c-forward-syntactic-ws))
+	     t)
+	   (prog1
+             (>= (point) placeholder)
+             (goto-char placeholder)))
+      (c-add-syntax 'annotation-top-cont (c-point 'boi)))
 
 	 ;; CASE 5M: we are at a topmost continuation line
 	 (t
@@ -10106,7 +10311,6 @@ comment at the start of cc-engine.el for
 	  (c-add-syntax 'topmost-intro-cont (c-point 'boi)))
 	 ))
 
-
        ;; (CASE 6 has been removed.)
 
        ;; CASE 7: line is an expression, not a statement.  Most
@@ -10206,14 +10410,14 @@ comment at the start of cc-engine.el for
 	 ;; but the preceding argument is on the same line as the
 	 ;; opening paren.  This case includes multi-line
 	 ;; mathematical paren groupings, but we could be on a
-	 ;; for-list continuation line.  C.f. case 7A.
+	 ;; for-list continuation line.	 C.f. case 7A.
 	 ((progn
 	    (goto-char (1+ containing-sexp))
 	    (< (save-excursion
 		 (c-forward-syntactic-ws)
 		 (point))
 	       (c-point 'bonl)))
-	  (goto-char containing-sexp)	; paren opening the arglist
+	  (goto-char containing-sexp)
 	  (setq placeholder (c-point 'boi))
 	  (if (and (c-safe (backward-up-list 1) t)
 		   (>= (point) placeholder))
@@ -10257,7 +10461,7 @@ comment at the start of cc-engine.el for
 	  )))
 
        ;; CASE 9: we are inside a brace-list
-       ((and (not (c-major-mode-is 'awk-mode)) ; Maybe this isn't needed (ACM, 2002/3/29)
+       ((and (not (c-major-mode-is 'awk-mode))	; Maybe this isn't needed (ACM, 2002/3/29)
 	     (setq special-brace-list
 		   (or (and c-special-brace-lists ;;;; ALWAYS NIL FOR AWK!!
 			    (save-excursion
@@ -10309,7 +10513,7 @@ comment at the start of cc-engine.el for
 	  (if (eq (point) (c-point 'boi))
 	      (c-add-syntax 'brace-list-close (point))
 	    (setq lim (c-most-enclosing-brace c-state-cache (point)))
-	    (c-beginning-of-statement-1 lim)
+	    (c-beginning-of-statement-1 lim nil nil t)
 	    (c-add-stmt-syntax 'brace-list-close nil t lim paren-state)))
 
 	 (t
@@ -10374,27 +10578,27 @@ comment at the start of cc-engine.el for
 	;; From here on we have the next containing sexp in lim.
 	(setq lim (c-most-enclosing-brace paren-state))
 	(goto-char containing-sexp)
-	(cond
+	    (cond
 
-	 ;; CASE 16E: Closing a statement block?  This catches
-	 ;; cases where it's preceded by a statement keyword,
-	 ;; which works even when used in an "invalid" context,
-	 ;; e.g. a macro argument.
-	 ((c-after-conditional)
-	  (c-backward-to-block-anchor lim)
-	  (c-add-stmt-syntax 'block-close nil t lim paren-state))
+	     ;; CASE 16E: Closing a statement block?  This catches
+	     ;; cases where it's preceded by a statement keyword,
+	     ;; which works even when used in an "invalid" context,
+	     ;; e.g. a macro argument.
+	     ((c-after-conditional)
+	      (c-backward-to-block-anchor lim)
+	      (c-add-stmt-syntax 'block-close nil t lim paren-state))
 
-	 ;; CASE 16A: closing a lambda defun or an in-expression
-	 ;; block?  C.f. cases 4, 7B and 17E.
-	 ((setq placeholder (c-looking-at-inexpr-block
+	     ;; CASE 16A: closing a lambda defun or an in-expression
+	     ;; block?	C.f. cases 4, 7B and 17E.
+	     ((setq placeholder (c-looking-at-inexpr-block
 			     (c-safe-position containing-sexp paren-state)
 			     nil))
-	  (setq tmpsymbol (if (eq (car placeholder) 'inlambda)
+	      (setq tmpsymbol (if (eq (car placeholder) 'inlambda)
 			      'inline-close
 			    'block-close))
-	  (goto-char containing-sexp)
-	  (back-to-indentation)
-	  (if (= containing-sexp (point))
+	      (goto-char containing-sexp)
+	      (back-to-indentation)
+	      (if (= containing-sexp (point))
 	      (c-add-syntax tmpsymbol (point))
 	    (goto-char (cdr placeholder))
 	    (back-to-indentation)
@@ -10404,9 +10608,9 @@ comment at the start of cc-engine.el for
 	    (if (/= (point) (cdr placeholder))
 		(c-add-syntax (car placeholder)))))
 
-	 ;; CASE 16B: does this close an inline or a function in
-	 ;; a non-class declaration level block?
-	 ((save-excursion
+	     ;; CASE 16B: does this close an inline or a function in
+	     ;; a non-class declaration level block?
+	     ((save-excursion
 	    (and lim
 		 (progn
 		   (goto-char lim)
@@ -10414,20 +10618,20 @@ comment at the start of cc-engine.el for
 		    (c-most-enclosing-brace paren-state lim)
 		    nil))
 		 (setq placeholder (point))))
-	  (c-backward-to-decl-anchor lim)
-	  (back-to-indentation)
-	  (if (save-excursion
+	      (c-backward-to-decl-anchor lim)
+	      (back-to-indentation)
+	      (if (save-excursion
 		(goto-char placeholder)
 		(looking-at c-other-decl-block-key))
 	      (c-add-syntax 'defun-close (point))
 	    (c-add-syntax 'inline-close (point))))
 
-	 ;; CASE 16F: Can be a defun-close of a function declared
-	 ;; in a statement block, e.g. in Pike or when using gcc
-	 ;; extensions, but watch out for macros followed by
-	 ;; blocks.  Let it through to be handled below.
-	 ;; C.f. cases B.3 and 17G.
-	 ((save-excursion
+	     ;; CASE 16F: Can be a defun-close of a function declared
+	     ;; in a statement block, e.g. in Pike or when using gcc
+	     ;; extensions, but watch out for macros followed by
+	     ;; blocks.	 Let it through to be handled below.
+	     ;; C.f. cases B.3 and 17G.
+	     ((save-excursion
 	    (and (not (c-at-statement-start-p))
 		 (eq (c-beginning-of-statement-1 lim nil nil t) 'same)
 		 (setq placeholder (point))
@@ -10436,39 +10640,39 @@ comment at the start of cc-engine.el for
 		   ;; lacks a type in this case, since that's more
 		   ;; likely to be a macro followed by a block.
 		   (c-forward-decl-or-cast-1 (c-point 'bosws) nil nil))))
-	  (back-to-indentation)
-	  (if (/= (point) containing-sexp)
+	      (back-to-indentation)
+	      (if (/= (point) containing-sexp)
 	      (goto-char placeholder))
-	  (c-add-stmt-syntax 'defun-close nil t lim paren-state))
+	      (c-add-stmt-syntax 'defun-close nil t lim paren-state))
 
-	 ;; CASE 16C: If there is an enclosing brace then this is
-	 ;; a block close since defun closes inside declaration
-	 ;; level blocks have been handled above.
-	 (lim
-	  ;; If the block is preceded by a case/switch label on
-	  ;; the same line, we anchor at the first preceding label
-	  ;; at boi.  The default handling in c-add-stmt-syntax
-	  ;; really fixes it better, but we do like this to keep
-	  ;; the indentation compatible with version 5.28 and
-	  ;; earlier.  C.f. case 17H.
-	  (while (and (/= (setq placeholder (point)) (c-point 'boi))
+	     ;; CASE 16C: If there is an enclosing brace then this is
+	     ;; a block close since defun closes inside declaration
+	     ;; level blocks have been handled above.
+	     (lim
+	      ;; If the block is preceded by a case/switch label on
+	      ;; the same line, we anchor at the first preceding label
+	      ;; at boi.  The default handling in c-add-stmt-syntax
+	      ;; really fixes it better, but we do like this to keep
+	      ;; the indentation compatible with version 5.28 and
+	      ;; earlier.  C.f. case 17H.
+	      (while (and (/= (setq placeholder (point)) (c-point 'boi))
 		      (eq (c-beginning-of-statement-1 lim) 'label)))
-	  (goto-char placeholder)
-	  (if (looking-at c-label-kwds-regexp)
+	      (goto-char placeholder)
+	      (if (looking-at c-label-kwds-regexp)
 	      (c-add-syntax 'block-close (point))
 	    (goto-char containing-sexp)
 	    ;; c-backward-to-block-anchor not necessary here; those
 	    ;; situations are handled in case 16E above.
 	    (c-add-stmt-syntax 'block-close nil t lim paren-state)))
 
-	 ;; CASE 16D: Only top level defun close left.
-	 (t
-	  (goto-char containing-sexp)
-	  (c-backward-to-decl-anchor lim)
-	  (c-add-stmt-syntax 'defun-close nil nil
+	     ;; CASE 16D: Only top level defun close left.
+	     (t
+	      (goto-char containing-sexp)
+	      (c-backward-to-decl-anchor lim)
+	      (c-add-stmt-syntax 'defun-close nil nil
 			     (c-most-enclosing-brace paren-state)
 			     paren-state))
-	 ))
+	     ))
 
        ;; CASE 19: line is an expression, not a statement, and is directly
        ;; contained by a template delimiter.	Most likely, we are in a
@@ -10590,7 +10794,7 @@ comment at the start of cc-engine.el for
 	 ;; CASE 17G: First statement in a function declared inside
 	 ;; a normal block.  This can occur in Pike and with
 	 ;; e.g. the gcc extensions, but watch out for macros
-	 ;; followed by blocks.  C.f. cases B.3 and 16F.
+	 ;; followed by blocks.	 C.f. cases B.3 and 16F.
 	 ((save-excursion
 	    (and (not (c-at-statement-start-p))
 		 (eq (c-beginning-of-statement-1 lim nil nil t) 'same)
@@ -10683,7 +10887,7 @@ comment at the start of cc-engine.el for
 			 (or (not (c-forward-to-cpp-define-body))
 			     (<= (point) (c-point 'boi indent-point)))))
 	      ;; Inside a #define body and the syntactic analysis is
-	      ;; anchored on the start of the #define.  In this case
+	      ;; anchored on the start of the #define.	In this case
 	      ;; we add cpp-define-intro to get the extra
 	      ;; indentation of the #define body.
 	      (c-add-syntax 'cpp-define-intro)))))
@@ -10809,7 +11013,7 @@ Cannot combine absolute offsets %S and %
   ;;
   ;; This function might do hidden buffer changes.
   (let* ((symbol (c-langelem-sym langelem))
-	 (match  (assq symbol c-offsets-alist))
+	 (match	 (assq symbol c-offsets-alist))
 	 (offset (cdr-safe match)))
     (if match
 	(setq offset (c-evaluate-offset offset langelem symbol))
@@ -10880,4 +11084,6 @@ Cannot combine absolute offsets %S and %
 
 (cc-provide 'cc-engine)
 
+;;; arch-tag: 149add18-4673-4da5-ac47-6805e4eae089
 ;;; cc-engine.el ends here
+
--- /dev/null
+++ emacs24-24.3+1/lisp/progmodes/cc-fix.el
@@ -0,0 +1,155 @@
+;;; cc-fix.el --- compatibility library for old (X)Emacs versions
+
+;; Copyright (C) 1985,1987,1992-2003, 2004, 2005, 2006, 2007, 2008,
+;; 2009, 2010, 2011  Free Software Foundation, Inc.
+
+;; Authors:    2003- Alan Mackenzie
+;;             1998- Martin Stjernholm
+;;             1997-1999 Barry A. Warsaw
+;; Maintainer: bug-cc-mode@gnu.org
+;; Created:    03-Jul-1997 (as cc-mode-19.el)
+;; Version:    See cc-mode.el
+;; Keywords:   c languages oop
+
+;; This file is not part of GNU Emacs.
+
+;; This program is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3 of the License, or
+;; (at your option) any later version.
+
+;; This program is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with this program; see the file COPYING.  If not, see
+;; <http://www.gnu.org/licenses/>.
+
+;;; Commentary:
+
+;; This file is necessary in order to run CC Mode in older (X)Emacs
+;; versions.  It's not needed at all for the latest versions of Emacs
+;; and XEmacs.
+
+;;; Code:
+
+(eval-when-compile
+  (let ((load-path
+	 (if (and (boundp 'byte-compile-dest-file)
+		  (stringp byte-compile-dest-file))
+	     (cons (file-name-directory byte-compile-dest-file) load-path)
+	   load-path)))
+    (load "cc-bytecomp" nil t)))
+
+;; Silence the compiler (in case this file is compiled by other
+;; Emacsen even though it isn't used by them).
+(cc-bytecomp-obsolete-fun byte-code-function-p)
+(cc-bytecomp-defun regexp-opt-depth)
+
+(cc-external-require 'advice)
+
+;; Emacs 20.n doesn't have the macros push and pop.  Here're the Emacs 21
+;; definitions.
+(or (fboundp 'push)
+    (defmacro push (newelt listname)
+      "Add NEWELT to the list stored in the symbol LISTNAME.
+This is equivalent to (setq LISTNAME (cons NEWELT LISTNAME)).
+LISTNAME must be a symbol."
+      (list 'setq listname
+	    (list 'cons newelt listname))))
+
+(or (fboundp 'pop)
+    (defmacro pop (listname)
+      "Return the first element of LISTNAME's value, and remove it from the list.
+LISTNAME must be a symbol whose value is a list.
+If the value is nil, `pop' returns nil but does not actually
+change the list."
+      (list 'prog1 (list 'car listname)
+	    (list 'setq listname (list 'cdr listname)))))
+
+
+(if (/= (regexp-opt-depth "\\(\\(\\)\\)") 2)
+    (progn
+      ;; Emacs 21.1 has a buggy regexp-opt-depth which prevents CC
+      ;; Mode building.  Those in Emacs 21.[23] are not entirely
+      ;; accurate.  The following definition comes from Emacs's
+      ;; regexp-opt.el CVS version 1.25 and is believed to be a
+      ;; rigorously correct implementation.
+      (defconst regexp-opt-not-groupie*-re
+	(let* ((harmless-ch "[^\\\\[]")
+	       (esc-pair-not-lp "\\\\[^(]")
+	       (class-harmless-ch "[^][]")
+	       (class-lb-harmless "[^]:]")
+	       (class-lb-colon-maybe-charclass ":\\([a-z]+:]\\)?")
+	       (class-lb (concat "\\[\\(" class-lb-harmless
+				 "\\|" class-lb-colon-maybe-charclass "\\)"))
+	       (class
+		(concat "\\[^?]?"
+			"\\(" class-harmless-ch
+			"\\|" class-lb "\\)*"
+			"\\[?]")) ; special handling for bare [ at end of re
+	       (shy-lp "\\\\(\\?:"))
+	  (concat "\\(" harmless-ch "\\|" esc-pair-not-lp
+		  "\\|" class "\\|" shy-lp "\\)*"))
+	"Matches any part of a regular expression EXCEPT for non-shy \"\\\\(\"s")
+
+      (defun regexp-opt-depth (regexp)
+	"Return the depth of REGEXP.
+This means the number of regexp grouping constructs (parenthesised expressions)
+in REGEXP."
+	(save-match-data
+	  ;; Hack to signal an error if REGEXP does not have balanced
+	  ;; parentheses.
+	  (string-match regexp "")
+	  ;; Count the number of open parentheses in REGEXP.
+	  (let ((count 0) start)
+	    (while
+		(progn
+		  (string-match regexp-opt-not-groupie*-re regexp start)
+		  (setq start ( + (match-end 0) 2)) ; +2 for "\\(" after match-end.
+		  (<= start (length regexp)))
+	      (setq count (1+ count)))
+	    count)))
+      ))
+
+;; Some XEmacs versions have a bug in which font-lock-compile-keywords
+;; overwrites the variable font-lock-keywords with its result.  This causes
+;; havoc when what the function is compiling is font-lock-SYNTACTIC-keywords,
+;; hence....
+(eval-after-load "font-lock"
+  '(when (and (featurep 'xemacs) ; There is now (2005/12) code in GNU Emacs CVS
+				 ; to make the call to f-l-c-k throw an error.
+	      (let (font-lock-keywords)
+		(font-lock-compile-keywords '("\\<\\>"))
+		font-lock-keywords))	; did the previous call foul this up?
+     (defun font-lock-compile-keywords (keywords)
+       "Compile KEYWORDS (a list) and return the list of compiled keywords.
+Each keyword has the form (MATCHER HIGHLIGHT ...).  See `font-lock-keywords'."
+       (if (eq (car-safe keywords) t)
+	   keywords
+	 (cons t (mapcar 'font-lock-compile-keyword keywords))))
+     (defadvice font-lock-fontify-keywords-region (before c-compile-font-lock-keywords
+							  activate preactivate)
+       (unless (eq (car-safe font-lock-keywords) t)
+	 (setq font-lock-keywords
+	       (font-lock-compile-keywords font-lock-keywords))))
+     ))
+
+;; XEmacs 21.4 doesn't have `delete-dups'.
+(if (not (fboundp 'delete-dups))
+    (defun delete-dups (list)
+      "Destructively remove `equal' duplicates from LIST.
+Store the result in LIST and return it.  LIST must be a proper list.
+Of several `equal' occurrences of an element in LIST, the first
+one is kept."
+      (let ((tail list))
+	(while tail
+	  (setcdr tail (delete (car tail) (cdr tail)))
+	  (setq tail (cdr tail))))
+      list))
+
+
+(cc-provide 'cc-fix)
+;;; cc-fix.el ends here
--- emacs24-24.3+1.orig/lisp/progmodes/cc-fonts.el
+++ emacs24-24.3+1/lisp/progmodes/cc-fonts.el
@@ -1,20 +1,21 @@
 ;;; cc-fonts.el --- font lock support for CC Mode
 
-;; Copyright (C) 2002-2013 Free Software Foundation, Inc.
+;; Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+;;   2010, 2011  Free Software Foundation, Inc.
 
 ;; Authors:    2003- Alan Mackenzie
 ;;             2002- Martin Stjernholm
 ;; Maintainer: bug-cc-mode@gnu.org
 ;; Created:    07-Jan-2002
-;; Keywords:   c languages
-;; Package:    cc-mode
+;; Version:    See cc-mode.el
+;; Keywords:   c languages oop
 
 ;; This file is part of GNU Emacs.
 
-;; GNU Emacs is free software: you can redistribute it and/or modify
+;; GNU Emacs is free software; you can redistribute it and/or modify
 ;; it under the terms of the GNU General Public License as published by
-;; the Free Software Foundation, either version 3 of the License, or
-;; (at your option) any later version.
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
 
 ;; GNU Emacs is distributed in the hope that it will be useful,
 ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -22,7 +23,8 @@
 ;; GNU General Public License for more details.
 
 ;; You should have received a copy of the GNU General Public License
-;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
+;; along with this program; see the file COPYING.  If not, see
+;; <http://www.gnu.org/licenses/>.
 
 ;;; Commentary:
 
@@ -141,14 +143,13 @@
     c-label-face-name))
 
 (defconst c-reference-face-name
-  (with-no-warnings
-   (if (and (c-face-name-p 'font-lock-reference-face)
-	    (eq font-lock-reference-face 'font-lock-reference-face))
-       ;; This is considered obsolete in Emacs, but it still maps well
-       ;; to this use.  (Another reason to do this is to get unique
-       ;; faces for the test suite.)
-       'font-lock-reference-face
-     c-label-face-name)))
+  (if (and (c-face-name-p 'font-lock-reference-face)
+	   (eq font-lock-reference-face 'font-lock-reference-face))
+      ;; This is considered obsolete in Emacs, but it still maps well
+      ;; to this use.  (Another reason to do this is to get unique
+      ;; faces for the test suite.)
+      'font-lock-reference-face
+    c-label-face-name))
 
 ;; This should not mapped to a face that also is used to fontify things
 ;; that aren't comments or string literals.
@@ -194,14 +195,6 @@
 	 (unless (face-property-instance oldface 'reverse)
 	   (invert-face newface)))))
 
-(defvar c-annotation-face 'c-annotation-face)
-
-(defface c-annotation-face
-  '((default :inherit font-lock-constant-face))
-  "Face for highlighting annotations in Java mode and similar modes."
-  :version "24.1"
-  :group 'c)
-
 (eval-and-compile
   ;; We need the following definitions during compilation since they're
   ;; used when the `c-lang-defconst' initializers are evaluated.  Define
@@ -212,7 +205,7 @@
   ;; from within a #if preprocessor construct.
   (defvar c-font-lock-context nil)
   (make-variable-buffer-local 'c-font-lock-context)
-
+  
   (defmacro c-put-font-lock-face (from to face)
     ;; Put a face on a region (overriding any existing face) in the way
     ;; font-lock would do it.  In XEmacs that means putting an
@@ -267,7 +260,7 @@
     ;; This function might do hidden buffer changes.
     (when (c-got-face-at (point) c-literal-faces)
       (while (progn
-	       (goto-char (next-single-property-change
+	       (goto-char (c-next-single-property-change
 			   (point) 'face nil limit))
 	       (and (< (point) limit)
 		    (c-got-face-at (point) c-literal-faces))))
@@ -294,7 +287,7 @@
 	  res))))
 
   (defun c-make-font-lock-search-form (regexp highlights)
-    ;; Return a lisp form which will fontify every occurrence of REGEXP
+    ;; Return a lisp form which will fontify every occurence of REGEXP
     ;; (a regular expression, NOT a function) between POINT and `limit'
     ;; with HIGHLIGHTS, a list of highlighters as specified on page
     ;; "Search-based Fontification" in the elisp manual.
@@ -321,7 +314,7 @@
 			(match-beginning ,(car highlight))
 			(match-end ,(car highlight))
 			,(elt highlight 1))))
-		;; highlight is an "ANCHORED HIGHLIGHTER" of the form
+		;; highlight is an "ANCHORED HIGHLIGHER" of the form
 		;; (ANCHORED-MATCHER PRE-FORM POST-FORM SUBEXP-HIGHLIGHTERS...)
 		(when (nth 3 highlight)
 		  (error "Match highlights currently not supported in %s"
@@ -367,39 +360,7 @@
 	      (parse-sexp-lookup-properties
 	       (cc-eval-when-compile
 		 (boundp 'parse-sexp-lookup-properties))))
-
-	  ;; (while (re-search-forward ,regexp limit t)
-	  ;;   (unless (progn
-	  ;; 	      (goto-char (match-beginning 0))
-	  ;; 	      (c-skip-comments-and-strings limit))
-	  ;;     (goto-char (match-end 0))
-	  ;;     ,@(mapcar
-	  ;; 	 (lambda (highlight)
-	  ;; 	   (if (integerp (car highlight))
-	  ;; 	       (progn
-	  ;; 		 (unless (eq (nth 2 highlight) t)
-	  ;; 		   (error
-	  ;; 		    "The override flag must currently be t in %s"
-	  ;; 		    highlight))
-	  ;; 		 (when (nth 3 highlight)
-	  ;; 		   (error
-	  ;; 		    "The laxmatch flag may currently not be set in %s"
-	  ;; 		    highlight))
-	  ;; 		 `(save-match-data
-	  ;; 		    (c-put-font-lock-face
-	  ;; 		     (match-beginning ,(car highlight))
-	  ;; 		     (match-end ,(car highlight))
-	  ;; 		     ,(elt highlight 1))))
-	  ;; 	     (when (nth 3 highlight)
-	  ;; 	       (error "Match highlights currently not supported in %s"
-	  ;; 		      highlight))
-	  ;; 	     `(progn
-	  ;; 		,(nth 1 highlight)
-	  ;; 		(save-match-data ,(car highlight))
-	  ;; 		,(nth 2 highlight))))
-	  ;; 	 highlights)))
 	  ,(c-make-font-lock-search-form regexp highlights))
-
 	nil)))
 
   (defun c-make-font-lock-BO-decl-search-function (regexp &rest highlights)
@@ -412,7 +373,7 @@
     ;; establish a context for the current text when, e.g., a character
     ;; is typed on a C++ inheritance continuation line, or a jit-lock
     ;; chunk starts there.
-    ;;
+    ;; 
     ;; The new function works much like a matcher element in
     ;; `font-lock-keywords'.  It cuts out a little bit of the overhead
     ;; compared to a real matcher.  The main reason is however to pass the
@@ -488,7 +449,7 @@
     ;; This function does not do any hidden buffer changes, but the
     ;; generated functions will.  (They are however used in places
     ;; covered by the font-lock context.)
-    ;;
+    ;; 
     ;; Note: Replace `byte-compile' with `eval' to debug the generated
     ;; lambda more easily.
     (byte-compile
@@ -512,15 +473,15 @@
 	  ,(c-make-font-lock-search-form (car normal) (cdr normal))
 	  nil))))
 
-;  (eval-after-load "edebug" ; 2006-07-09: def-edebug-spec is now in subr.el.
-;    '(progn
-  (def-edebug-spec c-fontify-types-and-refs let*)
-  (def-edebug-spec c-make-syntactic-matcher t)
-  ;; If there are literal quoted or backquoted highlight specs in
-  ;; the call to `c-make-font-lock-search-function' then let's
-  ;; instrument the forms in them.
-  (def-edebug-spec c-make-font-lock-search-function
-    (form &rest &or ("quote" (&rest form)) ("`" (&rest form)) form)));))
+  (eval-after-load "edebug"
+    '(progn
+       (def-edebug-spec c-fontify-types-and-refs let*)
+       (def-edebug-spec c-make-syntactic-matcher t)
+       ;; If there are literal quoted or backquoted highlight specs in
+       ;; the call to `c-make-font-lock-search-function' then let's
+       ;; instrument the forms in them.
+       (def-edebug-spec c-make-font-lock-search-function
+	 (form &rest &or ("quote" (&rest form)) ("`" (&rest form)) form)))))
 
 (defun c-fontify-recorded-types-and-refs ()
   ;; Convert the ranges recorded on `c-record-type-identifiers' and
@@ -592,8 +553,7 @@ stuff.  Used on level 1 and higher."
 				   (progn
 				     (c-mark-<-as-paren beg)
 				     (c-mark->-as-paren end))
-				 ;; (c-clear-char-property beg 'syntax-table)
-				 (c-clear-char-property beg 'category)))
+				 (c-unmark-<->-as-paren beg)))
 			     nil)))))))
 
 	      ;; #define.
@@ -717,7 +677,11 @@ stuff.  Used on level 1 and higher."
   (let ((start (1- (point))))
     (save-excursion
       (and (eq (elt (parse-partial-sexp start (c-point 'eol)) 8) start)
-	   (if (integerp c-multiline-string-start-char)
+	   (if (if (integerp ?c)
+		   ;; Emacs
+		   (integerp c-multiline-string-start-char)
+		 ;; XEmacs
+		 (characterp c-multiline-string-start-char))
 	       ;; There's no multiline string start char before the
 	       ;; string, so newlines aren't allowed.
 	       (not (eq (char-before start) c-multiline-string-start-char))
@@ -772,6 +736,13 @@ casts and declarations are fontified.  U
 	 `(,(concat "\\<" (c-lang-const c-regular-keywords-regexp))
 	   1 font-lock-keyword-face))
 
+      ;; The following must come before c-font-lock-enclosing-decls in
+      ;; c-complex-decl-matchers.  It fontifies java @annotations.
+      ,@(when (c-major-mode-is 'java-mode)
+	  `((eval . (list "\\<\\(@[a-zA-Z0-9]+\\)\\>" 1
+			  c-preprocessor-face-name
+			  ))))
+
       ;; Fontify leading identifiers in fully qualified names like
       ;; "foo::bar" in languages that supports such things.
       ,@(when (c-lang-const c-opt-identifier-concat-key)
@@ -1038,7 +1009,8 @@ casts and declarations are fontified.  U
        paren-depth
        id-face got-init
        c-last-identifier-range
-       (separator-prop (if types 'c-decl-type-start 'c-decl-id-start)))
+       (separator-prop (if types 'c-decl-type-start 'c-decl-id-start))
+       brackets-after-id)
 
     ;; The following `while' fontifies a single declarator id each time round.
     ;; It loops only when LIST is non-nil.
@@ -1046,7 +1018,7 @@ casts and declarations are fontified.  U
 	;; Inside the following "condition form", we move forward over the
 	;; declarator's identifier up as far as any opening bracket (for array
 	;; size) or paren (for parameters of function-type) or brace (for
-	;; array/struct initialization) or "=" or terminating delimiter
+	;; array/struct initialisation) or "=" or terminating delimiter
 	;; (e.g. "," or ";" or "}").
 	(and
 	    pos
@@ -1109,26 +1081,30 @@ casts and declarations are fontified.  U
 	      (<= (point) limit))
 
 	    ;; Search syntactically to the end of the declarator (";",
-	    ;; ",", a closing paren, eob etc) or to the beginning of an
+	    ;; ",", a closen paren, eob etc) or to the beginning of an
 	    ;; initializer or function prototype ("=" or "\\s\(").
-	    ;; Note that the open paren will match array specs in
-	    ;; square brackets, and we treat them as initializers too.
-	    (c-syntactic-re-search-forward
-	     "[;,]\\|\\s)\\|\\'\\|\\(=\\|\\s(\\)" limit t t))
+	    ;; Note that square brackets are now not also treated as
+	    ;; initializers, since this broke when there were also
+	    ;; initializing brace lists.
+	    (let (found)
+	      (while
+		  (and (setq found (c-syntactic-re-search-forward
+			     "[;,]\\|\\s)\\|\\'\\|\\(=\\|\\s(\\)" limit t t))
+		       (eq (char-before) ?\[)
+		       (c-go-up-list-forward))
+		     (setq brackets-after-id t))
+	      found))
 
       (setq next-pos (match-beginning 0)
 	    id-face (if (and (eq (char-after next-pos) ?\()
-			     (let (c-last-identifier-range)
-			       (save-excursion
-				 (goto-char next-pos)
-				 (c-at-toplevel-p))))
+			     (not brackets-after-id))
 			'font-lock-function-name-face
 		      'font-lock-variable-name-face)
 	    got-init (and (match-beginning 1)
 			  (char-after (match-beginning 1))))
 
       (if types
-	  ;; Register and fontify the identifier as a type.
+	  ;; Register and fontify the identifer as a type.
 	  (let ((c-promote-possible-types t))
 	    (goto-char id-start)
 	    (c-forward-type))
@@ -1147,7 +1123,6 @@ casts and declarations are fontified.  U
       (when list
 	;; Jump past any initializer or function prototype to see if
 	;; there's a ',' to continue at.
-
 	(cond ((eq id-face 'font-lock-function-name-face)
 	       ;; Skip a parenthesized initializer (C++) or a function
 	       ;; prototype.
@@ -1213,10 +1188,10 @@ casts and declarations are fontified.  U
 	  ;; o - '<> if the arglist is of angle bracket type;
 	  ;; o - 'arglist if it's some other arglist;
 	  ;; o - nil, if not in an arglist at all.  This includes the
-	  ;;   parenthesized condition which follows "if", "while", etc.
+	  ;;   parenthesised condition which follows "if", "while", etc.
 	  context
-	  ;; The position of the next token after the closing paren of
-	  ;; the last detected cast.
+	  ;; A list of starting positions of possible type declarations, or of
+	  ;; the typedef preceding one, if any.
 	  last-cast-end
 	  ;; The result from `c-forward-decl-or-cast-1'.
 	  decl-or-cast
@@ -1308,7 +1283,8 @@ casts and declarations are fontified.  U
 			    (goto-char match-pos)
 			    (backward-char)
 			    (c-backward-token-2)
-			    (looking-at c-block-stmt-2-key)))
+			    (or (looking-at c-block-stmt-2-key)
+				(looking-at c-block-stmt-1-2-key))))
 		     (setq context nil
 			   c-restricted-<>-arglists t))
 		    ;; Near BOB.
@@ -1466,18 +1442,14 @@ casts and declarations are fontified.  U
 	      nil)
 
 	     ((and (not c-enums-contain-decls)
-		   ;; An optimization quickly to eliminate scans of long enum
+		   ;; An optimisation quickly to eliminate scans of long enum
 		   ;; declarations in the next cond arm.
 		   (let ((paren-state (c-parse-state)))
 		     (and
 		      (numberp (car paren-state))
 		      (save-excursion
 			(goto-char (car paren-state))
-			(c-backward-token-2)
-			(or (looking-at c-brace-list-key)
-			    (progn
-			      (c-backward-token-2)
-			      (looking-at c-brace-list-key)))))))
+			(c-backward-over-enum-header)))))
 	      (c-forward-token-2)
 	      nil)
 
@@ -1486,13 +1458,16 @@ casts and declarations are fontified.  U
 	      ;; to check this.  If we get there, check whether a "typedef"
 	      ;; is there, then fontify the declarators accordingly.
 	      (let ((decl-search-lim (c-determine-limit 1000))
-		    paren-state bod-res encl-pos is-typedef
+		    paren-state bod-res encl-pos is-typedef 
 		    c-recognize-knr-p) ; Strictly speaking, bogus, but it
 				       ; speeds up lisp.h tremendously.
 		(save-excursion
+		  (unless (or (eobp)
+			      (looking-at "\\s(\\|\\s)"))
+		    (forward-char))
 		  (setq bod-res (car (c-beginning-of-decl-1 decl-search-lim)))
 		  (if (and (eq bod-res 'same)
-			   (progn
+			   (save-excursion
 			     (c-backward-syntactic-ws)
 			     (eq (char-before) ?\})))
 		      (c-beginning-of-decl-1 decl-search-lim))
@@ -1559,20 +1534,13 @@ casts and declarations are fontified.  U
   ;; Note that this function won't attempt to fontify beyond the end of the
   ;; current enum block, if any.
   (let* ((paren-state (c-parse-state))
-	 (encl-pos (c-most-enclosing-brace paren-state))
-	 (start (point))
-	)
+	 (encl-pos (c-most-enclosing-brace paren-state)))
     (when (and
 	   encl-pos
 	   (eq (char-after encl-pos) ?\{)
 	   (save-excursion
 	     (goto-char encl-pos)
-	     (c-backward-syntactic-ws)
-	     (c-simple-skip-symbol-backward)
-	     (or (looking-at c-brace-list-key) ; "enum"
-		 (progn (c-backward-syntactic-ws)
-			(c-simple-skip-symbol-backward)
-			(looking-at c-brace-list-key)))))
+	     (c-backward-over-enum-header)))
       (c-syntactic-skip-backward "^{," nil t)
       (c-put-char-property (1- (point)) 'c-type 'c-decl-id-start)
 
@@ -1584,7 +1552,7 @@ casts and declarations are fontified.  U
   ;; Fontify the declarators of (nested) declarations we're in the middle of.
   ;; This is mainly for when a jit-lock etc. chunk starts inside the brace
   ;; block of a struct/union/class, etc.
-  ;;
+  ;; 
   ;; This function will be called from font-lock for a region bounded by POINT
   ;; and LIMIT, as though it were to identify a keyword for
   ;; font-lock-keyword-face.  It always returns NIL to inhibit this and
@@ -1609,7 +1577,7 @@ casts and declarations are fontified.  U
 	  (when (c-safe (c-forward-sexp))
 	    (c-forward-syntactic-ws)
 	    (c-font-lock-declarators limit t in-typedef)))))))
-
+	
 (c-lang-defconst c-simple-decl-matchers
   "Simple font lock matchers for types and declarations.  These are used
 on level 2 only and so aren't combined with `c-complex-decl-matchers'."
@@ -1723,7 +1691,7 @@ on level 2 only and so aren't combined w
       ,@(when (c-lang-const c-recognize-<>-arglists)
 	  `(c-font-lock-<>-arglists))
 
-      ;; The first two rules here mostly find occurrences that
+      ;; The first two rules here mostly find occurences that
       ;; `c-font-lock-declarations' has found already, but not
       ;; declarations containing blocks in the type (see note below).
       ;; It's also useful to fontify these everywhere to show e.g. when
@@ -1893,7 +1861,7 @@ higher."
 		"\\)\\>"
 		;; Disallow various common punctuation chars that can't come
 		;; before the '{' of the enum list, to avoid searching too far.
-		"[^\]\[{}();,/#=]*"
+		"[^\]\[{}();/#=]*"
 		"{")
 	       '((c-font-lock-declarators limit t nil)
 		 (save-match-data
@@ -1948,11 +1916,7 @@ higher."
 			 "\\)\\>")
 		 '((c-fontify-types-and-refs ((c-promote-possible-types t))
 		     (c-forward-keyword-clause 1)
-		     (if (> (point) limit) (goto-char limit))))))))
-
-	,@(when (c-major-mode-is 'java-mode)
-	    `((eval . (list "\\<\\(@[a-zA-Z0-9]+\\)\\>" 1 c-annotation-face))))
-      ))
+		     (if (> (point) limit) (goto-char limit))))))))))
 
 (c-lang-defconst c-matchers-1
   t (c-lang-const c-cpp-matchers))
@@ -2486,7 +2450,7 @@ need for `pike-font-lock-extra-types'.")
 	      (setq comment-beg nil))
 	    (setq region-beg comment-beg))
 
-      (if (eq (elt (parse-partial-sexp comment-beg (+ comment-beg 2)) 7) t)
+      (if (elt (parse-partial-sexp comment-beg (+ comment-beg 2)) 7)
 	  ;; Collect a sequence of doc style line comments.
 	  (progn
 	    (goto-char comment-beg)
@@ -2535,7 +2499,7 @@ need for `pike-font-lock-extra-types'.")
 
 (defun c-find-invalid-doc-markup (regexp limit)
   ;; Used to fontify invalid markup in doc comments after the correct
-  ;; ones have been fontified: Find the first occurrence of REGEXP
+  ;; ones have been fontified: Find the first occurence of REGEXP
   ;; between the point and LIMIT that only is fontified with
   ;; `c-doc-face-name'.  If a match is found then submatch 0 surrounds
   ;; the first char and t is returned, otherwise nil is returned.
@@ -2563,7 +2527,7 @@ need for `pike-font-lock-extra-types'.")
        0 ,c-doc-markup-face-name prepend nil)
       (,(concat header "\\(" "@" symbol "\\):")
        1 ,c-doc-markup-face-name prepend nil)
-      (,(concat "[#%@]" symbol)
+      (,(concat "[#%]" symbol)
        0 ,c-doc-markup-face-name prepend nil))
     ))
 
@@ -2728,4 +2692,5 @@ need for `pike-font-lock-extra-types'.")
 ;; 2006-07-10:  awk-font-lock-keywords has been moved back to cc-awk.el.
 (cc-provide 'cc-fonts)
 
+;;; arch-tag: 2f65f405-735f-4da5-8d4b-b957844c5203
 ;;; cc-fonts.el ends here
--- emacs24-24.3+1.orig/lisp/progmodes/cc-guess.el
+++ emacs24-24.3+1/lisp/progmodes/cc-guess.el
@@ -1,7 +1,7 @@
 ;;; cc-guess.el --- guess indentation values by scanning existing code
 
-;; Copyright (C) 1985, 1987, 1992-2006, 2011-2013 Free Software
-;; Foundation, Inc.
+;; Copyright (C) 1985,1987,1992-2003, 2004, 2005, 2006, 2007, 2008,
+;; 2009, 2010, 2011  Free Software Foundation, Inc.
 
 ;; Author:     1994-1995 Barry A. Warsaw
 ;;             2011-     Masatake YAMATO
@@ -12,18 +12,19 @@
 
 ;; This file is part of GNU Emacs.
 
-;; GNU Emacs is free software: you can redistribute it and/or modify
+;; GNU Emacs is free software; you can redistribute it and/or modify
 ;; it under the terms of the GNU General Public License as published by
-;; the Free Software Foundation, either version 3 of the License, or
+;; the Free Software Foundation; either version 3 of the License, or
 ;; (at your option) any later version.
-
-;; GNU Emacs is distributed in the hope that it will be useful,
+;;
+;; GNU EMACS is distributed in the hope that it will be useful,
 ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
 ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ;; GNU General Public License for more details.
-
+;;
 ;; You should have received a copy of the GNU General Public License
-;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
+;; along with this program; see the file COPYING.  If not, see
+;; <http://www.gnu.org/licenses/>.
 
 ;;; Commentary:
 ;;
@@ -76,6 +77,9 @@
 (cc-require 'cc-defs)
 (cc-require 'cc-engine)
 (cc-require 'cc-styles)
+(cc-bytecomp-defvar make-progress-reporter)
+(cc-bytecomp-defvar progress-reporter-update)
+(cc-bytecomp-defvar progress-reporter-done)
 
 
 
@@ -85,7 +89,6 @@ Discard an examined offset if its absolu
 
 The offset of a line included in the indent information returned by
 `c-guess-basic-syntax'."
-  :version "24.1"
   :type 'integer
   :group 'c)
 
@@ -93,7 +96,6 @@ The offset of a line included in the ind
   "The maximum region size for examining indent information with `c-guess'.
 It takes a long time to examine indent information from a large region;
 this option helps you limit that time. `nil' means no limit."
-  :version "24.1"
   :type 'integer
   :group 'c)
 
--- emacs24-24.3+1.orig/lisp/progmodes/cc-langs.el
+++ emacs24-24.3+1/lisp/progmodes/cc-langs.el
@@ -1,32 +1,34 @@
 ;;; cc-langs.el --- language specific settings for CC Mode
 
-;; Copyright (C) 1985, 1987, 1992-2013 Free Software Foundation, Inc.
+;; Copyright (C) 1985, 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+;;   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+;;   2010, 2011   Free Software Foundation, Inc.
 
 ;; Authors:    2002- Alan Mackenzie
-;;             1998- Martin Stjernholm
-;;             1992-1999 Barry A. Warsaw
-;;             1987 Dave Detlefs
-;;             1987 Stewart Clamen
-;;             1985 Richard M. Stallman
+;;	       1998- Martin Stjernholm
+;;	       1992-1999 Barry A. Warsaw
+;;	       1987 Dave Detlefs and Stewart Clamen
+;;	       1985 Richard M. Stallman
 ;; Maintainer: bug-cc-mode@gnu.org
 ;; Created:    22-Apr-1997 (split from cc-mode.el)
-;; Keywords:   c languages
-;; Package:    cc-mode
+;; Version:    See cc-mode.el
+;; Keywords:   c languages oop
 
 ;; This file is part of GNU Emacs.
 
-;; GNU Emacs is free software: you can redistribute it and/or modify
+;; GNU Emacs is free software; you can redistribute it and/or modify
 ;; it under the terms of the GNU General Public License as published by
-;; the Free Software Foundation, either version 3 of the License, or
-;; (at your option) any later version.
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
 
 ;; GNU Emacs is distributed in the hope that it will be useful,
 ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
 ;; GNU General Public License for more details.
 
 ;; You should have received a copy of the GNU General Public License
-;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
+;; along with this program; see the file COPYING.  If not, see
+;; <http://www.gnu.org/licenses/>.
 
 ;;; Commentary:
 
@@ -47,7 +49,7 @@
 ;;; Introduction to the language dependent variable system:
 ;;
 ;; This file contains all the language dependent variables, except
-;; those specific for font locking which reside in cc-fonts.el.  As
+;; those specific for font locking which reside in cc-fonts.el.	 As
 ;; far as possible, all the differences between the languages that CC
 ;; Mode supports are described with these variables only, so that the
 ;; code can be shared.
@@ -85,21 +87,21 @@
 ;; evaluation; the byte compiled file(s) for them will contain the
 ;; compiled runtime constants ready for use by (the byte compiled) CC
 ;; Mode, and the source definitions in this file don't have to be
-;; loaded then.  However, if a byte compiled package is loaded that
+;; loaded then.	 However, if a byte compiled package is loaded that
 ;; has been compiled with a different version of CC Mode than the one
 ;; currently loaded, then the compiled-in values will be discarded and
-;; new ones will be built when the mode is initialized.  That will
+;; new ones will be built when the mode is initialized.	 That will
 ;; automatically trig a load of the file(s) containing the source
 ;; definitions (i.e. this file and/or cc-fonts.el) if necessary.
 ;;
 ;; A small example of a derived mode is available at
-;; <http://cc-mode.sourceforge.net/derived-mode-ex.el>.  It also
+;; <http://cc-mode.sourceforge.net/derived-mode-ex.el>.	 It also
 ;; contains some useful hints for derived mode developers.
 
 ;;; Using language variables:
 ;;
 ;; The `c-lang-defvar' forms in this file comprise the language
-;; variables that CC Mode uses.  It does not work to use
+;; variables that CC Mode uses.	 It does not work to use
 ;; `c-lang-defvar' anywhere else (which isn't much of a limitation
 ;; since these variables sole purpose is to interface with the CC Mode
 ;; core functions).  The values in these `c-lang-defvar's are not
@@ -113,10 +115,6 @@
 
 ;;; Code:
 
-;; For Emacs < 22.2.
-(eval-and-compile
-  (unless (fboundp 'declare-function) (defmacro declare-function (&rest r))))
-
 (eval-when-compile
   (let ((load-path
 	 (if (and (boundp 'byte-compile-dest-file)
@@ -151,8 +149,8 @@
 	c-emacs-variable-inits-tail c-emacs-variable-inits))
 
 (defmacro c-lang-defvar (var val &optional doc)
-  "Declares the buffer local variable VAR to get the value VAL.  VAL is
-evaluated and assigned at mode initialization.  More precisely, VAL is
+  "Declares the buffer local variable VAR to get the value VAL.	 VAL is
+evaluated and assigned at mode initialization.	More precisely, VAL is
 evaluated and bound to VAR when the result from the macro
 `c-init-language-vars' is evaluated.
 
@@ -201,17 +199,9 @@ the evaluated constant value at compile
   `',var)
 
 (put 'c-lang-defvar 'lisp-indent-function 'defun)
-; (eval-after-load "edebug" ; 2006-07-09: def-edebug-spec is now in subr.el.
-;  '
-(def-edebug-spec c-lang-defvar
-  (&define name def-form &optional stringp)) ;)
-
-;; Suppress "might not be defined at runtime" warning.
-;; This file is only used when compiling other cc files.
-;; These are defined in cl as aliases to the cl- versions.
-(declare-function delete-duplicates "cl-seq" (cl-seq &rest cl-keys) t)
-(declare-function mapcan "cl-extra" (cl-func cl-seq &rest cl-rest) t)
-(declare-function cl-macroexpand-all "cl" (form &optional env))
+(eval-after-load "edebug"
+  '(def-edebug-spec c-lang-defvar
+     (&define name def-form &optional stringp)))
 
 (eval-and-compile
   ;; Some helper functions used when building the language constants.
@@ -271,29 +261,29 @@ the evaluated constant value at compile
 ;;; Various mode specific values that aren't language related.
 
 (c-lang-defconst c-mode-menu
-  ;; The definition for the mode menu.  The menu title is prepended to
+  ;; The definition for the mode menu.	The menu title is prepended to
   ;; this before it's fed to `easy-menu-define'.
-  t `(["Comment Out Region"     comment-region
+  t `(["Comment Out Region"	comment-region
        (c-fn-region-is-active-p)]
-      ["Uncomment Region"       (comment-region (region-beginning)
+      ["Uncomment Region"	(comment-region (region-beginning)
 						(region-end) '(4))
        (c-fn-region-is-active-p)]
-      ["Indent Expression"      c-indent-exp
+      ["Indent Expression"	c-indent-exp
        (memq (char-after) '(?\( ?\[ ?\{))]
-      ["Indent Line or Region"  c-indent-line-or-region t]
+      ["Indent Line or Region"	c-indent-line-or-region t]
       ["Fill Comment Paragraph" c-fill-paragraph t]
       "----"
-      ["Backward Statement"     c-beginning-of-statement t]
-      ["Forward Statement"      c-end-of-statement t]
+      ["Backward Statement"	c-beginning-of-statement t]
+      ["Forward Statement"	c-end-of-statement t]
       ,@(when (c-lang-const c-opt-cpp-prefix)
 	  ;; Only applicable if there's a cpp preprocessor.
-	  `(["Up Conditional"         c-up-conditional t]
+	  `(["Up Conditional"	      c-up-conditional t]
 	    ["Backward Conditional"   c-backward-conditional t]
 	    ["Forward Conditional"    c-forward-conditional t]
 	    "----"
 	    ["Macro Expand Region"    c-macro-expand
 	     (c-fn-region-is-active-p)]
-	    ["Backslashify"           c-backslash-region
+	    ["Backslashify"	      c-backslash-region
 	     (c-fn-region-is-active-p)]))
       "----"
       ("Style..."
@@ -302,7 +292,7 @@ the evaluated constant value at compile
 					  "Style Name: %s"
 					  c-indentation-style) t]
        ["Guess Style from this Buffer"   c-guess-buffer-no-install t]
-       ["Install the Last Guessed Style..." c-guess-install
+       ["Install the Last Guessed Style" c-guess-install
 	(and c-guess-guessed-offsets-alist
 	     c-guess-guessed-basic-offset) ]
        ["View the Last Guessed Style"    c-guess-view
@@ -310,17 +300,11 @@ the evaluated constant value at compile
 	     c-guess-guessed-basic-offset) ])
       "----"
       ("Toggle..."
-       ["Syntactic indentation" c-toggle-syntactic-indentation
-	:style toggle :selected c-syntactic-indentation]
-       ["Electric mode"         c-toggle-electric-state
-	:style toggle :selected c-electric-flag]
-       ["Auto newline"          c-toggle-auto-newline
-	:style toggle :selected c-auto-newline]
-       ["Hungry delete"         c-toggle-hungry-state
-	:style toggle :selected c-hungry-delete-key]
-       ["Subword mode"          subword-mode
-	:style toggle :selected (and (boundp 'subword-mode)
-                                     subword-mode)])))
+       ["Syntactic indentation" c-toggle-syntactic-indentation t]
+       ["Electric mode"		c-toggle-electric-state t]
+       ["Auto newline"		c-toggle-auto-newline t]
+       ["Hungry delete"		c-toggle-hungry-state t]
+       ["Subword mode"		c-subword-mode t])))
 
 
 ;;; Syntax tables.
@@ -331,17 +315,17 @@ This includes setting ' and \" as string
 the comment syntax to handle both line style \"//\" and block style
 \"/*\" \"*/\" comments."
 
-  (modify-syntax-entry ?_  "_"     table)
-  (modify-syntax-entry ?\\ "\\"    table)
-  (modify-syntax-entry ?+  "."     table)
-  (modify-syntax-entry ?-  "."     table)
-  (modify-syntax-entry ?=  "."     table)
-  (modify-syntax-entry ?%  "."     table)
-  (modify-syntax-entry ?<  "."     table)
-  (modify-syntax-entry ?>  "."     table)
-  (modify-syntax-entry ?&  "."     table)
-  (modify-syntax-entry ?|  "."     table)
-  (modify-syntax-entry ?\' "\""    table)
+  (modify-syntax-entry ?_  "_"	   table)
+  (modify-syntax-entry ?\\ "\\"	   table)
+  (modify-syntax-entry ?+  "."	   table)
+  (modify-syntax-entry ?-  "."	   table)
+  (modify-syntax-entry ?=  "."	   table)
+  (modify-syntax-entry ?%  "."	   table)
+  (modify-syntax-entry ?<  "."	   table)
+  (modify-syntax-entry ?>  "."	   table)
+  (modify-syntax-entry ?&  "."	   table)
+  (modify-syntax-entry ?|  "."	   table)
+  (modify-syntax-entry ?\' "\""	   table)
   (modify-syntax-entry ?\240 "."   table)
 
   ;; Set up block and line oriented comments.  The new C
@@ -389,10 +373,12 @@ The syntax tables aren't stored directly
 (c-lang-defconst c++-make-template-syntax-table
   ;; A variant of `c++-mode-syntax-table' that defines `<' and `>' as
   ;; parenthesis characters.  Used temporarily when template argument
-  ;; lists are parsed.  Note that this encourages incorrect parsing of
+  ;; lists are parsed.	Note that this encourages incorrect parsing of
   ;; templates since they might contain normal operators that uses the
   ;; '<' and '>' characters.  Therefore this syntax table might go
-  ;; away when CC Mode handles templates correctly everywhere.
+  ;; away when CC Mode handles templates correctly everywhere.  WHILE
+  ;; THIS SYNTAX TABLE IS CURRENT, `c-parse-state' MUST _NOT_ BE
+  ;; CALLED!!!
   t   nil
   (java c++) `(lambda ()
 	 (let ((table (funcall ,(c-lang-const c-make-mode-syntax-table))))
@@ -434,7 +420,7 @@ element is a cons where the car is the c
 the new syntax, as accepted by `modify-syntax-entry'."
   ;; The $ character is not allowed in most languages (one exception
   ;; is Java which allows it for legacy reasons) but we still classify
-  ;; it as an identifier character since it's often used in various
+  ;; it as an indentifier character since it's often used in various
   ;; machine generated identifiers.
   t    '((?_ . "w") (?$ . "w"))
   (objc java) (append '((?@ . "w"))
@@ -477,7 +463,7 @@ Typically these will record enough state
 and may do such things as removing text-properties which must be
 recalculated.
 
-These functions will be run in the order given.  Each of them
+These functions will be run in the order given.	 Each of them
 takes 2 parameters, the BEG and END supplied to every
 before-change function; on entry, the buffer will have been
 widened and match-data will have been saved; point is undefined
@@ -553,7 +539,7 @@ don't have EOL terminated statements. "
 
 (c-lang-defconst c-vsemi-status-unknown-p-fn
   "Contains a function \"are we unsure whether there is a virtual semicolon on this line?\".
-The (admittedly kludgy) purpose of such a function is to prevent an infinite
+The (admittedly kludgey) purpose of such a function is to prevent an infinite
 recursion in c-beginning-of-statement-1 when point starts at a `while' token.
 The function MUST NOT UNDER ANY CIRCUMSTANCES call c-beginning-of-statement-1,
 even indirectly.  This variable contains nil for languages which don't have
@@ -573,13 +559,22 @@ EOL terminated statements."
   (c c++ objc) t)
 (c-lang-defvar c-has-bitfields (c-lang-const c-has-bitfields))
 
+(c-lang-defconst c-modified-constant
+  "Regexp that matches a \"modified\" constant literal such as \"L'a'\",
+a \"long character\".  In particular, this recognizes forms of constant
+which c-backward-sexp needs to be called twice to move backwards over."
+  t nil
+  (c c++ objc) "L'\\([^\\'\t\f\n\r]\\|\\\\.\\)'")
+;; FIXME!!!  Extend this to cover strings, if needed.  2008-04-11
+(c-lang-defvar c-modified-constant (c-lang-const c-modified-constant))
+
 (c-lang-defconst c-symbol-start
   "Regexp that matches the start of a symbol, i.e. any identifier or
 keyword.  It's unspecified how far it matches.	Does not contain a \\|
 operator at the top level."
   t    (concat "[" c-alpha "_]")
   java (concat "[" c-alpha "_@]")
-  objc (concat "[" c-alpha "_@]")
+  objc (concat "[" c-alpha "@]")
   pike (concat "[" c-alpha "_`]"))
 (c-lang-defvar c-symbol-start (c-lang-const c-symbol-start))
 
@@ -593,7 +588,7 @@ This is of the form that fits inside [ ]
 (c-lang-defvar c-symbol-chars (c-lang-const c-symbol-chars))
 
 (c-lang-defconst c-symbol-key
-  "Regexp matching identifiers and keywords (with submatch 0).  Assumed
+  "Regexp matching identifiers and keywords (with submatch 0).	Assumed
 to match if `c-symbol-start' matches on the same position."
   t    (concat (c-lang-const c-symbol-start)
 	       "[" (c-lang-const c-symbol-chars) "]*")
@@ -626,7 +621,7 @@ It's assumed to not contain any submatch
 
 (c-lang-defconst c-identifier-ops
   "The operators that make up fully qualified identifiers.  nil in
-languages that don't have such things.  See `c-operators' for a
+languages that don't have such things.	See `c-operators' for a
 description of the format.  Binary operators can concatenate symbols,
 e.g. \"::\" in \"A::B::C\".  Prefix operators can precede identifiers,
 e.g. \"~\" in \"~A::B\".  Other types of operators aren't supported.
@@ -681,7 +676,7 @@ This value is by default merged into `c-
 
 (c-lang-defconst c-after-id-concat-ops
   "Operators that can occur after a binary operator on `c-identifier-ops'
-in identifiers.  nil in languages that don't have such things.
+in identifiers.	 nil in languages that don't have such things.
 
 Operators here should also have appropriate entries in `c-operators' -
 it's not taken care of by default."
@@ -803,7 +798,7 @@ literal are multiline."
   "Regexp matching the prefix of a cpp directive in the languages that
 normally use that macro preprocessor.  Tested at bol or at boi.
 Assumed to not contain any submatches or \\| operators."
-  ;; TODO (ACM, 2005-04-01).  Amend the following to recognize escaped NLs;
+  ;; TODO (ACM, 2005-04-01).  Amend the following to recognise escaped NLs;
   ;; amend all uses of c-opt-cpp-prefix which count regexp-depth.
   t "\\s *#\\s *"
   (java awk) nil)
@@ -812,13 +807,13 @@ Assumed to not contain any submatches or
 (c-lang-defconst c-anchored-cpp-prefix
   "Regexp matching the prefix of a cpp directive anchored to BOL,
 in the languages that have a macro preprocessor."
-  t (if (c-lang-const c-opt-cpp-prefix)
-	(concat "^" (c-lang-const c-opt-cpp-prefix))))
+  t "^\\s *\\(#\\)\\s *"
+  (java awk) nil)
 (c-lang-defvar c-anchored-cpp-prefix (c-lang-const c-anchored-cpp-prefix))
 
 (c-lang-defconst c-opt-cpp-start
   "Regexp matching the prefix of a cpp directive including the directive
-name, or nil in languages without preprocessor support.  The first
+name, or nil in languages without preprocessor support.	 The first
 submatch surrounds the directive name."
   t    (if (c-lang-const c-opt-cpp-prefix)
 	   (concat (c-lang-const c-opt-cpp-prefix)
@@ -852,13 +847,13 @@ definition, or nil if the language doesn
 
 (c-lang-defconst c-opt-cpp-macro-define-start
   ;; Regexp matching everything up to the macro body of a cpp define, or the
-  ;; end of the logical line if there is none.  Submatch 1 is the name of the
+  ;; end of the logical line if there is none.	Submatch 1 is the name of the
   ;; macro.  Set if c-opt-cpp-macro-define is.
   t (if (c-lang-const c-opt-cpp-macro-define)
 	(concat (c-lang-const c-opt-cpp-prefix)
 		(c-lang-const c-opt-cpp-macro-define)
 		"[ \t]+\\(\\(\\sw\\|_\\)+\\)\\(\([^\)]*\)\\)?"
-		;;       ^                 ^ #defined name
+		;;	 ^		   ^ #defined name
 		"\\([ \t]\\|\\\\\n\\)*")))
 (c-lang-defvar c-opt-cpp-macro-define-start
   (c-lang-const c-opt-cpp-macro-define-start))
@@ -906,26 +901,26 @@ expression, or nil if there aren't any i
 
 (c-lang-defconst c-operators
   "List describing all operators, along with their precedence and
-associativity.  The order in the list corresponds to the precedence of
+associativity.	The order in the list corresponds to the precedence of
 the operators: The operators in each element are a group with the same
 precedence, and the group has higher precedence than the groups in all
 following elements.  The car of each element describes the type of the
 operator group, and the cdr is a list of the operator tokens in it.
 The operator group types are:
 
-'prefix         Unary prefix operators.
-'postfix        Unary postfix operators.
+'prefix		Unary prefix operators.
+'postfix	Unary postfix operators.
 'postfix-if-paren
 		Unary postfix operators if and only if the chars have
 		parenthesis syntax.
-'left-assoc     Binary left associative operators (i.e. a+b+c means (a+b)+c).
-'right-assoc    Binary right associative operators (i.e. a=b=c means a=(b=c)).
+'left-assoc	Binary left associative operators (i.e. a+b+c means (a+b)+c).
+'right-assoc	Binary right associative operators (i.e. a=b=c means a=(b=c)).
 'right-assoc-sequence
-                Right associative operator that constitutes of a
-                sequence of tokens that separate expressions.  All the
-                tokens in the group are in this case taken as
-                describing the sequence in one such operator, and the
-                order between them is therefore significant.
+		Right associative operator that constitutes of a
+		sequence of tokens that separate expressions.  All the
+		tokens in the group are in this case taken as
+		describing the sequence in one such operator, and the
+		order between them is therefore significant.
 
 Operators containing a character with paren syntax are taken to match
 with a corresponding open/close paren somewhere else.  A postfix
@@ -1060,7 +1055,7 @@ since CC Mode treats every identifier as
 	;; Primary.
 	,@(c-lang-const c-identifier-ops)
 	;; Unary.
-	(prefix  "+" "-" "~")
+	(prefix	 "+" "-" "~")
 	;; Multiplicative.
 	(left-assoc "*" "/" "%")
 	;; Additive.
@@ -1080,7 +1075,7 @@ since CC Mode treats every identifier as
 
 (c-lang-defconst c-overloadable-operators
   "List of the operators that are overloadable, in their \"identifier
-form\".  See also `c-op-identifier-prefix'."
+form\".	 See also `c-op-identifier-prefix'."
   t    nil
   c++  '("new" "delete" ;; Can be followed by "[]" but we ignore that.
 	 "+" "-" "*" "/" "%"
@@ -1120,7 +1115,7 @@ This regexp is assumed to not match any
 ;; Note: the following alias is an old name which was a mis-spelling.  It has
 ;; been corrected above and throughout cc-engine.el.  It will be removed at
 ;; some release very shortly in the future.  ACM, 2006-04-14.
-(defvaralias 'c-opt-op-identitier-prefix 'c-opt-op-identifier-prefix)
+(defalias 'c-opt-op-identitier-prefix 'c-opt-op-identifier-prefix)
 (make-obsolete-variable 'c-opt-op-identitier-prefix 'c-opt-op-identifier-prefix
 			"CC Mode 5.31.4, 2006-04-14")
 
@@ -1233,7 +1228,7 @@ operators."
 (c-lang-defconst c-stmt-delim-chars
   ;; The characters that should be considered to bound statements.  To
   ;; optimize `c-crosses-statement-barrier-p' somewhat, it's assumed to
-  ;; begin with "^" to negate the set.  If ? : operators should be
+  ;; begin with "^" to negate the set.	If ? : operators should be
   ;; detected then the string must end with "?:".
   t "^;{}?:")
 (c-lang-defvar c-stmt-delim-chars (c-lang-const c-stmt-delim-chars))
@@ -1263,7 +1258,7 @@ Line comments are always terminated by n
 `c-block-comment-starter' and this one is assumed to be set.
 
 Note that it's currently not enough to set this to support a new
-comment style.  Other stuff like the syntax table must also be set up
+comment style.	Other stuff like the syntax table must also be set up
 properly."
   t    "//"
   awk  "#")
@@ -1276,7 +1271,7 @@ to be set if this is.  At least one of `
 this one is assumed to be set.
 
 Note that it's currently not enough to set this to support a new
-comment style.  Other stuff like the syntax table must also be set up
+comment style.	Other stuff like the syntax table must also be set up
 properly."
   t    "/*"
   awk  nil)
@@ -1285,7 +1280,7 @@ properly."
   "String that ends block comments, or nil if such don't exist.
 
 Note that it's currently not enough to set this to support a new
-comment style.  Other stuff like the syntax table must also be set up
+comment style.	Other stuff like the syntax table must also be set up
 properly."
   t    "*/"
   awk  nil)
@@ -1447,7 +1442,7 @@ properly."
   ;; allow line breaks is to avoid going very far and risk running out
   ;; of regexp stack; this regexp is intended to handle only short
   ;; comments that might be put in the middle of limited constructs
-  ;; like declarations.  Does not contain a \| operator at the top
+  ;; like declarations.	 Does not contain a \| operator at the top
   ;; level.
   t (when (c-lang-const c-unterminated-block-comment-regexp)
       (concat
@@ -1464,7 +1459,7 @@ properly."
 
 (c-lang-defconst c-nonwhite-syntactic-ws
   ;; Regexp matching a piece of syntactic whitespace that isn't a
-  ;; sequence of simple whitespace characters.  As opposed to
+  ;; sequence of simple whitespace characters.	As opposed to
   ;; `c-(forward|backward)-syntactic-ws', this doesn't regard cpp
   ;; directives as syntactic whitespace.
   t (c-concat-separated
@@ -1545,13 +1540,14 @@ properly."
 (c-lang-defvar c-syntactic-eol (c-lang-const c-syntactic-eol))
 
 
-;;; Defun functions
+;;; Defun handling.
 
-;; The Emacs variables beginning-of-defun-function and
-;; end-of-defun-function will be set so that commands like
-;; `mark-defun' and `narrow-to-defun' work right.  The key sequences
-;; C-M-a and C-M-e are, however, bound directly to the CC Mode
-;; functions, allowing optimization for large n.
+;; The Emacs variables beginning-of-defun-function and end-of-defun-function
+;; will be set so that commands like `mark-defun' and `narrow-to-defun' work
+;; right.  In older Emacsen, the key sequences C-M-a and C-M-e are, however,
+;; bound directly to the CC Mode functions, allowing optimisation for large n.
+;; From Emacs 23, this isn't necessary any more, since n is passed to the two
+;; functions.
 (c-lang-defconst beginning-of-defun-function
   "Function to which beginning-of-defun-function will be set."
   t 'c-beginning-of-defun
@@ -1564,6 +1560,7 @@ properly."
   t 'c-end-of-defun
   awk 'c-awk-end-of-defun)
 (c-lang-setvar end-of-defun-function (c-lang-const end-of-defun-function))
+
 
 ;;; In-comment text handling.
 
@@ -1634,9 +1631,9 @@ the appropriate place for that."
 (c-lang-defconst c-primitive-type-prefix-kwds
   "Keywords that might act as prefixes for primitive types.  Assumed to
 be a subset of `c-primitive-type-kwds'."
-  t       nil
+  t	  nil
   (c c++) '("long" "short" "signed" "unsigned")
-  idl     '("long" "unsigned"
+  idl	  '("long" "unsigned"
 	    ;; In CORBA PSDL:
 	    "strong"))
 
@@ -1847,7 +1844,7 @@ will be handled."
 
 (c-lang-defconst c-modifier-kwds
   "Keywords that can prefix normal declarations of identifiers
-\(and typically act as flags).  Things like argument declarations
+\(and typically act as flags).	Things like argument declarations
 inside function headers are also considered declarations in this
 sense.
 
@@ -1884,10 +1881,10 @@ If any of these also are on `c-type-list
 `c-colon-type-list-kwds', `c-paren-nontype-kwds', `c-paren-type-kwds',
 `c-<>-type-kwds', or `c-<>-arglist-kwds' then the associated clauses
 will be handled."
-  t       nil
-  objc    '("@class" "@end" "@defs")
-  java    '("import" "package")
-  pike    '("import" "inherit"))
+  t	  nil
+  objc	  '("@class" "@end" "@defs")
+  java	  '("import" "package")
+  pike	  '("import" "inherit"))
 
 (c-lang-defconst c-decl-start-kwds
   "Keywords that always start declarations, wherever they occur.
@@ -2017,9 +2014,9 @@ like that, it ends with the following ';
 
 The keywords on list are assumed to also be present on one of the
 `*-decl-kwds' lists."
-  t        nil
+  t	   nil
   (c objc) '("struct" "union" "enum" "typedef")
-  c++      '("class" "struct" "union" "enum" "typedef"))
+  c++	   '("class" "struct" "union" "enum" "typedef"))
 
 (c-lang-defconst c-opt-block-decls-with-vars-key
   ;; Regexp matching the `c-block-decls-with-vars' keywords, or nil in
@@ -2040,6 +2037,12 @@ declarations."
 	 ;; In CORBA PSDL:
 	 "as" "const" "implements" "of" "ref"))
 
+(c-lang-defconst c-postfix-decl-spec-key
+  ;; Regexp matching the keywords in `c-postfix-decl-spec-kwds'.
+  t (c-make-keywords-re t (c-lang-const c-postfix-decl-spec-kwds)))
+(c-lang-defvar c-postfix-decl-spec-key
+  (c-lang-const c-postfix-decl-spec-key))
+
 (c-lang-defconst c-nonsymbol-sexp-kwds
   "Keywords that may be followed by a nonsymbol sexp before whatever
 construct it's part of continues."
@@ -2048,7 +2051,7 @@ construct it's part of continues."
 
 (c-lang-defconst c-type-list-kwds
   "Keywords that may be followed by a comma separated list of type
-identifiers, where each optionally can be prefixed by keywords.  (Can
+identifiers, where each optionally can be prefixed by keywords.	 (Can
 also be used for the special case when the list can contain only one
 element.)
 
@@ -2073,7 +2076,7 @@ or variable identifier (that's being def
 (c-lang-defconst c-ref-list-kwds
   "Keywords that may be followed by a comma separated list of
 reference (i.e. namespace/scope/module) identifiers, where each
-optionally can be prefixed by keywords.  (Can also be used for the
+optionally can be prefixed by keywords.	 (Can also be used for the
 special case when the list can contain only one element.)  Assumed to
 be mutually exclusive with `c-type-list-kwds'.
 
@@ -2090,7 +2093,7 @@ or variable identifier (that's being def
 (c-lang-defconst c-colon-type-list-kwds
   "Keywords that may be followed (not necessarily directly) by a colon
 and then a comma separated list of type identifiers, where each
-optionally can be prefixed by keywords.  (Can also be used for the
+optionally can be prefixed by keywords.	 (Can also be used for the
 special case when the list can contain only one element.)"
   t    nil
   c++  '("class" "struct")
@@ -2106,7 +2109,7 @@ regexp if `c-colon-type-list-kwds' isn't
   t (if (c-lang-const c-colon-type-list-kwds)
 	;; Disallow various common punctuation chars that can't come
 	;; before the ":" that starts the inherit list after "class"
-	;; or "struct" in C++.  (Also used as default for other
+	;; or "struct" in C++.	(Also used as default for other
 	;; languages.)
 	"[^\]\[{}();,/#=:]*:"))
 (c-lang-defvar c-colon-type-list-re (c-lang-const c-colon-type-list-re))
@@ -2114,7 +2117,7 @@ regexp if `c-colon-type-list-kwds' isn't
 (c-lang-defconst c-paren-nontype-kwds
   "Keywords that may be followed by a parenthesis expression that doesn't
 contain type identifiers."
-  t       nil
+  t	  nil
   (c c++) '(;; GCC extension.
 	    "__attribute__"
 	    ;; MSVC extension.
@@ -2136,9 +2139,9 @@ type identifiers separated by arbitrary
 
 (c-lang-defconst c-<>-type-kwds
   "Keywords that may be followed by an angle bracket expression
-containing type identifiers separated by \",\".  The difference from
+containing type identifiers separated by \",\".	 The difference from
 `c-<>-arglist-kwds' is that unknown names are taken to be types and
-not other identifiers.  `c-recognize-<>-arglists' is assumed to be set
+not other identifiers.	`c-recognize-<>-arglists' is assumed to be set
 if this isn't nil."
   t    nil
   objc '("id")
@@ -2148,7 +2151,7 @@ if this isn't nil."
 
 (c-lang-defconst c-<>-arglist-kwds
   "Keywords that can be followed by a C++ style template arglist; see
-`c-recognize-<>-arglists' for details.  That language constant is
+`c-recognize-<>-arglists' for details.	That language constant is
 assumed to be set if this isn't nil."
   t    nil
   c++  '("template")
@@ -2163,8 +2166,7 @@ assumed to be set if this isn't nil."
 (c-lang-defconst c-opt-<>-sexp-key
   ;; Adorned regexp matching keywords that can be followed by an angle
   ;; bracket sexp.  Always set when `c-recognize-<>-arglists' is.
-  t (if (c-lang-const c-recognize-<>-arglists)
-	(c-make-keywords-re t (c-lang-const c-<>-sexp-kwds))))
+  t (c-make-keywords-re t (c-lang-const c-<>-sexp-kwds)))
 (c-lang-defvar c-opt-<>-sexp-key (c-lang-const c-opt-<>-sexp-key))
 
 (c-lang-defconst c-brace-id-list-kwds
@@ -2177,7 +2179,6 @@ identifiers that follows the type in a n
   "Statement keywords followed directly by a substatement."
   t    '("do" "else")
   c++  '("do" "else" "try")
-  objc '("do" "else" "@finally" "@try")
   java '("do" "else" "finally" "try")
   idl  nil)
 
@@ -2187,11 +2188,22 @@ identifiers that follows the type in a n
   t (c-make-keywords-re t (c-lang-const c-block-stmt-1-kwds)))
 (c-lang-defvar c-block-stmt-1-key (c-lang-const c-block-stmt-1-key))
 
+(c-lang-defconst c-block-stmt-1-2-kwds
+  "Statement keywords optionally followed by a paren sexp.
+Keywords here should also be in `c-block-stmt-1-kwds'."
+  t nil
+  java '("try"))
+
+(c-lang-defconst c-block-stmt-1-2-key
+  ;; Regexp matching the start of a statement which may be followed by a
+  ;; paren sexp and will then be followed by a substatement.
+  t (c-make-keywords-re t (c-lang-const c-block-stmt-1-2-kwds)))
+(c-lang-defvar c-block-stmt-1-2-key (c-lang-const c-block-stmt-1-2-key))
+
 (c-lang-defconst c-block-stmt-2-kwds
   "Statement keywords followed by a paren sexp and then by a substatement."
   t    '("for" "if" "switch" "while")
   c++  '("for" "if" "switch" "while" "catch")
-  objc '("for" "if" "switch" "while" "@catch" "@synchronized")
   java '("for" "if" "switch" "while" "catch" "synchronized")
   idl  nil
   pike '("for" "if" "switch" "while" "foreach")
@@ -2223,7 +2235,6 @@ identifiers that follows the type in a n
 (c-lang-defconst c-simple-stmt-kwds
   "Statement keywords followed by an expression or nothing."
   t    '("break" "continue" "goto" "return")
-  objc '("break" "continue" "goto" "return" "@throw")
   ;; Note: `goto' is not valid in Java, but the keyword is still reserved.
   java '("break" "continue" "goto" "return" "throw")
   idl  nil
@@ -2290,13 +2301,12 @@ This construct is \"<keyword> <expressio
 
 (c-lang-defconst c-constant-kwds
   "Keywords for constants."
-  t       nil
+  t	  nil
   (c c++) '("NULL" ;; Not a keyword, but practically works as one.
 	    "false" "true")		; Defined in C99.
-  objc    '("nil" "Nil" "YES" "NO" "NS_DURING" "NS_HANDLER" "NS_ENDHANDLER")
-  idl     '("TRUE" "FALSE")
-  java    '("true" "false" "null") ; technically "literals", not keywords
-  pike    '("UNDEFINED")) ;; Not a keyword, but practically works as one.
+  objc	  '("nil" "Nil" "YES" "NO" "NS_DURING" "NS_HANDLER" "NS_ENDHANDLER")
+  idl	  '("TRUE" "FALSE")
+  pike	  '("UNDEFINED")) ;; Not a keyword, but practically works as one.
 
 (c-lang-defconst c-primary-expr-kwds
   "Keywords besides constants and operators that start primary expressions."
@@ -2381,7 +2391,7 @@ Note that Java specific rules are curren
 (c-lang-defconst c-opt-bitfield-key
   ;; Regexp matching the start of a bitfield (not uniquely), or nil in
   ;; languages without bitfield support.
-  t       nil
+  t	  nil
   (c c++) (c-make-keywords-re t (c-lang-const c-bitfield-kwds)))
 (c-lang-defvar c-opt-bitfield-key (c-lang-const c-opt-bitfield-key))
 
@@ -2458,10 +2468,10 @@ Note that Java specific rules are curren
   ;;
   ;; E.g. to see whether the string str contains a keyword on
   ;; `c-class-decl-kwds', one can do like this:
-  ;;     (get (intern-soft str c-keyword-obarray) 'c-class-decl-kwds)
+  ;;	 (get (intern-soft str c-keyword-obarray) 'c-class-decl-kwds)
   ;; Which preferably is written using the associated functions in
   ;; cc-engine:
-  ;;     (c-keyword-member (c-keyword-sym str) 'c-class-decl-kwds)
+  ;;	 (c-keyword-member (c-keyword-sym str) 'c-class-decl-kwds)
 
   ;; The obarray is not stored directly as a language constant since
   ;; the printed representation for obarrays used in .elc files isn't
@@ -2476,7 +2486,7 @@ Note that Java specific rules are curren
 	    alist (cdr alist))
       (setplist (intern kwd obarray)
 		;; Emacs has an odd bug that causes `mapcan' to fail
-		;; with unintelligible errors.  (XEmacs works.)
+		;; with unintelligible errors.	(XEmacs works.)
 		;;(mapcan (lambda (lang-const)
 		;;	      (list lang-const t))
 		;;	    lang-const-list)
@@ -2498,7 +2508,7 @@ Note that Java specific rules are curren
 
 (c-lang-defconst c-primary-expr-regexp
   ;; Regexp matching the start of any primary expression, i.e. any
-  ;; literal, symbol, prefix operator, and '('.  It doesn't need to
+  ;; literal, symbol, prefix operator, and '('.	 It doesn't need to
   ;; exclude keywords; they are excluded afterwards unless the second
   ;; submatch matches. If the first but not the second submatch
   ;; matches then it is an ambiguous primary expression; it could also
@@ -2560,7 +2570,7 @@ Note that Java specific rules are curren
        "\\.?[0-9]"
 
        "\\|"
-       ;; The unambiguous operators from `prefix-ops'.
+       ;; The nonambiguous operators from `prefix-ops'.
        (c-make-keywords-re nil
 	 (set-difference nonkeyword-prefix-ops in-or-postfix-ops
 			 :test 'string-equal))
@@ -2576,6 +2586,15 @@ Note that Java specific rules are curren
 
 ;;; Additional constants for parser-level constructs.
 
+(c-lang-defconst c-decl-start-colon-kwd-re
+  "Regexp matching a keyword that is followed by a colon, where
+  the whole construct can precede a declaration.
+  E.g. \"public:\" in C++."
+  t "\\<\\>"
+  c++ (c-make-keywords-re t (c-lang-const c-protection-kwds)))
+(c-lang-defvar c-decl-start-colon-kwd-re
+  (c-lang-const c-decl-start-colon-kwd-re))
+
 (c-lang-defconst c-decl-prefix-re
   "Regexp matching something that might precede a declaration, cast or
 label, such as the last token of a preceding statement or declaration.
@@ -2583,9 +2602,9 @@ This is used in the common situation whe
 doesn't start with any specific token that can be searched for.
 
 The regexp should not match bob; that is done implicitly.  It can't
-require a match longer than one token.  The end of the token is taken
+require a match longer than one token.	The end of the token is taken
 to be at the end of the first submatch, which is assumed to always
-match.  It's undefined whether identifier syntax (see
+match.	It's undefined whether identifier syntax (see
 `c-identifier-syntax-table') is in effect or not.  This regexp is
 assumed to be a superset of `c-label-prefix-re' if
 `c-recognize-colon-labels' is set.
@@ -2594,11 +2613,11 @@ Besides this, `c-decl-start-kwds' is use
 
 Note: This variable together with `c-decl-start-re' and
 `c-decl-start-kwds' is only used to detect \"likely\"
-declaration/cast/label starts.  I.e. they might produce more matches
+declaration/cast/label starts.	I.e. they might produce more matches
 but should not miss anything (or else it's necessary to use text
 properties - see the next note).  Wherever they match, the following
 construct is analyzed to see if it indeed is a declaration, cast or
-label.  That analysis is not cheap, so it's important that not too
+label.	That analysis is not cheap, so it's important that not too
 many false matches are triggered.
 
 Note: If a declaration/cast/label start can't be detected with this
@@ -2615,8 +2634,11 @@ more info."
   java "\\([\{\}\(;,<]+\\)"
   ;; Match "<" in C++ to get the first argument in a template arglist.
   ;; In that case there's an additional check in `c-find-decl-spots'
-  ;; that it got open paren syntax.
-  c++ "\\([\{\}\(\);,<]+\\)"
+  ;; that it got open paren syntax.  Match ":" to aid in picking up
+  ;; "public:", etc.  This involves additional checks in
+  ;; `c-find-decl-prefix-search' to prevent a match of identifiers
+  ;; or labels.
+  c++ "\\([\{\}\(\);:,<]+\\)"
   ;; Additionally match the protection directives in Objective-C.
   ;; Note that this doesn't cope with the longer directives, which we
   ;; would have to match from start to end since they don't end with
@@ -2686,7 +2708,7 @@ If parens can occur, the chars inside th
 list.
 
 '<' and '>' should be disallowed even if angle bracket arglists can
-occur.  That since the search function needs to stop at them anyway to
+occur.	That since the search function needs to stop at them anyway to
 ensure they are given paren syntax.
 
 This is used to skip backward from the open brace to find the region
@@ -2711,7 +2733,7 @@ possible for good performance."
 			       pos (match-end 0)))
 		       res))))
 
-  ;; Allow cpp operations (where applicable).
+  ;; Allow cpp operatios (where applicable).
   t (if (c-lang-const c-opt-cpp-prefix)
 	(set-difference (c-lang-const c-block-prefix-disallowed-chars)
 			'(?#))
@@ -2741,8 +2763,8 @@ possible for good performance."
 (c-lang-defvar c-block-prefix-charset (c-lang-const c-block-prefix-charset))
 
 (c-lang-defconst c-type-decl-prefix-key
-  "Regexp matching the declarator operators that might precede the
-identifier in a declaration, e.g. the \"*\" in \"char *argv\".  This
+  "Regexp matching any declarator operator that might precede the
+identifier in a declaration, e.g. the \"*\" in \"char *argv\".	This
 regexp should match \"(\" if parentheses are valid in declarators.
 The end of the first submatch is taken as the end of the operator.
 Identifier syntax is in effect when this is matched \(see
@@ -2779,7 +2801,7 @@ Identifier syntax is in effect when this
 
 (c-lang-defconst c-type-decl-suffix-key
   "Regexp matching the declarator operators that might follow after the
-identifier in a declaration, e.g. the \"[\" in \"char argv[]\".  This
+identifier in a declaration, e.g. the \"[\" in \"char argv[]\".	 This
 regexp should match \")\" if parentheses are valid in declarators.  If
 it matches an open paren of some kind, the type declaration check
 continues at the corresponding close paren, otherwise the end of the
@@ -2805,7 +2827,8 @@ is in effect when this is matched (see `
 		     "\\>")
 		  "")
 		"\\)")
-  (java idl) "\\([\[\(]\\)")
+  java "\\([\[\(\)]\\)"
+  idl "\\([\[\(]\\)")
 (c-lang-defvar c-type-decl-suffix-key (c-lang-const c-type-decl-suffix-key)
   'dont-doc)
 
@@ -2819,7 +2842,7 @@ undefined whether identifier syntax (see
 is in effect or not.
 
 Note that it's used in cases like after \"foo (bar)\" so it should
-only match when it's certain that it's a declaration, e.g., \"{\" but
+only match when it's certain that it's a declaration, e.g \"{\" but
 not \",\" or \";\"."
   t "{"
   ;; If K&R style declarations should be recognized then one could
@@ -2854,8 +2877,8 @@ not \",\" or \";\"."
 
 (c-lang-defconst c-opt-type-concat-key
   "Regexp matching operators that concatenate types, e.g. the \"|\" in
-\"int|string\" in Pike.  The end of the first submatch is taken as the
-end of the operator.  nil in languages without such operators.  It's
+\"int|string\" in Pike.	 The end of the first submatch is taken as the
+end of the operator.  nil in languages without such operators.	It's
 undefined whether identifier syntax (see `c-identifier-syntax-table')
 is in effect or not."
   t nil
@@ -2878,24 +2901,22 @@ is in effect or not."
 (c-lang-defvar c-known-type-key
   ;; Regexp matching the known type identifiers.  This is initialized
   ;; from the type keywords and `*-font-lock-extra-types'.  The first
-  ;; submatch is the one that matches the type.  Note that this regexp
+  ;; submatch is the one that matches the type.	 Note that this regexp
   ;; assumes that symbol constituents like '_' and '$' have word
   ;; syntax.
   (let* ((extra-types
 	  (when (boundp (c-mode-symbol "font-lock-extra-types"))
 	    (c-mode-var "font-lock-extra-types")))
 	 (regexp-strings
-	  (apply 'nconc
-		 (mapcar (lambda (re)
+	  (mapcan (lambda (re)
 		    (when (string-match "[][.*+?^$\\]" re)
 		      (list re)))
-		  extra-types)))
+		  extra-types))
 	 (plain-strings
-	  (apply 'nconc
-		 (mapcar (lambda (re)
+	  (mapcan (lambda (re)
 		    (unless (string-match "[][.*+?^$\\]" re)
 		      (list re)))
-		  extra-types))))
+		  extra-types)))
     (concat "\\<\\("
 	    (c-concat-separated
 	     (append (list (c-make-keywords-re nil
@@ -2926,19 +2947,21 @@ calls before a brace block.  This settin
 that are preceded by a declaration starting keyword, so
 e.g. `c-typeless-decl-kwds' may still be used when it's set to nil."
   t nil
-  (c c++ objc) t)
+  (c c++ objc java) t)
 (c-lang-defvar c-recognize-typeless-decls
   (c-lang-const c-recognize-typeless-decls))
 
 (c-lang-defconst c-recognize-<>-arglists
-  "Non-nil means C++ style template arglists should be handled.  More
+  "Non-nil means C++ style template arglists should be handled.	 More
 specifically, this means a comma separated list of types or
 expressions surrounded by \"<\" and \">\".  It's always preceded by an
 identifier or one of the keywords on `c-<>-type-kwds' or
 `c-<>-arglist-kwds'.  If there's an identifier before then the whole
 expression is considered to be a type."
   t (or (consp (c-lang-const c-<>-type-kwds))
-	(consp (c-lang-const c-<>-arglist-kwds))))
+	(consp (c-lang-const c-<>-arglist-kwds)))
+  java t)	    ; 2008-10-19.  This is crude.  The syntax for java
+		    ; generics is not yet coded in CC Mode.
 (c-lang-defvar c-recognize-<>-arglists (c-lang-const c-recognize-<>-arglists))
 
 (c-lang-defconst c-enums-contain-decls
@@ -2972,7 +2995,7 @@ i.e. compound statements surrounded by p
   ;; Regexp matching the start of angle bracket arglists in languages
   ;; where `c-recognize-<>-arglists' is set.  Does not exclude
   ;; keywords outside `c-<>-arglist-kwds'.  The first submatch is
-  ;; assumed to surround the preceding symbol.  The whole match is
+  ;; assumed to surround the preceding symbol.	The whole match is
   ;; assumed to end directly after the opening "<".
   t (if (c-lang-const c-recognize-<>-arglists)
 	(concat "\\("
@@ -3022,7 +3045,7 @@ not apply to labels recognized by `c-lab
 
 (c-lang-defconst c-label-prefix-re
   "Regexp like `c-decl-prefix-re' that matches any token that can precede
-a generic colon label.  Not used if `c-recognize-colon-labels' is
+a generic colon label.	Not used if `c-recognize-colon-labels' is
 nil."
   t "\\([{};]+\\)")
 (c-lang-defvar c-label-prefix-re
@@ -3085,7 +3108,7 @@ way."
 (c-lang-defvar c-opt-friend-key (c-lang-const c-opt-friend-key))
 
 (c-lang-defconst c-opt-method-key
-  ;; Special regexp to match the start of Objective-C methods.  The
+  ;; Special regexp to match the start of Objective-C methods.	The
   ;; first submatch is assumed to end after the + or - key.
   t    nil
   objc (concat
@@ -3117,7 +3140,7 @@ way."
 ;;; Wrap up the `c-lang-defvar' system.
 
 ;; Compile in the list of language variables that has been collected
-;; with the `c-lang-defvar' and `c-lang-setvar' macros.  Note that the
+;; with the `c-lang-defvar' and `c-lang-setvar' macros.	 Note that the
 ;; first element of each is nil.
 (defconst c-lang-variable-inits (cc-eval-when-compile c-lang-variable-inits))
 (defconst c-emacs-variable-inits (cc-eval-when-compile c-emacs-variable-inits))
@@ -3237,4 +3260,7 @@ evaluated and should not be quoted."
 
 (cc-provide 'cc-langs)
 
+;;; arch-tag: 1ab57482-cfc2-4c5b-b628-3539c3098822
+
 ;;; cc-langs.el ends here
+
--- /dev/null
+++ emacs24-24.3+1/lisp/progmodes/cc-lobotomy.el
@@ -0,0 +1,160 @@
+;;; cc-lobotomy.el --- excise portions of cc-mode's brain... for speed
+
+;; Copyright (C) 1985,1987,1992-2003, 2005, 2006, 2007, 2008, 2009,
+;;   2010, 2011  Free Software Foundation, Inc.
+
+;; Author:     1995 Barry A. Warsaw
+;; Maintainer: Unmaintained
+;; Created:    March 1995, split from cc-mode.el
+;; Version:    See cc-mode.el
+;; Keywords:   c languages oop
+
+;; This file is not part of GNU Emacs.
+
+;; This program is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3 of the License, or
+;; (at your option) any later version.
+
+;; This program is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with this program; see the file COPYING.  If not, see
+;; <http://www.gnu.org/licenses/>.
+
+;;; Commentary:
+;;
+;; Every effort has been made to improve the performance of
+;; cc-mode. However, due to the nature of the C, C++, and Objective-C
+;; language definitions, a trade-off is often required between
+;; accuracy of construct recognition and speed. I believe it is always
+;; best to be correct, and that the mode is currently fast enough for
+;; most normal usage.  Others disagree.	 I have no intention of
+;; including these hacks in the main distribution.  When cc-mode
+;; version 5 comes out, it will include a rewritten indentation engine
+;; so that performance will be greatly improved automatically.	This
+;; was not included in this release of version 4 so that Emacs 18
+;; could still be supported.  Note that this implies that cc-mode
+;; version 5 will *not* work on Emacs 18!
+;;
+;; To use, see the variable cc-lobotomy-pith-list and the function
+;; cc-lobotomize.   The variable contains a good explanation of the
+;; speed/accuracy trade-offs for each option.  Set it to what you'd
+;; like, and call cc-lobotomy in your c-mode-hook.
+;;
+;; This will redefine certain cc-mode functions and affect all cc-mode
+;; buffers globally.
+;;
+;; This file is completely unsupported!	 Although it has been patched
+;; superficially to keep pace with the rest of CC Mode, it hasn't been
+;; tested for a long time.
+
+;;; Code:
+
+(eval-when-compile
+  (let ((load-path
+	 (if (and (boundp 'byte-compile-dest-file)
+		  (stringp byte-compile-dest-file))
+	     (cons (file-name-directory byte-compile-dest-file) load-path)
+	   load-path)))
+    (load "cc-bytecomp" nil t)))
+
+(cc-require 'cc-defs)
+(cc-require 'cc-engine)
+(cc-require 'cc-cmds)
+
+
+(defvar cc-lobotomy-pith-list ()
+  "*List of things to dumb-ify to speed up cc-mode.  Note that each
+incurs a penalty in correct identification of certain code constructs.
+Possible values to put on this list:
+
+  'literal -- `c-in-literal' is lobotomized.  This will significantly
+	      speed up parsing over large lists of cpp macros, as seen
+	      for instance in header files.  The penalty is that you
+	      cannot put the `#' character as the first non-whitespace
+	      character on a line inside other multi-line literals
+	      (i.e. comments or strings)
+
+  'class   -- `c-narrow-out-enclosing-class' and `c-search-uplist for
+	      classkey' are lobotomized.  This speeds up some
+	      indenting inside and around class and struct
+	      definitions.  The penalty is that elements inside of
+	      classes and structs may not indent correctly.
+
+  'lists   -- `c-inside-bracelist-p' is lobotomized.  This speeds up
+	      indenting inside and around brace lists (e.g. aggregate
+	      initializers, enum lists, etc.).	The penalty is that
+	      elements inside these lists may not indent correctly.")
+
+(defun cc-lobotomize ()
+  "Perform lobotomies on cc-mode as described in `cc-lobotomy-pith-list'."
+  (let (pithedp)
+    (if (memq 'literal cc-lobotomy-pith-list)
+	(progn
+	  (fset 'c-in-literal 'cc-in-literal-lobotomized)
+	  (setq pithedp t)))
+    (if (memq 'class cc-lobotomy-pith-list)
+	(progn
+	  (fset 'c-narrow-out-enclosing-class
+		'cc-narrow-out-enclosing-class-lobotomized)
+	  (fset 'c-search-uplist-for-classkey
+		'cc-search-uplist-for-classkey-lobotomized)
+	  (setq pithedp t)))
+    (if (memq 'lists cc-lobotomy-pith-list)
+	(progn
+	  (fset 'c-inside-bracelist-p 'cc-inside-bracelist-p-lobotomized)
+	  (setq pithedp t)))
+    (if pithedp
+	(add-hook 'c-prepare-bug-report-hooks 'cc-lobo-bug-report-blurb))
+    ))
+
+
+;; This is a faster version of c-in-literal.  It trades speed for one
+;; approximation, namely that within other literals, the `#' character
+;; cannot be the first non-whitespace on a line.  This only happens if
+;; detect-cpp is non-nil, which isn't very often.
+(defun cc-in-literal-lobotomized (&optional lim detect-cpp)
+  ;; first check the cache
+  (if (and (vectorp c-in-literal-cache)
+	   (= (point) (aref c-in-literal-cache 0)))
+      (aref c-in-literal-cache 1)
+    ;; quickly check for cpp macro. this breaks if the `#' character
+    ;; appears as the first non-whitespace on a line inside another
+    ;; literal.
+    (let* (state
+	   (char-at-boi (char-after (c-point 'boi)))
+	   (rtn (cond
+		 ((and detect-cpp char-at-boi (= char-at-boi ?#))
+		  'pound)
+		 ((nth 3 (setq state (save-excursion
+				       (parse-partial-sexp
+					(or lim (c-point 'bod))
+					(point)))))
+		  'string)
+		 ((nth 4 state) (if (nth 7 state) 'c++ 'c))
+		 (t nil))))
+      ;; cache this result if the cache is enabled
+      (if (not c-in-literal-cache)
+	  (setq c-in-literal-cache (vector (point) rtn)))
+      rtn)))
+
+(defun cc-narrow-out-enclosing-class-lobotomized (dummy1 dummy2) nil)
+
+(defun cc-search-uplist-for-classkey-lobotomized (dummy) nil)
+
+(defun cc-inside-bracelist-p-lobotomized (dummy1 dummy2) nil)
+
+(defun cc-lobo-bug-report-blurb ()
+  (insert
+   "\nYou are using cc-lobotomy.el.  You realize that by doing\n"
+   "so you have already made the decision to trade off accuracy\n"
+   "for speed?	Don't set your hopes too high that your problem\n"
+   "will be fixed.\n\n"))
+
+
+(cc-provide 'cc-lobotomy)
+;;; cc-lobotomy.el ends here
--- emacs24-24.3+1.orig/lisp/progmodes/cc-menus.el
+++ emacs24-24.3+1/lisp/progmodes/cc-menus.el
@@ -1,31 +1,33 @@
 ;;; cc-menus.el --- imenu support for CC Mode
 
-;; Copyright (C) 1985, 1987, 1992-2013 Free Software Foundation, Inc.
+;; Copyright (C) 1985, 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+;;   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+;;   2010, 2011   Free Software Foundation, Inc.
 
 ;; Authors:    1998- Martin Stjernholm
-;;             1992-1999 Barry A. Warsaw
-;;             1987 Dave Detlefs
-;;             1987 Stewart Clamen
-;;             1985 Richard M. Stallman
+;;	       1992-1999 Barry A. Warsaw
+;;	       1987 Dave Detlefs and Stewart Clamen
+;;	       1985 Richard M. Stallman
 ;; Maintainer: bug-cc-mode@gnu.org
 ;; Created:    22-Apr-1997 (split from cc-mode.el)
-;; Keywords:   c languages
-;; Package:    cc-mode
+;; Version:    See cc-mode.el
+;; Keywords:   c languages oop
 
 ;; This file is part of GNU Emacs.
 
-;; GNU Emacs is free software: you can redistribute it and/or modify
+;; GNU Emacs is free software; you can redistribute it and/or modify
 ;; it under the terms of the GNU General Public License as published by
-;; the Free Software Foundation, either version 3 of the License, or
-;; (at your option) any later version.
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
 
 ;; GNU Emacs is distributed in the hope that it will be useful,
 ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
 ;; GNU General Public License for more details.
 
 ;; You should have received a copy of the GNU General Public License
-;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
+;; along with this program; see the file COPYING.  If not, see
+;; <http://www.gnu.org/licenses/>.
 
 ;;; Commentary:
 
@@ -45,6 +47,7 @@
 (cc-bytecomp-defvar imenu-case-fold-search)
 (cc-bytecomp-defvar imenu-generic-expression)
 (cc-bytecomp-defvar imenu-create-index-function)
+(cc-bytecomp-defun imenu-progress-message)
 
 
 ;; imenu integration
@@ -80,27 +83,27 @@ A sample value might look like: `\\(_P\\
 (defvar cc-imenu-c++-generic-expression
   `(
     ;; Try to match ::operator definitions first. Otherwise `X::operator new ()'
-    ;; will be incorrectly recognized as function `new ()' because the regexps
+    ;; will be incorrectly recognised as function `new ()' because the regexps
     ;; work by backtracking from the end of the definition.
     (nil
      ,(concat
        "^\\<.*"
-       "[^" c-alnum "_:<>~]"                  ; match any non-identifier char
-                                              ; (note: this can be `\n')
+       "[^" c-alnum "_:<>~]"		      ; match any non-identifier char
+					      ; (note: this can be `\n')
        "\\("
 	  "\\([" c-alnum "_:<>~]*::\\)?"      ; match an operator
-          "operator\\>[ \t]*"
-          "\\(()\\|[^(]*\\)"                  ; special case for `()' operator
+	  "operator\\>[ \t]*"
+	  "\\(()\\|[^(]*\\)"		      ; special case for `()' operator
        "\\)"
 
-       "[ \t]*([^)]*)[ \t]*[^ \t;]"           ; followed by ws, arg list,
-                                              ; require something other than
-                                              ; a `;' after the (...) to
-                                              ; avoid prototypes.  Can't
-                                              ; catch cases with () inside
-                                              ; the parentheses surrounding
-                                              ; the parameters.  e.g.:
-                                              ; `int foo(int a=bar()) {...}'
+       "[ \t]*([^)]*)[ \t]*[^ \t;]"	      ; followed by ws, arg list,
+					      ; require something other than
+					      ; a `;' after the (...) to
+					      ; avoid prototypes.  Can't
+					      ; catch cases with () inside
+					      ; the parentheses surrounding
+					      ; the parameters.	 e.g.:
+					      ; `int foo(int a=bar()) {...}'
        ) 1)
     ;; Special case to match a line like `main() {}'
     ;; e.g. no return type, not even on the previous line.
@@ -109,17 +112,15 @@ A sample value might look like: `\\(_P\\
        "^"
        "\\([" c-alpha "_][" c-alnum "_:<>~]*\\)" ; match function name
        "[ \t]*("			      ; see above, BUT
-       "[ \t]*\\([^ \t(*][^)]*\\)?)"          ; the arg list must not start
-       "[ \t]*[^ \t;(]"                       ; with an asterisk or parentheses
+       "[ \t]*\\([^ \t(*][^)]*\\)?)"	      ; the arg list must not start
+       "[ \t]*[^ \t;(]"			      ; with an asterisk or parentheses
        ) 1)
     ;; General function name regexp
     (nil
      ,(concat
-       "^\\<"                                 ; line MUST start with word char
-       ;; \n added to prevent overflow in regexp matcher.
-       ;; http://lists.gnu.org/archive/html/emacs-pretest-bug/2007-02/msg00021.html
-       "[^()\n]*"                             ; no parentheses before
-       "[^" c-alnum "_:<>~]"                  ; match any non-identifier char
+       "^\\<"				      ; line MUST start with word char
+       "[^()]*"				      ; no parentheses before
+       "[^" c-alnum "_:<>~]"		      ; match any non-identifier char
        "\\([" c-alpha "_][" c-alnum "_:<>~]*\\)" ; match function name
        "\\([ \t\n]\\|\\\\\n\\)*("	      ; see above, BUT the arg list
        "\\([ \t\n]\\|\\\\\n\\)*"	      ; must not start
@@ -133,77 +134,160 @@ A sample value might look like: `\\(_P\\
     ;; This case is only included if cc-imenu-c-prototype-macro-regexp is set.
     ;; Only supported in c-code, so no `:<>~' chars in function name!
     ,@(if cc-imenu-c-prototype-macro-regexp
-            `((nil
-                 ,(concat
-                   "^\\<.*"                   ; line MUST start with word char
-		   "[^" c-alnum "_]"          ; match any non-identifier char
+	    `((nil
+		 ,(concat
+		   "^\\<.*"		      ; line MUST start with word char
+		   "[^" c-alnum "_]"	      ; match any non-identifier char
 		   "\\([" c-alpha "_][" c-alnum "_]*\\)" ; match function name
-                   "[ \t]*"                   ; whitespace before macro name
-                   cc-imenu-c-prototype-macro-regexp
-                   "[ \t]*("                  ; ws followed by first paren.
-                   "[ \t]*([^)]*)[ \t]*)[ \t]*[^ \t;]" ; see above
-                   ) 1)))
+		   "[ \t]*"		      ; whitespace before macro name
+		   cc-imenu-c-prototype-macro-regexp
+		   "[ \t]*("		      ; ws followed by first paren.
+		   "[ \t]*([^)]*)[ \t]*)[ \t]*[^ \t;]" ; see above
+		   ) 1)))
     ;; Class definitions
     ("Class"
      ,(concat
-         "^"                                  ; beginning of line is required
-         "\\(template[ \t]*<[^>]+>[ \t]*\\)?" ; there may be a `template <...>'
-         "\\(class\\|struct\\)[ \t]+"
-         "\\("                                ; the string we want to get
-	 "[" c-alnum "_]+"                    ; class name
-         "\\(<[^>]+>\\)?"                     ; possibly explicitly specialized
-         "\\)"
-         "\\([ \t\n]\\|\\\\\n\\)*[:{]"
-         ) 3))
+	 "^"				      ; beginning of line is required
+	 "\\(template[ \t]*<[^>]+>[ \t]*\\)?" ; there may be a `template <...>'
+	 "\\(class\\|struct\\)[ \t]+"
+	 "\\("				      ; the string we want to get
+	 "[" c-alnum "_]+"		      ; class name
+	 "\\(<[^>]+>\\)?"		      ; possibly explicitly specialized
+	 "\\)"
+	 "\\([ \t\n]\\|\\\\\n\\)*[:{]"
+	 ) 3))
   "Imenu generic expression for C++ mode.  See `imenu-generic-expression'.")
 
 (defvar cc-imenu-c-generic-expression
   cc-imenu-c++-generic-expression
-  "Imenu generic expression for C mode.  See `imenu-generic-expression'.")
+  "Imenu generic expression for C mode.	 See `imenu-generic-expression'.")
 
-(defvar cc-imenu-java-generic-expression
+
+;; Auxiliary regexps for Java try to match their trailing whitespace where
+;; appropriate, but _not_ starting whitespace.
+
+(defconst cc-imenu-java-ellipsis-regexp
+  (concat
+   "\\.\\{3\\}"
+   "[ \t\n\r]*"))
+
+(defun cc-imenu-java-build-type-args-regex (depth)
+  "Builds regexp for type arguments list with DEPTH allowed
+nested angle brackets constructs."
+  (if (> depth 0)
+      (concat "<"
+		"[][.," c-alnum "_? \t\n\r]+"
+		(if (> depth 1)
+		    "\\(")
+		(cc-imenu-java-build-type-args-regex (1- depth))
+		(if (> depth 1)
+		  (concat "[][.," c-alnum "_? \t\n\r]*"
+			  "\\)*"))
+	      ">")))
+
+(defconst cc-imenu-java-type-spec-regexp
+  (concat
+   ;; zero or more identifiers followed by a dot
+   "\\("
+     "[" c-alpha "_][" c-alnum "_]*\\."
+   "\\)*"
+   ;; a single mandatory identifier without a dot
+   "[" c-alpha "_][" c-alnum "_]*"
+   ;; then choice:
+   "\\("
+   ;; (option 1) type arguments list which _may_ be followed with brackets
+   ;; and/or spaces, then optional variable arity
+     "[ \t\n\r]*"
+     (cc-imenu-java-build-type-args-regex 3)
+     "[][ \t\n\r]*"
+     "\\(" cc-imenu-java-ellipsis-regexp "\\)?"
+   "\\|"
+   ;; (option 2) just brackets and/or spaces (there should be at least one),
+   ;; then optional variable arity
+     "[][ \t\n\r]+"
+     "\\(" cc-imenu-java-ellipsis-regexp "\\)?"
+   "\\|"
+   ;; (option 3) just variable arity
+     cc-imenu-java-ellipsis-regexp
+   "\\)"))
+
+(defconst cc-imenu-java-comment-regexp
+  (concat
+   "/"
+   "\\("
+   ;; a traditional comment
+     "\\*"
+     "\\("
+       "[^*]"
+     "\\|"
+       "\\*+[^/*]"
+     "\\)*"
+     "\\*+/"
+   "\\|"
+   ;; an end-of-line comment
+     "/[^\n\r]*[\n\r]"
+   "\\)"
+  "[ \t\n\r]*"
+   ))
+
+;; Comments are allowed before the argument, after any of the
+;; modifiers and after the identifier.
+(defconst cc-imenu-java-method-arg-regexp
+  (concat
+   "\\(" cc-imenu-java-comment-regexp "\\)*"
+   ;; optional modifiers
+   "\\("
+     ;; a modifier is either an annotation or "final"
+     "\\("
+       "@[" c-alpha "_]"
+       "[" c-alnum "._]*"
+       ;; TODO support element-value pairs!
+     "\\|"
+       "final"
+     "\\)"
+     ;; a modifier ends with comments and/or ws
+     "\\("
+       "\\(" cc-imenu-java-comment-regexp "\\)+"
+     "\\|"
+       "[ \t\n\r]+"
+       "\\(" cc-imenu-java-comment-regexp "\\)*"
+     "\\)"
+   "\\)*"
+   ;; type spec
+   cc-imenu-java-type-spec-regexp
+   ;; identifier
+   "[" c-alpha "_]"
+   "[" c-alnum "_]*"
+   ;; optional comments and/or ws
+   "[ \t\n\r]*"
+   "\\(" cc-imenu-java-comment-regexp "\\)*"
+   ))
+
+(defconst cc-imenu-java-generic-expression
   `((nil
      ,(concat
-       "[" c-alpha "_][\]\[." c-alnum "_<> ]+[ \t\n\r]+" ; type spec
-       "\\([" c-alpha "_][" c-alnum "_]*\\)" ; method name
+       cc-imenu-java-type-spec-regexp
+       "\\("				      ; method name which gets captured
+					      ; into index
+         "[" c-alpha "_]"
+         "[" c-alnum "_]*"
+       "\\)"
        "[ \t\n\r]*"
-       ;; An argument list htat is either empty or contains any number
-       ;; of arguments.  An argument is any number of annotations
-       ;; followed by a type spec followed by a word.  A word is an
-       ;; identifier.  A type spec is an identifier, possibly followed
-       ;; by < typespec > possibly followed by [].
-       (concat "("
-               "\\("
-               "[ \t\n\r]*"
-               "\\("
-               "@"
-               "[" c-alpha "_]"
-               "[" c-alnum "._]""*"
-               "[ \t\n\r]+"
-               "\\)*"
-               "\\("
-               "[" c-alpha "_]"
-               "[\]\[" c-alnum "_.]*"
-               "\\("
-
-               "<"
-               "[ \t\n\r]*"
-               "[\]\[.," c-alnum "_<> \t\n\r]*"
-               ">"
-               "\\)?"
-               "\\(\\[\\]\\)?"
-               "[ \t\n\r]+"
-               "\\)"
-               "[" c-alpha "_]"
-               "[" c-alnum "_]*"
-               "[ \t\n\r,]*"
-               "\\)*"
-               ")"
-               "[.," c-alnum " \t\n\r]*"
-               "{"
-	       )) 1))
+       ;; An argument list that contains zero or more arguments.
+       (concat
+	"("
+	"[ \t\n\r]*"
+	"\\("
+	  "\\(" cc-imenu-java-method-arg-regexp ",[ \t\n\r]*\\)*"
+	  cc-imenu-java-method-arg-regexp
+	"\\)?"
+	")"
+	"[.,_" c-alnum " \t\n\r]*"	      ; throws etc.
+	"{"
+	)) 7))
   "Imenu generic expression for Java mode.  See `imenu-generic-expression'.")
 
+
 ;; Internal variables
 (defvar cc-imenu-objc-generic-expression-noreturn-index nil)
 (defvar cc-imenu-objc-generic-expression-general-func-index nil)
@@ -242,7 +326,7 @@ A sample value might look like: `\\(_P\\
    ;; Pick a token by (match-string 8 or 9)
    ;;
    "\\|\\("
-   "^[-+][:" c-alnum "()*_<>\n\t ]*[;{]"        ; Methods
+   "^[-+][:" c-alnum "()*_<>\n\t ]*[;{]"	; Methods
    "\\|"
    "^@interface[\t ]+[" c-alnum "_]+[\t ]*:"
    "\\|"
@@ -278,7 +362,7 @@ Example:
 	    p (1+ p))
       (cond
        ;; Is CHAR part of a objc token?
-       ((and (not inargvar)     ; Ignore if CHAR is part of an argument variable.
+       ((and (not inargvar)	; Ignore if CHAR is part of an argument variable.
 	     (eq 0 betweenparen) ; Ignore if CHAR is in parentheses.
 	     (or (and (<= ?a char) (<= char ?z))
 		 (and (<= ?A char) (<= char ?Z))
@@ -304,7 +388,7 @@ Example:
 	(setq betweenparen (1- betweenparen)))))
     return))
 
-(defun cc-imenu-objc-remove-white-space  (str)
+(defun cc-imenu-objc-remove-white-space	 (str)
   "Remove all spaces and tabs from STR."
   (let ((return "")
 	(p 0)
@@ -319,13 +403,13 @@ Example:
     return))
 
 (defun cc-imenu-objc-function ()
-  "Imenu support for Objective C mode."
+  "imenu supports for objc-mode."
   (let (methodlist
 	clist
 	;;
 	;; OBJC, Cnoreturn, Cgeneralfunc, Cproto are constants.
 	;;
-	;;                  *Warning for developers*
+	;;		    *Warning for developers*
 	;; These constants depend on `cc-imenu-c++-generic-expression'.
 	;;
 	(OBJC cc-imenu-objc-generic-expression-objc-base-index)
@@ -342,11 +426,11 @@ Example:
 	str
 	str2
 	(intflen (length "@interface"))
-	(implen  (length "@implementation"))
-	(prtlen  (length "@protocol"))
+	(implen	 (length "@implementation"))
+	(prtlen	 (length "@protocol"))
 	(func
 	 ;;
-	 ;; Does this emacs have buffer-substring-no-properties?
+	 ;; Does this emacs has buffer-substring-no-properties?
 	 ;;
 	 (if (fboundp 'buffer-substring-no-properties)
 	     'buffer-substring-no-properties
@@ -399,10 +483,14 @@ Example:
 		str2 "@protocol")))
 	(setq str (cc-imenu-objc-remove-white-space str))
 	(setq methodlist (cons (cons str2
-				     (match-beginning langnum))
+			      (match-beginning langnum))
 			       methodlist))
-	(setq toplist (cons (cons str methodlist) toplist)
+	(setq toplist (cons nil (cons (cons str
+					  methodlist) toplist))
 	      methodlist nil))))
+    ;;
+    (if (eq (car toplist) nil)
+	(setq toplist (cdr toplist)))
 
     ;; In this buffer, there is only one or zero @{interface|implementation|protocol}.
     (if (< classcount 2)
@@ -438,4 +526,5 @@ Example:
 
 (cc-provide 'cc-menus)
 
+;;; arch-tag: f6b60933-91f0-4145-ab44-70ca6d1b919b
 ;;; cc-menus.el ends here
--- emacs24-24.3+1.orig/lisp/progmodes/cc-mode.el
+++ emacs24-24.3+1/lisp/progmodes/cc-mode.el
@@ -1,23 +1,24 @@
 ;;; cc-mode.el --- major mode for editing C and similar languages
 
-;; Copyright (C) 1985, 1987, 1992-2013 Free Software Foundation, Inc.
+;; Copyright (C) 1985, 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+;;   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+;;   2010, 2011   Free Software Foundation, Inc.
 
 ;; Authors:    2003- Alan Mackenzie
 ;;             1998- Martin Stjernholm
 ;;             1992-1999 Barry A. Warsaw
-;;             1987 Dave Detlefs
-;;             1987 Stewart Clamen
+;;             1987 Dave Detlefs and Stewart Clamen
 ;;             1985 Richard M. Stallman
 ;; Maintainer: bug-cc-mode@gnu.org
 ;; Created:    a long, long, time ago. adapted from the original c-mode.el
-;; Keywords:   c languages
+;; Keywords:   c languages oop
 
 ;; This file is part of GNU Emacs.
 
-;; GNU Emacs is free software: you can redistribute it and/or modify
+;; GNU Emacs is free software; you can redistribute it and/or modify
 ;; it under the terms of the GNU General Public License as published by
-;; the Free Software Foundation, either version 3 of the License, or
-;; (at your option) any later version.
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
 
 ;; GNU Emacs is distributed in the hope that it will be useful,
 ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -25,7 +26,8 @@
 ;; GNU General Public License for more details.
 
 ;; You should have received a copy of the GNU General Public License
-;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
+;; along with this program; see the file COPYING.  If not, see
+;; <http://www.gnu.org/licenses/>.
 
 ;;; Commentary:
 
@@ -73,10 +75,6 @@
 
 ;;; Code:
 
-;; For Emacs < 22.2.
-(eval-and-compile
-  (unless (fboundp 'declare-function) (defmacro declare-function (&rest r))))
-
 (eval-when-compile
   (let ((load-path
 	 (if (and (boundp 'byte-compile-dest-file)
@@ -99,6 +97,10 @@
 (cc-bytecomp-defvar adaptive-fill-first-line-regexp) ; Emacs
 (cc-bytecomp-defun set-keymap-parents)	; XEmacs
 (cc-bytecomp-defun run-mode-hooks)	; Emacs 21.1
+(cc-bytecomp-obsolete-fun make-local-hook) ; Marked obsolete in Emacs 21.1.
+(cc-bytecomp-defvar normal-erase-is-backspace)
+(cc-bytecomp-defvar file-local-variables-alist)
+(cc-bytecomp-defvar dir-local-variables-alist)
 
 ;; We set these variables during mode init, yet we don't require
 ;; font-lock.
@@ -111,14 +113,13 @@
 
 ;; Autoload directive for emacsen that doesn't have an older CC Mode
 ;; version in the dist.
-(autoload 'subword-mode "subword"
+(autoload 'c-subword-mode "cc-subword"
   "Mode enabling subword movement and editing keys." t)
 
 ;; Load cc-fonts first after font-lock is loaded, since it isn't
 ;; necessary until font locking is requested.
-; (eval-after-load "font-lock" ; 2006-07-09: font-lock is now preloaded.
-;   '
-(require 'cc-fonts) ;)
+(eval-after-load "font-lock"
+  '(require 'cc-fonts))
 
 
 ;; Other modes and packages which depend on CC Mode should do the
@@ -186,8 +187,7 @@ control).  See \"cc-mode.el\" for more i
 	    (run-hooks 'c-initialization-hook)
 	    ;; Fix obsolete variables.
 	    (if (boundp 'c-comment-continuation-stars)
-		(setq c-block-comment-prefix
-		      (symbol-value 'c-comment-continuation-stars)))
+		(setq c-block-comment-prefix c-comment-continuation-stars))
 	    (add-hook 'change-major-mode-hook 'c-leave-cc-mode-mode)
 	    (setq c-initialization-ok t))
 	;; Will try initialization hooks again if they failed.
@@ -208,12 +208,12 @@ control).  See \"cc-mode.el\" for more i
     ;; function is called from top-level forms that are evaluated
     ;; while cc-bytecomp is active when one does M-x eval-buffer.
     (cond
-     ;; Emacs
-     ((cc-bytecomp-fboundp 'set-keymap-parent)
-      (set-keymap-parent map c-mode-base-map))
      ;; XEmacs
      ((cc-bytecomp-fboundp 'set-keymap-parents)
       (set-keymap-parents map c-mode-base-map))
+     ;; Emacs
+     ((cc-bytecomp-fboundp 'set-keymap-parent)
+      (set-keymap-parent map c-mode-base-map))
      ;; incompatible
      (t (error "CC Mode is incompatible with this version of Emacs")))
     map))
@@ -266,9 +266,7 @@ control).  See \"cc-mode.el\" for more i
 			     'c-indent-new-comment-line
 			     c-mode-base-map global-map)
   (substitute-key-definition 'indent-for-tab-command
-			     ;; XXX Is this the right thing to do
-			     ;; here?
-			     'c-indent-line-or-region
+			     'c-indent-command
 			     c-mode-base-map global-map)
   (when (fboundp 'comment-indent-new-line)
     ;; indent-new-comment-line has changed name to
@@ -293,7 +291,7 @@ control).  See \"cc-mode.el\" for more i
   ;; replaces `fill-paragraph' and does the adaption before calling
   ;; `fill-paragraph-function', and we have to mask comments etc
   ;; before that.  Also, `c-fill-paragraph' chains on to
-  ;; `fill-paragraph' and the value on `fill-paragraph-function' to
+  ;; `fill-paragraph' and the value on `fill-parapgraph-function' to
   ;; do the actual filling work.
   (substitute-key-definition 'fill-paragraph 'c-fill-paragraph
 			     c-mode-base-map global-map)
@@ -372,7 +370,7 @@ control).  See \"cc-mode.el\" for more i
   ;; conflicts with OOBR
   ;;(define-key c-mode-base-map "\C-c\C-v"  'c-version)
   ;; (define-key c-mode-base-map "\C-c\C-y"  'c-toggle-hungry-state)  Commented out by ACM, 2005-11-22.
-  (define-key c-mode-base-map "\C-c\C-w" 'subword-mode)
+  (define-key c-mode-base-map "\C-c\C-w" 'c-subword-mode)
   )
 
 ;; We don't require the outline package, but we configure it a bit anyway.
@@ -464,6 +462,14 @@ preferably use the `c-mode-menu' languag
 (defvar c-maybe-stale-found-type nil)
 (make-variable-buffer-local 'c-maybe-stale-found-type)
 
+(defvar c-just-done-before-change nil)
+(make-variable-buffer-local 'c-just-done-before-change)
+;; This variable is set to t by `c-before-change' and to nil by
+;; `c-after-change'.  It is used to detect a spurious invocation of
+;; `before-change-functions' directly following on from a correct one.  This
+;; happens in some Emacsen, for example when `basic-save-buffer' does (insert
+;; ?\n) when `require-final-newline' is non-nil.
+
 (defun c-basic-common-init (mode default-style)
   "Do the necessary initialization for the syntax handling routines
 and the line breaking/filling code.  Intended to be used by other
@@ -481,10 +487,15 @@ that requires a literal mode spec at com
 
   ;; these variables should always be buffer local; they do not affect
   ;; indentation style.
+  (make-local-variable 'parse-sexp-ignore-comments)
+  (make-local-variable 'indent-line-function)
+  (make-local-variable 'indent-region-function)
+  (make-local-variable 'normal-auto-fill-function)
   (make-local-variable 'comment-start)
   (make-local-variable 'comment-end)
   (make-local-variable 'comment-start-skip)
-
+  (make-local-variable 'comment-multi-line)
+  (make-local-variable 'comment-line-break-function)
   (make-local-variable 'paragraph-start)
   (make-local-variable 'paragraph-separate)
   (make-local-variable 'paragraph-ignore-fill-prefix)
@@ -493,13 +504,12 @@ that requires a literal mode spec at com
   (make-local-variable 'fill-paragraph-handle-comment)
 
   ;; now set their values
-  (set (make-local-variable 'parse-sexp-ignore-comments) t)
-  (set (make-local-variable 'indent-line-function) 'c-indent-line)
-  (set (make-local-variable 'indent-region-function) 'c-indent-region)
-  (set (make-local-variable 'normal-auto-fill-function) 'c-do-auto-fill)
-  (set (make-local-variable 'comment-multi-line) t)
-  (set (make-local-variable 'comment-line-break-function)
-       'c-indent-new-comment-line)
+  (setq parse-sexp-ignore-comments t
+	indent-line-function 'c-indent-line
+	indent-region-function 'c-indent-region
+	normal-auto-fill-function 'c-do-auto-fill
+	comment-multi-line t
+	comment-line-break-function 'c-indent-new-comment-line)
 
   ;; For the benefit of adaptive file, which otherwise mis-fills.
   (setq fill-paragraph-handle-comment nil)
@@ -507,9 +517,10 @@ that requires a literal mode spec at com
   ;; Install `c-fill-paragraph' on `fill-paragraph-function' so that a
   ;; direct call to `fill-paragraph' behaves better.  This still
   ;; doesn't work with filladapt but it's better than nothing.
-  (set (make-local-variable 'fill-paragraph-function) 'c-fill-paragraph)
+  (make-local-variable 'fill-paragraph-function)
+  (setq fill-paragraph-function 'c-fill-paragraph)
 
-  ;; Initialize the cache of brace pairs, and opening braces/brackets/parens.
+  ;; Initialise the cache of brace pairs, and opening braces/brackets/parens.
   (c-state-cache-init)
 
   (when (or c-recognize-<>-arglists
@@ -525,27 +536,28 @@ that requires a literal mode spec at com
 
     ;; Emacs.
     (when (boundp 'parse-sexp-lookup-properties)
-      (set (make-local-variable 'parse-sexp-lookup-properties) t))
+      (make-local-variable 'parse-sexp-lookup-properties)
+      (setq parse-sexp-lookup-properties t))
 
     ;; Same as above for XEmacs.
     (when (boundp 'lookup-syntax-properties)
-      (set (make-local-variable 'lookup-syntax-properties) t)))
+      (make-local-variable 'lookup-syntax-properties)
+      (setq lookup-syntax-properties t)))
 
   ;; Use this in Emacs 21+ to avoid meddling with the rear-nonsticky
   ;; property on each character.
   (when (boundp 'text-property-default-nonsticky)
+    (make-local-variable 'text-property-default-nonsticky)
     (mapc (lambda (tprop)
 	    (unless (assq tprop text-property-default-nonsticky)
-	      (set (make-local-variable 'text-property-default-nonsticky)
-                   (cons `(,tprop . t) text-property-default-nonsticky))))
+	      (setq text-property-default-nonsticky
+		    (cons `(,tprop . t) text-property-default-nonsticky))))
 	  '(syntax-table category c-type)))
 
   ;; In Emacs 21 and later it's possible to turn off the ad-hoc
   ;; heuristic that open parens in column 0 are defun starters.  Since
   ;; we have c-state-cache, that heuristic isn't useful and only causes
   ;; trouble, so turn it off.
-;; 2006/12/17: This facility is somewhat confused, and doesn't really seem
-;; helpful.  Comment it out for now.
 ;;   (when (memq 'col-0-paren c-emacs-features)
 ;;     (make-local-variable 'open-paren-in-column-0-is-defun-start)
 ;;     (setq open-paren-in-column-0-is-defun-start nil))
@@ -573,7 +585,8 @@ that requires a literal mode spec at com
   (setq c-offsets-alist (copy-alist c-offsets-alist))
 
   ;; setup the comment indent variable in a Emacs version portable way
-  (set (make-local-variable 'comment-indent-function) 'c-comment-indent)
+  (make-local-variable 'comment-indent-function)
+  (setq comment-indent-function 'c-comment-indent)
 
 ;;   ;; Put submode indicators onto minor-mode-alist, but only once.
 ;;   (or (assq 'c-submode-indicators minor-mode-alist)
@@ -584,14 +597,17 @@ that requires a literal mode spec at com
 
   ;; Install the functions that ensure that various internal caches
   ;; don't become invalid due to buffer changes.
-  (when (featurep 'xemacs)
-    (make-local-hook 'before-change-functions)
-    (make-local-hook 'after-change-functions))
+  (or (memq 'add-hook-local c-emacs-features)
+      (make-local-hook 'before-change-functions))
   (add-hook 'before-change-functions 'c-before-change nil t)
+  (setq c-just-done-before-change nil)
+  (or (memq 'add-hook-local c-emacs-features)
+      (make-local-hook 'after-change-functions))
   (add-hook 'after-change-functions 'c-after-change nil t)
-  (set (make-local-variable 'font-lock-extend-after-change-region-function)
- 	'c-extend-after-change-region))	; Currently (2009-05) used by all
-			; languages with #define (C, C++,; ObjC), and by AWK.
+  (when (boundp 'font-lock-extend-after-change-region-function)
+    (set (make-local-variable 'font-lock-extend-after-change-region-function)
+	 'c-extend-after-change-region))) ; Currently (2009-05) used by all
+			; lanaguages with #define (C, C++,; ObjC), and by AWK.
 
 (defun c-setup-doc-comment-style ()
   "Initialize the variables that depend on the value of `c-doc-comment-style'."
@@ -601,15 +617,6 @@ that requires a literal mode spec at com
     (font-lock-mode 0)
     (font-lock-mode 1)))
 
-;; Buffer local variables defining the region to be fontified by a font lock
-;; after-change function.  They are set in c-after-change to
-;; after-change-functions' BEG and END, and may be modified by functions in
-;; `c-before-font-lock-functions'.
-(defvar c-new-BEG 0)
-(make-variable-buffer-local 'c-new-BEG)
-(defvar c-new-END 0)
-(make-variable-buffer-local 'c-new-END)
-
 (defun c-common-init (&optional mode)
   "Common initialization for all CC Mode modes.
 In addition to the work done by `c-basic-common-init' and
@@ -645,14 +652,15 @@ compatible with old code; callers should
 		       (- (point-max) (point-min))))
 	    c-before-font-lock-functions)))
 
-  (set (make-local-variable 'outline-regexp) "[^#\n\^M]")
-  (set (make-local-variable 'outline-level) 'c-outline-level)
+  (make-local-variable 'outline-regexp)
+  (make-local-variable 'outline-level)
+  (setq outline-regexp "[^#\n\^M]"
+	outline-level 'c-outline-level)
 
   (let ((rfn (assq mode c-require-final-newline)))
     (when rfn
-      (and (cdr rfn)
-	   (set (make-local-variable 'require-final-newline)
-                mode-require-final-newline)))))
+      (make-local-variable 'require-final-newline)
+      (setq require-final-newline (cdr rfn)))))
 
 (defun c-count-cfss (lv-alist)
   ;; LV-ALIST is an alist like `file-local-variables-alist'.  Count how many
@@ -664,7 +672,7 @@ compatible with old code; callers should
       (when (eq (car elt) 'c-file-style)
 	(setq cownt (1+ cownt))))
     cownt))
-
+							  
 (defun c-before-hack-hook ()
   "Set the CC Mode style and \"offsets\" when in the buffer's local variables.
 They are set only when, respectively, the pseudo variables
@@ -688,8 +696,7 @@ This function is called from the hook `b
 		   (c-count-cfss file-local-variables-alist))
 		  (cfs-in-dir-count (c-count-cfss dir-local-variables-alist)))
 	      (c-set-style stile
-			   (and (= cfs-in-file-and-dir-count cfs-in-dir-count)
-				'keep-defaults)))
+			   (= cfs-in-file-and-dir-count cfs-in-dir-count)))
 	  (c-set-style stile)))
       (when offsets
 	(mapc
@@ -761,7 +768,8 @@ Note that the style variables are always
     (when c-file-style
       (or (stringp c-file-style)
 	  (error "c-file-style is not a string"))
-      (c-set-style c-file-style))
+      (c-set-style c-file-style ;t
+		   ))
 
     (and c-file-offsets
 	 (mapc
@@ -804,6 +812,15 @@ Note that the style variables are always
 
 ;;; Change hooks, linking with Font Lock.
 
+;; Buffer local variables defining the region to be fontified by a font lock
+;; after-change function.  They are set in c-after-change to
+;; after-change-functions' BEG and END, and may be modified by functions in
+;; `c-before-font-lock-functions'.
+(defvar c-new-BEG 0)
+(make-variable-buffer-local 'c-new-BEG)
+(defvar c-new-END 0)
+(make-variable-buffer-local 'c-new-END)
+
 ;; Buffer local variables recording Beginning/End-of-Macro position before a
 ;; change, when a macro straddles, respectively, the BEG or END (or both) of
 ;; the change region.  Otherwise these have the values BEG/END.
@@ -891,8 +908,8 @@ Note that the style variables are always
 
 (defun c-neutralize-syntax-in-and-mark-CPP (begg endd old-len)
   ;; (i) Extend the font lock region to cover all changed preprocessor
-  ;; regions; it does this by setting the variables `c-new-BEG' and
-  ;; `c-new-END' to the new boundaries.
+  ;; regions; it sets the variables `c-new-BEG' and `c-new-END' to the new
+  ;; boundaries.
   ;;
   ;; (ii) "Neutralize" every preprocessor line wholly or partially in the
   ;; extended changed region.  "Restore" lines which were CPP lines before the
@@ -927,14 +944,18 @@ Note that the style variables are always
 		      c-new-BEG c-new-END old-len))
     (setq c-new-BEG (max (car new-bounds) (c-determine-limit 500 begg))
 	  c-new-END (min (cdr new-bounds) (c-determine-+ve-limit 500 endd)))
-    ;; Clear all old relevant properties.
+    ;; Clear 'syntax-table properties "punctuation":
     (c-clear-char-property-with-value c-new-BEG c-new-END 'syntax-table '(1))
-    (c-clear-char-property-with-value c-new-BEG c-new-END 'category 'c-cpp-delimiter)
-    ;; FIXME!!!  What about the "<" and ">" category properties?  2009-11-16
+
+    ;; CPP "comment" markers:
+    (if (memq 'category-properties c-emacs-features) ; GNU Emacs.
+	(c-clear-char-property-with-value
+	 c-new-BEG c-new-END 'category 'c-cpp-delimiter))
 
     ;; Add needed properties to each CPP construct in the region.
     (goto-char c-new-BEG)
-    (let ((pps-position c-new-BEG)  pps-state mbeg)
+    (skip-chars-backward " \t")
+    (let ((pps-position (point))  pps-state mbeg)
       (while (and (< (point) c-new-END)
 		  (search-forward-regexp c-anchored-cpp-prefix c-new-END t))
 	;; If we've found a "#" inside a string/comment, ignore it.
@@ -943,19 +964,18 @@ Note that the style variables are always
 	      pps-position (point))
 	(unless (or (nth 3 pps-state)	; in a string?
 		    (nth 4 pps-state))	; in a comment?
-	  (goto-char (match-beginning 0))
+	  (goto-char (match-beginning 1))
 	  (setq mbeg (point))
 	  (if (> (c-syntactic-end-of-macro) mbeg)
 	      (progn
-		(c-neutralize-CPP-line mbeg (point))
-		(c-set-cpp-delimiters mbeg (point))
-		;(setq pps-position (point))
-		)
+		(c-neutralize-CPP-line mbeg (point)) ; "punctuation" properties
+		(if (memq 'category-properties c-emacs-features) ; GNU Emacs.
+		    (c-set-cpp-delimiters mbeg (point)))) ; "comment" markers
 	    (forward-line))	      ; no infinite loop with, e.g., "#//"
 	  )))))
 
 (defun c-before-change (beg end)
-  ;; Function to be put on `before-change-functions'.  Primarily, this calls
+  ;; Function to be put in `before-change-functions'.  Primarily, this calls
   ;; the language dependent `c-get-state-before-change-functions'.  It is
   ;; otherwise used only to remove stale entries from the `c-found-types'
   ;; cache, and to record entries which a `c-after-change' function might
@@ -964,80 +984,84 @@ Note that the style variables are always
   ;; Note that this function must be FAST rather than accurate.  Note
   ;; also that it only has any effect when font locking is enabled.
   ;; We exploit this by checking for font-lock-*-face instead of doing
-  ;; rigorous syntactic analysis.
+  ;; rigourous syntactic analysis.
 
   ;; If either change boundary is wholly inside an identifier, delete
   ;; it/them from the cache.  Don't worry about being inside a string
   ;; or a comment - "wrongly" removing a symbol from `c-found-types'
   ;; isn't critical.
-  (setq c-maybe-stale-found-type nil)
-  (save-restriction
-    (save-match-data
-      (widen)
-      (save-excursion
-	;; Are we inserting/deleting stuff in the middle of an identifier?
-	(c-unfind-enclosing-token beg)
-	(c-unfind-enclosing-token end)
-	;; Are we coalescing two tokens together, e.g. "fo o" -> "foo"?
-	(when (< beg end)
-	  (c-unfind-coalesced-tokens beg end))
-	;; Are we (potentially) disrupting the syntactic context which
-	;; makes a type a type?  E.g. by inserting stuff after "foo" in
-	;; "foo bar;", or before "foo" in "typedef foo *bar;"?
-	;;
-	;; We search for appropriate c-type properties "near" the change.
-	;; First, find an appropriate boundary for this property search.
-	(let (lim
-	      type type-pos
-	      marked-id term-pos
-	      (end1
-	       (or (and (eq (get-text-property end 'face) 'font-lock-comment-face)
-			(previous-single-property-change end 'face))
-		   end)))
-	  (when (>= end1 beg) ; Don't hassle about changes entirely in comments.
-	    ;; Find a limit for the search for a `c-type' property
-	    (while
-		(and (/= (skip-chars-backward "^;{}") 0)
-		     (> (point) (point-min))
-		     (memq (c-get-char-property (1- (point)) 'face)
-			   '(font-lock-comment-face font-lock-string-face))))
-	    (setq lim (max (point-min) (1- (point))))
-
-	    ;; Look for the latest `c-type' property before end1
-	    (when (and (> end1 (point-min))
-		       (setq type-pos
-			     (if (get-text-property (1- end1) 'c-type)
-				 end1
-			       (previous-single-property-change end1 'c-type nil lim))))
-	      (setq type (get-text-property (max (1- type-pos) lim) 'c-type))
-
-	      (when (memq type '(c-decl-id-start c-decl-type-start))
-		;; Get the identifier, if any, that the property is on.
-		(goto-char (1- type-pos))
-		(setq marked-id
-		      (when (looking-at "\\(\\sw\\|\\s_\\)")
-			(c-beginning-of-current-token)
-			(buffer-substring-no-properties (point) type-pos)))
-
-		(goto-char end1)
-		(skip-chars-forward "^;{}") ; FIXME!!!  loop for comment, maybe
-		(setq lim (point))
-		(setq term-pos
-		      (or (next-single-property-change end 'c-type nil lim) lim))
-		(setq c-maybe-stale-found-type
-		      (list type marked-id
-			    type-pos term-pos
-			    (buffer-substring-no-properties type-pos term-pos)
-			    (buffer-substring-no-properties beg end)))))))
-
-	(if c-get-state-before-change-functions
-	    (mapc (lambda (fn)
-		    (funcall fn beg end))
-		  c-get-state-before-change-functions))
-	)))
-  ;; The following must be done here rather than in `c-after-change' because
-  ;; newly inserted parens would foul up the invalidation algorithm.
-  (c-invalidate-state-cache beg))
+  (unless c-just-done-before-change   ; guard against a spurious second
+					; invocation of before-change-functions.
+    (setq c-just-done-before-change t)
+    (setq c-maybe-stale-found-type nil)
+    (save-restriction
+      (save-match-data
+	(widen)
+	(save-excursion
+	  ;; Are we inserting/deleting stuff in the middle of an identifier?
+	  (c-unfind-enclosing-token beg)
+	  (c-unfind-enclosing-token end)
+	  ;; Are we coalescing two tokens together, e.g. "fo o" -> "foo"?
+	  (when (< beg end)
+	    (c-unfind-coalesced-tokens beg end))
+	  ;; Are we (potentially) disrupting the syntactic context which
+	  ;; makes a type a type?  E.g. by inserting stuff after "foo" in
+	  ;; "foo bar;", or before "foo" in "typedef foo *bar;"?
+	  ;;
+	  ;; We search for appropriate c-type properties "near" the change.
+	  ;; First, find an appropriate boundary for this property search.
+	  (let (lim
+		type type-pos
+		marked-id term-pos
+		(end1
+		 (or (and (eq (get-text-property end 'face) 'font-lock-comment-face)
+			  (previous-single-property-change end 'face))
+		     end)))
+	    (when (>= end1 beg) ; Don't hassle about changes entirely in comments.
+	      ;; Find a limit for the search for a `c-type' property
+	      (while
+		  (and (/= (skip-chars-backward "^;{}") 0)
+		       (> (point) (point-min))
+		       (memq (c-get-char-property (1- (point)) 'face)
+			     '(font-lock-comment-face font-lock-string-face))))
+	      (setq lim (max (point-min) (1- (point))))
+
+	      ;; Look for the latest `c-type' property before end1
+	      (when (and (> end1 (point-min))
+			 (setq type-pos
+			       (if (get-text-property (1- end1) 'c-type)
+				   end1
+				 (previous-single-property-change end1 'c-type nil lim))))
+		(setq type (get-text-property (max (1- type-pos) lim) 'c-type))
+
+		(when (memq type '(c-decl-id-start c-decl-type-start))
+		  ;; Get the identifier, if any, that the property is on.
+		  (goto-char (1- type-pos))
+		  (setq marked-id
+			(when (looking-at "\\(\\sw\\|\\s_\\)")
+			  (c-beginning-of-current-token)
+			  (buffer-substring-no-properties (point) type-pos)))
+
+		  (goto-char end1)
+		  (skip-chars-forward "^;{}") ; FIXME!!!  loop for comment, maybe
+		  (setq lim (point))
+		  (setq term-pos
+			(or (c-next-single-property-change end 'c-type nil lim) lim))
+		  (setq c-maybe-stale-found-type
+			(list type marked-id
+			      type-pos term-pos
+			      (buffer-substring-no-properties type-pos term-pos)
+			      (buffer-substring-no-properties beg end)))))))
+
+	  (if c-get-state-before-change-functions
+	      (let (open-paren-in-column-0-is-defun-start)
+		(mapc (lambda (fn)
+			(funcall fn beg end))
+		      c-get-state-before-change-functions)))
+	  )))
+    ;; The following must be done here rather than in `c-after-change' because
+    ;; newly inserted parens would foul up the invalidation algorithm.
+    (c-invalidate-state-cache beg)))
 
 (defvar c-in-after-change-fontification nil)
 (make-variable-buffer-local 'c-in-after-change-fontification)
@@ -1058,7 +1082,8 @@ Note that the style variables are always
   ;; This calls the language variable c-before-font-lock-functions, if non nil.
   ;; This typically sets `syntax-table' properties.
 
-  (c-save-buffer-state ()
+  (setq c-just-done-before-change nil)
+  (c-save-buffer-state (case-fold-search open-paren-in-column-0-is-defun-start)
     ;; When `combine-after-change-calls' is used we might get calls
     ;; with regions outside the current narrowing.  This has been
     ;; observed in Emacs 20.7.
@@ -1076,12 +1101,14 @@ Note that the style variables are always
 	    (setq beg end)))
 
 	;; C-y is capable of spuriously converting category properties
-	;; c-</>-as-paren-syntax into hard syntax-table properties.  Remove
-	;; these when it happens.
-	(c-clear-char-property-with-value beg end 'syntax-table
-					  c-<-as-paren-syntax)
-	(c-clear-char-property-with-value beg end 'syntax-table
-					  c->-as-paren-syntax)
+	;; c-</>-as-paren-syntax and c-cpp-delimiter into hard syntax-table
+	;; properties.  Remove these when it happens.
+	(when (memq 'category-properties c-emacs-features)
+	  (c-clear-char-property-with-value beg end 'syntax-table
+					    c-<-as-paren-syntax)
+	  (c-clear-char-property-with-value beg end 'syntax-table
+					    c->-as-paren-syntax)
+	  (c-clear-char-property-with-value beg end 'syntax-table nil))
 
 	(c-trim-found-types beg end old-len) ; maybe we don't need all of these.
 	(c-invalidate-sws-region-after beg end)
@@ -1109,7 +1136,7 @@ Note that the style variables are always
   ;; nested.
   ;;
   ;; This function is called indirectly from font locking stuff - either from
-  ;; c-after-change (to prepare for after-change font-locking) or from font
+  ;; c-after-change (to prepare for after-change font-lockng) or from font
   ;; lock context (etc.) fontification.
   (let ((lit-limits (c-literal-limits))
 	(new-pos pos)
@@ -1159,9 +1186,6 @@ Note that the style variables are always
   ;; `c-set-fl-decl-start' for the detailed functionality.
   (cons (c-set-fl-decl-start beg) end))
 
-(defvar c-standard-font-lock-fontify-region-function nil
-  "Standard value of `font-lock-fontify-region-function'")
-
 (defun c-font-lock-fontify-region (beg end &optional verbose)
   ;; Effectively advice around `font-lock-fontify-region' which extends the
   ;; region (BEG END), for example, to avoid context fontification chopping
@@ -1176,7 +1200,8 @@ Note that the style variables are always
   ;; 
   ;; Type a space in the first blank line, and the fontification of the next
   ;; line was fouled up by context fontification.
-  (let ((new-beg beg) (new-end end) new-region case-fold-search)
+  (let ((new-beg beg) (new-end end) new-region case-fold-search
+	open-paren-in-column-0-is-defun-start)
     (if c-in-after-change-fontification
 	(setq c-in-after-change-fontification nil)
       (save-restriction
@@ -1186,17 +1211,14 @@ Note that the style variables are always
 		  (setq new-region (funcall fn new-beg new-end))
 		  (setq new-beg (car new-region)  new-end (cdr new-region)))
 		c-before-context-fontification-functions))))
-    (funcall c-standard-font-lock-fontify-region-function
+    (funcall (default-value 'font-lock-fontify-region-function)
 	     new-beg new-end verbose)))
-
+  
 (defun c-after-font-lock-init ()
   ;; Put on `font-lock-mode-hook'.  This function ensures our after-change
-  ;; function will get executed before the font-lock one.  Amongst other
-  ;; things.
+  ;; function will get excuted before the font-lock one.
   (remove-hook 'after-change-functions 'c-after-change t)
-  (add-hook 'after-change-functions 'c-after-change nil t)
-  (setq c-standard-font-lock-fontify-region-function
-	(default-value 'font-lock-fontify-region-function)))
+  (add-hook 'after-change-functions 'c-after-change nil t))
 
 (defun c-font-lock-init ()
   "Set up the font-lock variables for using the font-lock support in CC Mode.
@@ -1204,7 +1226,8 @@ This does not load the font-lock package
 `c-basic-common-init' and after cc-fonts has been loaded.
 This function is called from `c-common-init', once per mode initialization."
 
-  (set (make-local-variable 'font-lock-defaults)
+  (make-local-variable 'font-lock-defaults)
+  (setq font-lock-defaults
 	`(,(if (c-major-mode-is 'awk-mode)
 	       ;; awk-mode currently has only one font lock level.
 	       'awk-font-lock-keywords
@@ -1220,23 +1243,35 @@ This function is called from `c-common-i
   (make-local-variable 'font-lock-fontify-region-function)
   (setq font-lock-fontify-region-function 'c-font-lock-fontify-region)
 
-  (if (featurep 'xemacs)
+  (or (memq 'add-hook-local c-emacs-features)
       (make-local-hook 'font-lock-mode-hook))
   (add-hook 'font-lock-mode-hook 'c-after-font-lock-init nil t))
 
+;; Emacs 22 and later.
 (defun c-extend-after-change-region (beg end old-len)
   "Extend the region to be fontified, if necessary."
-  ;; Note: the parameters are ignored here.  This somewhat indirect
-  ;; implementation exists because it is minimally different from the
-  ;; stand-alone CC Mode which, lacking
-  ;; font-lock-extend-after-change-region-function, is forced to use advice
-  ;; instead.
-  ;;
-  ;; Of the seven CC Mode languages, currently (2009-05) only C, C++, Objc
-  ;; (the languages with #define) and AWK Mode make non-null use of this
-  ;; function.
+  ;; Note: the parameters are ignored here.
+  ;;
+  ;; Of the seven CC Mode languages, currently (2009-05) only C, C++,
+  ;; Objc (the languages with #define) and AWK Mode make non-null use of
+  ;; this function.
   (cons c-new-BEG c-new-END))
 
+;; Emacs < 22 and XEmacs
+(defmacro c-advise-fl-for-region (function)
+  `(defadvice ,function (before get-awk-region activate)
+     ;; Make sure that any string/regexp is completely font-locked.
+     (when c-buffer-is-cc-mode
+       (save-excursion
+	 (ad-set-arg 1 c-new-END)   ; end
+	 (ad-set-arg 0 c-new-BEG)))))	; beg
+
+(unless (boundp 'font-lock-extend-after-change-region-function)
+  (c-advise-fl-for-region font-lock-after-change-function)
+  (c-advise-fl-for-region jit-lock-after-change)
+  (c-advise-fl-for-region lazy-lock-defer-rest-after-change)
+  (c-advise-fl-for-region lazy-lock-defer-line-after-change))
+
 
 ;; Support for C
 
@@ -1289,13 +1324,8 @@ This function is called from `c-common-i
 ;;;###autoload (add-to-list 'auto-mode-alist '("\\.y\\(acc\\)?\\'" . c-mode))
 ;;;###autoload (add-to-list 'auto-mode-alist '("\\.lex\\'" . c-mode))
 
-;; Preprocessed files generated by C and C++ compilers.
-;;;###autoload (add-to-list 'auto-mode-alist '("\\.i\\'" . c-mode))
-;;;###autoload (add-to-list 'auto-mode-alist '("\\.ii\\'" . c++-mode))
-
-
 ;;;###autoload
-(define-derived-mode c-mode prog-mode "C"
+(defun c-mode ()
   "Major mode for editing K&R and ANSI C code.
 To submit a problem report, enter `\\[c-submit-bug-report]' from a
 c-mode buffer.  This automatically sets up a mail buffer with version
@@ -1309,9 +1339,13 @@ initialization, then `c-mode-hook'.
 
 Key bindings:
 \\{c-mode-map}"
+  (interactive)
+  (kill-all-local-variables)
   (c-initialize-cc-mode t)
   (set-syntax-table c-mode-syntax-table)
-  (setq local-abbrev-table c-mode-abbrev-table
+  (setq major-mode 'c-mode
+	mode-name "C"
+	local-abbrev-table c-mode-abbrev-table
 	abbrev-mode t)
   (use-local-map c-mode-map)
   (c-init-language-vars-for 'c-mode)
@@ -1354,7 +1388,7 @@ Key bindings:
 		  (cons "C++" (c-lang-const c-mode-menu c++)))
 
 ;;;###autoload
-(define-derived-mode c++-mode prog-mode "C++"
+(defun c++-mode ()
   "Major mode for editing C++ code.
 To submit a problem report, enter `\\[c-submit-bug-report]' from a
 c++-mode buffer.  This automatically sets up a mail buffer with
@@ -1369,9 +1403,13 @@ initialization, then `c++-mode-hook'.
 
 Key bindings:
 \\{c++-mode-map}"
+  (interactive)
+  (kill-all-local-variables)
   (c-initialize-cc-mode t)
   (set-syntax-table c++-mode-syntax-table)
-  (setq local-abbrev-table c++-mode-abbrev-table
+  (setq major-mode 'c++-mode
+	mode-name "C++"
+	local-abbrev-table c++-mode-abbrev-table
 	abbrev-mode t)
   (use-local-map c++-mode-map)
   (c-init-language-vars-for 'c++-mode)
@@ -1412,7 +1450,7 @@ Key bindings:
 ;;;###autoload (add-to-list 'auto-mode-alist '("\\.m\\'" . objc-mode))
 
 ;;;###autoload
-(define-derived-mode objc-mode prog-mode "ObjC"
+(defun objc-mode ()
   "Major mode for editing Objective C code.
 To submit a problem report, enter `\\[c-submit-bug-report]' from an
 objc-mode buffer.  This automatically sets up a mail buffer with
@@ -1427,9 +1465,13 @@ initialization, then `objc-mode-hook'.
 
 Key bindings:
 \\{objc-mode-map}"
+  (interactive)
+  (kill-all-local-variables)
   (c-initialize-cc-mode t)
   (set-syntax-table objc-mode-syntax-table)
-  (setq local-abbrev-table objc-mode-abbrev-table
+  (setq major-mode 'objc-mode
+	mode-name "ObjC"
+	local-abbrev-table objc-mode-abbrev-table
 	abbrev-mode t)
   (use-local-map objc-mode-map)
   (c-init-language-vars-for 'objc-mode)
@@ -1479,7 +1521,7 @@ Key bindings:
 ;;;###autoload (add-to-list 'auto-mode-alist '("\\.java\\'" . java-mode))
 
 ;;;###autoload
-(define-derived-mode java-mode prog-mode "Java"
+(defun java-mode ()
   "Major mode for editing Java code.
 To submit a problem report, enter `\\[c-submit-bug-report]' from a
 java-mode buffer.  This automatically sets up a mail buffer with
@@ -1494,9 +1536,13 @@ initialization, then `java-mode-hook'.
 
 Key bindings:
 \\{java-mode-map}"
+  (interactive)
+  (kill-all-local-variables)
   (c-initialize-cc-mode t)
   (set-syntax-table java-mode-syntax-table)
-  (setq local-abbrev-table java-mode-abbrev-table
+  (setq major-mode 'java-mode
+ 	mode-name "Java"
+ 	local-abbrev-table java-mode-abbrev-table
 	abbrev-mode t)
   (use-local-map java-mode-map)
   (c-init-language-vars-for 'java-mode)
@@ -1534,7 +1580,7 @@ Key bindings:
 ;;;###autoload (add-to-list 'auto-mode-alist '("\\.idl\\'" . idl-mode))
 
 ;;;###autoload
-(define-derived-mode idl-mode prog-mode "IDL"
+(defun idl-mode ()
   "Major mode for editing CORBA's IDL, PSDL and CIDL code.
 To submit a problem report, enter `\\[c-submit-bug-report]' from an
 idl-mode buffer.  This automatically sets up a mail buffer with
@@ -1549,9 +1595,13 @@ initialization, then `idl-mode-hook'.
 
 Key bindings:
 \\{idl-mode-map}"
+  (interactive)
+  (kill-all-local-variables)
   (c-initialize-cc-mode t)
   (set-syntax-table idl-mode-syntax-table)
-  (setq local-abbrev-table idl-mode-abbrev-table)
+  (setq major-mode 'idl-mode
+	mode-name "IDL"
+	local-abbrev-table idl-mode-abbrev-table)
   (use-local-map idl-mode-map)
   (c-init-language-vars-for 'idl-mode)
   (c-common-init 'idl-mode)
@@ -1587,11 +1637,11 @@ Key bindings:
 (easy-menu-define c-pike-menu pike-mode-map "Pike Mode Commands"
 		  (cons "Pike" (c-lang-const c-mode-menu pike)))
 
-;;;###autoload (add-to-list 'auto-mode-alist '("\\.\\(u?lpc\\|pike\\|pmod\\(\\.in\\)?\\)\\'" . pike-mode))
+;;;###autoload (add-to-list 'auto-mode-alist '("\\.\\(u?lpc\\|pike\\|pmod\\(.in\\)?\\)\\'" . pike-mode))
 ;;;###autoload (add-to-list 'interpreter-mode-alist '("pike" . pike-mode))
 
 ;;;###autoload
-(define-derived-mode pike-mode prog-mode "Pike"
+(defun pike-mode ()
   "Major mode for editing Pike code.
 To submit a problem report, enter `\\[c-submit-bug-report]' from a
 pike-mode buffer.  This automatically sets up a mail buffer with
@@ -1606,9 +1656,13 @@ initialization, then `pike-mode-hook'.
 
 Key bindings:
 \\{pike-mode-map}"
+  (interactive)
+  (kill-all-local-variables)
   (c-initialize-cc-mode t)
   (set-syntax-table pike-mode-syntax-table)
-  (setq local-abbrev-table pike-mode-abbrev-table
+  (setq major-mode 'pike-mode
+ 	mode-name "Pike"
+ 	local-abbrev-table pike-mode-abbrev-table
 	abbrev-mode t)
   (use-local-map pike-mode-map)
   (c-init-language-vars-for 'pike-mode)
@@ -1657,12 +1711,7 @@ Key bindings:
 (easy-menu-define c-awk-menu awk-mode-map "AWK Mode Commands"
 		  (cons "AWK" (c-lang-const c-mode-menu awk)))
 
-;; (require 'cc-awk) brings these in.
-(defvar awk-mode-syntax-table)
-(declare-function c-awk-unstick-NL-prop "cc-awk" ())
-
-;;;###autoload
-(define-derived-mode awk-mode prog-mode "AWK"
+(defun awk-mode ()
   "Major mode for editing AWK code.
 To submit a problem report, enter `\\[c-submit-bug-report]' from an
 awk-mode buffer.  This automatically sets up a mail buffer with version
@@ -1676,14 +1725,14 @@ initialization, then `awk-mode-hook'.
 
 Key bindings:
 \\{awk-mode-map}"
-  ;; We need the next line to stop the macro defining
-  ;; `awk-mode-syntax-table'.  This would mask the real table which is
-  ;; declared in cc-awk.el and hasn't yet been loaded.
-  :syntax-table nil
+  (interactive)
   (require 'cc-awk)			; Added 2003/6/10.
+  (kill-all-local-variables)
   (c-initialize-cc-mode t)
   (set-syntax-table awk-mode-syntax-table)
-  (setq local-abbrev-table awk-mode-abbrev-table
+  (setq major-mode 'awk-mode
+	mode-name "AWK"
+	local-abbrev-table awk-mode-abbrev-table
 	abbrev-mode t)
   (use-local-map awk-mode-map)
   (c-init-language-vars-for 'awk-mode)
@@ -1706,9 +1755,7 @@ Key bindings:
   (message "Using CC Mode version %s" c-version)
   (c-keep-region-active))
 
-(define-obsolete-variable-alias 'c-prepare-bug-report-hooks
-  'c-prepare-bug-report-hook "24.3")
-(defvar c-prepare-bug-report-hook nil)
+(defvar c-prepare-bug-report-hooks nil)
 
 ;; Dynamic variables used by reporter.
 (defvar reporter-prompt-for-summary-p)
@@ -1765,7 +1812,7 @@ Key bindings:
 		     adaptive-fill-regexp)
 		   nil)))
 	(mapc (lambda (var) (unless (boundp var)
-                         (setq vars (delq var vars))))
+			      (setq vars (delq var vars))))
 	      '(signal-error-on-buffer-boundary
 		filladapt-mode
 		defun-prompt-regexp
@@ -1775,11 +1822,12 @@ Key bindings:
 		lookup-syntax-properties))
 	vars)
       (lambda ()
-	(run-hooks 'c-prepare-bug-report-hook)
+	(run-hooks 'c-prepare-bug-report-hooks)
 	(insert (format "Buffer Style: %s\nc-emacs-features: %s\n"
 			style c-features)))))))
 
 
 (cc-provide 'cc-mode)
 
+;;; arch-tag: 7825e5c4-fd09-439f-a04d-4c13208ba3d7
 ;;; cc-mode.el ends here
--- emacs24-24.3+1.orig/lisp/progmodes/cc-styles.el
+++ emacs24-24.3+1/lisp/progmodes/cc-styles.el
@@ -1,32 +1,34 @@
 ;;; cc-styles.el --- support for styles in CC Mode
 
-;; Copyright (C) 1985, 1987, 1992-2013 Free Software Foundation, Inc.
+;; Copyright (C) 1985, 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+;;   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+;;   2010, 2011   Free Software Foundation, Inc.
 
 ;; Authors:    2004- Alan Mackenzie
-;;             1998- Martin Stjernholm
-;;             1992-1999 Barry A. Warsaw
-;;             1987 Dave Detlefs
-;;             1987 Stewart Clamen
-;;             1985 Richard M. Stallman
+;;	       1998- Martin Stjernholm
+;;	       1992-1999 Barry A. Warsaw
+;;	       1987 Dave Detlefs and Stewart Clamen
+;;	       1985 Richard M. Stallman
 ;; Maintainer: bug-cc-mode@gnu.org
 ;; Created:    22-Apr-1997 (split from cc-mode.el)
-;; Keywords:   c languages
-;; Package:    cc-mode
+;; Version:    See cc-mode.el
+;; Keywords:   c languages oop
 
 ;; This file is part of GNU Emacs.
 
-;; GNU Emacs is free software: you can redistribute it and/or modify
+;; GNU Emacs is free software; you can redistribute it and/or modify
 ;; it under the terms of the GNU General Public License as published by
-;; the Free Software Foundation, either version 3 of the License, or
-;; (at your option) any later version.
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
 
 ;; GNU Emacs is distributed in the hope that it will be useful,
 ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
 ;; GNU General Public License for more details.
 
 ;; You should have received a copy of the GNU General Public License
-;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
+;; along with this program; see the file COPYING.  If not, see
+;; <http://www.gnu.org/licenses/>.
 
 ;;; Commentary:
 
@@ -48,13 +50,16 @@
 
 ;; Silence the compiler.
 (cc-bytecomp-defvar adaptive-fill-first-line-regexp) ; Emacs
+(cc-bytecomp-obsolete-fun make-local-hook) ; Marked obsolete in Emacs 21.1.
+					   ; Allegedly still required by
+					   ; XEmacs 21.4.n (2011-08).
 
 
 (defvar c-style-alist
   '(("gnu"
      (c-basic-offset . 2)
      (c-comment-only-line-offset . (0 . 0))
-     (c-hanging-braces-alist     . ((substatement-open before after)
+     (c-hanging-braces-alist	 . ((substatement-open before after)
 				    (arglist-cont-nonempty)))
      (c-offsets-alist . ((statement-block-intro . +)
 			 (knr-argdecl-intro . 5)
@@ -160,15 +165,15 @@
     ("ellemtel"
      (c-basic-offset . 3)
      (c-comment-only-line-offset . 0)
-     (c-hanging-braces-alist     . ((substatement-open before after)
+     (c-hanging-braces-alist	 . ((substatement-open before after)
 				    (arglist-cont-nonempty)))
-     (c-offsets-alist . ((topmost-intro        . 0)
-			 (substatement         . +)
+     (c-offsets-alist . ((topmost-intro	       . 0)
+			 (substatement	       . +)
 			 (substatement-open    . 0)
-                         (case-label           . +)
-                         (access-label         . -)
-			 (inclass              . +)
-			 (inline-open          . 0))))
+			 (case-label	       . +)
+			 (access-label	       . -)
+			 (inclass	       . +)
+			 (inline-open	       . 0))))
     ("linux"
      (c-basic-offset  . 8)
      (c-comment-only-line-offset . 0)
@@ -179,11 +184,11 @@
 				(arglist-cont-nonempty)))
      (c-cleanup-list . (brace-else-brace))
      (c-offsets-alist . ((statement-block-intro . +)
-			 (knr-argdecl-intro     . 0)
-			 (substatement-open     . 0)
-			 (substatement-label    . 0)
-			 (label                 . 0)
-			 (statement-cont        . +))))
+			 (knr-argdecl-intro	. 0)
+			 (substatement-open	. 0)
+			 (substatement-label	. 0)
+			 (label			. 0)
+			 (statement-cont	. +))))
 
     ("python"
      (indent-tabs-mode . t)
@@ -207,18 +212,18 @@
      (c-comment-only-line-offset . (0 . 0))
      ;; the following preserves Javadoc starter lines
      (c-offsets-alist . ((inline-open . 0)
-			 (topmost-intro-cont    . +)
+			 (topmost-intro-cont	. +)
 			 (statement-block-intro . +)
- 			 (knr-argdecl-intro     . 5)
-			 (substatement-open     . +)
-			 (substatement-label    . +)
- 			 (label                 . +)
- 			 (statement-case-open   . +)
- 			 (statement-cont        . +)
- 			 (arglist-intro  . c-lineup-arglist-intro-after-paren)
- 			 (arglist-close  . c-lineup-arglist)
- 			 (access-label   . 0)
-			 (inher-cont     . c-lineup-java-inher)
+			 (knr-argdecl-intro	. 5)
+			 (substatement-open	. +)
+			 (substatement-label	. +)
+			 (label			. +)
+			 (statement-case-open	. +)
+			 (statement-cont	. +)
+			 (arglist-intro	 . c-lineup-arglist-intro-after-paren)
+			 (arglist-close	 . c-lineup-arglist)
+			 (access-label	 . 0)
+			 (inher-cont	 . c-lineup-java-inher)
 			 (func-decl-cont . c-lineup-java-throws))))
 
     ;; awk style exists primarily for auto-newline settings.  Otherwise it's
@@ -351,9 +356,9 @@ might get set too.
 
 If DONT-OVERRIDE is neither nil nor t, style variables whose default values
 have been set (more precisely, whose default values are not the symbol
-`set-from-style') will not be changed.  This avoids overriding global settings
-done in your init file.  It is useful to call c-set-style from a mode hook
-in this way.
+`set-from-style') will not be changed.	This avoids overriding global settings
+done in ~/.emacs.  It is useful to call c-set-style from a mode hook in this
+way.
 
 If DONT-OVERRIDE is t, style variables that already have values (i.e., whose
 values are not the symbol `set-from-style') will not be overridden.  CC Mode
@@ -403,13 +408,13 @@ STYLE using `c-set-style' if the optiona
   (interactive
    (let ((stylename (completing-read "Style to add: " c-style-alist
 				     nil nil nil 'c-set-style-history))
-         (descr (eval-minibuffer "Style description: ")))
+	 (descr (eval-minibuffer "Style description: ")))
      (list stylename descr
 	   (y-or-n-p "Set the style too? "))))
   (setq style (downcase style))
   (let ((s (assoc style c-style-alist)))
     (if s
-        (setcdr s (copy-alist description)) ; replace
+	(setcdr s (copy-alist description)) ; replace
       (setq c-style-alist (cons (cons style description) c-style-alist))))
   (and set-p (c-set-style style)))
 
@@ -538,12 +543,13 @@ variables."
 
     (when (boundp 'adaptive-fill-first-line-regexp)
       ;; XEmacs adaptive fill mode doesn't have this.
-      (set (make-local-variable 'adaptive-fill-first-line-regexp)
-           (concat "\\`" comment-line-prefix
-                   ;; Maybe we should incorporate the old value here,
-                   ;; but then we have to do all sorts of kludges to
-                   ;; deal with the \` and \' it probably contains.
-                   "\\'"))))
+      (make-local-variable 'adaptive-fill-first-line-regexp)
+      (setq adaptive-fill-first-line-regexp
+	    (concat "\\`" comment-line-prefix
+		    ;; Maybe we should incorporate the old value here,
+		    ;; but then we have to do all sorts of kludges to
+		    ;; deal with the \` and \' it probably contains.
+		    "\\'"))))
 
   ;; Set up the values for use in strings.  These are the default
   ;; paragraph-start/separate values, enhanced to accept escaped EOLs as
@@ -577,7 +583,7 @@ CC Mode by making sure the proper entrie
   ;; only.
 
   ;; The default configuration already handles C++ comments, but we
-  ;; need to add handling of C block comments.  A new filladapt token
+  ;; need to add handling of C block comments.	A new filladapt token
   ;; `c-comment' is added for that.
   (let (p)
     (setq p filladapt-token-table)
@@ -645,8 +651,9 @@ any reason to call this function directl
     (mapc func varsyms)
     ;; Hooks must be handled specially
     (if this-buf-only-p
-	(if (featurep 'xemacs) (make-local-hook 'c-special-indent-hook))
-      (with-no-warnings (make-variable-buffer-local 'c-special-indent-hook))
+	(or (memq 'add-hook-local c-emacs-features)
+	   (make-local-hook 'c-special-indent-hook))
+      (make-variable-buffer-local 'c-special-indent-hook)
       (setq c-style-variables-are-local-p t))
     ))
 
@@ -663,4 +670,5 @@ DEFAULT-STYLE has the same format as `c-
 
 (cc-provide 'cc-styles)
 
+;;; arch-tag: c764f61a-96ba-484a-a68f-101c0e9d5d2c
 ;;; cc-styles.el ends here
--- /dev/null
+++ emacs24-24.3+1/lisp/progmodes/cc-subword.el
@@ -0,0 +1,326 @@
+;;; cc-subword.el --- Handling capitalized subwords in a nomenclature
+
+;; Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
+;; Free Software Foundation, Inc.
+
+;; Author: Masatake YAMATO
+
+;; This program is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+
+;; This program is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with this program; see the file COPYING.  If not, see
+;; <http://www.gnu.org/licenses/>.
+
+;;; Commentary:
+
+;; This package provides `subword' oriented commands and a minor mode
+;; (`c-subword-mode') that substitutes the common word handling
+;; functions with them.
+
+;; In spite of GNU Coding Standards, it is popular to name a symbol by
+;; mixing uppercase and lowercase letters, e.g. "GtkWidget",
+;; "EmacsFrameClass", "NSGraphicsContext", etc.  Here we call these
+;; mixed case symbols `nomenclatures'.  Also, each capitalized (or
+;; completely uppercase) part of a nomenclature is called a `subword'.
+;; Here are some examples:
+
+;;  Nomenclature           Subwords
+;;  ===========================================================
+;;  GtkWindow          =>  "Gtk" and "Window"
+;;  EmacsFrameClass    =>  "Emacs", "Frame" and "Class"
+;;  NSGraphicsContext  =>  "NS", "Graphics" and "Context"
+
+;; The subword oriented commands defined in this package recognize
+;; subwords in a nomenclature to move between them and to edit them as
+;; words.
+
+;; In the minor mode, all common key bindings for word oriented
+;; commands are overridden by the subword oriented commands:
+
+;; Key     Word oriented command      Subword oriented command
+;; ============================================================
+;; M-f     `forward-word'             `c-forward-subword'
+;; M-b     `backward-word'            `c-backward-subword'
+;; M-@     `mark-word'                `c-mark-subword'
+;; M-d     `kill-word'                `c-kill-subword'
+;; M-DEL   `backward-kill-word'       `c-backward-kill-subword'
+;; M-t     `transpose-words'          `c-transpose-subwords'
+;; M-c     `capitalize-word'          `c-capitalize-subword'
+;; M-u     `upcase-word'              `c-upcase-subword'
+;; M-l     `downcase-word'            `c-downcase-subword'
+;;
+;; Note: If you have changed the key bindings for the word oriented
+;; commands in your .emacs or a similar place, the keys you've changed
+;; to are also used for the corresponding subword oriented commands.
+
+;; To make the mode turn on automatically, put the following code in
+;; your .emacs:
+;;
+;; (add-hook 'c-mode-common-hook
+;; 	  (lambda () (c-subword-mode 1)))
+;;
+
+;; Acknowledgment:
+;; The regular expressions to detect subwords are mostly based on
+;; the old `c-forward-into-nomenclature' originally contributed by
+;; Terry_Glanfield dot Southern at rxuk dot xerox dot com.
+
+;; TODO: ispell-word and subword oriented C-w in isearch.
+
+;;; Code:
+
+(eval-when-compile
+  (let ((load-path
+	 (if (and (boundp 'byte-compile-dest-file)
+		  (stringp byte-compile-dest-file))
+	     (cons (file-name-directory byte-compile-dest-file) load-path)
+	   load-path)))
+    (load "cc-bytecomp" nil t)))
+
+(cc-require 'cc-defs)
+(cc-require 'cc-cmds)
+
+;; Don't complain about the `define-minor-mode' form if it isn't defined.
+(cc-bytecomp-defvar c-subword-mode)
+
+;; Autoload directives must be on the top level, so we construct an
+;; autoload form instead.
+;;;###autoload (autoload 'c-subword-mode "cc-subword" "Mode enabling subword movement and editing keys." t)
+
+(if (not (fboundp 'define-minor-mode))
+    (defun c-subword-mode ()
+      "(Missing) mode enabling subword movement and editing keys.
+This mode is not (yet) available in this version of (X)Emacs.  Sorry!  If
+you really want it, please send a request to <bug-gnu-emacs@gnu.org>,
+telling us which (X)Emacs version you're using."
+      (interactive)
+      (error
+       "c-subword-mode is not (yet) available in this version of (X)Emacs.  Sorry!"))
+
+  (defvar c-subword-mode-map
+    (let ((map (make-sparse-keymap)))
+      (substitute-key-definition 'forward-word
+				 'c-forward-subword
+				 map global-map)
+      (substitute-key-definition 'backward-word
+				 'c-backward-subword
+				 map global-map)
+      (substitute-key-definition 'mark-word
+				 'c-mark-subword
+				 map global-map)
+    
+      (substitute-key-definition 'kill-word
+				 'c-kill-subword
+				 map global-map)
+      (substitute-key-definition 'backward-kill-word
+				 'c-backward-kill-subword
+				 map global-map)
+    
+      (substitute-key-definition 'transpose-words
+				 'c-transpose-subwords
+				 map global-map)
+    
+      (substitute-key-definition 'capitalize-word
+				 'c-capitalize-subword
+				 map global-map)
+      (substitute-key-definition 'upcase-word
+				 'c-upcase-subword
+				 map global-map)
+      (substitute-key-definition 'downcase-word
+				 'c-downcase-subword
+				 map global-map)
+      map)
+    "Keymap used in command `c-subword-mode' minor mode.")
+
+  (define-minor-mode c-subword-mode
+    "Mode enabling subword movement and editing keys.
+In spite of GNU Coding Standards, it is popular to name a symbol by
+mixing uppercase and lowercase letters, e.g. \"GtkWidget\",
+\"EmacsFrameClass\", \"NSGraphicsContext\", etc.  Here we call these
+mixed case symbols `nomenclatures'. Also, each capitalized (or
+completely uppercase) part of a nomenclature is called a `subword'.
+Here are some examples:
+
+  Nomenclature           Subwords
+  ===========================================================
+  GtkWindow          =>  \"Gtk\" and \"Window\"
+  EmacsFrameClass    =>  \"Emacs\", \"Frame\" and \"Class\"
+  NSGraphicsContext  =>  \"NS\", \"Graphics\" and \"Context\"
+
+The subword oriented commands activated in this minor mode recognize
+subwords in a nomenclature to move between subwords and to edit them
+as words.
+
+\\{c-subword-mode-map}"
+    nil
+    nil
+    c-subword-mode-map
+    (c-update-modeline))
+
+  )
+
+(defun c-forward-subword (&optional arg)
+  "Do the same as `forward-word' but on subwords.
+See the command `c-subword-mode' for a description of subwords.
+Optional argument ARG is the same as for `forward-word'."
+  (interactive "p")
+  (unless arg (setq arg 1))
+  (c-keep-region-active)
+  (cond
+   ((< 0 arg)
+    (dotimes (i arg (point))
+      (c-forward-subword-internal)))
+   ((> 0 arg)
+    (dotimes (i (- arg) (point))
+      (c-backward-subword-internal)))
+   (t
+    (point))))
+
+(defun c-backward-subword (&optional arg)
+  "Do the same as `backward-word' but on subwords.
+See the command `c-subword-mode' for a description of subwords.
+Optional argument ARG is the same as for `backward-word'."
+  (interactive "p")
+  (c-forward-subword (- (or arg 1))))
+
+(defun c-mark-subword (arg)
+  "Do the same as `mark-word' but on subwords.
+See the command `c-subword-mode' for a description of subwords.
+Optional argument ARG is the same as for `mark-word'."
+  ;; This code is almost copied from `mark-word' in GNU Emacs.
+  (interactive "p")
+  (cond ((and (eq last-command this-command) (mark t))
+	 (set-mark
+	  (save-excursion
+	    (goto-char (mark))
+	    (c-forward-subword arg)
+	    (point))))
+	(t
+	 (push-mark
+	  (save-excursion
+	    (c-forward-subword arg)
+	    (point))
+	  nil t))))
+
+(defun c-kill-subword (arg)
+  "Do the same as `kill-word' but on subwords.
+See the command `c-subword-mode' for a description of subwords.
+Optional argument ARG is the same as for `kill-word'."
+  (interactive "p")
+  (kill-region (point) (c-forward-subword arg)))
+
+(defun c-backward-kill-subword (arg)
+  "Do the same as `backward-kill-word' but on subwords.
+See the command `c-subword-mode' for a description of subwords.
+Optional argument ARG is the same as for `backward-kill-word'."
+  (interactive "p")
+  (c-kill-subword (- arg)))
+
+(defun c-transpose-subwords (arg)
+  "Do the same as `transpose-words' but on subwords.
+See the command `c-subword-mode' for a description of subwords.
+Optional argument ARG is the same as for `transpose-words'."
+  (interactive "*p")
+  (transpose-subr 'c-forward-subword arg))
+
+
+
+(defun c-downcase-subword (arg)
+  "Do the same as `downcase-word' but on subwords.
+See the command `c-subword-mode' for a description of subwords.
+Optional argument ARG is the same as for `downcase-word'."
+  (interactive "p")
+  (let ((start (point)))
+    (downcase-region (point) (c-forward-subword arg))
+    (when (< arg 0) 
+      (goto-char start))))
+
+(defun c-upcase-subword (arg)
+  "Do the same as `upcase-word' but on subwords.
+See the command `c-subword-mode' for a description of subwords.
+Optional argument ARG is the same as for `upcase-word'."
+  (interactive "p")
+  (let ((start (point)))
+    (upcase-region (point) (c-forward-subword arg))
+    (when (< arg 0) 
+      (goto-char start))))
+
+(defun c-capitalize-subword (arg)
+  "Do the same as `capitalize-word' but on subwords.
+See the command `c-subword-mode' for a description of subwords.
+Optional argument ARG is the same as for `capitalize-word'."
+  (interactive "p")
+  (let ((count (abs arg))
+	(start (point))
+	(advance (if (< arg 0) nil t)))
+    (dotimes (i count)
+      (if advance
+	  (progn (re-search-forward
+		  (concat "[" c-alpha "]")
+		  nil t)
+		 (goto-char (match-beginning 0)))
+	(c-backward-subword))
+      (let* ((p (point))
+	     (pp (1+ p))
+	     (np (c-forward-subword)))
+	(upcase-region p pp)
+	(downcase-region pp np)
+	(goto-char (if advance np p))))
+    (unless advance
+      (goto-char start))))
+
+
+
+;;
+;; Internal functions
+;;
+(defun c-forward-subword-internal ()
+  (if (and
+       (save-excursion
+	 (let ((case-fold-search nil))
+	   (re-search-forward
+	    (concat "\\W*\\(\\([" c-upper "]*\\W?\\)[" c-lower c-digit "]*\\)")
+	    nil t)))
+       (> (match-end 0) (point))) ; So we don't get stuck at a
+				  ; "word-constituent" which isn't c-upper,
+				  ; c-lower or c-digit
+      (goto-char
+       (cond
+	((< 1 (- (match-end 2) (match-beginning 2)))
+	 (1- (match-end 2)))
+	(t
+	 (match-end 0))))
+    (forward-word 1)))
+
+
+(defun c-backward-subword-internal ()
+  (if (save-excursion
+	(let ((case-fold-search nil))
+	  (re-search-backward
+	   (concat
+	    "\\(\\(\\W\\|[" c-lower c-digit "]\\)\\([" c-upper "]+\\W*\\)"
+	    "\\|\\W\\w+\\)")
+	   nil t)))
+      (goto-char
+       (cond
+	((and (match-end 3)
+	      (< 1 (- (match-end 3) (match-beginning 3)))
+	      (not (eq (point) (match-end 3))))
+	 (1- (match-end 3)))
+	(t
+	 (1+ (match-beginning 0)))))
+    (backward-word 1)))
+
+
+(cc-provide 'cc-subword)
+
+;; arch-tag: 2be9d294-7f30-4626-95e6-9964bb93c7a3
+;;; cc-subword.el ends here
--- emacs24-24.3+1.orig/lisp/progmodes/cc-vars.el
+++ emacs24-24.3+1/lisp/progmodes/cc-vars.el
@@ -1,32 +1,34 @@
 ;;; cc-vars.el --- user customization variables for CC Mode
 
-;; Copyright (C) 1985, 1987, 1992-2013 Free Software Foundation, Inc.
+;; Copyright (C) 1985, 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+;;   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+;;   2010, 2011   Free Software Foundation, Inc.
 
 ;; Authors:    2002- Alan Mackenzie
-;;             1998- Martin Stjernholm
-;;             1992-1999 Barry A. Warsaw
-;;             1987 Dave Detlefs
-;;             1987 Stewart Clamen
-;;             1985 Richard M. Stallman
+;;	       1998- Martin Stjernholm
+;;	       1992-1999 Barry A. Warsaw
+;;	       1987 Dave Detlefs and Stewart Clamen
+;;	       1985 Richard M. Stallman
 ;; Maintainer: bug-cc-mode@gnu.org
 ;; Created:    22-Apr-1997 (split from cc-mode.el)
-;; Keywords:   c languages
-;; Package:    cc-mode
+;; Version:    See cc-mode.el
+;; Keywords:   c languages oop
 
 ;; This file is part of GNU Emacs.
 
-;; GNU Emacs is free software: you can redistribute it and/or modify
+;; GNU Emacs is free software; you can redistribute it and/or modify
 ;; it under the terms of the GNU General Public License as published by
-;; the Free Software Foundation, either version 3 of the License, or
-;; (at your option) any later version.
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
 
 ;; GNU Emacs is distributed in the hope that it will be useful,
 ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
 ;; GNU General Public License for more details.
 
 ;; You should have received a copy of the GNU General Public License
-;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
+;; along with this program; see the file COPYING.  If not, see
+;; <http://www.gnu.org/licenses/>.
 
 ;;; Commentary:
 
@@ -49,6 +51,16 @@
   (require 'custom)
   (require 'widget))
 
+(cc-eval-when-compile
+  ;; Need the function form of `backquote', which isn't standardized
+  ;; between Emacsen.  It's called `bq-process' in XEmacs, and
+  ;; `backquote-process' in Emacs.  `backquote-process' returns a
+  ;; slightly more convoluted form, so let `bq-process' be the norm.
+  (if (fboundp 'backquote-process)
+      (cc-bytecomp-defmacro bq-process (form)
+	`(cdr (backquote-process ,form)))))
+
+
 ;;; Helpers
 
 ;; This widget exists in newer versions of the Custom library
@@ -63,21 +75,21 @@ Useful as last item in a `choice' widget
 ;; The next defun will supersede c-const-symbol.
 (eval-and-compile
   (defun c-constant-symbol (sym len)
-  "Create an uneditable symbol for customization buffers.
+    "Create an uneditable symbol for customization buffers.
 SYM is the name of the symbol, LEN the length of the field (in
 characters) the symbol will be displayed in.  LEN must be big
 enough.
 
 This returns a (const ....) structure, suitable for embedding
 within a customization type."
-  (or (symbolp sym) (error "c-constant-symbol: %s is not a symbol" sym))
-  (let* ((name (symbol-name sym))
-	 (l (length name))
-	 (disp (concat name ":" (make-string (- len l 1) ?\ ))))
-    `(const
-      :size ,len
-      :format ,disp
-      :value ,sym))))
+    (or (symbolp sym) (error "c-constant-symbol: %s is not a symbol" sym))
+    (let* ((name (symbol-name sym))
+	   (l (length name))
+	   (disp (concat name ":" (make-string (- len l 1) ?\ ))))
+      `(const
+	:size ,len
+	:format ,disp
+	:value ,sym))))
 
 (define-widget 'c-const-symbol 'item
   "An uneditable lisp symbol.  This is obsolete -
@@ -171,7 +183,7 @@ value of NAME to be VAL, and call `custo
 do the rest of the work.
 
 STYLE stands for the choice where the value is taken from some
-style setting.  PREAMBLE is optionally prepended to FOO; that is,
+style setting.	PREAMBLE is optionally prepended to FOO; that is,
 if FOO contains :tag or :value, the respective two-element list
 component is ignored."
   (declare (debug (symbolp form stringp &rest)))
@@ -180,27 +192,27 @@ component is ignored."
 This is a style variable.  Apart from the valid values described
 above, it can be set to the symbol `set-from-style'.  In that case,
 it takes its value from the style system (see `c-default-style' and
-`c-style-alist') when a CC Mode buffer is initialized.  Otherwise,
+`c-style-alist') when a CC Mode buffer is initialized.	Otherwise,
 the value set here overrides the style system (there is a variable
 `c-old-style-variable-behavior' that changes this, though)."))
-         (typ (eval (plist-get args :type)))
-         (type (if (consp typ) typ (list typ)))
-         (head (car type))
-         (tail (cdr type))
-         (newt (append (unless (plist-get tail :tag)
-                         '(:tag "Override style settings"))
-                       (unless (plist-get tail :value)
-                         `(:value ,(eval val)))
-                       tail))
-         (aggregate `'(radio
-                       (const :tag "Use style settings" set-from-style)
-                       ,(cons head newt))))
+	 (typ (eval (c-safe (plist-get args :type))))
+	 (type (if (consp typ) typ (list typ)))
+	 (head (car type))
+	 (tail (cdr type))
+	 (newt (append (unless (c-safe (plist-get tail :tag))
+			 '(:tag "Override style settings"))
+		       (unless (c-safe (plist-get tail :value))
+			 `(:value ,val))
+		       tail))
+	 (aggregate `'(radio
+		       (const :tag "Use style settings" set-from-style)
+		       ,(cons head newt))))
     `(progn
        (c-set-stylevar-fallback ',name ,val)
        (custom-declare-variable
-        ',name ''set-from-style
-        ,expanded-doc
-        ,@(plist-put args :type aggregate)))))
+	',name ''set-from-style
+	,expanded-doc
+	,@(plist-put args :type aggregate)))))
 
 (defun c-valid-offset (offset)
   "Return non-nil if OFFSET is a valid offset for a syntactic symbol.
@@ -240,7 +252,7 @@ and the syntactic symbol is ignored.
 
 This variable is considered obsolete; it doesn't work well with lineup
 functions that return nil to support the feature of using lists on
-syntactic symbols in `c-offsets-alist'.  Please keep it set to nil."
+syntactic symbols in `c-offsets-alist'.	 Please keep it set to nil."
   :type 'boolean
   :group 'c)
 
@@ -267,19 +279,23 @@ Also used as the indentation step when `
 nil."
   :type 'integer
   :group 'c)
-;;;###autoload(put 'c-basic-offset 'safe-local-variable 'integerp)
 
 (defcustom c-tab-always-indent t
   "*Controls the operation of the TAB key.
-If t, hitting TAB always just indents the current line.  If nil, hitting
+If t, hitting TAB always just indents the current line.	 If nil, hitting
 TAB indents the current line if point is at the left margin or in the
-line's indentation, otherwise it calls `c-insert-tab-function' to
-insert a `real' tab character.  If some other value (neither nil nor t),
-then inserts a tab only within literals (comments and strings), but
-always reindents the line.
+line's indentation, otherwise it inserts a `real' tab character \(see
+note\).	 If some other value (not nil or t), then tab is inserted only
+within literals \(comments and strings), but the line is always
+reindented.
+
+Note: The value of `indent-tabs-mode' will determine whether a real
+tab character will be inserted, or the equivalent number of spaces.
+When inserting a tab, actually the function stored in the variable
+`c-insert-tab-function' is called.
 
-Note: the variable `c-comment-only-line-offset' also controls the
-indentation of lines containing only comments."
+Note: indentation of lines containing only comments is also controlled
+by the `c-comment-only-line-offset' variable."
   :type '(radio
 	  (const :tag "TAB key always indents, never inserts TAB" t)
 	  (const :tag "TAB key indents in left margin, otherwise inserts TAB" nil)
@@ -289,9 +305,7 @@ indentation of lines containing only com
 (defcustom c-insert-tab-function 'insert-tab
   "*Function used when inserting a tab for \\[c-indent-command].
 Only used when `c-tab-always-indent' indicates a `real' tab character
-should be inserted.  Value must be a function taking no arguments.
-The default, `insert-tab', inserts either a tab or the equivalent
-number of spaces depending on the value of `indent-tabs-mode'."
+should be inserted.  Value must be a function taking no arguments."
   :type 'function
   :group 'c)
 
@@ -309,7 +323,6 @@ e.g. `c-special-indent-hook'."
   :type 'boolean
   :group 'c)
 (make-variable-buffer-local 'c-syntactic-indentation)
-(put 'c-syntactic-indentation 'safe-local-variable 'booleanp)
 
 (defcustom c-syntactic-indentation-in-macros t
   "*Enable syntactic analysis inside macros.
@@ -328,7 +341,6 @@ countered easily by surrounding the stat
 better with the \"do { ... } while \(0)\" trick)."
   :type 'boolean
   :group 'c)
-(put 'c-syntactic-indentation-in-macros 'safe-local-variable 'booleanp)
 
 (defcustom c-defun-tactic 'go-outward
   "*Whether functions are recognized inside, e.g., a class.
@@ -339,7 +351,6 @@ Its value is one of:
  go-outward  -- Nested functions are also recognized.  Should a function
                 command hit the beginning/end of a nested scope, it will
                 carry on at the less nested level."
-  :version "24.1"
   :type '(radio
 	  (const :tag "Functions are at the top-level" t)
 	  (const :tag "Functions are also recognized inside declaration scopes" go-outward))
@@ -380,13 +391,13 @@ says what \\[indent-for-comment] should
 
 The recognized values for LINE-TYPE are:
 
- empty-line        -- The line is empty.
+ empty-line	   -- The line is empty.
  anchored-comment  -- The line contains a comment that starts in column 0.
- end-block         -- The line contains a solitary block closing brace.
- cpp-end-block     -- The line contains a preprocessor directive that
-                      closes a block, i.e. either \"#endif\" or \"#else\".
- other             -- The line does not match any other entry
-                      currently on the list.
+ end-block	   -- The line contains a solitary block closing brace.
+ cpp-end-block	   -- The line contains a preprocessor directive that
+		      closes a block, i.e. either \"#endif\" or \"#else\".
+ other		   -- The line does not match any other entry
+		      currently on the list.
 
 An INDENT-SPEC is a cons cell of the form:
 
@@ -396,22 +407,22 @@ ACTION says how \\[indent-for-comment] s
 VALUE is interpreted depending on ACTION.  ACTION can be any of the
 following:
 
- space   -- Put VALUE spaces between the end of the line and the start
-            of the comment.
- column  -- Start the comment at the column VALUE.  If the line is
-            longer than that, the comment is preceded by a single
-            space.  If VALUE is nil, `comment-column' is used.
- align   -- Align the comment with one on the previous line, if there
-            is any.  If the line is too long, the comment is preceded
-            by a single space.  If there isn't a comment start on the
-            previous line, the behavior is specified by VALUE, which
-            in turn is interpreted as an INDENT-SPEC.
+ space	 -- Put VALUE spaces between the end of the line and the start
+	    of the comment.
+ column	 -- Start the comment at the column VALUE.  If the line is
+	    longer than that, the comment is preceded by a single
+	    space.  If VALUE is nil, `comment-column' is used.
+ align	 -- Align the comment with one on the previous line, if there
+	    is any.  If the line is too long, the comment is preceded
+	    by a single space.	If there isn't a comment start on the
+	    previous line, the behavior is specified by VALUE, which
+	    in turn is interpreted as an INDENT-SPEC.
 
 If a LINE-TYPE is missing, then \\[indent-for-comment] indents the comment
 according to `comment-column'.
 
 Note that a non-nil value on `c-indent-comments-syntactically-p'
-overrides this variable, so empty lines are indented syntactically
+overrides this variable, so empty lines are indentented syntactically
 in that case, i.e. as if \\[c-indent-command] was used instead."
   :type
   (let ((space '(cons :tag "space"
@@ -446,7 +457,7 @@ in that case, i.e. as if \\[c-indent-com
 (defcustom-c-stylevar c-indent-comments-syntactically-p nil
   "*Specifies how \\[indent-for-comment] should handle comment-only lines.
 When this variable is non-nil, comment-only lines are indented
-according to syntactic analysis via `c-offsets-alist'.  Otherwise, the
+according to syntactic analysis via `c-offsets-alist'.	Otherwise, the
 comment is indented as if it was preceded by code.  Note that this
 variable does not affect how the normal line indentation treats
 comment-only lines."
@@ -454,24 +465,24 @@ comment-only lines."
   :group 'c)
 
 (make-obsolete-variable 'c-comment-continuation-stars
-			'c-block-comment-prefix "21.1")
+			'c-block-comment-prefix
+			nil)
 
 ;; Although c-comment-continuation-stars is obsolete, we look at it in
 ;; some places in CC Mode anyway, so make the compiler ignore it
 ;; during our compilation.
-;; [This is unclean; better to use `symbol-value'. --ttn]
-;;(cc-bytecomp-obsolete-var c-comment-continuation-stars)
-;;(cc-bytecomp-defvar c-comment-continuation-stars)
+(cc-bytecomp-obsolete-var c-comment-continuation-stars)
+(cc-bytecomp-defvar c-comment-continuation-stars)
 
 (defcustom-c-stylevar c-block-comment-prefix
   (if (boundp 'c-comment-continuation-stars)
-      (symbol-value 'c-comment-continuation-stars)
+      c-comment-continuation-stars
     "* ")
   "*Specifies the line prefix of continued C-style block comments.
 You should set this variable to the literal string that gets inserted
 at the front of continued block style comment lines.  This should
 either be the empty string, or some characters without preceding
-spaces.  To adjust the alignment under the comment starter, put an
+spaces.	 To adjust the alignment under the comment starter, put an
 appropriate value on the `c' syntactic symbol (see the
 `c-offsets-alist' variable).
 
@@ -491,15 +502,15 @@ This regexp is used to recognize the fil
 correct paragraph filling and other things.
 
 If this variable is a string, it will be used in all CC Mode major
-modes.  It can also be an association list, to associate specific
+modes.	It can also be an association list, to associate specific
 regexps to specific major modes.  The symbol for the major mode is
 looked up in the association list, and its value is used as the line
-prefix regexp.  If it's not found, then the symbol `other' is looked
+prefix regexp.	If it's not found, then the symbol `other' is looked
 up and its value is used instead.
 
 The regexp should match the prefix used in both C++ style line
 comments and C style block comments, but it does not need to match a
-block comment starter.  In other words, it should at least match
+block comment starter.	In other words, it should at least match
 \"//\" for line comments and the string in `c-block-comment-prefix',
 which is sometimes inserted by CC Mode inside block comments.  It
 should not match any surrounding whitespace.
@@ -512,7 +523,7 @@ you will need to do \\[c-setup-paragraph
 the other variables are updated with the new value.
 
 Note also that when CC Mode starts up, all variables are initialized
-before the mode hooks are run.  It's therefore necessary to make a
+before the mode hooks are run.	It's therefore necessary to make a
 call to `c-setup-paragraph-variables' explicitly if you change this
 variable in a mode hook."
   :type '(radio
@@ -522,19 +533,19 @@ variable in a mode hook."
 	   (set
 	    :inline t :format "%v"
 	    (cons :format "%v"
-		  (const :format "C     " c-mode) (regexp :format "%v"))
+		  (const :format "C	" c-mode) (regexp :format "%v"))
 	    (cons :format "%v"
-		  (const :format "C++   " c++-mode) (regexp :format "%v"))
+		  (const :format "C++	" c++-mode) (regexp :format "%v"))
 	    (cons :format "%v"
-		  (const :format "ObjC  " objc-mode) (regexp :format "%v"))
+		  (const :format "ObjC	" objc-mode) (regexp :format "%v"))
 	    (cons :format "%v"
-		  (const :format "Java  " java-mode) (regexp :format "%v"))
+		  (const :format "Java	" java-mode) (regexp :format "%v"))
 	    (cons :format "%v"
-		  (const :format "IDL   " idl-mode) (regexp :format "%v"))
+		  (const :format "IDL	" idl-mode) (regexp :format "%v"))
 	    (cons :format "%v"
-		  (const :format "Pike  " pike-mode) (regexp :format "%v"))
-            (cons :format "%v"
-		  (const :format "AWK   " awk-mode) (regexp :format "%v")))
+		  (const :format "Pike	" pike-mode) (regexp :format "%v"))
+	    (cons :format "%v"
+		  (const :format "AWK	" awk-mode) (regexp :format "%v")))
 	   (cons :format "    %v"
 		 (const :format "Other " other) (regexp :format "%v"))))
   :group 'c)
@@ -552,32 +563,32 @@ comment styles:
 
  javadoc -- Javadoc style for \"/** ... */\" comments (default in Java mode).
  autodoc -- Pike autodoc style for \"//! ...\" comments (default in Pike mode).
- gtkdoc  -- GtkDoc style for \"/** ... **/\" comments (default in C mode).
+ gtkdoc	 -- GtkDoc style for \"/** ... **/\" comments (default in C mode).
 
 The value may also be a list of doc comment styles, in which case all
 of them are recognized simultaneously (presumably with markup cues
 that don't conflict).
 
 The value may also be an association list to specify different doc
-comment styles for different languages.  The symbol for the major mode
+comment styles for different languages.	 The symbol for the major mode
 is then looked up in the alist, and the value of that element is
-interpreted as above if found.  If it isn't found then the symbol
+interpreted as above if found.	If it isn't found then the symbol
 `other' is looked up and its value is used instead.
 
 Note that CC Mode uses this variable to set other variables that
 handle fontification etc.  That's done at mode initialization or when
-you switch to a style which sets this variable.  Thus, if you change
+you switch to a style which sets this variable.	 Thus, if you change
 it in some other way, e.g. interactively in a CC Mode buffer, you will
 need to do \\[java-mode] (or whatever mode you're currently using) to
 reinitialize.
 
 Note also that when CC Mode starts up, the other variables are
-modified before the mode hooks are run.  If you change this variable
+modified before the mode hooks are run.	 If you change this variable
 in a mode hook, you have to call `c-setup-doc-comment-style'
 afterwards to redo that work."
   ;; Symbols other than those documented above may be used on this
-  ;; variable.  If a variable exists that has that name with
-  ;; "-font-lock-keywords" appended, its value is prepended to the
+  ;; variable.	If a variable exists that has that name with
+  ;; "-font-lock-keywords" appended, it's value is prepended to the
   ;; font lock keywords list.  If it's a function then it's called and
   ;; the result is prepended.
   :type '(radio
@@ -587,25 +598,25 @@ afterwards to redo that work."
 	   (set
 	    :inline t :format "%v"
 	    (cons :format "%v"
-		  (const :format "C     " c-mode)
+		  (const :format "C	" c-mode)
 		  (c-symbol-list :format "%v"))
 	    (cons :format "%v"
-		  (const :format "C++   " c++-mode)
+		  (const :format "C++	" c++-mode)
 		  (c-symbol-list :format "%v"))
 	    (cons :format "%v"
-		  (const :format "ObjC  " objc-mode)
+		  (const :format "ObjC	" objc-mode)
 		  (c-symbol-list :format "%v"))
 	    (cons :format "%v"
-		  (const :format "Java  " java-mode)
+		  (const :format "Java	" java-mode)
 		  (c-symbol-list :format "%v"))
 	    (cons :format "%v"
-		  (const :format "IDL   " idl-mode)
+		  (const :format "IDL	" idl-mode)
 		  (c-symbol-list :format "%v"))
 	    (cons :format "%v"
-		  (const :format "Pike  " pike-mode)
+		  (const :format "Pike	" pike-mode)
 		  (c-symbol-list :format "%v"))
 	    (cons :format "%v"
-		  (const :format "AWK   " awk-mode)
+		  (const :format "AWK	" awk-mode)
 		  (c-symbol-list :format "%v"))
 	    (cons :format "%v"
 		  (const :format "Other " other)
@@ -615,15 +626,15 @@ afterwards to redo that work."
 (defcustom c-ignore-auto-fill '(string cpp code)
   "*List of contexts in which automatic filling never occurs.
 If Auto Fill mode is active, it will be temporarily disabled if point
-is in any context on this list.  It's e.g. useful to enable Auto Fill
+is in any context on this list.	 It's e.g. useful to enable Auto Fill
 in comments only, but not in strings or normal code.  The valid
 contexts are:
 
- string  -- inside a string or character literal
- c       -- inside a C style block comment
- c++     -- inside a C++ style line comment
- cpp     -- inside a preprocessor directive
- code    -- anywhere else, i.e. in normal code"
+ string	 -- inside a string or character literal
+ c	 -- inside a C style block comment
+ c++	 -- inside a C++ style line comment
+ cpp	 -- inside a preprocessor directive
+ code	 -- anywhere else, i.e. in normal code"
   :type '(set
 	  (const :tag "String literals" string)
 	  (const :tag "C style block comments" c)
@@ -639,60 +650,60 @@ is turned on, as evidenced by the `/la'
 name:
 
  brace-else-brace    -- Clean up \"} else {\" constructs by placing
-                        entire construct on a single line.  This clean
-                        up only takes place when there is nothing but
-                        white space between the braces and the `else'.
-                        Clean up occurs when the open brace after the
-                        `else' is typed.
+			entire construct on a single line.  This clean
+			up only takes place when there is nothing but
+			white space between the braces and the `else'.
+			Clean up occurs when the open brace after the
+			`else' is typed.
  brace-elseif-brace  -- Similar to brace-else-brace, but clean up
-                        \"} else if (...) {\" constructs.  Clean up
-                        occurs after the open parenthesis and the open
-                        brace.
+			\"} else if (...) {\" constructs.  Clean up
+			occurs after the open parenthesis and the open
+			brace.
  brace-catch-brace   -- Similar to brace-elseif-brace, but clean up
-                        \"} catch (...) {\" constructs.
+			\"} catch (...) {\" constructs.
  empty-defun-braces  -- Clean up empty defun braces by placing the
-                        braces on the same line.  Clean up occurs when
-                        the defun closing brace is typed.
+			braces on the same line.  Clean up occurs when
+			the defun closing brace is typed.
  one-liner-defun     -- If the code inside a function body can fit in
-                        a single line, then remove any newlines
-                        between that line and the defun braces so that
-                        the whole body becomes a single line.
-                        `c-max-one-liner-length' gives the maximum
-                        length allowed for the resulting line.  Clean
-                        up occurs when the closing brace is typed.
+			a single line, then remove any newlines
+			between that line and the defun braces so that
+			the whole body becomes a single line.
+			`c-max-one-liner-length' gives the maximum
+			length allowed for the resulting line.	Clean
+			up occurs when the closing brace is typed.
  defun-close-semi    -- Clean up the terminating semi-colon on defuns
-                        by placing the semi-colon on the same line as
-                        the closing brace.  Clean up occurs when the
-                        semi-colon is typed.
+			by placing the semi-colon on the same line as
+			the closing brace.  Clean up occurs when the
+			semi-colon is typed.
  list-close-comma    -- Clean up commas following braces in array
-                        and aggregate initializers.  Clean up occurs
-                        when the comma is typed.
- scope-operator      -- Clean up double colons which may designate
-                        a C++ scope operator split across multiple
-                        lines.  Note that certain C++ constructs can
-                        generate ambiguous situations.  This clean up
-                        only takes place when there is nothing but
-                        whitespace between colons.  Clean up occurs
-                        when the second colon is typed.
+			and aggregate initializers.  Clean up occurs
+			when the comma is typed.
+ scope-operator	     -- Clean up double colons which may designate
+			a C++ scope operator split across multiple
+			lines.	Note that certain C++ constructs can
+			generate ambiguous situations.	This clean up
+			only takes place when there is nothing but
+			whitespace between colons.  Clean up occurs
+			when the second colon is typed.
 
 The following clean ups always take place when they are on this list,
 regardless of the auto-newline feature, since they typically don't
 involve auto-newline inserted newlines:
 
  space-before-funcall -- Insert exactly one space before the opening
-                        parenthesis of a function call.  Clean up
-                        occurs when the opening parenthesis is typed.
+			parenthesis of a function call.	 Clean up
+			occurs when the opening parenthesis is typed.
  compact-empty-funcall -- Clean up any space before the function call
-                        opening parenthesis if and only if the
-                        argument list is empty.  This is typically
-                        useful together with `space-before-funcall' to
-                        get the style \"foo (bar)\" and \"foo()\".
-                        Clean up occurs when the closing parenthesis
-                        is typed.
+			opening parenthesis if and only if the
+			argument list is empty.	 This is typically
+			useful together with `space-before-funcall' to
+			get the style \"foo (bar)\" and \"foo()\".
+			Clean up occurs when the closing parenthesis
+			is typed.
  comment-close-slash -- When a slash is typed after the comment prefix
-                        on a bare line in a c-style comment, the comment
-                        is closed by cleaning up preceding space and
-                        inserting a star if needed."
+			on a bare line in a c-style comment, the comment
+			is closed by cleaning up preceding space and
+			inserting a star if needed."
   :type '(set
 	  (const :tag "Put \"} else {\" on one line (brace-else-brace)"
 		 brace-else-brace)
@@ -750,7 +761,7 @@ opening and closing braces, respectively
 in Java.
 
 ACTION can be either a function symbol or a list containing any
-combination of the symbols `before' or `after'.  If the list is empty,
+combination of the symbols `before' or `after'.	 If the list is empty,
 no newlines are inserted either before or after the brace.
 
 When ACTION is a function symbol, the function is called with a two
@@ -824,8 +835,8 @@ string in the mode line), and a semicolo
 `c-electric-semi&comma').  Each function in this list is called with
 no arguments, and should return one of the following values:
 
-  nil             -- no determination made, continue checking
-  'stop           -- do not insert a newline, and stop checking
+  nil		  -- no determination made, continue checking
+  'stop		  -- do not insert a newline, and stop checking
   (anything else) -- insert a newline, and stop checking
 
 If every function in the list is called with no determination made,
@@ -841,7 +852,6 @@ macro exceeds this column then the next
 used as alignment column instead.  See also `c-backslash-max-column'."
   :type 'integer
   :group 'c)
-;;;###autoload(put 'c-backslash-column 'safe-local-variable 'integerp)
 
 (defcustom-c-stylevar c-backslash-max-column 72
   "*Maximum alignment column for line continuation backslashes.
@@ -875,7 +885,7 @@ space."
 (defcustom c-require-final-newline
   ;; C and C++ mandate that all nonempty files should end with a
   ;; newline.  Objective-C refers to C for all things it doesn't
-  ;; specify, so the same holds there.  The other languages do not
+  ;; specify, so the same holds there.	The other languages do not
   ;; require it (at least not explicitly in a normative text).
   '((c-mode    . t)
     (c++-mode  . t)
@@ -883,14 +893,14 @@ space."
   "*Controls whether a final newline is ensured when the file is saved.
 The value is an association list that for each language mode specifies
 the value to give to `require-final-newline' at mode initialization;
-see that variable for details about the value.  If a language isn't
+see that variable for details about the value.	If a language isn't
 present on the association list, CC Mode won't touch
 `require-final-newline' in buffers for that language."
   :type `(set (cons :format "%v"
-		    (const :format "C     " c-mode)
+		    (const :format "C	  " c-mode)
 		    (symbol :format "%v" :value ,require-final-newline))
 	      (cons :format "%v"
-		    (const :format "C++   " c++-mode)
+		    (const :format "C++	  " c++-mode)
 		    (symbol :format "%v" :value ,require-final-newline))
 	      (cons :format "%v"
 		    (const :format "ObjC  " objc-mode)
@@ -899,13 +909,13 @@ present on the association list, CC Mode
 		    (const :format "Java  " java-mode)
 		    (symbol :format "%v" :value ,require-final-newline))
 	      (cons :format "%v"
-		    (const :format "IDL   " idl-mode)
+		    (const :format "IDL	  " idl-mode)
 		    (symbol :format "%v" :value ,require-final-newline))
 	      (cons :format "%v"
 		    (const :format "Pike  " pike-mode)
 		    (symbol :format "%v" :value ,require-final-newline))
 	      (cons :format "%v"
-		    (const :format "AWK   " awk-mode)
+		    (const :format "AWK	  " awk-mode)
 		    (symbol :format "%v" :value ,require-final-newline)))
   :group 'c)
 
@@ -917,8 +927,8 @@ Only currently supported behavior is `al
 
 (defcustom c-special-indent-hook nil
   "*Hook for user defined special indentation adjustments.
-This hook gets called after each line is indented by the mode.  It is only
-called if `c-syntactic-indentation' is non-nil."
+This hook gets called after each line is indented by the mode.	It is only
+called when `c-syntactic-indentation' is non-nil."
   :type 'hook
   :group 'c)
 
@@ -926,7 +936,7 @@ called if `c-syntactic-indentation' is n
   "*Minimum indentation for lines inside code blocks.
 This variable typically only affects code using the `gnu' style, which
 mandates a minimum of one space in front of every line inside code
-blocks.  Specifically, the function `c-gnu-impose-minimum' on your
+blocks.	 Specifically, the function `c-gnu-impose-minimum' on your
 `c-special-indent-hook' is what enforces this."
   :type 'integer
   :group 'c)
@@ -954,7 +964,7 @@ this is `c-lineup-ObjC-method-call', whi
 	[foo blahBlahBlah: fred
 	     thisIsTooDamnLong: barney
 
-This behavior can be overridden by customizing the indentation of
+This behaviour can be overridden by customizing the indentation of
 `objc-method-call-cont' in the \"objc\" style."
   :type 'integer
   :group 'c)
@@ -964,7 +974,7 @@ This behavior can be overridden by custo
 
     [aaaaaaaaa
     |<-x->|bbbbbbb:  cccccc
-             ddddd: eeee];"
+	     ddddd: eeee];"
   :type 'integer
   :group 'c)
 
@@ -973,8 +983,8 @@ This behavior can be overridden by custo
 
     [aaaaaaa bbbbbbbbbb:
 	     |<-x->|cccccccc
-                    ddd: eeee
-                   ffff: ggg];"
+		    ddd: eeee
+		   ffff: ggg];"
   :type 'integer
   :group 'c)
 
@@ -990,7 +1000,7 @@ When the value is a string, all CC Mode
 style by default.
 
 When the value is an alist, the major mode symbol is looked up in it
-and the associated style is installed.  If the major mode is not
+and the associated style is installed.	If the major mode is not
 listed in the alist, then the symbol `other' is looked up in it, and
 if found, the style in that entry is used.  If `other' is not found in
 the alist, then \"gnu\" style is used.
@@ -1002,19 +1012,19 @@ can always override the use of `c-defaul
 	  (string :tag "Style in all modes")
 	  (set :tag "Mode-specific styles"
 	    (cons :format "%v"
-		  (const :format "C     " c-mode) (string :format "%v"))
+		  (const :format "C	" c-mode) (string :format "%v"))
 	    (cons :format "%v"
-		  (const :format "C++   " c++-mode) (string :format "%v"))
+		  (const :format "C++	" c++-mode) (string :format "%v"))
 	    (cons :format "%v"
-		  (const :format "ObjC  " objc-mode) (string :format "%v"))
+		  (const :format "ObjC	" objc-mode) (string :format "%v"))
 	    (cons :format "%v"
-		  (const :format "Java  " java-mode) (string :format "%v"))
+		  (const :format "Java	" java-mode) (string :format "%v"))
 	    (cons :format "%v"
-		  (const :format "IDL   " idl-mode) (string :format "%v"))
+		  (const :format "IDL	" idl-mode) (string :format "%v"))
 	    (cons :format "%v"
-		  (const :format "Pike  " pike-mode) (string :format "%v"))
+		  (const :format "Pike	" pike-mode) (string :format "%v"))
 	    (cons :format "%v"
-		  (const :format "AWK   " awk-mode) (string :format "%v"))
+		  (const :format "AWK	" awk-mode) (string :format "%v"))
 	    (cons :format "%v"
 		  (const :format "Other " other) (string :format "%v"))))
   :group 'c)
@@ -1027,37 +1037,37 @@ can always override the use of `c-defaul
 ;; statement-block-intro, defun-block-intro or substatement syntax
 ;; symbol and continue searching.
 (c-set-stylevar-fallback 'c-offsets-alist
-     '((string                . c-lineup-dont-change)
+     '((string		      . c-lineup-dont-change)
        ;; Anchor pos: Beg of previous line.
-       (c                     . c-lineup-C-comments)
+       (c		      . c-lineup-C-comments)
        ;; Anchor pos: Beg of the comment.
-       (defun-open            . 0)
+       (defun-open	      . 0)
        ;; Anchor pos: When inside a class: Boi at the func decl start.
        ;; When at top level: Bol at the func decl start.  When inside
        ;; a code block (only possible in Pike): At the func decl
        ;; start(*).
-       (defun-close           . 0)
+       (defun-close	      . 0)
        ;; Anchor pos: At the defun block open if it's at boi,
        ;; otherwise boi at the func decl start.
        (defun-block-intro     . +)
        ;; Anchor pos: At the block open(*).
-       (class-open            . 0)
+       (class-open	      . 0)
        ;; Anchor pos: Boi at the class decl start.
-       (class-close           . 0)
+       (class-close	      . 0)
        ;; Anchor pos: Boi at the class decl start.
-       (inline-open           . +)
+       (inline-open	      . +)
        ;; Anchor pos: None for functions (inclass got the relpos
        ;; then), boi at the lambda start for lambdas.
-       (inline-close          . 0)
+       (inline-close	      . 0)
        ;; Anchor pos: Inexpr functions: At the lambda block open if
        ;; it's at boi, else at the statement(*) at boi of the start of
-       ;; the lambda construct.  Otherwise: At the inline block open
+       ;; the lambda construct.	 Otherwise: At the inline block open
        ;; if it's at boi, otherwise boi at the func decl start.
-       (func-decl-cont        . +)
+       (func-decl-cont	      . +)
        ;; Anchor pos: Boi at the func decl start.
        (knr-argdecl-intro     . +)
        ;; Anchor pos: Boi at the topmost intro line.
-       (knr-argdecl           . 0)
+       (knr-argdecl	      . 0)
        ;; Anchor pos: At the beginning of the first K&R argdecl.
        (topmost-intro	      . 0)
        ;; Anchor pos: Bol at the last line of previous construct.
@@ -1071,23 +1081,23 @@ can always override the use of `c-defaul
        ;; Anchor pos: Boi at the func decl arglist open.
        (member-init-cont      . c-lineup-multi-inher)
        ;; Anchor pos: Beg of the first member init.
-       (inher-intro           . +)
+       (inher-intro	      . +)
        ;; Anchor pos: Boi at the class decl start.
-       (inher-cont            . c-lineup-multi-inher)
+       (inher-cont	      . c-lineup-multi-inher)
        ;; Anchor pos: Java: At the implements/extends keyword start.
        ;; Otherwise: At the inher start colon, or boi at the class
        ;; decl start if the first inherit clause hangs and it's not a
        ;; func-local inherit clause (when does that occur?).
-       (block-open            . 0)
+       (block-open	      . 0)
        ;; Anchor pos: Inexpr statement: At the statement(*) at boi of
        ;; the start of the inexpr construct.  Otherwise: None.
-       (block-close           . 0)
+       (block-close	      . 0)
        ;; Anchor pos: Inexpr statement: At the inexpr block open if
        ;; it's at boi, else at the statement(*) at boi of the start of
-       ;; the inexpr construct.  Block hanging on a case/default
+       ;; the inexpr construct.	 Block hanging on a case/default
        ;; label: At the closest preceding label that starts at boi.
        ;; Otherwise: At the block open(*).
-       (brace-list-open       . 0)
+       (brace-list-open	      . 0)
        ;; Anchor pos: Boi at the brace list decl start, but a starting
        ;; "typedef" token is ignored.
        (brace-list-close      . 0)
@@ -1100,11 +1110,11 @@ can always override the use of `c-defaul
        ;; token.
        (brace-entry-open      . 0)
        ;; Anchor pos: Same as brace-list-entry.
-       (statement             . 0)
+       (statement	      . 0)
        ;; Anchor pos: After a `;' in the condition clause of a for
        ;; statement: At the first token after the starting paren.
        ;; Otherwise: At the preceding statement(*).
-       (statement-cont        . +)
+       (statement-cont	      . +)
        ;; Anchor pos: After the first token in the condition clause of
        ;; a for statement: At the first token after the starting
        ;; paren.  Otherwise: At the containing statement(*).
@@ -1119,83 +1129,83 @@ can always override the use of `c-defaul
        ;; Anchor pos: At the case/default label(*).
        (statement-case-open   . 0)
        ;; Anchor pos: At the case/default label(*).
-       (substatement          . +)
+       (substatement	      . +)
        ;; Anchor pos: At the containing statement(*).
        (substatement-open     . +)
        ;; Anchor pos: At the containing statement(*).
        (substatement-label    . 2)
        ;; Anchor pos: At the containing statement(*).
-       (case-label            . 0)
+       (case-label	      . 0)
        ;; Anchor pos: At the start of the switch block(*).
-       (access-label          . -)
+       (access-label	      . -)
        ;; Anchor pos: Same as inclass.
-       (label                 . 2)
+       (label		      . 2)
        ;; Anchor pos: At the start of the containing block(*).
        (do-while-closure      . 0)
        ;; Anchor pos: At the corresponding while statement(*).
-       (else-clause           . 0)
+       (else-clause	      . 0)
        ;; Anchor pos: At the corresponding if statement(*).
-       (catch-clause          . 0)
+       (catch-clause	      . 0)
        ;; Anchor pos: At the previous try or catch statement clause(*).
-       (comment-intro         . (c-lineup-knr-region-comment c-lineup-comment))
+       (comment-intro	      . (c-lineup-knr-region-comment c-lineup-comment))
        ;; Anchor pos: None.
-       (arglist-intro         . +)
+       (arglist-intro	      . +)
        ;; Anchor pos: At the containing statement(*).
        ;; 2nd pos: At the open paren.
-       (arglist-cont          . (c-lineup-gcc-asm-reg 0))
+       (arglist-cont	      . (c-lineup-gcc-asm-reg 0))
        ;; Anchor pos: At the first token after the open paren.
        (arglist-cont-nonempty . (c-lineup-gcc-asm-reg c-lineup-arglist))
        ;; Anchor pos: At the containing statement(*).
        ;; 2nd pos: At the open paren.
-       (arglist-close         . +)
+       (arglist-close	      . +)
        ;; Anchor pos: At the containing statement(*).
        ;; 2nd pos: At the open paren.
-       (stream-op             . c-lineup-streamop)
+       (stream-op	      . c-lineup-streamop)
        ;; Anchor pos: Boi at the first stream op in the statement.
-       (inclass               . +)
+       (inclass		      . +)
        ;; Anchor pos: At the class open brace if it's at boi,
        ;; otherwise boi at the class decl start.
-       (cpp-macro             . [0])
+       (cpp-macro	      . [0])
        ;; Anchor pos: None.
-       (cpp-macro-cont        . +)
+       (cpp-macro-cont	      . +)
        ;; Anchor pos: At the macro start (always at boi).
        (cpp-define-intro      . (c-lineup-cpp-define +))
        ;; Anchor pos: None.
-       (friend                . 0)
+       (friend		      . 0)
        ;; Anchor pos: None.
        (objc-method-intro     . [0])
        ;; Anchor pos: Boi.
        (objc-method-args-cont . c-lineup-ObjC-method-args)
        ;; Anchor pos: At the method start (always at boi).
        (objc-method-call-cont . (c-lineup-ObjC-method-call-colons
-			        c-lineup-ObjC-method-call +))
+				c-lineup-ObjC-method-call +))
        ;; Anchor pos: At the open bracket.
        (extern-lang-open      . 0)
-       (namespace-open        . 0)
-       (module-open           . 0)
+       (namespace-open	      . 0)
+       (module-open	      . 0)
        (composition-open      . 0)
        ;; Anchor pos: Boi at the extern/namespace/etc keyword.
        (extern-lang-close     . 0)
-       (namespace-close       . 0)
-       (module-close          . 0)
+       (namespace-close	      . 0)
+       (module-close	      . 0)
        (composition-close     . 0)
        ;; Anchor pos: Boi at the corresponding extern/namespace/etc keyword.
-       (inextern-lang         . +)
-       (innamespace           . +)
-       (inmodule              . +)
-       (incomposition         . +)
+       (inextern-lang	      . +)
+       (innamespace	      . +)
+       (inmodule	      . +)
+       (incomposition	      . +)
        ;; Anchor pos: At the extern/namespace/etc block open brace if
        ;; it's at boi, otherwise boi at the keyword.
        (template-args-cont    . (c-lineup-template-args +))
        ;; Anchor pos: Boi at the decl start.  This might be changed;
        ;; the logical position is clearly the opening '<'.
-       (inlambda              . c-lineup-inexpr-block)
+       (inlambda	      . c-lineup-inexpr-block)
        ;; Anchor pos: None.
        (lambda-intro-cont     . +)
        ;; Anchor pos: Boi at the lambda start.
        (inexpr-statement      . +)
        ;; Anchor pos: None.
-       (inexpr-class          . +)
+       (inexpr-class	      . +)
        ;; Anchor pos: None.
        ))
 (defcustom c-offsets-alist nil
@@ -1254,20 +1264,20 @@ OFFSET can specify an offset in several
   offset specifications.  If the first element is any of the symbols
   below then it isn't evaluated but instead specifies how the
   remaining offsets in the list should be combined.  If it's something
-  else then the list is combined according the method `first'.  The
+  else then the list is combined according the method `first'.	The
   valid combination methods are:
 
   `first' -- Use the first offset (that doesn't evaluate to nil).
-  `min'   -- Use the minimum of all the offsets.  All must be either
-             relative or absolute - they can't be mixed.
-  `max'   -- Use the maximum of all the offsets.  All must be either
-             relative or absolute - they can't be mixed.
-  `add'   -- Add all the evaluated offsets together.  Exactly one of
-             them may be absolute, in which case the result is
-             absolute.  Any relative offsets that preceded the
-             absolute one in the list will be ignored in that case.
+  `min'	  -- Use the minimum of all the offsets.  All must be either
+	     relative or absolute - they can't be mixed.
+  `max'	  -- Use the maximum of all the offsets.  All must be either
+	     relative or absolute - they can't be mixed.
+  `add'	  -- Add all the evaluated offsets together.  Exactly one of
+	     them may be absolute, in which case the result is
+	     absolute.	Any relative offsets that preceded the
+	     absolute one in the list will be ignored in that case.
 
-`c-offsets-alist' is a style variable.  This means that the offsets on
+`c-offsets-alist' is a style variable.	This means that the offsets on
 this variable are normally taken from the style system in CC Mode
 \(see `c-default-style' and `c-style-alist').  However, any offsets
 put explicitly on this list will override the style system when a CC
@@ -1276,22 +1286,22 @@ Mode buffer is initialized \(there is a
 
 Here is the current list of valid syntactic element symbols:
 
- string                 -- Inside multi-line string.
- c                      -- Inside a multi-line C style block comment.
- defun-open             -- Brace that opens a function definition.
- defun-close            -- Brace that closes a function definition.
- defun-block-intro      -- The first line in a top-level defun.
- class-open             -- Brace that opens a class definition.
- class-close            -- Brace that closes a class definition.
- inline-open            -- Brace that opens an in-class inline method.
- inline-close           -- Brace that closes an in-class inline method.
- func-decl-cont         -- The region between a function definition's
-                           argument list and the function opening brace
-                           (excluding K&R argument declarations).  In C, you
-                           cannot put anything but whitespace and comments
-                           between them; in C++ and Java, throws declarations
-                           and other things can appear in this context.
- knr-argdecl-intro      -- First line of a K&R C argument declaration.
+ string			-- Inside multi-line string.
+ c			-- Inside a multi-line C style block comment.
+ defun-open		-- Brace that opens a function definition.
+ defun-close		-- Brace that closes a function definition.
+ defun-block-intro	-- The first line in a top-level defun.
+ class-open		-- Brace that opens a class definition.
+ class-close		-- Brace that closes a class definition.
+ inline-open		-- Brace that opens an in-class inline method.
+ inline-close		-- Brace that closes an in-class inline method.
+ func-decl-cont		-- The region between a function definition's
+			   argument list and the function opening brace
+			   (excluding K&R argument declarations).  In C, you
+			   cannot put anything but whitespace and comments
+			   between them; in C++ and Java, throws declarations
+			   and other things can appear in this context.
+ knr-argdecl-intro	-- First line of a K&R C argument declaration.
  knr-argdecl		-- Subsequent lines in a K&R C argument declaration.
  topmost-intro		-- The first line in a topmost construct definition.
  topmost-intro-cont	-- Topmost definition continuation lines.
@@ -1302,70 +1312,70 @@ Here is the current list of valid syntac
  member-init-intro	-- First line in a member initialization list.
  member-init-cont	-- Subsequent member initialization list lines.
  inher-intro		-- First line of a multiple inheritance list.
- inher-cont             -- Subsequent multiple inheritance lines.
- block-open             -- Statement block open brace.
- block-close            -- Statement block close brace.
- brace-list-open        -- Open brace of an enum or static array list.
- brace-list-close       -- Close brace of an enum or static array list.
- brace-list-intro       -- First line in an enum or static array list.
- brace-list-entry       -- Subsequent lines in an enum or static array list.
- brace-entry-open       -- Subsequent lines in an enum or static array
-                           list that start with an open brace.
- statement              -- A C (or like) statement.
- statement-cont         -- A continuation of a C (or like) statement.
- statement-block-intro  -- The first line in a new statement block.
- statement-case-intro   -- The first line in a case \"block\".
- statement-case-open    -- The first line in a case block starting with brace.
- substatement           -- The first line after an if/while/for/do/else.
- substatement-open      -- The brace that opens a substatement block.
- substatement-label     -- Labeled line after an if/while/for/do/else.
- case-label             -- A \"case\" or \"default\" label.
- access-label           -- C++ private/protected/public access label.
- label                  -- Any ordinary label.
- do-while-closure       -- The \"while\" that ends a do/while construct.
- else-clause            -- The \"else\" of an if/else construct.
- catch-clause           -- The \"catch\" or \"finally\" of a try/catch construct.
- comment-intro          -- A line containing only a comment introduction.
- arglist-intro          -- The first line in an argument list.
- arglist-cont           -- Subsequent argument list lines when no
-                           arguments follow on the same line as the
-                           arglist opening paren.
- arglist-cont-nonempty  -- Subsequent argument list lines when at
-                           least one argument follows on the same
-                           line as the arglist opening paren.
- arglist-close          -- The solo close paren of an argument list.
- stream-op              -- Lines continuing a stream operator construct.
- inclass                -- The construct is nested inside a class definition.
-                           Used together with e.g. `topmost-intro'.
- cpp-macro              -- The start of a C preprocessor macro definition.
- cpp-macro-cont         -- Inside a multi-line C preprocessor macro definition.
- friend                 -- A C++ friend declaration.
- objc-method-intro      -- The first line of an Objective-C method definition.
- objc-method-args-cont  -- Lines continuing an Objective-C method definition.
- objc-method-call-cont  -- Lines continuing an Objective-C method call.
- extern-lang-open       -- Brace that opens an \"extern\" block.
- extern-lang-close      -- Brace that closes an \"extern\" block.
- inextern-lang          -- Analogous to the `inclass' syntactic symbol,
-                           but used inside \"extern\" blocks.
+ inher-cont		-- Subsequent multiple inheritance lines.
+ block-open		-- Statement block open brace.
+ block-close		-- Statement block close brace.
+ brace-list-open	-- Open brace of an enum or static array list.
+ brace-list-close	-- Close brace of an enum or static array list.
+ brace-list-intro	-- First line in an enum or static array list.
+ brace-list-entry	-- Subsequent lines in an enum or static array list.
+ brace-entry-open	-- Subsequent lines in an enum or static array
+			   list that start with an open brace.
+ statement		-- A C (or like) statement.
+ statement-cont		-- A continuation of a C (or like) statement.
+ statement-block-intro	-- The first line in a new statement block.
+ statement-case-intro	-- The first line in a case \"block\".
+ statement-case-open	-- The first line in a case block starting with brace.
+ substatement		-- The first line after an if/while/for/do/else.
+ substatement-open	-- The brace that opens a substatement block.
+ substatement-label	-- Labelled line after an if/while/for/do/else.
+ case-label		-- A \"case\" or \"default\" label.
+ access-label		-- C++ private/protected/public access label.
+ label			-- Any ordinary label.
+ do-while-closure	-- The \"while\" that ends a do/while construct.
+ else-clause		-- The \"else\" of an if/else construct.
+ catch-clause		-- The \"catch\" or \"finally\" of a try/catch construct.
+ comment-intro		-- A line containing only a comment introduction.
+ arglist-intro		-- The first line in an argument list.
+ arglist-cont		-- Subsequent argument list lines when no
+			   arguments follow on the same line as the
+			   arglist opening paren.
+ arglist-cont-nonempty	-- Subsequent argument list lines when at
+			   least one argument follows on the same
+			   line as the arglist opening paren.
+ arglist-close		-- The solo close paren of an argument list.
+ stream-op		-- Lines continuing a stream operator construct.
+ inclass		-- The construct is nested inside a class definition.
+			   Used together with e.g. `topmost-intro'.
+ cpp-macro		-- The start of a C preprocessor macro definition.
+ cpp-macro-cont		-- Inside a multi-line C preprocessor macro definition.
+ friend			-- A C++ friend declaration.
+ objc-method-intro	-- The first line of an Objective-C method definition.
+ objc-method-args-cont	-- Lines continuing an Objective-C method definition.
+ objc-method-call-cont	-- Lines continuing an Objective-C method call.
+ extern-lang-open	-- Brace that opens an \"extern\" block.
+ extern-lang-close	-- Brace that closes an \"extern\" block.
+ inextern-lang		-- Analogous to the `inclass' syntactic symbol,
+			   but used inside \"extern\" blocks.
  namespace-open, namespace-close, innamespace
-                        -- Similar to the three `extern-lang' symbols, but for
-                           C++ \"namespace\" blocks.
+			-- Similar to the three `extern-lang' symbols, but for
+			   C++ \"namespace\" blocks.
  module-open, module-close, inmodule
-                        -- Similar to the three `extern-lang' symbols, but for
-                           CORBA IDL \"module\" blocks.
+			-- Similar to the three `extern-lang' symbols, but for
+			   CORBA IDL \"module\" blocks.
  composition-open, composition-close, incomposition
-                        -- Similar to the three `extern-lang' symbols, but for
-                           CORBA CIDL \"composition\" blocks.
- template-args-cont     -- C++ template argument list continuations.
- inlambda               -- In the header or body of a lambda function.
- lambda-intro-cont      -- Continuation of the header of a lambda function.
- inexpr-statement       -- The statement is inside an expression.
- inexpr-class           -- The class is inside an expression.  Used e.g. for
-                           Java anonymous classes."
+			-- Similar to the three `extern-lang' symbols, but for
+			   CORBA CIDL \"composition\" blocks.
+ template-args-cont	-- C++ template argument list continuations.
+ inlambda		-- In the header or body of a lambda function.
+ lambda-intro-cont	-- Continuation of the header of a lambda function.
+ inexpr-statement	-- The statement is inside an expression.
+ inexpr-class		-- The class is inside an expression.  Used e.g. for
+			   Java anonymous classes."
   :type
   `(set :format "%{%t%}:
  Override style setting
- |  Syntax                     Offset
+ |  Syntax		       Offset
 %v"
 	,@(mapcar
 	   (lambda (elt)
@@ -1417,7 +1427,6 @@ The list of variables to buffer localize
     c-special-indent-hook
     c-indentation-style"
   :type 'boolean
-  :safe 'booleanp
   :group 'c)
 
 (defcustom c-mode-hook nil
@@ -1491,7 +1500,7 @@ were taken.  That was confusing, especia
 It's believed that despite this change, the new behavior will still
 produce the same results for most old CC Mode configurations, since
 all style variables are per default set in a special non-override
-state.  Set this variable only if your configuration has stopped
+state.	Set this variable only if your configuration has stopped
 working due to this change.")
 
 (define-widget 'c-extra-types-widget 'radio
@@ -1511,9 +1520,9 @@ characters are automatically optimized u
 should not use `regexp-opt' explicitly to build regexps here.
 
 On decoration level 3 (and higher, where applicable), a method is used
-that finds most types and declarations by syntax alone.  This variable
+that finds most types and declarations by syntax alone.	 This variable
 is still used as a first step, but other types are recognized
-correctly anyway in most cases.  Therefore this variable should be
+correctly anyway in most cases.	 Therefore this variable should be
 fairly restrictive and not contain patterns that are uncertain.
 
 Note that this variable is only consulted when the major mode is
@@ -1616,7 +1625,7 @@ names)."))
 (defvar c-macro-with-semi-re nil
   ;; Regular expression which matches a (#define'd) symbol whose expansion
   ;; ends with a semicolon.
-  ;;
+  ;; 
   ;; This variable should be set by `c-make-macros-with-semi-re' rather than
   ;; directly.
 )
@@ -1642,7 +1651,7 @@ names)."))
 	  (t (error "c-make-macro-with-semi-re: invalid \
 c-macro-names-with-semicolon: %s"
 		    c-macro-names-with-semicolon))))))
-
+    
 (defvar c-macro-names-with-semicolon
   '("Q_OBJECT" "Q_PROPERTY" "Q_DECLARE" "Q_ENUMS")
   "List of #defined symbols whose expansion ends with a semicolon.
@@ -1670,7 +1679,6 @@ will set the style of the file to this v
 Note that file style settings are applied before file offset settings
 as designated in the variable `c-file-offsets'.")
 (make-variable-buffer-local 'c-file-style)
-;;;###autoload(put 'c-file-style 'safe-local-variable 'string-or-null-p)
 
 (defvar c-file-offsets nil
   "Variable interface for setting offsets via File Local Variables.
@@ -1686,7 +1694,8 @@ as designated in the variable `c-file-st
 ;; It isn't possible to specify a doc-string without specifying an
 ;; initial value with `defvar', so the following two variables have been
 ;; given doc-strings by setting the property `variable-documentation'
-;; directly.  It's really good not to have an initial value for
+;; directly.  C-h v will read this documentation only for versions of GNU
+;; Emacs from 22.1.  It's really good not to have an initial value for
 ;; variables like these that always should be dynamically bound, so it's
 ;; worth the inconvenience.
 
@@ -1737,7 +1746,7 @@ Set from `c-comment-prefix-regexp' at mo
 (make-variable-buffer-local 'c-current-comment-prefix)
 
 ;; N.B. The next three variables are initialized in
-;; c-setup-paragraph-variables.  Their initializations here are "just in
+;; c-setup-paragraph-variables.	 Their initializations here are "just in
 ;; case".  ACM, 2004/2/15.  They are NOT buffer local (yet?).
 (defvar c-string-par-start
 ;;   (concat "\\(" (default-value 'paragraph-start) "\\)\\|[ \t]*\\\\$")
@@ -1762,4 +1771,5 @@ It treats escaped EOLs as whitespace.")
 
 (cc-provide 'cc-vars)
 
+;;; arch-tag: d62e9a55-c9fe-409b-b5b6-050b6aa202c9
 ;;; cc-vars.el ends here
